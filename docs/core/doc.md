# Память в Java

![java-memory.jpeg](../../img/java-memory.jpeg)

Память делится на две большие части: стек и куча. Куча - это огромный объем
памяти по сравнению со стеком.

## Стек (Stack)

Стековая память отвечает за хранение ссылок на объекты кучи и за хранение типов
значений (также известных в Java как примитивные типы), которые содержат само
значение, а не ссылку на объект из кучи.

Кроме того, переменные в стеке имеют определенную видимость, также называемую
областью видимости. Используются только объекты из активной области. Например,
предполагая, что у нас нет никаких глобальных переменных (полей) области
видимости, а только локальные переменные, если компилятор выполняет тело метода,
он может получить доступ только к объектам из стека, которые находятся внутри
тела метода. Он не может получить доступ к другим локальным переменным, так как
они не входят в область видимости. Когда метод завершается и возвращается,
верхняя часть стека выталкивается, и активная область видимости изменяется.

Cтековая память в Java выделяется для каждого потока. Следовательно, каждый раз,
когда поток создается и запускается, он имеет свою собственную стековую память и
не может получить доступ к стековой памяти другого потока.

## Куча (Heap)

Эта часть памяти хранит в памяти фактические объекты, на которые ссылаются
переменные из стека.

    StringBuilder builder = new StringBuilder();

Ключевое слово new несет ответственность за обеспечение того, достаточно ли
свободного места на куче, создавая объект типа StringBuilder в памяти и
обращаясь к нему через «builder» ссылки, которая попадает в стек.

Для каждого запущенного процесса JVM существует только одна область памяти в
куче. Следовательно, это общая часть памяти независимо от того, сколько потоков
выполняется. Сама куча разделена на несколько частей, что облегчает процесс
сборки мусора. Максимальные размеры стека и кучи не определены заранее - это
зависит от работающей JVM машины.

## Типы ссылок

Стрелки, представляющие ссылки на объекты из кучи, на самом деле
относятся к разным типам. Это потому, что в языке программирования Java
используются разные типы ссылок: сильные, слабые, мягкие и фантомные ссылки.
Разница между типами ссылок заключается в том, что объекты в куче, на которые
они ссылаются, имеют право на сборку мусора по различным критериям.

### Сильная ссылка

Это самые популярные ссылочные типы, к которым мы все привыкли. В приведенном
выше примере со StringBuilder мы фактически храним сильную ссылку на объект из
кучи. Объект в куче не удаляется сборщиком мусора, пока на него указывает
сильная ссылка или если он явно доступен через цепочку сильных ссылок.

### Слабая ссылка

Попросту говоря, слабая ссылка на объект из кучи, скорее всего, не сохранится
после следующего процесса сборки мусора. Слабая ссылка создается следующим
образом:

    WeakReference<StringBuilder> reference = 
                new WeakReference<>(new StringBuilder());

Хорошим вариантом использования слабых ссылок являются сценарии кеширования.
Представьте, что вы извлекаете некоторые данные и хотите, чтобы они также были
сохранены в памяти - те же данные могут быть запрошены снова. С другой стороны,
вы не уверены, когда и будут ли эти данные запрашиваться снова. Таким образом,
вы можете сохранить слабую ссылку на него, и в случае запуска сборщика мусора,
возможно, он уничтожит ваш объект в куче. Следовательно, через некоторое время,
если вы захотите получить объект, на который вы ссылаетесь, вы можете внезапно
получить null значение. Хорошей реализацией сценариев кеширования является
коллекция WeakHashMap <K, V>. Если мы откроем WeakHashMap класс в Java API, мы
увидим, что его записи фактически расширяют WeakReferenceкласс и используют его
поле ref в качестве ключа отображения (Map):

    /**
      * Записи в этой хэш-таблице расширяют WeakReference, используя ее 
        основное поле ref * в качестве ключа.
      */
    
    private static class Entry<K,V> 
                extends WeakReference<Object> 
                implements Map.Entry<K,V> { 
        V value;
    }

После сбора мусора ключа из WeakHashMap вся запись удаляется из карты.

### Мягкая ссылка

Эти типы ссылок используются для более чувствительных к памяти сценариев,
поскольку они будут собираться сборщиком мусора только тогда, когда вашему
приложению не хватает памяти. Следовательно, пока нет критической необходимости
в освобождении некоторого места, сборщик мусора не будет касаться легко
доступных объектов. Java гарантирует, что все объекты, на которые имеются мягкие
ссылки, будут очищены до того, как будет выдано исключение OutOfMemoryError. В
документации Javadocs говорится, что «все мягкие ссылки на мягко достижимые
объекты гарантированно очищены до того, как виртуальная машина выдаст
OutOfMemoryError».

Подобно слабым ссылкам, мягкая ссылка создается следующим образом:

    SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());

### Фантомная ссылка

Используется для планирования посмертных действий по очистке, поскольку мы точно
знаем, что объекты больше не живы. Используется только с очередью ссылок,
поскольку .get()метод таких ссылок всегда будет возвращаться null. Эти типы
ссылок считаются предпочтительными для финализаторов.

## Ссылки на String

Ссылки на тип String в Java обрабатываются немного по- другому. Строки
неизменяемы, что означает, что каждый раз, когда вы делаете что-то со строкой, в
куче фактически создается другой объект. Для строк Java управляет пулом строк в
памяти. Это означает, что Java сохраняет и повторно использует строки, когда это
возможно. В основном это верно для строковых литералов. Например:

    String localPrefix = "297"; //1
    String prefix = "297";      //2
    
    if (prefix == localPrefix) {
        System.out.println("Strings are equal" );
    }else{
        System.out.println("Strings are different");
    }Строка  localPrefix  =  «297» ; // 1

При запуске этот код распечатывает следующее:

    Strings are equal

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые
литералы фактически указывают на одни и те же объекты в куче. Однако это не
действует для вычисляемых строк. Предположим, что у нас есть следующее изменение
в строке // 1 приведенного выше кода.

    String localPrefix = new Integer(297).toString(); //1

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые
литералы фактически указывают на одни и те же объекты в куче. Однако это не
действует для вычисляемых строк. Предположим, что у нас есть следующее изменение
в строке // 1 приведенного выше кода.

    String localPrefix = new Integer(297).toString(); //1

Вывод:

    Strings are different

В этом случае мы фактически видим, что у нас есть два разных объекта в куче.
Если учесть, что вычисляемая строка будет использоваться довольно часто, мы
можем заставить JVM добавить ее в пул строк, добавив .intern()метод в конец
вычисляемой строки:

    String localPrefix = new Integer(297).toString().intern(); //1

При добавлении вышеуказанного изменения создается следующий результат:

    Строки равны

## Процесс сборки мусора

В зависимости от типа ссылки, которую переменная из стека содержит на объект из
кучи, в определенный момент времени этот объект становится подходящим для
сборщика мусора.

![java-memory-2.jpeg](../../img/java-memory-2.jpeg)

