# Память в Java

![java-memory.jpeg](../../img/java-memory.jpeg)

Память делится на две большие части: стек и куча. Куча - это огромный объем
памяти по сравнению со стеком.

## Стек (Stack)

Стековая память отвечает за хранение ссылок на объекты кучи и за хранение типов
значений (также известных в Java как примитивные типы), которые содержат само
значение, а не ссылку на объект из кучи.

Кроме того, переменные в стеке имеют определенную видимость, также называемую
областью видимости. Используются только объекты из активной области. Например,
предполагая, что у нас нет никаких глобальных переменных (полей) области
видимости, а только локальные переменные, если компилятор выполняет тело метода,
он может получить доступ только к объектам из стека, которые находятся внутри
тела метода. Он не может получить доступ к другим локальным переменным, так как
они не входят в область видимости. Когда метод завершается и возвращается,
верхняя часть стека выталкивается, и активная область видимости изменяется.

Cтековая память в Java выделяется для каждого потока. Следовательно, каждый раз,
когда поток создается и запускается, он имеет свою собственную стековую память и
не может получить доступ к стековой памяти другого потока.

Стек работает по схеме LIFO (последним вошел, первым вышел). Всякий раз, когда
вызывается новый метод, содержащий примитивные значения или ссылки на объекты,
то на вершине стека под них выделяется блок памяти. Из этого можно сделать
вывод, что стек хранит значения примитивных переменных, создаваемых в методах, а
также ссылки на объекты в куче на которые ссылается метод.

Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд,
очищается, и пространство становится доступным для следующего метода. При этом
поток выполнения программы возвращается к месту вызова этого метода с
последующим переходом к следующей строке кода.

Основные особенности стека:

- Он заполняется и освобождается по мере вызова и завершения новых методов;
- Переменные в стеке существуют до тех пор, пока выполняется метод в котором они
  были созданы;
- Если память стека будет заполнена, Java бросит исключение
  java.lang.StackOverFlowError;
- Доступ к этой области памяти осуществляется быстрее, чем к куче;
- Является потокобезопасным, поскольку для каждого потока создается свой
  отдельный стек;

## Куча (Heap)

Эта часть памяти хранит в памяти фактические объекты, на которые ссылаются
переменные из стека.

    StringBuilder builder = new StringBuilder();

Ключевое слово new несет ответственность за обеспечение того, достаточно ли
свободного места на куче, создавая объект типа StringBuilder в памяти и
обращаясь к нему через «builder» ссылки, которая попадает в стек.

Для каждого запущенного процесса JVM существует только одна область памяти в
куче. Следовательно, это общая часть памяти независимо от того, сколько потоков
выполняется. Сама куча разделена на несколько частей, что облегчает процесс
сборки мусора. Максимальные размеры стека и кучи не определены заранее - это
зависит от работающей JVM машины.

Эта область памяти используется для динамического выделения памяти для объектов
и классов JRE во время выполнения. Новые объекты всегда создаются в куче, а
ссылки на них хранятся в стеке.

Эти объекты имеют глобальный доступ и могут быть получены из любого места
программы.

Эта область памяти разбита на несколько более мелких частей, называемых
поколениями:

1. Young Generation — область где размещаются недавно созданные объекты. Когда
   она заполняется, происходит быстрая сборка мусора
2. Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты
   из Young Generation достигают определенного порога «возраста», они
   перемещаются в Old Generation
3. Permanent Generation — эта область содержит метаинформацию о классах и
   методах приложения, но начиная с Java 8 данная область памяти была
   упразднена.

Основные особенности кучи

- Когда эта область памяти полностью заполняется, Java бросает
  java.lang.OutOfMemoryError
- Доступ к ней медленнее, чем к стеку
- Эта память, в отличие от стека, автоматически не освобождается. Для сбора
  неиспользуемых объектов используется сборщик мусора
- В отличие от стека, куча не является потокобезопасной и ее необходимо
  контролировать, правильно синхронизируя код

Выполнение кода по шагам:

```java
class Person {
    int id;
    String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class PersonBuilder {
    private static Person buildPerson(int id, String name) {
        return new Person(id, name);
    }

    public static void main(String[] args) {
        int id = 23;
        String name = "John";
        Person person = null;
        person = buildPerson(id, name);
    }
}
```

1. До начала выполнения метода main(), в стеке будет выделено пространство для
   хранения примитивов и ссылок этого метода:
    - примитивное значение id типа int будет храниться непосредственно в стеке;
    - ссылочная переменная name типа String будет создана в стеке, но сама
      строка "John" будет храниться в области, называемой String Pool (является
      частью Кучи);
    - ссылочная переменная person типа Person будет также создана в памяти
      стека, но будет указывать на объект, расположенный в куче;
2. Для вызова конструктора с параметрами Person (int, String) из метода main() в
   стеке, поверх предыдущего вызова метода main(), будет выделен блок памяти,
   который будет хранить:
    - this — ссылка на текущий объект;
    - примитивное значение id;
    - ссылочную переменную name типа String, которая указывает на объект строки
      из пула строк;
3. В методе main дополнительно вызывается метод buildPerson для которого будет
   выделен блок памяти в стеке поверх предыдущего вызова. Этот блок снова
   сохранит переменные способом, описанным выше.
4. Для вновь созданного объекта person типа Person все переменные будут
   сохранены в памяти кучи.

## Типы ссылок

Стрелки, представляющие ссылки на объекты из кучи, на самом деле
относятся к разным типам. Это потому, что в языке программирования Java
используются разные типы ссылок: сильные, слабые, мягкие и фантомные ссылки.
Разница между типами ссылок заключается в том, что объекты в куче, на которые
они ссылаются, имеют право на сборку мусора по различным критериям.

### Сильная ссылка

Это самые популярные ссылочные типы, к которым мы все привыкли. В приведенном
выше примере со StringBuilder мы фактически храним сильную ссылку на объект из
кучи. Объект в куче не удаляется сборщиком мусора, пока на него указывает
сильная ссылка или если он явно доступен через цепочку сильных ссылок.

### Слабая ссылка

Попросту говоря, слабая ссылка на объект из кучи, скорее всего, не сохранится
после следующего процесса сборки мусора. Слабая ссылка создается следующим
образом:

    WeakReference<StringBuilder> reference = 
                new WeakReference<>(new StringBuilder());

Хорошим вариантом использования слабых ссылок являются сценарии кеширования.
Представьте, что вы извлекаете некоторые данные и хотите, чтобы они также были
сохранены в памяти - те же данные могут быть запрошены снова. С другой стороны,
вы не уверены, когда и будут ли эти данные запрашиваться снова. Таким образом,
вы можете сохранить слабую ссылку на него, и в случае запуска сборщика мусора,
возможно, он уничтожит ваш объект в куче. Следовательно, через некоторое время,
если вы захотите получить объект, на который вы ссылаетесь, вы можете внезапно
получить null значение. Хорошей реализацией сценариев кеширования является
коллекция WeakHashMap <K, V>. Если мы откроем WeakHashMap класс в Java API, мы
увидим, что его записи фактически расширяют WeakReferenceкласс и используют его
поле ref в качестве ключа отображения (Map):

    /**
      * Записи в этой хэш-таблице расширяют WeakReference, используя ее 
        основное поле ref * в качестве ключа.
      */
    
    private static class Entry<K,V> 
                extends WeakReference<Object> 
                implements Map.Entry<K,V> { 
        V value;
    }

После сбора мусора ключа из WeakHashMap вся запись удаляется из карты.

### Мягкая ссылка

Эти типы ссылок используются для более чувствительных к памяти сценариев,
поскольку они будут собираться сборщиком мусора только тогда, когда вашему
приложению не хватает памяти. Следовательно, пока нет критической необходимости
в освобождении некоторого места, сборщик мусора не будет касаться легко
доступных объектов. Java гарантирует, что все объекты, на которые имеются мягкие
ссылки, будут очищены до того, как будет выдано исключение OutOfMemoryError. В
документации Javadocs говорится, что «все мягкие ссылки на мягко достижимые
объекты гарантированно очищены до того, как виртуальная машина выдаст
OutOfMemoryError».

Подобно слабым ссылкам, мягкая ссылка создается следующим образом:

    SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());

### Фантомная ссылка

Используется для планирования посмертных действий по очистке, поскольку мы точно
знаем, что объекты больше не живы. Используется только с очередью ссылок,
поскольку .get()метод таких ссылок всегда будет возвращаться null. Эти типы
ссылок считаются предпочтительными для финализаторов.

## Ссылки на String

Ссылки на тип String в Java обрабатываются немного по- другому. Строки
неизменяемы, что означает, что каждый раз, когда вы делаете что-то со строкой, в
куче фактически создается другой объект. Для строк Java управляет пулом строк в
памяти. Это означает, что Java сохраняет и повторно использует строки, когда это
возможно. В основном это верно для строковых литералов. Например:

    String localPrefix = "297"; //1
    String prefix = "297";      //2
    
    if (prefix == localPrefix) {
        System.out.println("Strings are equal" );
    }else{
        System.out.println("Strings are different");
    }Строка  localPrefix  =  «297» ; // 1

При запуске этот код распечатывает следующее:

    Strings are equal

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые
литералы фактически указывают на одни и те же объекты в куче. Однако это не
действует для вычисляемых строк. Предположим, что у нас есть следующее изменение
в строке // 1 приведенного выше кода.

    String localPrefix = new Integer(297).toString(); //1

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые
литералы фактически указывают на одни и те же объекты в куче. Однако это не
действует для вычисляемых строк. Предположим, что у нас есть следующее изменение
в строке // 1 приведенного выше кода.

    String localPrefix = new Integer(297).toString(); //1

Вывод:

    Strings are different

В этом случае мы фактически видим, что у нас есть два разных объекта в куче.
Если учесть, что вычисляемая строка будет использоваться довольно часто, мы
можем заставить JVM добавить ее в пул строк, добавив .intern()метод в конец
вычисляемой строки:

    String localPrefix = new Integer(297).toString().intern(); //1

При добавлении вышеуказанного изменения создается следующий результат:

    Строки равны

## Процесс сборки мусора

В зависимости от типа ссылки, которую переменная из стека содержит на объект из
кучи, в определенный момент времени этот объект становится подходящим для
сборщика мусора.

![java-memory-2.jpeg](../../img/java-memory-2.jpeg)

В куче есть объект, который имеет строгие ссылки на другие объекты, которые
также находятся в куче (например, это может быть список, который имеет ссылки
на его элементы, или объект, имеющий два поля типа, на которые есть ссылки).
Однако, поскольку ссылка из стека потеряна, к ней больше нельзя получить доступ,
так что это тоже мусор.

Этот процесс запускается автоматически Java, и Java решает, запускать или нет
этот процесс.

На самом деле это дорогостоящий процесс. При запуске сборщика мусора все потоки
в вашем приложении приостанавливаются (в зависимости от типа GC, который будет
обсуждаться позже).

На самом деле это более сложный процесс, чем просто сбор мусора и освобождение
памяти.

Поскольку это довольно сложный процесс и может повлиять на производительность, 
он реализован разумно. Для этого используется так называемый процесс «Mark and 
Sweep». Java анализирует переменные из стека и «отмечает» все объекты, которые 
необходимо поддерживать в рабочем состоянии. Затем все неиспользуемые объекты 
очищаются.

Так что на самом деле Java не собирает мусор. Фактически, чем больше мусора и 
чем меньше объектов помечены как живые, тем быстрее идет процесс. Чтобы сделать 
это еще более оптимизированным, память кучи на самом деле состоит из нескольких 
частей. Мы можем визуализировать использование памяти и другие полезные вещи с помощью JVisualVM, инструмента, поставляемого с Java JDK. Единственное, что вам нужно сделать, это установить плагин с именем Visual GC, который позволяет увидеть, как на самом деле структурирована память. Давайте немного увеличим масштаб и разберем общую картину:


