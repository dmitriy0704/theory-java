# Память в Java

![java-memory.jpeg](../../img/java-memory.jpeg)

Память делится на две большие части: стек и куча. Куча - это огромный объем
памяти по сравнению со стеком.

## Стек (Stack)

Стековая память отвечает за хранение ссылок на объекты кучи и за хранение типов
значений (также известных в Java как примитивные типы), которые содержат само
значение, а не ссылку на объект из кучи.

Кроме того, переменные в стеке имеют определенную видимость, также называемую
областью видимости. Используются только объекты из активной области. Например,
предполагая, что у нас нет никаких глобальных переменных (полей) области
видимости, а только локальные переменные, если компилятор выполняет тело метода,
он может получить доступ только к объектам из стека, которые находятся внутри
тела метода. Он не может получить доступ к другим локальным переменным, так как
они не входят в область видимости. Когда метод завершается и возвращается,
верхняя часть стека выталкивается, и активная область видимости изменяется.

Cтековая память в Java выделяется для каждого потока. Следовательно, каждый раз,
когда поток создается и запускается, он имеет свою собственную стековую память и
не может получить доступ к стековой памяти другого потока.

Стек работает по схеме LIFO (последним вошел, первым вышел). Всякий раз, когда
вызывается новый метод, содержащий примитивные значения или ссылки на объекты,
то на вершине стека под них выделяется блок памяти. Из этого можно сделать
вывод, что стек хранит значения примитивных переменных, создаваемых в методах, а
также ссылки на объекты в куче на которые ссылается метод.

Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд,
очищается, и пространство становится доступным для следующего метода. При этом
поток выполнения программы возвращается к месту вызова этого метода с
последующим переходом к следующей строке кода.

Основные особенности стека:

- Он заполняется и освобождается по мере вызова и завершения новых методов;
- Переменные в стеке существуют до тех пор, пока выполняется метод в котором они
  были созданы;
- Если память стека будет заполнена, Java бросит исключение
  java.lang.StackOverFlowError;
- Доступ к этой области памяти осуществляется быстрее, чем к куче;
- Является потокобезопасным, поскольку для каждого потока создается свой
  отдельный стек;

## Куча (Heap)

Эта часть памяти хранит в памяти фактические объекты, на которые ссылаются
переменные из стека.

    StringBuilder builder = new StringBuilder();

Ключевое слово new несет ответственность за обеспечение того, достаточно ли
свободного места на куче, создавая объект типа StringBuilder в памяти и
обращаясь к нему через «builder» ссылки, которая попадает в стек.

Для каждого запущенного процесса JVM существует только одна область памяти в
куче. Следовательно, это общая часть памяти независимо от того, сколько потоков
выполняется. Сама куча разделена на несколько частей, что облегчает процесс
сборки мусора. Максимальные размеры стека и кучи не определены заранее - это
зависит от работающей JVM машины.

Куча - эта область памяти используется для динамического выделения памяти для 
объектов и классов JRE во время выполнения. Новые объекты всегда создаются в 
куче, а ссылки на них хранятся в стеке.

Эти объекты имеют глобальный доступ и могут быть получены из любого места
программы.

Куча разбита на несколько более мелких частей, называемых поколениями:

1. Young Generation — область где размещаются недавно созданные объекты. Когда
   она заполняется, происходит быстрая сборка мусора
2. Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты
   из Young Generation достигают определенного порога «возраста», они
   перемещаются в Old Generation
3. Permanent Generation — эта область содержит метаинформацию о классах и
   методах приложения, но начиная с Java 8 данная область памяти была
   упразднена.

Основные особенности кучи

- Когда эта область памяти полностью заполняется, Java бросает
  java.lang.OutOfMemoryError
- Доступ к ней медленнее, чем к стеку
- Эта память, в отличие от стека, автоматически не освобождается. Для сбора
  неиспользуемых объектов используется сборщик мусора
- В отличие от стека, куча не является потокобезопасной и ее необходимо
  контролировать, правильно синхронизируя код

Выполнение кода по шагам:

```java
class Person {
    int id;
    String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class PersonBuilder {
    private static Person buildPerson(int id, String name) {
        return new Person(id, name);
    }

    public static void main(String[] args) {
        int id = 23;
        String name = "John";
        Person person = null;
        person = buildPerson(id, name);
    }
}
```

1. До начала выполнения метода main(), в стеке будет выделено пространство для
   хранения примитивов и ссылок этого метода:
    - примитивное значение id типа int будет храниться непосредственно в стеке;
    - ссылочная переменная name типа String будет создана в стеке, но сама
      строка "John" будет храниться в области, называемой String Pool (является
      частью Кучи);
    - ссылочная переменная person типа Person будет также создана в памяти
      стека, но будет указывать на объект, расположенный в куче;
2. Для вызова конструктора с параметрами Person (int, String) из метода main() в
   стеке, поверх предыдущего вызова метода main(), будет выделен блок памяти,
   который будет хранить:
    - this — ссылка на текущий объект;
    - примитивное значение id;
    - ссылочную переменную name типа String, которая указывает на объект строки
      из пула строк;
3. В методе main дополнительно вызывается метод buildPerson для которого будет
   выделен блок памяти в стеке поверх предыдущего вызова. Этот блок снова
   сохранит переменные способом, описанным выше.
4. Для вновь созданного объекта person типа Person все переменные будут
   сохранены в памяти кучи.

## Типы ссылок

Стрелки, представляющие ссылки на объекты из кучи, на самом деле
относятся к разным типам. Это потому, что в языке программирования Java
используются разные типы ссылок: сильные, слабые, мягкие и фантомные ссылки.
Разница между типами ссылок заключается в том, что объекты в куче, на которые
они ссылаются, имеют право на сборку мусора по различным критериям.

### Сильная ссылка

Это самые популярные ссылочные типы, к которым мы все привыкли. В приведенном
выше примере со StringBuilder мы фактически храним сильную ссылку на объект из
кучи. Объект в куче не удаляется сборщиком мусора, пока на него указывает
сильная ссылка или если он явно доступен через цепочку сильных ссылок.

### Слабая ссылка

Попросту говоря, слабая ссылка на объект из кучи, скорее всего, не сохранится
после следующего процесса сборки мусора. Слабая ссылка создается следующим
образом:

    WeakReference<StringBuilder> reference = 
                new WeakReference<>(new StringBuilder());

Хорошим вариантом использования слабых ссылок являются сценарии кеширования.
Представьте, что вы извлекаете некоторые данные и хотите, чтобы они также были
сохранены в памяти - те же данные могут быть запрошены снова. С другой стороны,
вы не уверены, когда и будут ли эти данные запрашиваться снова. Таким образом,
вы можете сохранить слабую ссылку на него, и в случае запуска сборщика мусора,
возможно, он уничтожит ваш объект в куче. Следовательно, через некоторое время,
если вы захотите получить объект, на который вы ссылаетесь, вы можете внезапно
получить null значение. Хорошей реализацией сценариев кеширования является
коллекция WeakHashMap <K, V>. Если мы откроем WeakHashMap класс в Java API, мы
увидим, что его записи фактически расширяют WeakReferenceкласс и используют его
поле ref в качестве ключа отображения (Map):

    /**
      * Записи в этой хэш-таблице расширяют WeakReference, используя ее 
        основное поле ref * в качестве ключа.
      */
    
    private static class Entry<K,V> 
                extends WeakReference<Object> 
                implements Map.Entry<K,V> { 
        V value;
    }

После сбора мусора ключа из WeakHashMap вся запись удаляется из карты.

### Мягкая ссылка

Эти типы ссылок используются для более чувствительных к памяти сценариев,
поскольку они будут собираться сборщиком мусора только тогда, когда вашему
приложению не хватает памяти. Следовательно, пока нет критической необходимости
в освобождении некоторого места, сборщик мусора не будет касаться легко
доступных объектов. Java гарантирует, что все объекты, на которые имеются мягкие
ссылки, будут очищены до того, как будет выдано исключение OutOfMemoryError. В
документации Javadocs говорится, что «все мягкие ссылки на мягко достижимые
объекты гарантированно очищены до того, как виртуальная машина выдаст
OutOfMemoryError».

Подобно слабым ссылкам, мягкая ссылка создается следующим образом:

    SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());

### Фантомная ссылка

Используется для планирования посмертных действий по очистке, поскольку мы точно
знаем, что объекты больше не живы. Используется только с очередью ссылок,
поскольку .get()метод таких ссылок всегда будет возвращаться null. Эти типы
ссылок считаются предпочтительными для финализаторов.

## Ссылки на String

Ссылки на тип String в Java обрабатываются немного по- другому. Строки
неизменяемы, что означает, что каждый раз, когда вы делаете что-то со строкой, в
куче фактически создается другой объект. Для строк Java управляет пулом строк в
памяти. Это означает, что Java сохраняет и повторно использует строки, когда это
возможно. В основном это верно для строковых литералов. Например:

    String localPrefix = "297"; //1
    String prefix = "297";      //2
    
    if (prefix == localPrefix) {
        System.out.println("Strings are equal" );
    }else{
        System.out.println("Strings are different");
    }Строка  localPrefix  =  «297» ; // 1

При запуске этот код распечатывает следующее:

    Strings are equal

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые
литералы фактически указывают на одни и те же объекты в куче. Однако это не
действует для вычисляемых строк. Предположим, что у нас есть следующее изменение
в строке // 1 приведенного выше кода.

    String localPrefix = new Integer(297).toString(); //1

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые
литералы фактически указывают на одни и те же объекты в куче. Однако это не
действует для вычисляемых строк. Предположим, что у нас есть следующее изменение
в строке // 1 приведенного выше кода.

    String localPrefix = new Integer(297).toString(); //1

Вывод:

    Strings are different

В этом случае мы фактически видим, что у нас есть два разных объекта в куче.
Если учесть, что вычисляемая строка будет использоваться довольно часто, мы
можем заставить JVM добавить ее в пул строк, добавив .intern()метод в конец
вычисляемой строки:

    String localPrefix = new Integer(297).toString().intern(); //1

При добавлении вышеуказанного изменения создается следующий результат:

    Строки равны

## Процесс сборки мусора

В зависимости от типа ссылки, которую переменная из стека содержит на объект из
кучи, в определенный момент времени этот объект становится подходящим для
сборщика мусора.

![java-memory-2.jpeg](../../img/java-memory-2.jpeg)

В куче есть объект, который имеет строгие ссылки на другие объекты, которые
также находятся в куче (например, это может быть список, который имеет ссылки
на его элементы, или объект, имеющий два поля типа, на которые есть ссылки).
Однако, поскольку ссылка из стека потеряна, к ней больше нельзя получить доступ,
так что это тоже мусор.

Этот процесс запускается автоматически Java, и Java решает, запускать или нет
этот процесс.

На самом деле это дорогостоящий процесс. При запуске сборщика мусора все потоки
в вашем приложении приостанавливаются (в зависимости от типа GC, который будет
обсуждаться позже).

На самом деле это более сложный процесс, чем просто сбор мусора и освобождение
памяти.

Поскольку это довольно сложный процесс и может повлиять на производительность,
он реализован разумно. Для этого используется так называемый процесс «Mark and
Sweep». Java анализирует переменные из стека и «отмечает» все объекты, которые
необходимо поддерживать в рабочем состоянии. Затем все неиспользуемые объекты
очищаются.

Так что на самом деле Java не собирает мусор. Фактически, чем больше мусора и
чем меньше объектов помечены как живые, тем быстрее идет процесс. Чтобы сделать
это еще более оптимизированным, память кучи на самом деле состоит из нескольких
частей. Мы можем визуализировать использование памяти и другие полезные вещи с
помощью JVisualVM, инструмента, поставляемого с Java JDK. Единственное, что вам
нужно сделать, это установить плагин с именем Visual GC, который позволяет
увидеть, как на самом деле структурирована память. Давайте немного увеличим
масштаб и разберем общую картину:

![gc_process.jpeg](/img/gc_process.jpeg)

Когда объект создается, он размещается в пространстве Eden (1). Поскольку
пространство Eden не такое уж большое, оно заполняется довольно быстро. Сборщик
мусора работает в пространстве Eden и помечает объекты как живые.

Если объект выживает в процессе сборки мусора, он перемещается в так называемое
пространство выжившего S0(2). Во второй раз, когда сборщик мусора запускается в
пространстве Eden, он перемещает все уцелевшие объекты в пространство S1(3).
Кроме того, все, что в настоящее время находится на S0(2), перемещается в
пространство S1(3).

Если объект выживает в течение X раундов сборки мусора (X зависит от реализации
JVM, в моем случае это 8), скорее всего, он выживет вечно и перемещается в
пространство Old(4).

Принимая все сказанное выше, если вы посмотрите на график сборщика мусора (6),
каждый раз, когда он запускается, вы можете увидеть, что объекты переключаются
на пространство выживших и что пространство Эдема увеличивалось. И так далее.
Старое поколение также может быть обработано сборщиком мусора, но, поскольку это
большая часть памяти по сравнению с пространством Eden, это происходит не так
часто. Метапространство (5) используется для хранения метаданных о ваших
загруженных классах в JVM.

Представленное изображение на самом деле является приложением Java 8. До Java 8
структура памяти была немного другой. Метапространство на самом деле называется
PermGen область. Например, в Java 6 это пространство также хранит память для
пула строк. Поэтому, если в вашем приложении Java 6 слишком много строк, оно
может аварийно завершить работу.

**Типы сборщиков мусора**

Фактически, JVM имеет три типа сборщиков мусора, и программист может выбрать,
какой из них следует использовать. По умолчанию Java выбирает используемый тип
сборщика мусора в зависимости от базового оборудования.

1. Serial GC (Последовательный сборщик мусора) - однониточный коллектор. В
   основном относится к небольшим приложениям с небольшим использованием данных.
   Можно включить, указав параметр командной строки: -XX:+UseSerialGC.

2. Parallel GC (Параллельный сборщик мусора) - даже по названию, разница между
   последовательным и параллельным будет заключаться в том, что параллельный
   сборщик мусора использует несколько потоков для выполнения процесса сбора
   мусора. Этот тип GC также известен как сборщик производительности. Его можно
   включить, явно указав параметр: -XX:+UseParallelGC.

3. Mostly concurrent GC (В основном параллельный сборщик мусора). Если вы
   помните, ранее в этой статье упоминалось, что процесс сбора мусора на самом
   деле довольно дорогостоящий, и когда он выполняется, все потоки
   приостанавливаются. Однако у нас есть в основном параллельный тип GC, который
   утверждает, что он работает одновременно с приложением. Однако есть причина,
   по которой он «в основном» параллелен. Он не работает на 100% одновременно с
   приложением. Есть период времени, на который цепочки приостанавливаются. Тем
   не менее, пауза делается как можно короче для достижения наилучшей
   производительности сборщика мусора. На самом деле существует 2 типа в
   основном параллельных сборщиков мусора:

    - 3.1 Garbage First - высокая производительность с разумным временем паузы
      приложения. Включено с опцией: -XX:+UseG1GC.

    - 3.2 Concurrent Mark Sweep (Параллельное сканирование отметок) - время
      паузы приложения сведено к минимуму. Он может быть использован с помощью
      опции: -XX: +UseConcMarkSweepGC. Начиная с JDK 9, этот тип GC объявлен
      устаревшим.

Примечание переводчика. Информация про сборщики мусора для различных версий Java
приведена в переводе:

Систематизированный список всех функций Java и JVM в Java 8-15

Советы и приемы
Чтобы минимизировать объем памяти, максимально ограничьте область видимости
переменных. Помните, что каждый раз, когда выскакивает верхняя область видимости
из стека, ссылки из этой области теряются, и это может сделать объекты
пригодными для сбора мусора.

Явно устанавливайте в null устаревшие ссылки. Это сделает объекты, на которые
ссылаются, подходящими для сбора мусора.

Избегайте финализаторов (finalizer). Они замедляют процесс и ничего не
гарантируют. Фантомные ссылки предпочтительны для работы по очистке памяти.

Не используйте сильные ссылки там, где можно применить слабые или мягкие ссылки.
Наиболее распространенные ошибки памяти - это сценарии кэширования, когда данные
хранятся в памяти, даже если они могут не понадобиться.

JVisualVM также имеет функцию создания дампа кучи в определенный момент, чтобы
вы могли анализировать для каждого класса, сколько памяти он занимает.

Настройте JVM в соответствии с требованиями вашего приложения. Явно укажите
размер кучи для JVM при запуске приложения. Процесс выделения памяти также
является дорогостоящим, поэтому выделите разумный начальный и максимальный объем
памяти для кучи. Если вы знаете его, то не имеет смысла начинать с небольшого
начального размера кучи с самого начала, JVM расширит это пространство памяти.
Указание параметров памяти выполняется с помощью следующих параметров:

Начальный размер кучи -Xms512m- установите начальный размер кучи на 512
мегабайт.

Максимальный размер кучи -Xmx1024m- установите максимальный размер кучи 1024
мегабайта.

Размер стека потоков -Xss1m- установите размер стека потоков равным 1 мегабайту.

Размер поколения -Xmn256m- установите размер поколения 256 мегабайт.

Если приложение Java выдает ошибку OutOfMemoryError   и вам нужна дополнительная
информация для обнаружения утечки, запустите процесс с –XX:
HeapDumpOnOutOfMemoryпараметром, который создаст файл дампа кучи, когда эта
ошибка произойдет в следующий раз.

Используйте опцию -verbose:gc, чтобы получить вывод процесса сборки мусора.
Каждый раз, когда происходит сборка мусора, будет генерироваться вывод.

Заключение
Знание того, как организована память, дает вам преимущество в написании хорошего
и оптимизированного кода с точки зрения ресурсов памяти. Преимущество
заключается в том, что вы можете настроить свою работающую JVM, предоставив
различные конфигурации, наиболее подходящие для запуска вашего приложения.
Выявление и устранение утечек памяти - это очень просто, если использовать
правильные инструменты.
