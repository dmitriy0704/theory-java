# Строки

Системная библиотека Java содержит классы String, StringBuilder
и StringBuffer, поддерживающие хранение строк, их обработку и определенные
в пакете java.lang, подключаемом к приложению автоматически. Эти классы
объявлены как final, что означает невозможность создания собственных
порожденных классов со свойствами строки. Для форматирования и обработки
трок применяются также классы Formatter, Pattern, Matcher, StringJoiner и
другие.

## Класс String

Каждая строка, создаваемая с помощью оператора new, литерала (заключенная в
двойные апострофы) или метода класса, создающего строку, является экземпляром
класса String. Особенностью объекта класса String является то, что его значение
не может быть изменено после создания объекта при помощи любого метода класса.
Изменение строки всегда приводит к созданию нового объекта в heap. Сама
объектная ссылка при этом сохраняет прежнее значение и хранится в стеке.
Произведенные изменения можно сохранить переинициализируя ссылку.

Класс String поддерживает несколько конструкторов, например: String(),
String(String original), String(byte[] bytes), String(char[] value), String(
char[] value, int offset, int count), String(StringBuffer buffer),
String(StringBuilder builder) и др. Эти конструкторы используются для создания
объектов класса String на основе их инициализации значениями из массива типа
char, byte и др.

Cтрока хранится в массиве типа byte, а ее кодировка в отдельном поле.

Когда Java встречает литерал, заключенный в двойные кавычки, автоматически
создается объект-литерал типа String, на который можно установить
ссылку. Таким образом, объект класса String можно создать, присвоив ссылке
на класс значение существующего литерала:

    String str1 = "oracle.com";
    String str2 = new String("oracle.com");

**Методы String:**

- **String concat(String s)** или оператор «+» — слияние строк;
- **boolean equals(Object ob)** и **equalsIgnoreCase(String s)** — сравнение
  строк с учетом и без учета нижнего и верхнего регистра символов
  соответственно;
- **int compareTo(String s)** и **compareToIgnoreCase(String s)** —
  лексикографическое сравнение строк с учетом и без учета их регистра. Метод
  осуществляет вычитание кодов первых различных символов вызывающей и
  передаваемой строки в метод строк и возвращает целое значение. Метод
  возвращает значение 0 в случае, когда equals() возвращает значение true;
- **boolean contentEquals(CharSequence ob)** — сравнение строки и содержимого
  объекта типа StringBuffer, StringBuilder и пр.;
- **boolean matches(String regex)** — проверка строки на соответствие
  регулярному выражению;
- **String substring(int n, int m)** — извлечение из строки подстроки длины m-n,
  начиная с позиции n. Нумерация символов в строке начинается с нуля;
- **String substring(int n)** — извлечение из строки подстроки, начиная с
  позиции n;
- **int length()** — определение длины строки;
- **int indexOf(char ch)** — определение позиции символа в строке;
- **static String valueOf(type v)** — преобразование переменной базового типа к
  строке;
- **String toUpperCase()/toLowerCase()** — преобразование всех символов
  вызывающей строки в верхний/нижний регистр;
- **String replace(char с1, char с2)** — замена в строке всех вхождений первого
  символа вторым символом;
- **String replaceAll(String regex, String replacement)** — замена в строке всех
  подстрок, соответствующих регулярному выражению, новой строкой, см. также
  replaceFirst();
- **String intern()** — заносит строку в «пул» литералов и возвращает ее
  объектную ссылку;
- **String strip()** — удаление всех пробелов в начале и конце строки, более
  совершенный аналог метода trim(), см. также методы stripLeading() и
  stripTrailing();
- **char charAt(int position)** — возвращение символа из указанной позиции
- (нумерация с нуля);
- **boolean isEmpty()** — возвращает true, если длина строки равна 0;
- **boolean isBlank()** — возвращает true, если строка пуста или содержит только
  пробельные символы;
- **static String join(CharSequence delimiter, CharSequence... elements)** -
  объединение произвольного набора строк (коллекции строк) в одну строку с
  заданной строкой-разделителем;
- char[] getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) -
  извлечение символов строки в массив символов;
- **static String format(String format, Object… args), format(Locale l, String
  format, Object… args)** - создание форматированной строки, полученной с
  использованием формата, локализации и др.;
- **String[] split(String regex), String[] split(String regex, int limit)** —
  поиск вхождения в строку заданного регулярного выражения-шаблона в качестве
  разделителя и деление исходной строки в соответствии с этим разделителем на
  массив строк;
- **IntStream codePoints()** — извлечение символов строки в поток (stream) их
  кодов;
- **IntStream chars()** — преобразование строки в stream ее символов;
- **Stream<String> lines()** — извлечение строк, разделенных символом перехода
  на другую строку, в поток (stream) строк.

_Во всех случаях вызова методов, изменяющих строку, создается новый объект типа
String._

При создании экземпляра класса String путем присваивания его ссылки на
литерал, последний помещается в «пул литералов» типа String, который теперь
перенесен из стека в heap. Если в дальнейшем будет создана еще одна ссылка
на литерал, эквивалентный ранее объявленному, то будет произведена попытка
добавления его в «пул литералов». Так как идентичный литерал там уже
существует, то дубликат не может быть размещен, и вторая ссылка будет
ссылаться на существующий литерал. В случае, если литерал является вычисляемым,
то компилятор воспринимает литералы "Java" и "Ja" + "va" как эквивалентные.

```java
    public static void main(String[] args) {
    String s1 = "Java16";
    String s2 = "Ja" + "va" + "17";
    String s3 = new String("Java16");
    String s4 = new String(s1);
    System.out.println(s1 + "==" + s2 + " : " + (s1 == s2)); // true
    System.out.println(s3 + "==" + s4 + " : " + (s3 == s4)); // false
    System.out.println(s1 + "==" + s3 + " : " + (s1 == s3)); // false
    System.out.println(s1 + "==" + s4 + " : " + (s1 == s4)); // false
    System.out.println(s1 + " equals " + s2 + " : " + s1.equals(s2)); // true
    System.out.println(s1 + " equals " + s3 + " : " + s1.equals(s3)); // true
}
```

Несмотря на то, что одинаковые по значению строковые объекты расположены в
различных участках памяти, значения их хэш-кодов совпадают.
Так как в Java все ссылки хранятся в стеке, а объекты — в heap, то при создании
объектов s1, s2 сначала создается ссылка, а затем этой ссылке устанавливается в
соответствие объект. В данной ситуации s2 ассоциируется с уже существующим
литералом, так как объект s1 уже сделал ссылку на этот литерал. При создании s3
происходит вызов конструктора, т.е. выделение памяти происходит раньше
инициализации, и в этом случае в куче создается новый объект.

