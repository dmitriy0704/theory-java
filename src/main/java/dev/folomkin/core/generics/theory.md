# Обобщения

## Обобщенный класс

Класс, интерфейс или метод, оперирующий на параметризованном типе, называется
обобщенным. Принципиальное преимущество обобщенного кода связано с тем, что он
будет автоматически работать с типом данных, переданным в его параметре типа.

```java
// Простой обобщенный класс
// Здесь Т - параметр типа, который будет заменен при создании
// объекта типа Gen
class Gen<T> { // Обобщенный класс, Т - параметр обобщенного типа.
    T ob; // <-- объявлен объект типа Т;

    // Передаем конструктору ссылку на объект типа Т
    Gen(T o) {
        ob = o;
    }

    // Возвратить ob
    T getOb() {
        return ob;
    }

    // Отобразить тип Т
    void showType() {
        System.out.println("Тип T: " + ob.getClass().getName());
    }
}

// Демонстрация использования обобщенного класса
class Code {
    public static void main(String[] args) {
        //Создать ссылку Gen для Integer
        Gen<Integer> iOb;// <-- Создать ссылку на объект типа Gen<Integer>
        Integer i = 88;
        iOb = new Gen<Integer>(i); // Создать объект и присвоить iOb ссылку на него
        // Отобразить тип данных, используемый iOb;
        iOb.showType();
        // Получить значение iOb
        int v = iOb.getOb();
        System.out.println("Значение Integer: " + v);
        System.out.println();
        //Создать объект Gen для String:
        Gen<String> genString = new Gen<String>("Hello");
        genString.showType();
        String s = genString.getOb();
        System.out.println(s);
    }
}

```

Здесь T имя параметра типа. Оно применяется в качестве заполнителя для
фактического типа, который будет передан конструктору Gen при создании объекта.
Таким образом, T используется внутри Gen всякий раз, когда требуется параметр
типа. Обратите внимание, что T содержится внутри угловых скобок <>. Такой
синтаксис можно обобщить. Объявляемый параметр типа всегда указывается в угловых
скобках. Поскольку Gen задействует параметр типа, Gen является обобщенным
классом.

    Gen(T o) {
        ob = o;
    }

Параметр "о" имеет тип T, т.е. фактический тип "о" определяется типом,
переданным в Т, когда создается объект Gen. Поскольку и параметр "о", и
переменная-член ob относятся к типу T, при создании объекта Gen они будут иметь
один и тот же фактический тип.  
При объявлении экземпляра обобщенного типа передаваемый параметру
типа аргумент типа должен быть ссылочным типом.

### Обобщенный класс с двумя параметрами типов

```java
// Простой обобщенный класс с двумя параметрами типов: T и V

class TwoGen<T, V> {
    T ob; // <-- объявлен объект типа Т;
    V ob2;

    // Передаем конструктору ссылку на объект типа Т
    TwoGen(T o, V o2) {
        ob = o;
        ob2 = o2;
    }

    // Возвратить ob
    T getOb() {
        return ob;
    }

    V getOb2() {
        return ob2;
    }

    // Отобразить тип Т
    void showType() {
        System.out.println("Тип T: " + ob.getClass().getName());
        System.out.println("Тип V: " + ob2.getClass().getName());
    }
}

class Code {
    public static void main(String[] args) {
        //Создать ссылку Gen для Integer
        TwoGen<Integer, String> tgObj = new TwoGen<>(88, "Обобщения");

        // Отобразить типы
        tgObj.showType();

        // Получить и отобразить значения:
        int v1 = tgObj.getOb();
        System.out.println("Значение V1: " + v1);
        String v2 = tgObj.getOb2();
        System.out.println("Значение V2: " + v2);

    }
}
```

## Ограниченные типы

```java
// Ограничения типов
class NumericFns<T extends Number> { // Т наследуется от числового типа 
    T num;

    // Передаем конструктору ссылку на числовой объект
    NumericFns(T n) {
        num = n;
    }

    // Возвратить обратную величину
    double reciprocal() {
        return 1 / num.doubleValue();
    }

    // Возвратить дробную часть
    double fraction() {
        return num.doubleValue() - num.intValue();
    }

}

class Code {
    public static void main(String[] args) {
        //Создать ссылку Gen для Integer
        NumericFns<Integer> iOb = new NumericFns<>(5);
        System.out.println("Обратная величина iOb: " + iOb.reciprocal());
        System.out.println("Дробная часть Ob: " + iOb.fraction());
        NumericFns<Double> doubleNumericFns = new NumericFns<>(5.25);
        System.out.println("Обратная величина doubleNumericFns: " + doubleNumericFns.reciprocal());

    }
}

```

### Ограниченные аргументы с подстановочными знаками

```java

class A {
    // ...
}

class B extends A {
    // ...
}

class C extends A {
    // ...
}

class D {
    // ...
}

// Простой обобщенный класс
class Gen<T> {
    T ob;

    Gen(T o) {
        ob = o;
    }
}

class Code {

    // Здесь ? соответствует A или подклассу A

    static void test(Gen<? extends A> o) {  // <-- Использовать подстановочный
        // аргумент с подстановочным знаком
    }

    public static void main(String[] args) {
        A a = new A();
        B b = new B();
        C c = new C();
        D d = new D();

        Gen<A> w = new Gen<A>(a);
        Gen<B> w2 = new Gen<B>(b);
        Gen<C> w3 = new Gen<C>(c);
        Gen<D> w4 = new Gen<D>(d);

        // Допустимые вызовы метода test()
        // Допустимо, т.к. классы w, w2, w3 являются подклассами класса A
        test(w);
        test(w2);
        test(w3);
        // test(w4) <-- запрещено

    }
}
```

В общем случае для установления верхней границы аргумента с подстановочным
знаком используйте выражение следующего вида:

    <? extends суперкласс>

Суперкласс имя класса, служащего верхней границей. Это включающая конструкция,
поскольку класс, формирующий верхнюю границу (т.е. указанный в суперкласс), тоже
находится в пределах границ.
Также можно указать нижнюю границу аргумента с подстановочным знаком, добавив к
объявлению конструкцию super с таким общим видом:

    <? super подкласс>

В данном случае допустимыми аргументами будут только классы, являющиеся
суперклассами подкласса, который указан в подкласс. Конструкция тоже
включающая.

## Обобщенные методы

```java
class Code {
    // Демонстрация обобщенного метода
    // Выяснить, совпадет ли содержимое массивов
    static <T extends Comparable<T>, V extends T> boolean arrayEquals(T[] x, T[] y) { // <-- Обобщенный метод
        // Если длина массива отличается - отличается и содержимое массивов
        if (x.length != y.length) return false;
        for (int i = 0; i < x.length; i++) {
            if (!x[i].equals(y[i]))
                return false; // содержимое массивов отличается
        }
        return true; // содержимое массивов совпадает
    }

    public static void main(String[] args) {
        Integer[] a = new Integer[]{1, 2, 3, 4, 5};
        Integer[] b = new Integer[]{1, 2, 3, 4, 5};
        Integer[] c = new Integer[]{1, 2, 7, 4, 5};
        Integer[] d = new Integer[]{1, 2, 7, 4, 5, 6};
        if (arrayEquals(a, a)) {
            System.out.println("a совпадает с a");
        }
        if (arrayEquals(a, b)) {
            System.out.println("a совпадает с b");
        }
        if (arrayEquals(a, c)) {
            System.out.println("a совпадает с c");
        }

        if (arrayEquals(a, d)) {
            System.out.println("a совпадает с d");
        }

        // Создать массив элементов Double
        Double[] dvals = {1.1, 2.2, 3.3, 4.4, 5.5};
        // Показанный ниже код не скомпилируется, потому что nums и dvals имеют разные типы
        // if(arrayEquals(nums, dvals))
        //      System.out.println("nums совпадает с dvals")
    }
}
```

Параметры типа объявляются перед возвращаемым типом метода. Конструкция T
extends Comparable\<T>. Интерфейс Comparable объявлен в пакете java.lang. Класс,
реализующий Comparable, определяет объекты, которые можно упорядочивать.
Таким образом, требование верхней границы как Comparable гарантирует, что метод
arraysEqual() может использоваться только с объектами, которые обладают
способностью участвовать в сравнениях. Интерфейс Comparable является обобщенным,
и его параметр типа указывает тип сравниваемых объектов.

Далее обратите внимание, что тип V ограничен сверху типом Т. Соответственно тип
V должен быть либо тем же самым, что и тип T, либо подклассом T. Такое отношение
гарантирует, что метод arraysEqual() можно вызывать только с аргументами,
которые совместимы друг с другом.

Вдобавок метод arraysEqual() определен как статический, что позволяет вызывать
его независимо от любого объекта. Однако важно понимать, что обобщенные методы
могут быть как статическими, так и нестатическими. В этом смысле нет никаких
ограничений.

Метод arraysEqual() вызывается внутри main() с применением обычного синтаксиса
вызова без необходимости в указании аргументов типов. Дело в том, что типы
аргументов распознаются автоматически, а типы T и V надлежащим образом
корректируются. Например, при первом вызове типом элементов первого
аргумента оказывается Integer, что приводит к замене T на Integer:

    if(arraysEqual(nums, nums))

Вот синтаксис обобщенного метода:

    < список-парам-типов> возвр-тип имя-метода { список-параметров ) { II ...

## Обобщенные конструкторы

Конструкторы могут быть обобщенными, даже когда их класс не определен как
обобщенный.

```java
class Summation {
    private int sum;

    <T extends Number> Summation(T arg) { // <-- Обобщенный конструктор
        sum = 0;
        for (int i = 0; i < arg.intValue(); i++) {
            sum += i;
        }
    }

    int getSum() {
        return sum;
    }
}


class Code {
    public static void main(String[] args) {
        Summation summation = new Summation(4.0);
        System.out.println("Сумма целых чисел = " + summation.getSum());
    }
}
```

### Обобщенные интерфейсы

Любой класс реализующий обобщенный интерфейс должен быть обобщенным.  
Код реализации классом интерфейса:

    class MyClass<T> implements Containment<T>

Если класс реализует специфический тип обобщенного интерфейса, тогда реализующий
класс не обязан быть обобщенным:

    class MyClass implements Containment<Double>

Вполне ожидаемо параметры типов, указанные в обобщенном интерфейсе, могут быть
ограниченными, что позволяет ограничивать тип данных, для которых может быть
реализован интерфейс. Например, чтобы ограничить Containment числовыми типами,
его можно объявить следующим образом:

    interface Containment<T extends Number> {

Теперь любой реализующий класс должен передавать в Containment аргумент типа с
таким же ограничением. Скажем, MyClass должен быть объявлен, как показано ниже:

    class MyClass<T extends Number> implements Containment <T> {

Обратите особое внимание на то, как параметр типа T объявляется в MyClass и
далее передается Containment. Поскольку для Containment требуется тип, который
реализует Number, реализующий класс (в этом случае MyClass) должен указывать ту
же самую границу. Более того, после установления такой границы нет никакой
необходимости указывать ее снова в конструкции implements. На самом деле
поступать так было бы неправильно. Например, приведенный ниже код некорректен и
потому не скомпилируется:

    // Не скомпилируется!
    class MyClass <T extends Number>
        implements Containment <T extends Number> { // Ошибка!

Установленный параметр типа просто передается интерфейсу без дальнейших
изменений. Вот общий синтаксис обобщенного интерфейса:

    interface имя-интерфейса <список-парам-типов> { // ...

В "список-парам-типов" указывается список параметров типов, разделенных
запятыми. При реализации обобщенного интерфейса необходимо указывать аргументы
типов:

    class имя-класса <список-парам-типов> implements имя-интерфейса <список-арг-типов> {

src:

```java
// Пример использования обобщенного интерфейса
// Обобщенный интерфейс содержимого.
// Предполагается, что содержащий его класс содержит одно или несколько значений
interface Containment<T> { // <-- Обобщенный интерфейс
    // Метод contains() проверяет содержится или указанный элемент
    // внутри объекта, реализующего Containment
    boolean contains(T o);
}

// Реализовать Containment, используя массив для хранения значений
class MyClass<T> implements Containment<T> { // <-- Любой класс реализующий
    // обобщенный интерфейс должен быть обобщенным
    T[] arrayRef;

    MyClass(T[] o) {
        arrayRef = o;
    }

    // Реализовать метод contains()
    public boolean contains(T o) {
        for (T x : arrayRef) {
            if (x.equals(o)) return true;
        }
        return false;
    }
}

class Code {
    public static void main(String[] args) {
        Integer[] x = {1, 2, 3};
        MyClass<Integer> ob = new MyClass<>(x);
        System.out.println(ob.contains(3));
    }
}
```

### Стирание

При компиляции кода Java вся информация об обобщенных типах удаляется
(стирается), что подразумевает замену параметров типов их ограничивающим типом,
которым является Object, если не указано явное ограничение, и последующее
применение надлежащих приведений (как определено аргументами типов) для
обеспечения совместимости с типами, указанными в аргументах типов. Такая
совместимость типов навязывается самим компилятором. Подход к обобщениям
подобного рода означает, что параметры типов во время выполнения не существуют.
Они просто являются механизмом, относящимся к исходному коду.

### Ошибки неоднозначности

Ошибки неоднозначности происходят, когда стирание приводит к тому, что два на
вид разных обобщенных объявления распознаются как один и тот же стертый тип,
становясь причиной конфликта.

```java
// Неоднозначность перегруженных методов, возникающая из-за стирания
class MyClass<T, V> {
    T ob1;
    V ob2;

    // ...

    // Эти два метода неоднозначны и не скомпилируются
    void set(T o) { // <-- Эти два метода неоднозначны
        ob1 = o;   //
    }

    void set(V o) { // <--
        ob2 = o;
    }


}
```

Внутри MyGenClass предпринимается попытка перегрузки метода set() на основе
параметров типов T и V, что выглядит разумным, поскольку T и V кажутся
разными типами. Однако здесь имеются две проблемы неоднозначности.

Первая проблема заключается в том, что исходя из того, как написан класс
MyGenClass, на самом деле вовсе не обязательно, чтобы Т и V были разными
типами. Скажем, абсолютно корректно (в принципе) сконструировать объект
MyGenClass следующим образом:

    MyGenClass<String, String> obj = new MyGenClass<String, String>()

В таком случае T и V будут заменены типом String. В итоге обе версии метода
set() становятся идентичными, что, конечно же, является ошибкой .

Вторая и более фундаментальная проблема связана с тем, что стирание типов для
set() сводит обе версии к такому виду:

    void set( Object о) {

Соответственно перегрузка метода set(), предпринятая в MyGenClass, по своей сути
неоднозначна.
Решение в данном случае заключается в том, чтобы использовать два отдельных
имени методов, а не пытаться перегружать set().

### Некоторые ограничения обобщений

Существует несколько ограничений, которые следует иметь в виду при работе с
обобщениями. Они связаны с созданием объектов параметров типов , статических
членов, исключений и массивов.

#### ___Невозможность создать экземпляры параметров типов___

Создать экземпляр параметра типа невозможно. Например, рассмотрим следующий
класс:

    // Создать экземпляр Т невозможно ,
    class Gen<T> {
        Т оЪ;
        Gen() {
           ob = new Т(); // Ошибка!!!
        }
    }

Здесь предпринимается незаконная попытка создать экземпляр т. Понять
причину должно быть легко: компилятору ничего не известно о типе объекта,
который нужно создать. Параметр типа т это просто заполнитель.

#### ___Ограничения, касающиеся статических членов___

Статические члены не могут использовать параметр типа, объявленный в объемлющем
классе. Например, оба статических члена этого класса недопустимы:

    class Wrong<T> {
        // Ошибка; статические переменные не могут иметь тип Т.
        static Т ob;
        // Ошибка; статические методы не могут использовать Т.
        static Т getOb() {
            return ob;
        }
    }

Хотя объявлять статические члены, в которых задействован параметр типа,
объявленный в объемлющем классе, не разрешено, можно объявить статические
обобщенные методы, которые определяют собственные параметры типов,
как делалось ранее в главе.

#### ___Ограничения, касающиеся обобщенных массивов___

Существуют два важных ограничения обобщений, которые применяются к массивам.   
Во-первых, нельзя создавать экземпляр массива, тип элементов которого является
параметром типа.   
Во-вторых, не разрешено создавать массив обобщенных ссылок для конкретного типа.

```java
// Обобщения и массивы
class Gen<T extends Number> {
    T ob;
    T[] vals; // нормально

    Gen(T o, T[] nums) {
        ob = o;
        // Этот оператор не допустим.
        // vals = new T[10]; // Невозможно создать массив элементов типа Т
        // Но следующий оператор законен
        vals = nums; // Присваивать ссылку на существующий массив разрешено
    }
}

class Code {
    public static void main(String[] args) {
        Integer[] n = {1, 2, 3, 4, 5};
        Gen<Integer> iOb = new Gen<>(50, n);

        // невозможно создать массив обобщенных ссылок для конкретного типа
        // Gen<Integer>[] gens = new Gen<Integer>[10]; // Ошибка!
        // Все нормально.
        Gen<?>[] gens = new Gen<?>[10]; // нормально
    }
}
```

Как показано в программе, объявлять ссылку на массив типа Т разрешено:

    Т[] vals; // нормально

Но создавать экземпляр массива элементов типа т нельзя, как демонстрируется в
следующей закомментированной строке:

    // vals = new Т[10]; // невозможно создать массив элементов типа Т

Причина невозможности создать массив элементов типа Т связана с тем, что
компилятор не в состоянии выяснить фактический тип создаваемого массива. Однако
можно передать методу Gen() ссылку на совместимый по типу массив при создании
объекта и присвоить эту ссылку переменной vals:

    vals = nums; // присваивать ссылку на существующий массив разрешено

Прием работает, поскольку переданный в Gen массив относится к известному типу,
который будет совпадать с типом т во время создания объекта. Обратите внимание,
что внутри main() нельзя объявлять массив обобщенных ссылок для определенного
обобщенного типа, т.е. следующая строка кода не скомпилируется:

    // Gen<Integer>[] gens = new Gen<Integer>[10]; // Ошибка

#### ___Ограничения, касающиеся обобщенных исключений___

Обобщенный класс не может расширять тип Throwable, что означает невозможность
создания обобщенных классов исключений.