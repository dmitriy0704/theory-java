# Лямбда выражения и ссылки на методы

## Введение

Ключевым аспектом для понимания реализации лямбда-выражений в Java являются две
конструкции: собственно лямбда - выражение и функциональный интерфейс. Начнем с
простого определения каждого из них.

**_Лямбда-выражение_** - анонимный (т.е. безымянный) метод. Используется для
реализации метода, определенного функциональным интерфейсом. Таким образом,
лямбда-выражение приводит к форме анонимного класса. Лямбда-выражения также
часто называют замыканиями.

**_Функциональный интерфейс_** это интерфейс, который содержит один и только
один
абстрактный метод, обычно устанавливающий предполагаемое назначение интерфейса.
Соответственно функциональный интерфейс, как правило, представляет одиночное
действие. Например, стандартный интерфейс Runnable является функциональным
интерфейсом, поскольку в нем определен только один метод: run(). Следовательно,
run() определяет действие Runnable. Кроме того, функциональный интерфейс задает
целевой тип лямбда-выражения. Важно понимать, что лямбда-выражение может
применяться только в контексте, в котором указан его целевой тип. И еще один
момент: функциональный интерфейс иногда называют типом SAM, где SAM означает
Single Abstract Method - единственный абстрактный метод.

## Основы лямбда-выражений

Лямбда-выражение опирается на синтаксический элемент и операцию. Операцию иногда
называется лямбда-операцией или операцией стрелки и обозначается с помощью ->.
Она делит лямбда-выражение на две части. В левой части указываются любые
параметры, требующиеся в лямбда-выражении. В правой части находится тело
лямбда-выражения, которое определяет действия лямбда-выражения. В Java
определены два вида тела лямбда-выражения с одиночным выражением и с блоком
кода.

    // Код 
    double method() {
        return 98.6;
    }

    можно заменить на
    () -> 98.6;

Когда лямбда-выражению необходим параметр, он указывается в списке параметров
слева от лямбда-операции:

    n -> (n % 2) == 0

## Функциональные интерфейсы

Как упоминалось ранее, функциональный интерфейс представляет собой такой
интерфейс, в котором определен только один абстрактный метод.
Не все методы интерфейса должны быть абстрактными. Начиная с JDK 8, интерфейс
может иметь один или несколько стандартных методов, которые не являются
абстрактными, как и закрытые и статические методы интерфейса. В результате
теперь метод интерфейса будет абстрактным только в том случае, если для него не
определена реализация. Это означает, что функциональный интерфейс может включать
стандартные, статические или закрытые методы, но во всех случаях он должен иметь
один и только один абстрактный метод. Поскольку нестандартные, нестатические,
незакрытые методы интерфейса неявно абстрактны, нет нужды применять модификатор
abstract (правда, при желании его можно указывать).

Пример:

    interface MyValue{
       double getValue();
    }

В данном случае метод getValue ( ) является неявно абстрактным и единственным
методом, определенным в MyValue. Таким образом, MyValue функциональный
интерфейс, функция которого определяется getValue().

Пример:

```java

interface MyValue {
    double getValue();
}

public class Code {
    public static void main(String[] args) {
//        MyValue myValue = new MyValue() {
//            public double getValue() {
//                return Math.random();
//            }
//        };

        // Можно заменить на

        MyValue myValue = () -> Math.random();

        // Или

        MyValue myValue = Math::random;
    }
}






```

Когда лямбда-выражение встречается в контексте целевого типа, автоматически
создается экземпляр класса, который реализует функциональный интерфейс, а
лямбда-выражение определяет поведение абстрактного метода, объявленного в
функциональном интерфейсе. При вызове данного метода через цель лямбда-выражение
выполняется. Таким образом, лямбда-выражение предоставляет способ трансформации
кодового сегмента в объект.

