# Лямбда выражения и ссылки на методы

## Введение

Ключевым аспектом для понимания реализации лямбда-выражений в Java являются две
конструкции: собственно лямбда - выражение и функциональный интерфейс. Начнем с
простого определения каждого из них.

**_Лямбда-выражение_** - анонимный (т.е. безымянный) метод. Используется для
реализации метода, определенного функциональным интерфейсом. Таким образом,
лямбда-выражение приводит к форме анонимного класса. Лямбда-выражения также
часто называют замыканиями.

**_Функциональный интерфейс_** это интерфейс, который содержит один и только
один
абстрактный метод, обычно устанавливающий предполагаемое назначение интерфейса.
Соответственно функциональный интерфейс, как правило, представляет одиночное
действие. Например, стандартный интерфейс Runnable является функциональным
интерфейсом, поскольку в нем определен только один метод: run(). Следовательно,
run() определяет действие Runnable. Кроме того, функциональный интерфейс задает
целевой тип лямбда-выражения. Важно понимать, что лямбда-выражение может
применяться только в контексте, в котором указан его целевой тип. И еще один
момент: функциональный интерфейс иногда называют типом SAM, где SAM означает
Single Abstract Method - единственный абстрактный метод.

## Основы лямбда-выражений

Лямбда-выражение опирается на синтаксический элемент и операцию. Операцию иногда
называется лямбда-операцией или операцией стрелки и обозначается с помощью ->.
Она делит лямбда-выражение на две части. В левой части указываются любые
параметры, требующиеся в лямбда-выражении. В правой части находится тело
лямбда-выражения, которое определяет действия лямбда-выражения. В Java
определены два вида тела лямбда-выражения с **одиночным выражением** и с *
*блоком
кода**.

    // Код 
    double method() {
        return 98.6;
    }

    можно заменить на
    () -> 98.6;

Когда лямбда-выражению необходим параметр, он указывается в списке параметров
слева от лямбда-операции:

    n -> (n % 2) == 0

## Функциональные интерфейсы

Как упоминалось ранее, функциональный интерфейс представляет собой такой
интерфейс, в котором определен только один абстрактный метод.
Не все методы интерфейса должны быть абстрактными. Начиная с JDK 8, интерфейс
может иметь один или несколько стандартных методов, которые не являются
абстрактными, как и закрытые и статические методы интерфейса. В результате
теперь метод интерфейса будет абстрактным только в том случае, если для него не
определена реализация. Это означает, что функциональный интерфейс может включать
стандартные, статические или закрытые методы, но во всех случаях он должен иметь
один и только один абстрактный метод. Поскольку нестандартные, нестатические,
незакрытые методы интерфейса неявно абстрактны, нет нужды применять модификатор
abstract (правда, при желании его можно указывать).

Пример:

    interface MyValue{
       double getValue();
    }

В данном случае метод getValue ( ) является неявно абстрактным и единственным
методом, определенным в MyValue. Таким образом, MyValue функциональный
интерфейс, функция которого определяется getValue().

Пример:

```java
interface MyValue {
    double getValue();
}

public class Code {
    public static void main(String[] args) {
//        MyValue myValue = new MyValue() {
//            public double getValue() {
//                return Math.random();
//            }
//        };
        // Можно заменить на
        MyValue myValue = () -> Math.random();
        // Или
        MyValue myValue = Math::random;
    }
}
```

Когда лямбда-выражение встречается в контексте целевого типа, автоматически
создается экземпляр класса, который реализует функциональный интерфейс, а
лямбда-выражение определяет поведение абстрактного метода, объявленного в
функциональном интерфейсе. При вызове данного метода через цель лямбда-выражение
выполняется. Таким образом, лямбда-выражение предоставляет способ трансформации
кодового сегмента в объект.

Если лямбда-выражение принимает один или несколько параметров, то абстрактный
метод в функциональном интерфейсе тоже должен принимать такое же количество
параметров.

```java
interface MyValue {
    double getValue(double d);
}

public class Code {
    public static void main(String[] args) {
        MyValue myValue = (d) -> 1.0 / d;
        System.out.println(myValue.getValue(4.0));
    }
}
```

Здесь getValue() реализуется лямбда-выражением, на которое ссылается myPval, и
возвращает обратную величину аргумента. В данном случае значение 4.0 передается
методу getValue(), который возвращает 0.25.

```java
package dev.folomkin.core.lambda;


// Функциональный интерфейс
interface MyValue {
    double getValue();
}

// Функциональный интерфейс
interface MyParamValue {
    double getValue(double value);
}


public class Code {
    public static void main(String[] args) {
        MyValue myVal; // Ссылка на функциональный интерфейс

        // Здесь лямбда-выражение представляет собой константное выражение.
        // Когда оно присваивается myVal, конструируется экземпляр класса,
        // где лямбда-выражение реализует метод getValue() из MyValue.

        // Интерфейс реализуется с помощью анонимного класса
//        myVal = new MyValue() {
//            public double getValue() {
//                return 42.0;
//            }
//        };

        // Который можно записать как лямбда выражение:
        myVal = () -> 42.0; // <- Простое лямбда-выражение

        // Вызвать метод getValue(), предоставляемый ранее присвоенным лямбда-выражением
        System.out.println(myVal.getValue());

        // Создать параметризованное лямбда-выражение и присвоить
        // его ссылке MyParamValue. Это лямбда-выражение возвращает
        // обратную величину переданного ему аргумента.
        MyParamValue myParamVal = (value) -> 1 / value; // Лямбда-выражение имеющее параметры

        // Вызываем getValue через ссылку myPval
        System.out.println(myParamVal.getValue(4.0));
        System.out.println(myParamVal.getValue(8.0));

        // Лямбда-выражение должно быть совместимым с методом, определенным
        // в функциональном интерфейсе. Таким образом, следующий код недопустим:
        // myVal = О -> "three"; // Ошибка! Типы String и double не совместимы !
        // myPval = () > Math.random(); // Ошибка! Требуется параметр!
    }
}

```

Ключевой аспект функционального интерфейса состоит в том, что его можно
использовать с любым лямбда-выражением, которое с ним совместимо.

```java
// Использование одного и того же функционального интерфейса с 
// тремя разными лямбда выражениями
interface NumericTest {
    boolean test(int n, int m);
}

public class Code {
    public static void main(String[] args) {
        // Является ли одно число делителем другого
        NumericTest numericTest1 = (n, d) -> (n % d) == 0;
        if (numericTest1.test(10, 2))
            System.out.println("2 является делителем 10");
        if (!numericTest1.test(10, 3))
            System.out.println("3 не является делителем 10");
        System.out.println();

        // Первый аргумент меньше второго
        NumericTest numericTest2 = (n, m) -> (n < m);
        if (numericTest2.test(2, 10))
            System.out.println("2 меньше 10");
        if (!numericTest2.test(10, 2))
            System.out.println("10 не меньше 2");
        System.out.println();

        // Абсолютные значения аргументов равны
        NumericTest numericTest3 = (n, m) -> (n < 0 ? -n : n) == (m < 0 ? -m : m);
        if (numericTest3.test(4, -4))
            System.out.println("Абсолютные значения 4 и -4 равны .");
        if (!numericTest3.test(4, 5))
            System.out.println("Абсолютные значения 4 и -5 не равны .");
        System.out.println();
    }
}
```

## Блочные лямбда-выражения

Тело в лямбда-выражениях, показанных в предшествующих примерах, состояло из
единственного выражения. Такой вид тела лямбда-выражения называется
**_телом-выражением_**, а лямбда-выражение с телом-выражением **_одиночным
лямбда-выражением_**. В теле-выражении код в правой части лямбда-операции
должен содержать одно выражение. Но иногда требуется более одного выражения.
Для обработки таких случаев в Java поддерживается второй вид лямбда-выражений,
где в правой части лямбда-операции находится блок кода, который может содержать
более одного оператора. Тело этого вида называется **_блочным_**.
Лямбда-выражения с блочными телами иногда называются
**_блочными лямбда-выражениями_**.

За исключением того, что блочные лямбда-выражения разрешают указывать несколько
операторов, они используются почти так же, как только что рассмотренные
одиночные лямбда-выражения. Тем не менее, есть одно ключевое отличие: вы обязаны
явно применять оператор return, чтобы возвратить значение. Поступать так
необходимо, потому что тело блочного лямбда-выражения не представляет одиночное
выражение.

Блочное лямбда-выражение используется с целью нахождения наименьшего
положительного делителя для значения типа int. В нем применяется интерфейс
NumericFunc с методом func(), который принимает один аргумент типа int и
возвращает результат типа int. Таким образом, NumericFunc поддерживает числовую
функцию для значений типа int.

```java
// Блочное лямбда выражение находит наименьший положительный делитель для значения типа int.
interface NumericFunc {
    int func(int n);
}

public class Code {
    public static void main(String[] args) {
        // Это блочное лямбда-выражение возвращает наименьший
        // положительный делитель для значения.
        NumericFunc numericFunc = (n) -> {
            int result = 1;
            // Получаем абсолютное значение n.
            n = n < 0 ? -n : n;
            for (int i = 2; i < n / i; i++) {
                if ((n % 1) == 0) {
                    result = i;
                    break;
                }
            }
            return result;
        };
        System.out.println("Наименьший делитель 12" + numericFunc.func(12));
        System.out.println("Наименьший делитель 11" + numericFunc.func(11));
    }
}
```

## Обобщенные функциональные интерфейсы

Само лямбда-выражение не может указывать параметры типа. Таким образом,
лямбда-выражение не может быть обобщенным. (Разумеется, из-за выведения типов
все лямбда-выражения обладают некоторыми “обобщенными” качествами). Однако
функциональный интерфейс, ассоциированный с лямбда-выражением, может быть
обобщенным. В таком случае целевой тип лямбда-выражения частично определяется
аргументом или аргументами типов, указанными при объявлении ссылки на
функциональный интерфейс.

```java

// Использование обобщенного функционального интерфейса;

// Обобщенный функциональный интерфейс с двумя параметрами,
// который возвращает результат типа boolean
interface SomeTest<T> {
    boolean test(T n, T m);
}

public class Code {
    public static void main(String[] args) {
        // Это лямбда выражение определяет, является
        // ли одно число типа Integer делителем другого
        SomeTest<Integer> isFactor = (n, d) -> (n % d) == 0;
        if (isFactor.test(10, 2))
            System.out.println("2 является делителем 10");

        // Это лямбда-выражение определяет, является ли одно число типа Double
        // делителем другого
        SomeTest<Double> isFactorD = (n, d) -> (n % d) == 0;
        if (isFactorD.test(10.0, 2.0))
            System.out.println("2 является делителем 10");


        // Это лямбда-выражение определяет, является
        // л и одна строка частью другой строки.
        SomeTest<String> isIn = (a, b) -> a.indexOf(b) != -1;
        String str = "Generic Functional Interface";

        System.out.println("Проверяемая строка: " + str);
        if (isIn.test(str, "face"))
            System.out.println("Строка 'face' найдена.");
        else
            System.out.println("Строка 'face' не найдена.");

    }
}
```
Обобщенный функциональный интерфейс SomeTest в общем виде:

    interface SomeTest <T> {
        boolean test(T n, T m);
    }

Здесь T указывает возвращаемый тип и тип параметра test(). Это означает, что он
совместим с любым лямбда-выражением, которое принимает два параметра и
возвращает результат типа boolean.

Интерфейс SomeTest применяется для предоставления ссылки на три разных вида
лямбда - выражений. Первое лямбда-выражение использует тип Integer, второе — тип
Double, а третье — тип String. Таким образом, один и тот же функциональный
интерфейс может применяться для ссылки на лямбда-выражения isFactor, isFactorD и
isIn. Отличается только аргумент типа, передаваемый SomeTest.

## Лямбда-выражения и захват переменных

