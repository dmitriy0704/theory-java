# Лямбда выражения и ссылки на методы

## Введение

Ключевым аспектом для понимания реализации лямбда-выражений в Java являются две
конструкции: собственно лямбда - выражение и функциональный интерфейс. Начнем с
простого определения каждого из них.

**_Лямбда-выражение_** - анонимный (т.е. безымянный) метод. Используется для
реализации метода, определенного функциональным интерфейсом. Таким образом,
лямбда-выражение приводит к форме анонимного класса. Лямбда-выражения также
часто называют замыканиями.

**_Функциональный интерфейс_** это интерфейс, который содержит один и только
один
абстрактный метод, обычно устанавливающий предполагаемое назначение интерфейса.
Соответственно функциональный интерфейс, как правило, представляет одиночное
действие. Например, стандартный интерфейс Runnable является функциональным
интерфейсом, поскольку в нем определен только один метод: run(). Следовательно,
run() определяет действие Runnable. Кроме того, функциональный интерфейс задает
целевой тип лямбда-выражения. Важно понимать, что лямбда-выражение может
применяться только в контексте, в котором указан его целевой тип. И еще один
момент: функциональный интерфейс иногда называют типом SAM, где SAM означает
Single Abstract Method - единственный абстрактный метод.

## Основы лямбда-выражений

Лямбда-выражение опирается на синтаксический элемент и операцию. Операцию иногда
называется лямбда-операцией или операцией стрелки и обозначается с помощью ->.
Она делит лямбда-выражение на две части. В левой части указываются любые
параметры, требующиеся в лямбда-выражении. В правой части находится тело
лямбда-выражения, которое определяет действия лямбда-выражения. В Java
определены два вида тела лямбда-выражения с **одиночным выражением** и с *
*блоком
кода**.

    // Код 
    double method() {
        return 98.6;
    }

    можно заменить на
    () -> 98.6;

Когда лямбда-выражению необходим параметр, он указывается в списке параметров
слева от лямбда-операции:

    n -> (n % 2) == 0

## Функциональные интерфейсы

Как упоминалось ранее, функциональный интерфейс представляет собой такой
интерфейс, в котором определен только один абстрактный метод.
Не все методы интерфейса должны быть абстрактными. Начиная с JDK 8, интерфейс
может иметь один или несколько стандартных методов, которые не являются
абстрактными, как и закрытые и статические методы интерфейса. В результате
теперь метод интерфейса будет абстрактным только в том случае, если для него не
определена реализация. Это означает, что функциональный интерфейс может включать
стандартные, статические или закрытые методы, но во всех случаях он должен иметь
один и только один абстрактный метод. Поскольку нестандартные, нестатические,
незакрытые методы интерфейса неявно абстрактны, нет нужды применять модификатор
abstract (правда, при желании его можно указывать).

Пример:

    interface MyValue{
       double getValue();
    }

В данном случае метод getValue ( ) является неявно абстрактным и единственным
методом, определенным в MyValue. Таким образом, MyValue функциональный
интерфейс, функция которого определяется getValue().

Пример:

```java
interface MyValue {
    double getValue();
}

public class Code {
    public static void main(String[] args) {
//        MyValue myValue = new MyValue() {
//            public double getValue() {
//                return Math.random();
//            }
//        };
        // Можно заменить на
        MyValue myValue = () -> Math.random();
        // Или
        MyValue myValue = Math::random;
    }
}
```

Когда лямбда-выражение встречается в контексте целевого типа, автоматически
создается экземпляр класса, который реализует функциональный интерфейс, а
лямбда-выражение определяет поведение абстрактного метода, объявленного в
функциональном интерфейсе. При вызове данного метода через цель лямбда-выражение
выполняется. Таким образом, лямбда-выражение предоставляет способ трансформации
кодового сегмента в объект.

Если лямбда-выражение принимает один или несколько параметров, то абстрактный
метод в функциональном интерфейсе тоже должен принимать такое же количество
параметров.

```java
interface MyValue {
    double getValue(double d);
}

public class Code {
    public static void main(String[] args) {
        MyValue myValue = (d) -> 1.0 / d;
        System.out.println(myValue.getValue(4.0));
    }
}
```

Здесь getValue() реализуется лямбда-выражением, на которое ссылается myPval, и
возвращает обратную величину аргумента. В данном случае значение 4.0 передается
методу getValue(), который возвращает 0.25.

```java
package dev.folomkin.core.lambda;


// Функциональный интерфейс
interface MyValue {
    double getValue();
}

// Функциональный интерфейс
interface MyParamValue {
    double getValue(double value);
}


public class Code {
    public static void main(String[] args) {
        MyValue myVal; // Ссылка на функциональный интерфейс

        // Здесь лямбда-выражение представляет собой константное выражение.
        // Когда оно присваивается myVal, конструируется экземпляр класса,
        // где лямбда-выражение реализует метод getValue() из MyValue.

        // Интерфейс реализуется с помощью анонимного класса
//        myVal = new MyValue() {
//            public double getValue() {
//                return 42.0;
//            }
//        };

        // Который можно записать как лямбда выражение:
        myVal = () -> 42.0; // <- Простое лямбда-выражение

        // Вызвать метод getValue(), предоставляемый ранее присвоенным лямбда-выражением
        System.out.println(myVal.getValue());

        // Создать параметризованное лямбда-выражение и присвоить
        // его ссылке MyParamValue. Это лямбда-выражение возвращает
        // обратную величину переданного ему аргумента.
        MyParamValue myParamVal = (value) -> 1 / value; // Лямбда-выражение имеющее параметры

        // Вызываем getValue через ссылку myPval
        System.out.println(myParamVal.getValue(4.0));
        System.out.println(myParamVal.getValue(8.0));

        // Лямбда-выражение должно быть совместимым с методом, определенным
        // в функциональном интерфейсе. Таким образом, следующий код недопустим:
        // myVal = О -> "three"; // Ошибка! Типы String и double не совместимы !
        // myPval = () > Math.random(); // Ошибка! Требуется параметр!
    }
}

```

Ключевой аспект функционального интерфейса состоит в том, что его можно
использовать с любым лямбда-выражением, которое с ним совместимо.

```java
// Использование одного и того же функционального интерфейса с 
// тремя разными лямбда выражениями
interface NumericTest {
    boolean test(int n, int m);
}

public class Code {
    public static void main(String[] args) {
        // Является ли одно число делителем другого
        NumericTest numericTest1 = (n, d) -> (n % d) == 0;
        if (numericTest1.test(10, 2))
            System.out.println("2 является делителем 10");
        if (!numericTest1.test(10, 3))
            System.out.println("3 не является делителем 10");
        System.out.println();

        // Первый аргумент меньше второго
        NumericTest numericTest2 = (n, m) -> (n < m);
        if (numericTest2.test(2, 10))
            System.out.println("2 меньше 10");
        if (!numericTest2.test(10, 2))
            System.out.println("10 не меньше 2");
        System.out.println();

        // Абсолютные значения аргументов равны
        NumericTest numericTest3 = (n, m) -> (n < 0 ? -n : n) == (m < 0 ? -m : m);
        if (numericTest3.test(4, -4))
            System.out.println("Абсолютные значения 4 и -4 равны .");
        if (!numericTest3.test(4, 5))
            System.out.println("Абсолютные значения 4 и -5 не равны .");
        System.out.println();
    }
}
```

## Блочные лямбда-выражения

Тело в лямбда-выражениях, показанных в предшествующих примерах, состояло из
единственного выражения. Такой вид тела лямбда-выражения называется
**_телом-выражением_**, а лямбда-выражение с телом-выражением **_одиночным
лямбда-выражением_**. В теле-выражении код в правой части лямбда-операции
должен содержать одно выражение. Но иногда требуется более одного выражения.
Для обработки таких случаев в Java поддерживается второй вид лямбда-выражений,
где в правой части лямбда-операции находится блок кода, который может содержать
более одного оператора. Тело этого вида называется **_блочным_**.
Лямбда-выражения с блочными телами иногда называются
**_блочными лямбда-выражениями_**.

За исключением того, что блочные лямбда-выражения разрешают указывать несколько
операторов, они используются почти так же, как только что рассмотренные
одиночные лямбда-выражения. Тем не менее, есть одно ключевое отличие: вы обязаны
явно применять оператор return, чтобы возвратить значение. Поступать так
необходимо, потому что тело блочного лямбда-выражения не представляет одиночное
выражение.

Блочное лямбда-выражение используется с целью нахождения наименьшего
положительного делителя для значения типа int. В нем применяется интерфейс
NumericFunc с методом func(), который принимает один аргумент типа int и
возвращает результат типа int. Таким образом, NumericFunc поддерживает числовую
функцию для значений типа int.

```java
// Блочное лямбда выражение находит наименьший положительный делитель для значения типа int.
interface NumericFunc {
    int func(int n);
}

public class Code {
    public static void main(String[] args) {
        // Это блочное лямбда-выражение возвращает наименьший
        // положительный делитель для значения.
        NumericFunc numericFunc = (n) -> {
            int result = 1;
            // Получаем абсолютное значение n.
            n = n < 0 ? -n : n;
            for (int i = 2; i < n / i; i++) {
                if ((n % 1) == 0) {
                    result = i;
                    break;
                }
            }
            return result;
        };
        System.out.println("Наименьший делитель 12" + numericFunc.func(12));
        System.out.println("Наименьший делитель 11" + numericFunc.func(11));
    }
}
```

## Обобщенные функциональные интерфейсы

Само лямбда-выражение не может указывать параметры типа. Таким образом,
лямбда-выражение не может быть обобщенным. (Разумеется, из-за выведения типов
все лямбда-выражения обладают некоторыми “обобщенными” качествами). Однако
функциональный интерфейс, ассоциированный с лямбда-выражением, может быть
обобщенным. В таком случае целевой тип лямбда-выражения частично определяется
аргументом или аргументами типов, указанными при объявлении ссылки на
функциональный интерфейс.

```java

// Использование обобщенного функционального интерфейса;

// Обобщенный функциональный интерфейс с двумя параметрами,
// который возвращает результат типа boolean
interface SomeTest<T> {
    boolean test(T n, T m);
}

public class Code {
    public static void main(String[] args) {
        // Это лямбда выражение определяет, является
        // ли одно число типа Integer делителем другого
        SomeTest<Integer> isFactor = (n, d) -> (n % d) == 0;
        if (isFactor.test(10, 2))
            System.out.println("2 является делителем 10");

        // Это лямбда-выражение определяет, является ли одно число типа Double
        // делителем другого
        SomeTest<Double> isFactorD = (n, d) -> (n % d) == 0;
        if (isFactorD.test(10.0, 2.0))
            System.out.println("2 является делителем 10");


        // Это лямбда-выражение определяет, является
        // л и одна строка частью другой строки.
        SomeTest<String> isIn = (a, b) -> a.indexOf(b) != -1;
        String str = "Generic Functional Interface";

        System.out.println("Проверяемая строка: " + str);
        if (isIn.test(str, "face"))
            System.out.println("Строка 'face' найдена.");
        else
            System.out.println("Строка 'face' не найдена.");

    }
}
```

Обобщенный функциональный интерфейс SomeTest в общем виде:

    interface SomeTest <T> {
        boolean test(T n, T m);
    }

Здесь T указывает возвращаемый тип и тип параметра test(). Это означает, что он
совместим с любым лямбда-выражением, которое принимает два параметра и
возвращает результат типа boolean.

Интерфейс SomeTest применяется для предоставления ссылки на три разных вида
лямбда - выражений. Первое лямбда-выражение использует тип Integer, второе — тип
Double, а третье — тип String. Таким образом, один и тот же функциональный
интерфейс может применяться для ссылки на лямбда-выражения isFactor, isFactorD и
isIn. Отличается только аргумент типа, передаваемый SomeTest.

## Лямбда-выражения и захват переменных

Переменные, определенные в объемлющей области действия лямбда-выражения,
доступны внутри лямбда-выражения. Лямбда-выражение может задействовать
переменную экземпляра или статическую переменную, определенную в объемлющем
классе. Лямбда-выражение также имеет доступ к ссылке this(явно и неявно),
которая ссылается на вызывающий экземпляр класса, включающего лямбда-выражение.
Таким образом, лямбда-выражение может получать либо устанавливать значение
переменной экземпляра или статической переменной и вызывать метод, определенный
в объемлющем классе.

Когда в лямбда-выражении используется локальная переменная из его объемлющей
области видимости, то возникает особая ситуация, называемая захватом переменной.
В таком случае лямбда-выражение может работать только с локальными переменными,
которые являются фактически финальными. Фактически финальная переменная
представляет собой переменную, значение которой не меняется после ее первого
присваивания. Явно объявлять такую переменную как final нет никакой
необходимости, хотя поступать так не будет ошибкой. (Параметр this объемлющей
области видимости автоматически будет фактически финальным, а лямбда-выражения
не имеют собственной ссылки this.)
Локальная переменная из объемлющей области не может быть модифицирована
лямбда-выражением, поскольку в таком случае исчез бы ее статус фактически
финальной, из-за чего она стала бы незаконной для захвата.

```java
// Пример захвата локальной переменной из объемлющей области видимости ,
interface MyFunc {
    int func(int n);
}

class Code {
    public static void main(String[] args) {
        // Локальная переменная, которая может быть захвачена,
        int num = 10;
        MyFunc myLambda = (n) -> {
            // Использовать num подобным образом разрешено.
            // Переменная num не модифицируется,
            int v = num + n;
            // Однако следующая строка кода недопустима из-за того, что в ней
            // предпринимается попытка модифицировать значение num.
            // num++;
            return v;
        };
        // Использовать лямбда-выражение. Отобразится число 18.
        System.out.println(myLambda.func(8));
    }
    // Следующая строка кода тоже вызовет ошибку, потому что в ней
    // устраняется статус переменной num как фактически финальной.
    // num = 9;
}
```

В комментариях указано, что переменная num является фактически финальной и
потому может применяться внутри myLambda. Именно по этой причине оператор
printlnO выводит число 18. Когда метод func() вызывается с аргументом 8,
значение v внутри лямбда- выражения устанавливается путем сложения переменной
num (равной 10)и значения , переданного в п (равного 8). В итоге func()
возвращает 18. Такая работа объясняется тем, что num не изменяется после
инициализации. Однако если значение num будет изменено внутри лямбда-выражения
или за его пределами, то переменная num утратит свой статус фактически
финальной, что вызовет ошибку и программа не скомпилируется.

### Генерация исключений в лямбда-выражениях

Лямбда-выражение может генерировать исключение. Тем не менее, если инициируется
проверяемое исключение, то оно должно быть совместимым с исключением или
исключениями, которые перечислены в конструкции throws абстрактного метода в
функциональном интерфейсе. Например, если лямбда-выражение генерирует исключение
IOException, то в конструкции throws абстрактного метода в функциональном
интерфейсе должно быть указано IOException.

```java
interface MyIOAction {
    boolean ioAction(Reader rdr) throws IOException;
}

class Code {
    public static void main(String[] args) {

        // Это блочное лямбда-выражение может сгенерировать исключение IOException.
        // Следовательно, IOException должно быть указано в конструкции throws
        // метода ioAction() в MyAction.
        MyIOAction myIOAction = (rdr) -> {  // <-- Это лямбда выражение
            // может сгенерировать исключение

            int ch = rdr.read();            // может сгенерировать исключение
            // IOException;
            // ...
            return true;
        };
    }
}
```

Поскольку вызов read() может привести к генерации исключения IOException,
конструкция throws метода ioAction() в функциональном интерфейсе MylOAction
должна включать IOException. В противном случае программа не скомпилируется,
потому что лямбда - выражение больше не будет совместимым с ioAction().

## Ссылки на методы

С лямбда-выражениями связана одна важная возможность, которая называется ссылкой
на метод. Ссылка на метод предлагает способ обращения к методу, не инициируя его
выполнение. Она имеет отношение к лямбда-выражениям, поскольку тоже требует
контекста целевого типа, состоящего из совместимого функционального интерфейса.
При вычислении ссылки на метод также создается экземпляр функционального
интерфейса. Существуют различные виды ссылок.

### Ссылка на статические методы

Для ссылки на статический метод применяется следующий общий синтаксис,
предусматривающий указание имени класса перед именем метода:

    имя-класса::имя-метода

Имя класса отделяется от имени метода двойным двоеточием. Разделитель :: был
добавлен к языку в версии JDK 8 специально для этой цели. Ссылка на метод может
использоваться везде, где она совместима со своим целевым типом.

```java
import java.io.IOException;
import java.io.Reader;

// Функциональный интерфейс для предикатов,
// работающими с целочисленными значениями
interface IntPredicate {
    boolean test(int n);
}

// В этом классе определены три статических метода,
// которые выполняют проверку целого числа на предмет
// соответствию условию.
class MyIntPredicates {

    // Статический метод, который возвращает true,
    // если число является простым
    static boolean isPrime(int n) {
        if (n < 2) return false;
        for (int i = 2; i <= n / i; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }

    // Статический метод, который возвращает true,
    // если число является четным.
    static boolean isEven(int n) {
        return n % 2 == 0;
    }

    // Статический метод, который возвращает true,
    // если число является положительным.
    static boolean isPositive(int n) {
        return n > 0;
    }
}

class Code {
    // Типом первого параметра этого метода является
    // функциональный интерфейс. Таким образом, ему можно передавать
    // ссылку на любой экземпляр данного интерфейса, включая
    // созданный ссылкой на метод.
    static boolean numTest(IntPredicate p, int v) {
        return p.test(v);
    }

    public static void main(String[] args) throws IOException {
        boolean result;

        // Передать numTest() ссылку на метод isPrime.
        result = numTest(MyIntPredicates::isPrime, 17);
        if (result) System.out.println("17 is prime");

        // Передать numTestO ссылку на метод isEven.
        result = numTest(MyIntPredicates::isEven, 12);
        if (result) System.out.println("12 является четным.");

        // Передать numTestO ссылку на метод isPositive.
        result = numTest(MyIntPredicates::isPositive, 11);
        if (result) System.out.println("11 является положительным.");
    }
}

```

### Ссылки на методы экземпляра

Ссылка на метод конкретного экземпляра создается с помощью следующего базового
синтаксиса:

    объектная-ссылка : : имя-метода

Синтаксис ссылки на метод экземпляра подобен синтаксису, применяемому для ссылки
на статический метод, но вместо имени класса используется объектная ссылка.
Таким образом, метод, на который указывает ссылка, работает по отношению к
конструкции _объектная ссылка_.

Данный аспект иллюстрируется в приведенной ниже программе. В ней используется
тот же интерфейс IntPredicate и метод test(), что и в предыдущей программе, но
создается класс по имени MyIntNum, где хранится значение int и определяется
метод isFactor(), который выясняет, является ли переданное значение делителем
значения, сохраненного в экземпляре MyIntNum. Затем в методе main() создаются
два экземпляра MyIntNum, после чего вызывается numTest() с передачей ссылки на
метод isFactorO и проверяемое значение. В каждом случае ссылка на метод работает
относительно конкретного объекта.

