# Многопоточность

## Класс Thread и интерфейс Runnable

Потоки — средство, которое помогает организовать одновременное выполнение
нескольких задач, каждой в независимом потоке. Потоки представляют собой
экземпляры классов, каждый из которых запускается и функционирует
самостоятельно, автономно (или относительно автономно) от главного потока
выполнения программы. Существует три способа создания и запуска потока: на
основе расширения класса Thread, реализации интерфейсов Runnable или Callable.

```java
class WalkThread extends Thread {
    public void run() {
        try {
            for (int i = 0; i < 7; i++) {
                System.out.println("Walking " + i);
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        } finally {
            System.out.println(Thread.currentThread().getName() + " is over");
        }
    }
}

class TalkThread implements Runnable {
    @Override
    public void run() {
        try {
            for (int i = 0; i < 7; i++) {
                System.out.println("Talking -> " + i);
                try {
                    Thread.sleep(1);
                } catch (InterruptedException exception) {
                    exception.printStackTrace();
                }
            }
        } finally {
            System.out.println(Thread.currentThread().getName() + " is over");
        }
    }
}

public class Code {
    public static void main(String[] args) {
        WalkThread walk = new WalkThread(); // -> Новый объект thread
        walk.start(); // -> старт потока

        Thread talk = new Thread(new TalkThread()); // -> Создание потока 
        talk.start(); // -> старт потока

//      // Или лямбда
//      (new Thread(() ->
//              System.out.println(
//                      Thread.currentThread().getName() + " is over")
//      )).start(); // -> Новый объект thread и его старт
    }
}
```

Запуск двух потоков для объектов классов WalkThread непосредственно
и TalkThread через инициализацию экземпляра Thread приводит к выводу
строк: Walk n и Talk -->n. Порядок вывода, как правило, различен при
нескольких запусках приложения.

В конце работы каждого потока происходит вызов Thread.currentThread().getName(),
обеспечивающий вывод на консоль имени потока, в котором произошел вызов. В
данном случае это будут строки Thread-1 и Thread-2. Имена даются потокам по
умолчанию либо с помощью метода setName(String name)или конструктора потока.
Статический метод currentThread() дает доступ к потоку, в котором он вызван.

Интерфейс Runnable не имеет метода start(), а только единственный метод run().
Поэтому для запуска такого потока, как TalkThread, следует создать
экземпляр класса Thread с передачей экземпляра TalkThread его конструктору.
Однако при прямом вызове метода run() поток не запустится, выполнится только
тело самого метода.

## Жизненный цикл потока

При выполнении программы объект класса Thread может быть в одном из
четырех основных состояний: «новый», «работоспособный», «неработоспособный» и
«пассивный». При создании потока он получает состояние «новый» **_(NEW)_** и не
выполняется. Для перевода потока из состояния «новый» в состояние
«работоспособный» **_(RUNNABLE)_** следует выполнить метод start(), который
вызывает метод run() — основной метод потока. Поток в этом состоянии либо
запущен, либо готов к выполнению. Однако он может ожидать выделения ресурсов,
таких как процессорное время или доступ к общему ресурсу. Как только необходимые
ресурсы будут доступны, поток может продолжить свое выполнение.

Поток может находиться в одном из состояний, соответствующих элементам
статически вложенного класса-перечисления Thread.State:

- **_NEW_** — поток создан, но еще не запущен -> Создан новый объект потока;
- **_RUNNABLE_** — поток выполняется -> Вызван метод start();
- **_BLOCKED_** — поток блокирован;
- **_WAITING_** — поток ждет окончания работы другого потока;
- **_TIMED_WAITING_** — поток некоторое время ждет окончания другого потока или
  просто в ожидании истечения времени;
- **_TERMINATED_** — поток завершен.

Потоки пребывают в нескольких состояниях. Поток может выполняться. Он
может быть готовым к запуску, как только получит время ЦП. Работающий по-
ток может быть приостановлен, в результате чего он временно прекращает свою
активность. Выполнение приостановленного потока затем можно возобновить,
позволяя ему продолжиться с того места , где он остановился. Поток может быть
заблокирован при ожидании ресурса. В любой момент работа потока может быть
прекращена, что немедленно останавливает его выполнение . После прекращения
работы выполнение потока не может быть возобновлено.

Получить текущее значение состояния потока можно вызовом метода **getState()**.

Поток переходит в состояние «неработоспособный» в режиме ожидания
**_(WAITING)_** вызовом методов **_join(), wait()_** или методов ввода/вывода,
которые предполагают задержку.

Для задержки потока на некоторое время (в миллисекундах) можно перевести его в
режим ожидания по времени **_(TIMED_WAITING)_** с помощью методов
**yield(),sleep(longmillis), join(long timeout) и wait(long timeout)**.

Вернуть потоку работоспособность после вызова метода suspend() можно методом
resume() (deprecated-метод), а после вызова метода wait() — методами notify()
или notifyAll().

Когда поток просыпается, ему необходимо изменить состояние монитора
объекта, на котором проходило ожидание. Для этого поток переходит в состояние
BLOCKED и только после этого возвращается в работоспособное состояние.

Поток переходит в «пассивное» состояние (TERMINATED), если вызваны методы
interrupt(), stop() (deprecated-метод) или метод run() завершил выполнение,
и запустить его повторно уже невозможно. После этого, чтобы запустить поток,
необходимо создать новый объект потока. Метод interrupt() успешно завершает
поток, если он находится в состоянии «работоспособный». Если же поток в этот
момент неработоспособен, например, находится в состоянии TIMED_WAITING,
то метод инициирует исключение InterruptedException. Чтобы это не происходило,
следует предварительно вызвать метод isInterrupted(), который проверит
возможность завершения работы потока. При разработке не следует использовать
методы принудительной остановки потока, так как возможны проблемы с закрытием
ресурсов и другими внешними объектами.

Deprecated-методы класса Thread: suspend(), resume(), stop() и некоторые
другие категорически запрещены к использованию, так как они не являются
в полной мере потокобезопасными.

![thread-state0.png](/img/threads/thread-state0.png)

### Из другого источника

![thread-state1.png](/img/threads/thread-state1.png)
**_NEW_** — состояние, когда поток создан и готов к использованию. Это
состояние,
когда мы еще не запустили поток.

**_RUNNABLE_** — состояние, в которое поток переходит после того, как мы его
запустили. В этом состоянии поток выполняет свою работу, т.е. логику, которую мы
определили.

**_WAITING_** — состояние ожидания, в которое поток может перейти во время
своего выполнения. Есть три состояния ожидания — **_BLOCKED_**, **_WAITING_**,
**_TIMED_WAITING_**.
Например, когда поток пытается получить монитор объекта, он входит в состояние
блокировки — **_BLOCKED_**; когда поток ожидает выполнения другого потока, тогда
поток переходит в состояние ожидания — **_WAITING_**, а когда поток ожидает
только определённое количество времени для выполнения другого потока, поток
входит в состояние — **_TIMED_WAITING_**. Поток возвращается в состояние —
**_RUNNABLE_**, как только другие потоки выполнили или освободили монитор
объекта. Поток может бесконечно менять свое состояние из состояния —
**_RUNNABLE_** в состояние — **_WAITING_** и наоборот.

**_DEAD_** / **_TERMINATED_** — состояние, в которое поток переходит после
завершения
выполнения или в случае возникновения исключений. Поток после выполнения не
может быть запущен снова. Если мы попытаемся запустить поток в состоянии —
Dead / Terminated, мы получим исключение IllegalStateException.

## Перечисление TimeUnit

Представляет различные единицы измерения времени. В TimeUnit реализован ряд
методов по преобразованию между единицами измерения и по управлению операциями
ожидания в потоках в этих единицах. Используется для информирования методов,
работающих со временем, о том, как интерпретировать заданный параметр времени.

Перечисление TimeUnit может представлять время в семи размерностях-значениях:
NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS.

Кроме методов преобразования единиц времени, представляют интерес методы
управления потоками:

- void timedWait(Object obj, long timeout) — выполняет метод wait(long time) для
  объекта obj класса Object, используя заданные единицы измерения;
- void timedJoin(Thread thread, long timeout) — выполняет метод join(long time)
  на потоке thread, используя заданные единицы измерения;
- void sleep(long timeout) — выполняет метод sleep(long time) класса Thread,
  используя заданные единицы измерения. Например:

      TimeUnit.MINUTES.sleep(42);

