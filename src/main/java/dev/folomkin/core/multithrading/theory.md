# Многопоточность

## Класс Thread и интерфейс Runnable

Потоки — средство, которое помогает организовать одновременное выполнение
нескольких задач, каждой в независимом потоке. Потоки представляют собой
экземпляры классов, каждый из которых запускается и функционирует
самостоятельно, автономно (или относительно автономно) от главного потока
выполнения программы. Существует три способа создания и запуска потока: на
основе расширения класса Thread, реализации интерфейсов Runnable или Callable.

```java
class WalkThread extends Thread {
    public void run() {
        try {
            for (int i = 0; i < 7; i++) {
                System.out.println("Walking " + i);
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        } finally {
            System.out.println(Thread.currentThread().getName() + " is over");
        }
    }
}

class TalkThread implements Runnable {
    @Override
    public void run() {
        try {
            for (int i = 0; i < 7; i++) {
                System.out.println("Talking -> " + i);
                try {
                    Thread.sleep(1);
                } catch (InterruptedException exception) {
                    exception.printStackTrace();
                }
            }
        } finally {
            System.out.println(Thread.currentThread().getName() + " is over");
        }
    }
}

public class Code {
    public static void main(String[] args) {
        WalkThread walk = new WalkThread(); // -> Новый объект thread
        walk.start(); // -> старт потока

        Thread talk = new Thread(new TalkThread()); // -> Создание потока 
        talk.start(); // -> старт потока

//      // Или лямбда
//      (new Thread(() ->
//              System.out.println(
//                      Thread.currentThread().getName() + " is over")
//      )).start(); // -> Новый объект thread и его старт

        // Или так
//      Runnable runnable = ()-> System.out.println("Thread started");
//      new Thread(runnable).start();

    }
}
```

Запуск двух потоков для объектов классов WalkThread непосредственно
и TalkThread через инициализацию экземпляра Thread приводит к выводу
строк: Walk n и Talk -->n. Порядок вывода, как правило, различен при
нескольких запусках приложения.

В конце работы каждого потока происходит вызов Thread.currentThread().getName(),
обеспечивающий вывод на консоль имени потока, в котором произошел вызов. В
данном случае это будут строки Thread-1 и Thread-2. Имена даются потокам по
умолчанию либо с помощью метода setName(String name)или конструктора потока.
Статический метод currentThread() дает доступ к потоку, в котором он вызван.

Интерфейс Runnable не имеет метода start(), а только единственный метод run().
Поэтому для запуска такого потока, как TalkThread, следует создать
экземпляр класса Thread с передачей экземпляра TalkThread его конструктору.
Однако при прямом вызове метода run() поток не запустится, выполнится только
тело самого метода.

## Жизненный цикл потока

![thread-state0.png](/img/threads/thread-state0.png)

Поток готов к запуску когда он создается и запускается путем вызова метода
**start()** в классе Thread. Когда в Thread вызывается **sleep()** или
**wait()** поток переходит в неработоспособное состояние.

Состояния хранятся как статические перечисления в классе Thread.

        NEW
            Состояние потока, который еще не запущен.

        RUNNABLE 
            Состояние потока для работающего потока. Поток в работающем состоянии
            выполняется в виртуальной машине Java, но он может
            ожидать другие ресурсы от операционной системы,
            например, процессор.

        BLOCKED 
            Состояние потока для потока, заблокированного в ожидании блокировки монитора.
            Поток в заблокированном состоянии ожидает блокировки монитора,
            чтобы войти в синхронизированный блок/метод или
            повторно войти в синхронизированный блок/метод после вызова.
            Метод - Object.wait()
         
        WAITING, 
            Состояние потока для ожидающего потока.
            Поток находится в состоянии ожидания из-за вызова одного из
            следующих методов:                  
            - Object.wait() - без таймаута
            - Thread.join() - без таймаута
            - LockSupport.park()                   
            Поток в состоянии WAITING ждет, пока другой поток
            выполнит определенное действие.
            Например, поток, вызвавший Object.wait()
            для объекта, ждет, пока другой поток вызовет
            Object.notify() или Object.notifyAll()
            для этого объекта. Поток, вызвавший Thread.join()
            ожидает завершения указанного потока.             
          
        TIMED_WAITING,
            Состояние потока для ожидающего потока с указанным временем 
            ожидания. Поток находится в состоянии ожидания с заданным 
            временем из-за вызова одного из следующих методов с указанным 
            положительным временем ожидания:             
            * Thread.sleep()
            * Object.wait() с таймаутом
            * Thread.join() с таймаутом
            * LockSupport.parkNanos()
            * LockSupport.parkUntil()

        TERMINATED 
            Состояние потока для завершенного потока.
            Поток завершил выполнение.

Состояния потока

- **_NEW_** - Это состояние представляет собой недавно созданный поток, который
  еще не начал свое выполнение. В этом состоянии поток готов к планированию
  операционной системой, но ему не назначено никакого процессорного времени.
- **_RUNNABLE_** - Поток в этом состоянии либо запущен, либо готов к выполнению.
  Однако он может ожидать выделения ресурсов, таких как процессорное время или
  доступ к общему ресурсу. Как только необходимые ресурсы будут доступны, поток
  может продолжить свое выполнение.
- **_BLOCKED_** - В этом состоянии поток ожидает получения блокировки монитора
  (monitor lock), которая необходима для ввода или повторного ввода
  синхронизированного блока или метода. Поток остается в этом состоянии до тех
  пор, пока monitor lock не станет доступен.
- **_WAITING_** - Когда поток находится в этом состоянии, он ожидает, пока
  какой-либо другой поток выполнит определенное действие без каких-либо
  временных ограничений. Это может произойти, например, когда один поток ожидает
  сигнала от другого для продолжения своего выполнения.
- **_TIMED_WAITING_** - он похож на **WAITING**, но есть некоторые отличия. Это
  состояние возникает, когда один поток ожидает от другого выполнения
  определенного действия, но только в течение определенного периода времени.
- **_TERMINATED_** - состояние, когда поток завершил свое выполнение. Это
  означает, что он завершил назначенную ему задачу и больше не активен. Важно
  отметить, что как только поток достигает этого состояния, его нельзя
  перезапустить или возобновить работу.

**_ПОЛУЧЕНИЕ СОСТОЯНИЯ ПОТОКА:_**

#### NEW

```java
class State implements Runnable {
    public void run() {
    }
}

public class Code {
    public static void main(String[] args) {
        Runnable runnable = new State();
        Thread thread = new Thread(runnable);
        System.out.println("Thread state: " + thread.getState());
        // -> Thread state: NEW
    }
}
```

В многопоточной среде планировщик потоков(Thread-Scheduler) (который является
частью JVM) выделяет фиксированное количество времени для каждого потока. Таким
образом, он выполняется в течение определенного периода времени, затем передает
управление другим выполняемым потокам.

#### RUNNABLE

Когда мы создаем новый поток и вызываем для него метод start(), он переходит из
состояния NEW в состояние RUNNABLE. Потоки в этом состоянии либо запущены, либо
готовы к запуску, но они ожидают выделения ресурсов системой.

```java
class State implements Runnable {
    public void run() {
    }
}

public class Code {
    public static void main(String[] args) {
        Runnable runnable = new State();
        Thread thread = new Thread(runnable);
        thread.start();
        System.out.println("Thread state: " + thread.getState());
        // -> Thread state: RUNNABLE
    }
}
```

Теперь метод t.getState() вероятнее всего в консоль выведет "RUNNABLE".
Почему вероятнее всего? Дело в том, что когда наш элемент управления достигнет
t.getState(), мы не всегда можем быть уверены, что он будет находиться в
состоянии **_RUNNABLE_**. Это связано с тем, что в некоторых случаях элемент
может
быть немедленно запланирован планировщиком потоков (**_Thread-Scheduler_**) и
завершить своё выполнение. Именно в таких ситуациях возможны другие результаты.

#### BLOCKED

Поток переходит в состояние BLOCKED, когда ожидает блокировки монитора(monitor
lock) и пытается получить доступ к разделу кода, который заблокирован каким-либо
другим потоком.

```java
class State implements Runnable {
    @Override
    public void run() {
        commonResource();
    }

    public static synchronized void commonResource() {
        while (true) {
        }
    }
}

public class Code {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new State());
        Thread t2 = new Thread(new State());
        t1.start();
        t2.start();
        Thread.sleep(1000);
        System.out.println(t2.getState()); // -> BLOCKED
        System.exit(0);
    }
}
```

_**Разбор кода:**_

1. Мы создали два разных потока – t1 и t2
2. t1 запускается и вводит синхронизированный метод commonResource(); это
   означает, что только один поток может получить к нему доступ; все остальные
   последующие потоки, которые попытаются получить доступ к этому методу, будут
   заблокированы от дальнейшего выполнения до тех пор, пока текущий не завершит
   обработку.
3. Когда t1 входит в этот метод, он сохраняется в бесконечном цикле while; Это
   сделано для имитации интенсивной обработки, чтобы все остальные потоки не
   могли войти в этот метод.
4. Теперь, когда мы запускаем t2, он пытается ввести метод commonResource(), к
   которому уже обращается t1, таким образом, t2 будет сохранен в состоянии
   BLOCKED.
5. Вызовем t2.getState() и получим результат "BLOCKED"

#### WAITING

Поток находится в состоянии WAITING, когда он ожидает, пока какой-либо другой
поток выполнит определенное действие. Согласно JavaDocs, любой поток может войти
в это состояние, вызвав любой из этих трех методов:

- object.wait()
- thread.join() - в потоке1 вызывается поток2.join() и это переводит поток1 в
  состояние ожидания;
- LockSupport.park()

```java
public class Code implements Runnable {
    public static Thread t1;

    public static void main(String[] args) throws InterruptedException {
        t1 = new Thread(new Code());
        t1.start();
    }

    @Override
    public void run() {
        Thread t2 = new Thread(new State());
        t2.start();
        try {
            t2.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}

class State implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(Code.t1.getState()); // -> WAITING
    }
}
```

Разбор кода:

1. Мы создали и запустили t1
2. t1 создает t2 и запускает его
3. Пока продолжается работа t2, мы вызываем t2.join(), это переводит t1 в
   состояние ожидания(WAITING), пока t2 не завершит выполнение.
4. Поскольку t1 ожидает завершения t2, мы вызываем t1.getState() из t2 и
   получаем результат "WAITING"