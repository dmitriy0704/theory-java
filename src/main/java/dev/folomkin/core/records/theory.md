# Записи (record)

Как уже упоминалось, запись это узконаправленный, специализированный класс.
Запись объявляется с помощью контекстночувствительного ключевого слова record,
которое трактуется как ключевое слово только в контексте объявления записи. В
других ситуациях record считается пользовательским идентификатором без особой
значимости. Таким образом, добавление record не влияет на существующий код и не
нарушает его работу.

Ниже показана общая форма объявления записи:

    record имя записи [ список-компонентов ) {
        // необязательные операторы тела
    }

Видно, что объявление записи имеет существенные отличия от объявления класса.
Во-первых, сразу после имени записи следует разделенный запятыми список
объявлений параметров, называемый списком компонентов. В списке компонентов
определяются данные, которые будут храниться в записи.
Во-вторых, тело записи является необязательным благодаря тому, что компилятор
автоматически предоставит элементы, необходимые для хранения данных, создаст
конструктор записи и методы получения, которые обеспечат доступ к данным, а
также переопределит методы toString(), equals() и hashCode(), унаследованные от
класса Object. В результате во многих сценариях использования тело не требуется,
т.к. само объявление record полностью определяет запись.  
Пример объявления простой записи:

    record Item(String name, int itemNum, double price) {}

Для только что показанного объявления Item определенные элементы создаются
автоматически.
Во-первых, для name, itemNum и price объявляются закрытые финальные поля с
типами String, int и double.
Во-вторых, предоставляются открытые методы доступа, допускающие только чтение (
методы получения), которые имеют такие же имена и типы, как у компонентов записи
name, itemNum и price, т.е. name(), itemNum() и price(). В общем случае для
каждого компонента записи компилятор будет автоматически создавать
соответствующее закрытое финальное поле и открытый метод получения, допускающий
только чтение.  
Еще одним элементом, который автоматически создается компилятором, будет
канонический конструктор записи. Такой конструктор имеет список параметров,
который содержит те же элементы в том же порядке, что и список компонентов в
объявлении записи. Значения , передаваемые конструктору, автоматически
присваиваются соответствующим полям в записи. Канонический конструктор в записи
заменяет собой стандартный конструктор в классе.  
Запись создается с помощью операции new тем же способом, каким создается
экземпляр класса. Например:

```java
record Item(String name, int itemNum, double price) {
}

class Code {
    public static void main(String[] args) {
        Item item = new Item("test", 2, 1.0);
        System.out.println(item.itemNum() + " " + item.price() + " " + item.name());
    }
}
```

Данные записи хранятся в закрытых финальных полях и предоставляются только
методы получения. Следовательно, содержащиеся в записи данные являются
неизменяемыми. После конструирования записи ее содержимое модифицировать нельзя.
Тем не менее, если запись содержит ссылку на какой-то объект, тогда в этот
объект можно вносить изменения, но не разрешено изменять то, на что ссылается
ссылка в записи. Таким образом, в терминах Java говорят, что записи поверхностно
неизменяемы

```java
// Простой пример работы с записями.
// Объявить запись Item, что приведет к автоматическому созданию класса
// с закрытыми финальными полями, имеющими имена name, itemNum и price,
// а также с методами доступа name(), itemNum() и price().
record Item(String name, int itemNum, double price) {
} // <- Объявляется запись

class Code {
    public static void main(String[] args) {
        // Создать массив записей Item.
        Item[] items = new Item[4];
        // Заполнить массив элементами.
        // Аргументы автоматически присваиваются полям name, itemNum
        // и price в создаваемой записи.
        items[0] = new Item("Hammer", 257, 10.99); // Создать экземпляр записи
        items[1] = new Item("Wrench", 18, 19.29);
        items[2] = new Item("Drill", 903, 22.25);
        items[3] = new Item("Saw", 27, 34.59);
        // Использовать методы доступа к содержимому записи
        // для отображения списка товаров ,
        for (Item i : items) {
            System.out.println(i.name() + "; Идентификационный номер: "
                    + i.itemNum() + "; Цена: " + i.price());
        }
    }
}
```

**_Ограничения записей_**

**Запись не может быть унаследована от другого класса**.  
Все записи неявно унаследованы от класса java.lang. Record,
в котором переопределяются абстрактные методы equals(), hashCode() и toString(),
объявленные в Object. Неявные реализации этих методов создаются автоматически
на основе объявления записи.  
**Тип записи не может быть расширен**.   
Таким образом, все объявления записей считаются финальными. Хотя запись не может
расширять другой класс, она может реализовывать один или несколько интерфейсов.
За исключением equals применять имена методов, определенных в Object, для имен
компонентов записи нельзя. Помимо полей, ассоциированных с компонентами записи,
любые другие поля должны быть статическими.   
**Запись может быть обобщенной.**

## Создание конструкторов записи

Можно определить собственную реализацию канонического конструктора.
Например, конструктор может проверять, входит ли значение в требуемый
диапазон, выяснять, находится ли значение в корректном формате,
удостоверяться в том, что объект реализует необязательную функциональность,
или подтверждать, что аргумент не равен null.  
Существуют два основных вида конструкторов, создаваемые явно: канонический и
неканонический, и между ними есть некоторые различия.

### Объявление канонического конструктора

Существуют два способа, которыми можно написать собственную реализацию.
Во-первых, есть возможность явно объявить полную форму _канонического
конструктора._ Во-вторых, можно использовать так называемый _компактный
канонический конструктор._

Для определения собственной реализации канонического конструктора,
указывается имя записи и список параметров. Важно подчеркнуть, что для
канонического конструктора типы и имена параметров обязаны совпадать с
указанными в объявлении записи. Причина в том, что имена параметров связаны с
автоматически создаваемыми полями и методами доступа, определенными в объявлении
записи. Таким образом, они должны соответствовать как по типу, так и по имени.
Кроме того, после завершения конструктора каждый компонент должен быть полностью
инициализирован.

**Применяются следующие ограничения:**
конструктор должен быть, по меньшей мере, таким же доступным, как в объявлении
записи. Если в записи указан модификатор доступа public, то конструктор тоже
должен быть определен как public. Конструктор не может быть обобщенным и не
может включать конструкцию throws. Он также не может вызывать другой
конструктор, определенный для записи.

```java
record Item(String name, int itemNum, double price) {

    // Явно объявленный канонический конструктор
    public Item(String name, int itemNum, double price) {
        // Удалить ведущие и завершающие пробелы с использованием
        // метода trim() , определенного в классе String ,
        this.name = name.trim();
        // Установить остальные поля в Item ,
        this.itemNum = itemNum;
        this.price = price;
    }
}
```

**_Компактный канонический конструктор_**   
объявляется за счет указания имени записи, но без параметров. Компактный
конструктор неявно имеет параметры, имена которых соответствуют компонентам
записи, а значения аргументов, переданных конструктору, автоматически
присваиваются данным компонентам. Внутри компактного конструктора можно изменить
один или несколько аргументов до того, как их значения будут присвоены
компонентам записи. Можно также сгенерировать исключение в случае возникновения
ошибки или выполнить какую-либо другую процедуру.

```java
record Item(String name, int itemNum, double price) {
    // Компактный канонический конструктор.
    public Item { // <- В компактном каноническом
        // конструкторе параметры не указываются.
        // Удаляем ведущие и завершающие пробелы с использованием
        // метода trim(), определенного в классе String,
        name = name.trim();
        // Полям name, itemNum и price автоматически присваиваются значения
        // соответствующих параметров, когда конструктор завершает работу.
    }
}
```

### Объявление неканонического конструктора

Основное требование заключается в том, что любой неканонический конструктор
обязан сначала вызывать другой конструктор в записи через this. Объявление
неканонического конструктора позволяет создавать записи для особых случаев.
Скажем, вы можете применять такой конструктор для создания записи, в которой
одному или нескольким компонентам присваивается стандартное
значение-заполнитель. Другой сценарий использования связан с ситуацией, когда
аргумент не находится в форме, совместимой с каноническим конструктором.

```java
// Использование неканонического конструктора.
// Объявить запись для хранения товаров.
record Item(String name, int itemNum, double price) {
    // Использовать статическое поле в записи ,
    static double pricePending = -1;

    // Это неканонический конструктор. Он создает запись, для которой
    // цена товара передается в виде строки, а не значения double.
    // Таким образом, при передаче каноническому конструктору строка должна
    // быть преобразована в значение double,
    public Item(String name, int itemNum, String price) {
        this(name, itemNum, Double.parseDouble(price));
    }
}

class Code {
    public static void main(String[] args) {
        // Создать массив записей Item.
        Item[] items = new Item[4];
        // Создать несколько записей в items. Для этого будет
        // использоваться неявный канонический конструктор ,
        items[0] = new Item("Hammer ", 257, 10.99);
        items[1] = new Item("Wrench", 18, 19.29);
        // При создании следующих записей будет применяться неканонический
        // конструктор, поскольку цена передается в виде строки,
        // а не значения типа double.
        items[2] = new Item("Drill", 903, "22.25");
        items[3] = new Item("Saw", 27, "34.59");
        for (Item i : items) {
            System.out.println(i.name() + "; Идентификационный номер: "
                    + i.itemNum() + "; Цена: " + i.price());
        }
    }
}
```

### Методы получения для записей

В случае объявления метода получения его неявная версия больше не
предоставляется. Одна из причин объявления собственного метода получения связана
с возможностью генерации исключения, когда не удовлетворено какое-либо условие.
Например, если запись содержит имя файла и URL-адрес, то метод получения для
имени файла может генерировать исключение FileNotFoundException при отсутствии
файла по указанному URL-адресу. Однако существует очень важное требование
относительно создания методов получения: они должны придерживаться принципа
неизменяемости записи. Таким образом, метод получения, возвращающий
модифицированное значение, семантически сомнителен (и его следует избегать),
даже если код будет синтаксически корректным.

**_Ограничения:_**  
К объявлению реализации метода получения применяется несколько правил. Метод
получения обязан иметь такой же тип возвращаемого значения и имя, как у
компонента, который он получает. Кроме того, он должен быть явно объявлен
открытым. (Следовательно, для объявления метода получения в записи стандартной
доступности недостаточно.) В объявлении метода получения не разрешена
конструкция throws. Наконец, метод получения не должен быть ни обобщенным, ни
статическим.

Часто вместо переопределения встроенного метода получения лучше просто создать
метод, возвращающий желаемое значение. Например, в показанной далее версии Item
определен метод по имени DiscountPrice(), который возвращает цену товара со
скидкой на указанный процент. При таком подходе встроенный метод получения
price() не модифицируется, что сохраняет неизменяемость. Если необходимо
значение со скидкой, тогда вместо него вызывается DiscountPrice().

    record Item(String name, int itemNum, double price) (
      // . . .
      double discountPrice(double percentage) {
        return price - (price * percentage / 100.0);
      }
    }

