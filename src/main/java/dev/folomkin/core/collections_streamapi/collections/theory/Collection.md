# Коллекции

## Введение

Коллекции — это хранилища или контейнеры, поддерживающие различные способы
накопления и упорядочения объектов с целью обеспечения возможностей эффективного
доступа к ним. Они представляют собой реализацию абстрактных структур данных,
поддерживающих три основные операции:

- добавление нового элемента в коллекцию;
- удаление элемента из коллекции;
- изменение элемента в коллекции.

Примером коллекции является _стек_ (структура LIFO — Last In First Out),
в котором всегда удаляется объект, вставленный последним. Для очереди
(структура FIFO — First In First Out) используется другое правило удаления:
всегда удаляется элемент, вставляемый первым. В абстрактных типах данных
существует несколько видов очередей: двусторонние очереди, кольцевые очереди,
обобщенные очереди, в которых запрещены повторяющиеся элементы. Стеки и очереди
могут быть реализованы как на базе массива, так и на базе связного списка.

Коллекции в языке Java объединены в библиотеке классов java.util и представляют
собой контейнеры для хранения и манипулирования объектами. До появления
Java 2 эта библиотека содержала классы только для работы с простейшими
структурами данных: Vector, Stack, Hashtable, BitSet, а также интерфейс
Enumeration для работы с элементами этих классов. Коллекции, появившиеся
в Java 2, представляют собой общую технологию хранения и доступа к объектам.
Скорость обработки коллекций повысилась по сравнению с предыдущей версией
языка за счет отказа от их потокобезопасности. Поэтому, если объект коллекции
может быть доступен из различных потоков, что наиболее естественно для
распределенных приложений, возможно использование коллекции из Java 1.

В Java 5 в новом пакете java.util.concurrent появились ограниченно
потокобезопасные коллекции, гарантирующие более высокую производительность
в многопоточной среде для конкурирующих потоков. Так как в коллекциях при
практическом программировании хранится набор ссылок на объекты одного типа,
следует обезопасить коллекцию от появления ссылок на другие, не разрешенные
логикой приложения типы. Такие ошибки при использовании нетипизированных
коллекций выявляются на стадии выполнения, что повышает трудозатраты на
исправление и верификацию кода. Поэтому, начиная с версии Java SE 5,
коллекции стали типизированными или generic.

Более удобным стал механизм работы с коллекциями, а именно:

- предварительное сообщение компилятору о типе ссылок, которые будут храниться в
  коллекции, при этом проверка осуществляется на этапе компиляции;
- отсутствие необходимости постоянно преобразовывать возвращаемые по
  ссылке объекты (тип Object) к требуемому типу.

Структура коллекций характеризует способ, с помощью которого программы Java
обрабатывают группы объектов. Так как Object — суперкласс для всех
классов, то в коллекции можно хранить объекты любого типа, кроме базовых.
Коллекции — это динамические массивы, связные списки, деревья, множества,
хэш-таблицы, стеки, очереди.

Все классы коллекций реализуют интерфейсы Serializable, Cloneable (кро-
ме WeakHashMap).

**Иерархия колллекций:**
![collection.jpg](/img/collection/collection.jpg)

## Iterable

Объявляет один абстрактный метод _iterator()_ для извлечения объекта,
реализующего интерфейс Iterator.

## Iterator

Интерфейс Iterator<E> используется для последовательного доступа к элементам
коллекции. К этому типу относится объект, возвращаемый методом iterator(). Такой
объект позволяет осуществлять навигацию по содержимому коллекции
последовательно, элемент за элементом. Позиции итератора условно
располагаются в коллекции между элементами. В коллекции, состоящей из
N элементов, существует N+1 позиций итератора.

**_Основные методы:_**

- **boolean hasNext()** - проверяет наличие следующего элемента, а в случае его
  отсутствия (завершения коллекции) возвращает false. Итератор при этом остается
  неизменным;;
- E next() - возвращает ссылку на объект, на который указывает итератор, и
  передвигает текущий указатель на следующий, предоставляя доступ К следующему
  элементу. Если следующий элемент коллекции отсутствует, то метод next()
  генерирует исключение NoSuchElementException;
- void remove() - удаляет объект, возвращенный последним вызовом метода next().
  Если метод next() до вызова remove() не вызывался, то будет сгенерировано
  исключение IllegalStateException;
- removeIf(Predicate<? super T> filter) - ...
- foreach(Consumer<? super T> action) - ...
- void forEachRemaining(Consumer<? super E> action) - выполняет дейст- вие над
  каждым оставшимся необработанным элементом коллекции.

```java
    public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);
    list.add(4);

    Integer y = 3;
    Iterator<Integer> iterator = list.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
    // или
    for (Integer i : list) {
        System.out.println(i);
    }
    System.out.println(list);
}
```

Для доступа к элементам списка может также использоваться специализированный
интерфейс ListIterator<E>, который позволяет получить доступ
сразу в необходимую позицию списка вызовом метода listIterator(int index) на
объекте списка. Интерфейс ListIterator<E> расширяет интерфейс Iterator<E>,
предназначен для обработки списков и их вариаций. Наличие методов
E previous(), int previousIndex() и boolean hasPrevious() обеспечивает обратную
навигацию по списку. Метод int nextIndex() возвращает номер следующего
итератора. Метод void add(E e) позволяет вставлять элемент в список текущей
позиции. Вызов метода void set(E e) производит замену текущего
элемента списка на объект, передаваемый методу в качестве параметра.

Внесение изменений в коллекцию методами коллекции после извлечения итератора
гарантирует генерацию исключения ConcurrentModificationException из пакета
java.util при попытке использовать итератор позднее модификации коллекции.

Параллельная или конкурентная модификация коллекции методами самой
коллекции и ее итератором приводит к неразрешимой проблеме и заканчивается
генерацией исключения практически всегда. Проблема заключается в том,
что итератор извлек N число позиций, а коллекция изменила число своих
экземпляров, и итератор перестал соответствовать коллекции. Если модификацию
коллекции и работу с итератором нужно выполнять из различных потоков,
то для решения такой задачи используются ограниченно потокобезопасные решения
для коллекций из пакета java.util.concurrent.

При создании класса, содержащего коллекцию элементов, возможны два
способа: агрегация коллекции в качестве поля класса или отношение HAS-A
и наследование от класса, представляющего коллекцию, или отношение IS-A.

HAS-A:

```java
public class OrderType implements Iterable<String> {
    private int orderId;
    private List<String> currencyNames = new ArrayList<>();/* SEK, DKK, NOK, CZK,
    
    GBP, EUR, PLN */

    public OrderType(int orderId) {
        this.orderId = orderId;
    }

    public List<String> getCurrencyNames() {
        return List.copyOf(currencyNames);
    }

    // delegated method
    public boolean add(String e) {
        return currencyNames.add(e);
    }

    @Override
    public Iterator<String> iterator() {
        return currencyNames.iterator();
    }
}
```

Отношение IS-A записывается еще проще, но теряется имя currencyNames.
Класс OrderType теперь сам является списком

```java
public class OrderType extends ArrayList<String> {
    private int orderId;

    public OrderType(int orderId) {
        this.orderId = orderId;
    }
}
```

## Интерфейс Collection

Интерфейс Collection<E>, который принимает в качестве параметра дженерик типа
E (читается как «коллекция элементов типа E), является корневым интерфейсом
фреймворка «Коллекции». Он определяет общее поведение для всех классов,
например, устанавливает, как добавить или удалить элемент.

**_Основные подинтерфейсы:_**

- **List\<E>** - список, моделирует массив изменяемого размера, для которого
  разрешается доступ по индексу. Может содержать повторяющиеся элементы. Часто
  используемые реализации: ArrayList, LinkedList, Vector и Stack.
- **Queue\<E>** - очередь, моделирует очереди, организованные по принципу First
  In First Out(FIFO) - первым вошел - первым вышел. Элементы добавляются в один
  конец, извлекаются из другого. Подинтерфейс Deque<E> моделирует очереди,
  с котором можно работать с двух концов. Реализации включают PriorityQueue,
  ArrayDeque и LinkedList.
- **Set\<E>** - множество, моделирует математическое множество. Повторяющиеся
  элементы не допустимы. Часто используемые реализации: HashSet, LinkedHashSet.
  Подинтерфейс SortedSet<E> моделирует отсортированное упорядоченное множество
  элементов, реализованное TreeSet.

**_Основные методы Collection:_**

- **boolean add(E element)** - добавляет и возвращает true, если данная
  коллекция содержит заданный элемент и false, если такой элемент уже есть
  в коллекции;
- **boolean remove(Object element)** - Удаляет заданный элемент, если он имеется
  в коллекции;
- **int size()** - возвращает количество элементов данной коллекции
- **void clear()** - удаляет все элементы данной коллекции
- **boolean isEmpty()** - возвращает true, если коллекция не пуста
- **boolean contains(Object element)** - возвращает true, если коллекция
  содержит заданный элемент;
- **default boolean removeIf(Predicate<? super E> filter)** — удаляет все эле-
  менты коллекции в зависимости от условия.

**_Методы работы с другой коллекцией:_**

- **boolean addAll(Collection<? extends E> c)** - метод добавляет все элементы
  указанной коллекции в конец коллекции Collection типа E или ее подтипам, c -
  коллекция, которая будет добавляться в конец исходной;
- **boolean containsAll(Collection<?> c)** - Проверяет, содержит ли данная
  коллекция все элементы заданной коллекции, __**c**__ - коллекция элементы,
  которой будут проверяться на вхождение;
- **boolean removeAll(Collection<?> c)** - метод для удаления всех элементов
  указанной коллекции
- **boolean retainsAll(Collection<?> c)** - оставляет только те элементы,
  которые содержатся в указанной коллекции **с**.

**_Методы сравнения:_**

- **boolean equals(Object o)**
- **int hashCode()**

**_Методы работы с массивами:_**

- **Object[] toArrays()** - копирует все элементы коллекции в массив, возвращает
  массив типа Object[];
- **<T>T[] toArray(T[] a)** - возвращает массив, содержащий все элементы данной
  коллекции заданного типа T; тип возвращаемого массива

**_Методы для Stream API:_**

- **default Stream <E> stream()** - преобразует коллекцию в stream объектов;
- **default Stream<E> parallelStream()** — преобразует коллекцию в параллельный
  stream объектов. Повышает производительность при работе с очень
  большими коллекциями на многоядерных процессорах;

- **void forEach(Consumer<? super T> action)**, **Iterator<T> iterator()** -
  унаследован от интерфейса Iterable<T>.

При работе с элементами коллекции применяются интерфейсы: Iterator<E>,
ListIterator<E>, Map.Entry<K, V> — для перебора коллекции и доступа к объектам
коллекции.

