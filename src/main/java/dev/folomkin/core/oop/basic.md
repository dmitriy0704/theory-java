# Базовые понятия ООП

## Модификаторы доступа

*Спецификатор класса:*

- public
- friendly/private-package(не ставится, но означает) - класс доступен только в
  пакете
- final - класс не может иметь подклассов
- abstract - класс содержит абстрактные нереализованные методы, объект такого
  класса создать нельзя

*Уровни доступа для членов классов:*

- public - доступен везде
- private - переменная доступна в рамках класса
- protected - доступ только внутри пакета и подклассам в других пакетах

Модификаторы:

- private — члены класса доступны только членам данного класса;
- по умолчанию (package-private) — члены класса доступны классам, находящимся в
  том же пакете;
- protected — члены класса доступны классам, находящимся в том же пакете, и
  подклассам — в других пакетах;
- public — члены класса доступны для всех классов в этом и других пакетах.

Член класса (поле, конструктор или метод), объявленный public, доступен из
любого места вне класса. Спецификатор public для методов и конструкторов
public-классов обеспечивает внешний доступ к функциональности пакета, в котором
он объявлен. Если данный спецификатор отсутствует, то класс и его методы могут
использоваться только в текущем пакете.

Все, что объявлено private, доступно только конструкторам и методам внутри
класса и нигде больше. Они выполняют служебную или вспомогательную роль в
пределах класса, и их функциональность (методов и конструкторов) не
предназначена для внешнего использования. Закрытие private-полей обеспечивает
инкапсуляцию.

Если у члена класса вообще не указан спецификатор уровня доступа, то такой член
класса будет виден и доступен из подклассов и классов того же пакета. Именно
такой уровень доступа используется по умолчанию. Такой член класса обеспечивает
исполнение public-методами public-классов своей функциональности.

Если же необходимо, чтобы элемент был доступен из другого пакета, но только
подклассам того класса, которому он принадлежит, нужно объявить такой элемент со
спецификатором protected. Спецификатор применим, если поле часто используется в
подклассе или если метод предназначен для переопределения и использования его
функциональности в другом пакете. Для конструктора наличие protected
обеспечивает саму возможность наследования от этого класса в другом пакете.
Действие спецификатора доступа распространяется только на тот элемент класса,
перед которым стоит такой спецификатор.

## Конструкторы

Конструктор — особого вида метод, который по имени автоматически вызывается при
создании экземпляра класса с помощью оператора new. При корректном
проектировании класса конструктор не должен выполнять никаких
других обязанностей, кроме инициализации полей класса и проверки
непротиворечивости конструирования объекта.

Свойства конструктора:

- Конструктор имеет то же имя, что и класс; вызывается не просто по имени,
  а только вместе с ключевым словом new при создании экземпляра класса.
- Конструктор не возвращает значение, но может иметь параметры и быть
  перегружаемым.
- Конструкторов в классе может быть несколько, но не менее одного.
- Если конструктор в классе явно не определен, то компилятор предоставляет
  конструктор по умолчанию без параметров.
- Если же конструктор с параметрами определен, то конструктор по умолчанию
  становится недоступным, и для его вызова необходимо явное объявление такого
  конструктора.
- Конструктор подкласса при его создании всегда наделяется возможностью
  вызова конструктора суперкласса. Этот вызов может быть явным или неявным и
  располагается только в первой строке кода конструктора подкласса.
- Если конструктору суперкласса нужно передать параметры, то необходим
  явный вызов из конструктора подкласса super(parameters).
- Конструктор может объявляться только со спецификаторами видимости:
  public, private, protected или по умолчанию.
- Конструктор не может быть объявлен как static, final, abstract, synchronized,
  native.
- Если к конструктору добавить возвращаемое значение, то он перестанет
  быть конструктором, а превратится в метод данного класса. Компилятор
  при этом выдаст предупреждение о том, что в классе присутствуют методы
  с таким же именем, как и класс, что является грубым нарушением соглашения о
  написании кода.

## Статические методы и поля

**_Статические методы_** можно перегружать и «переопределять» в подклассах,
но их доступность всегда зависит от типа ссылки и атрибута доступа, и никогда —
от типа самого объекта.  
**_Статические поля_** являются переменными класса, но не объекта. Могут быть
использованы без создания экземпляра класса. Нестатические методы могут
обращаться к статическим полям.

**Свойства статических методов:**

- статические методы являются методами класса, не привязаны ни к какому объекту
  и не содержат указателя this на конкретный экземпляр, вызвавший метод.
- статические методы реализуют парадигму «раннего связывания», жестко
  определяющую версию метода на этапе компиляции.
- По причине недоступности указателя this статические поля и методы не могут
  обращаться к нестатическим полям и методам напрямую, так как они не «знают», к
  какому объекту относятся, да и сам экземпляр класса может быть не создан;
- Для обращения к статическим полям и методам достаточно имени класса, в котором
  они определены;
- Переопределение статических методов невозможно, так как обращение к
  статическому методу осуществляется посредством имени класса, которому они
  принадлежат;
- для вызова нестатического метода из статического надо создать экземпляр
  класса;

```java
class Example {
    void nonStaticMethod() { /* Здесь производится что-то интересное */ }

    static void staticMethod() {
        new Example().nonStaticMethod(); // И вот она, статическая магия
    }
}
```

## Методы с переменным числом аргументов

Применяются такие методы в случае, когда необходимо
присвоить\изменить\использовать какое-либо свойство набора объектов, но заранее
неизвестно, сколько таких объектов будет представлено. В некоторых ситуациях
параметризованные методы являются альтернативой циклу.
Существует возможность передачи в метод нефиксированного числа параметров, что
позволяет отказаться от предварительного создания сложного объекта для его
последующей передачи в метод. Набор объектов, переданный в такой метод,
преобразуется в массив с типом и именем, которые указаны в качестве параметров
метода.

```java
public class ExampleStart {
    public static int defineArgsCount(Integer... args) {
        if (args.length != 0) {
            for (int element : args) {
                System.out.printf("args:%d ", element);
            }
        } else {
            System.out.println("No arguments given");
        }
        return args.length;
    }

    public static void main(String... args) {
        System.out.println("N= " + defineArgsCount(7, 42, 555));
        Integer[] arr = {1, 2, 3, 4, 5, 42, 7};
        System.out.println("N= " + defineArgsCount(arr));
        System.out.println(defineArgsCount());
    }
}

```

## Отношения классов

### IS-A отношения

Наследование описывает связь "является" (IS A). Лев является животным. Animal
будет родительским классом для Lion.

### HAS-A отношения

Отношение "является частью"("HAS A") описывает принадлежность объекта к другому
как его части, например, клавиатура часть компьютера. Отношения HAS A можно
описать в коде, используя механизмы композиции и агрегирования. Разница между
ними заключается в «строгости» этих связей.

Три вида связи:

- ассоциация;
- агрегация;
- композиция

_**Ассоциация**_ означает, что объекты двух классов могут ссылаться один на
другой,
иметь некоторую связь между друг другом. Например, Менеджер может выписать Счет.
Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример —
Преподаватель и Студент - т.е. какой-то Студент учится у какого-то
Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент
учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны
между собой и это надо как-то описать.

Агрегация и композиция - частные случаи ассоциации. Это более конкретизированные
отношения между объектами.

**_Агрегация_** — отношение когда один объект является частью другого. Например
Студент входит в Группу любителей физики.
Car — машина. У каждой машины есть
двигатель. Кроме того, у каждой машины есть пассажиры внутри.
В чем же принципиальная разница между полями Engine engine и Passenger[]
passengers? Если у машины внутри сидит пассажир А, это не значит, что в ней не
могут находиться пассажиры B и C. Одна машина может соответствовать нескольким
пассажирам. Кроме того, если всех пассажиров высадить из машины, она продолжит
спокойно функционировать. Связь между классом Car и массивом пассажиров
Passenger[] passengers менее строгая. Она называется _**агрегацией**_. Еще один
хороший пример агрегации. Допустим, у нас есть класс Student, обозначающий
студента, и класс StudentsGroup (группа студентов). Студент может входить и в
клуб любителей физики, и в студенческий фан-клуб «Звездных войн» или команду
КВН.

**_Композиция_** — еще более «жесткое отношение, когда объект не только является
частью другого объекта, но и вообще не может принадлежать еще кому-то. Например
Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет
быть в двух или трех машинах одновременно. В отличие от студента, который может
входить и в другие группы тоже. Такие описания всегда несколько условны, но тем
не менее.

```java
package dev.folomkin.core.oop.oop;

class Robot {
    private double x = 0;
    private double y = 0;
    protected double course = 0;
    // Робот управляется оператором
    private Operator operator;

    public Robot(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // Можно узнать какой оператор управляет роботом
    public Operator getOperator() {
        return operator;
    }

    // Можно установить оператора для робота
    public void setOperator(Operator operator) {
        this.operator = operator;
    }

    public void forward(int distance) {
        x = x + distance * Math.cos(course / 180 * Math.PI);
        y = y + distance * Math.sin(course / 180 * Math.PI);
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getCourse() {
        return course;
    }

    public void setCourse(double course) {
        this.course = course;
    }

    public void printCoordinates() {
        System.out.println(x + "," + y);
    }
}

class Operator {
    private String firstName;
    private String lastName;
    // Оператор управляет конкретным роботом
    private Robot robot;

    public Operator(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    // У оператора можно спросить каким роботом он управляет
    public Robot getRobot() {
        return robot;
    }

    // Оператору можно поручить управлять роботом
    public void setRobot(Robot robot) {
        this.robot = robot;
    }
}

```



## Класс Object

Методы:

- protected Object clone() — создает и возвращает копию вызывающего объекта;
- public boolean equals(Object ob) — предназначен для использования и
  переопределения в подклассах с выполнением общих соглашений о сравнении
  содержимого двух объектов одного и того же типа;
- public Class<? extends Object> getClass() — возвращает экземпляр типа Class;
- protected void finalize() — (deprecated) автоматически вызывается сборщиком
  мусора (garbage collection) перед уничтожением объекта;
- public int hashCode() — вычисляет и возвращает хэш-код объекта (число, в общем
  случае вычисляемое на основе значений полей объекта);
- public String toString() — возвращает представление объекта в виде строки.

Если при создании класса предполагается проверка логической эквивалентности
объектов, которая не выполнена в суперклассе, следует переопределить два метода:
**boolean equals(Object ob)** и **int hashCode()**. Кроме того, переопределение
этих методов необходимо, если логика приложения предусматривает использование
элементов в коллекциях. Метод **equals()** при сравнении двух объектов
возвращает
истину, если содержимое объектов эквивалентно, и ложь — в противном случае.
Реализация метода в классе Object возвращает истину только в том случае, если
обе ссылки указывают на один и тот же объект, а конкретно:

    public boolean equals(Object obj) {
        return (this == obj);
    }

При переопределении метода equals() должны выполняться соглашения,
предусмотренные спецификацией языка Java, а именно:

- рефлексивность — объект равен самому себе;
- симметричность — если x.equals(y) возвращает значение true, то и y.equals(x)
  всегда возвращает значение true;
- транзитивность — если метод equals() возвращает значение true при сравнении
  объектов x и y, а также y и z, то и при сравнении x и z будет возвращено
  значение true;
- непротиворечивость — при многократном вызове метода для двух не подвергшихся
  изменению за это время объектов возвращаемое значение всегда должно быть
  одинаковым;
- ненулевая ссылка при сравнении с литералом null всегда возвращает значение
  false.

Метод **int hashCode()** переопределен, как правило, в каждом классе и
возвращает
число, являющееся уникальным идентификатором объекта, зависящим в большинстве
случаев только от значения объекта. Его следует переопределять всегда, когда
переопределен метод **equals()**. Метод **hashCode()** возвращает хэш-код
объекта,
вычисление которого управляется следующими соглашениями:

- все одинаковые по содержанию объекты одного типа должны иметь одинаковые
  хэш-коды;
- различные по содержанию объекты одного типа могут иметь различные хэш-коды;
- во время работы приложения значение хэш-кода объекта не изменяется, если
  объект не был изменен.

Метод **toString()** следует переопределять таким образом, чтобы, кроме
стандартной
информации о пакете (опционально), в котором находится класс, и самого имени
класса (опционально), он возвращал значения полей объекта, вызвавшего этот
метод (т.е. всю полезную информацию объекта), вместо хэш-кода, как это делается
в классе Object. Метод toString() класса Object возвращает строку с описанием
объекта в виде:

    getClass().getName() + '@' + Integer.toHexString(hashCode())

Метод вызывается автоматически, когда объект передается в поток вывода методами
println(), print() и некоторыми другими.


## Клонирование объектов

_**Объекты в методы передаются по ссылке, в результате чего метод получает
ссылку на объект, находящийся вне метода. Если в методе изменить значение поля
объекта, это изменение коснется исходного объекта.**_

Во избежание такой ситуации для защиты внешнего объекта следует создать клон (
копию) объекта в методе.

Класс Object содержит protected-метод clone(), осуществляющий побитовое
копирование объекта производного класса. Однако сначала необходимо
переопределить метод clone() как public для обеспечения возможности вызова из
другого пакета. В переопределенном методе следует вызвать базовую версию
метода super.clone(), которая и выполняет собственно клонирование. Чтобы
окончательно сделать объект клонируемым, класс должен реализовать
интерфейс Cloneable. Интерфейс Cloneable не содержит методов, относится к
помеченным (tagged) интерфейсам, а его реализация гарантирует, что метод
clone() класса Object возвратит точную копию вызвавшего его объекта с
воспроизведением значений всех его полей. В противном случае метод генерирует
исключение CloneNotSupportedException.

При использовании этого механизма объект создается без вызова конструктора, на
уровне виртуальной машины выполняется побитовое копирование объекта в другую
часть памяти.

```java
package dev.folomkin.core.oop.code;

class Student implements Cloneable {
    private int id;
    private String name;
    private int yearOfStudy;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getYearOfStudy() {
        return yearOfStudy;
    }

    public void setYearOfStudy(int yearOfStudy) {
        this.yearOfStudy = yearOfStudy;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Student student = (Student) o;
        if (id != student.id) {
            return false;
        }
        if (yearOfStudy != student.yearOfStudy) {
            return false;
        }
        return name != null ? name.equals(student.name) : student.name == null;
    }

    @Override
    public int hashCode() {
        return id + 31 * yearOfStudy + (name != null ? name.hashCode() : 0);
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("Student{");
        sb.append("id=").append(id);
        sb.append(", name='").append(name).append('\'');
        sb.append(", yearOfStudy=").append(yearOfStudy);
        sb.append('}');
        return sb.toString();
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

class Code {
    private static void preparation(Student student) {
        try {
            student = (Student) student.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        student.setId(1000);
        System.out.println("-> id=" + student.getId());
    }

    public static void main(String[] args) {
        Student student = new Student();
        student.setId(71);
        System.out.println("id=" + student.getId());
        preparation(student);
        System.out.println("id=" + student.getId());
    }
}
```

Решение эффективно только в случае, когда поля клонируемого объекта
представляют собой значения базовых типов и их оболочек или неизменяемых
(immutable) объектных типов. Если же поле клонируемого типа является изменяемым
объектным типом, то для корректного клонирования требуется другой
подход. Причина заключается в том, что при создании копии поля оригинал
и копия представляют собой ссылку на один и тот же объект.  
В этой ситуации следует также клонировать и объект поля класса, если он
сам поддерживает клонирование.



## Сборка мусора

Так как объекты создаются динамически с помощью операции new, а уничтожаются
автоматически, то желательно знать механизм ликвидации объектов и способ
освобождения памяти. Автоматическое освобождение памяти, занимаемой
объектом, выполняется с помощью механизма «сборки мусора». Когда никаких ссылок
на объект не существует, т.е. все ссылки на него вышли из области
видимости программы, предполагается, что объект больше не нужен, и память,
занятая объектом, может быть освобождена. «Сборка мусора» происходит
нерегулярно во время выполнения программы. Форсировать «сборку мусора»
невозможно, можно лишь «рекомендовать» выполнить ее вызовом метода
System.gc() или Runtime.getRuntime().gc(), но виртуальная машина выполнит
очистку памяти тогда, когда сама посчитает это удобным. Вызов метода
System.runFinalization() приведет к запуску метода finalize() для объектов,
утративших ссылки.  
Иногда объекту нужно выполнять некоторые действия перед освобождением памяти.
Например, освободить внешние ресурсы. Для обработки таких ситуаций могут
применяться два способа: конструкция try-finally и механизм autocloseable.
