# Основы ООП

## Модификаторы доступа

Модификаторы:

- private — члены класса доступны только членам данного класса;
- по умолчанию (package-private) — члены класса доступны классам, находящимся в
  том же пакете;
- protected — члены класса доступны классам, находящимся в том же пакете, и
  подклассам — в других пакетах;
- public — члены класса доступны для всех классов в этом и других пакетах.

Член класса (поле, конструктор или метод), объявленный public, доступен из
любого места вне класса. Спецификатор public для методов и конструкторов
public-классов обеспечивает внешний доступ к функциональности пакета, в котором
он объявлен. Если данный спецификатор отсутствует, то класс и его методы могут
использоваться только в текущем пакете.

Все, что объявлено private, доступно только конструкторам и методам внутри
класса и нигде больше. Они выполняют служебную или вспомогательную роль в
пределах класса, и их функциональность (методов и конструкторов) не
предназначена для внешнего использования. Закрытие private-полей обеспечивает
инкапсуляцию.

Если у члена класса вообще не указан спецификатор уровня доступа, то такой член
класса будет виден и доступен из подклассов и классов того же пакета. Именно
такой уровень доступа используется по умолчанию. Такой член класса обеспечивает
исполнение public-методами public-классов своей функциональности.

Если же необходимо, чтобы элемент был доступен из другого пакета, но только
подклассам того класса, которому он принадлежит, нужно объявить такой элемент со
спецификатором protected. Спецификатор применим, если поле часто используется в
подклассе или если метод предназначен для переопределения и использования его
функциональности в другом пакете. Для конструктора наличие protected
обеспечивает саму возможность наследования от этого класса в другом пакете.
Действие спецификатора доступа распространяется только на тот элемент класса,
перед которым стоит такой спецификатор.

## Конструкторы

Конструктор — особого вида метод, который по имени автоматически вызывается при
создании экземпляра класса с помощью оператора new. При корректном
проектировании класса конструктор не должен выполнять никаких
других обязанностей, кроме инициализации полей класса и проверки
непротиворечивости конструирования объекта.

Свойства конструктора:

- Конструктор имеет то же имя, что и класс; вызывается не просто по имени,
  а только вместе с ключевым словом new при создании экземпляра класса.
- Конструктор не возвращает значение, но может иметь параметры и быть
  перегружаемым.
- Конструкторов в классе может быть несколько, но не менее одного.
- Если конструктор в классе явно не определен, то компилятор предоставляет
  конструктор по умолчанию без параметров.
- Если же конструктор с параметрами определен, то конструктор по умолчанию
  становится недоступным, и для его вызова необходимо явное объявление такого
  конструктора.
- Конструктор подкласса при его создании всегда наделяется возможностью
  вызова конструктора суперкласса. Этот вызов может быть явным или неявным и
  располагается только в первой строке кода конструктора подкласса.
- Если конструктору суперкласса нужно передать параметры, то необходим
  явный вызов из конструктора подкласса super(parameters).
- Конструктор может объявляться только со спецификаторами видимости:
  public, private, protected или по умолчанию.
- Конструктор не может быть объявлен как static, final, abstract, synchronized,
  native.
- Если к конструктору добавить возвращаемое значение, то он перестанет
  быть конструктором, а превратится в метод данного класса. Компилятор
  при этом выдаст предупреждение о том, что в классе присутствуют методы
  с таким же именем, как и класс, что является грубым нарушением соглашения о
  написании кода.

## Статические методы и поля

Статические методы можно перегружать и «переопределять» в подклассах,
но их доступность всегда зависит от типа ссылки и атрибута доступа, и никогда —
от типа самого объекта.  
Статические поля являются переменными класса, но не объекта. Могут быть
использованы без создания экземпляра класса. Нестатические методы могут
обращаться к статическим полям.

**Свойства статических методов:**

- статические методы являются методами класса, не привязаны ни к какому объекту
  и не содержат указателя this на конкретный экземпляр, вызвавший метод.
- статические методы реализуют парадигму «раннего связывания», жестко
  определяющую версию метода на этапе компиляции.
- По причине недоступности указателя this статические поля и методы не могут
  обращаться к нестатическим полям и методам напрямую, так как они не «знают», к
  какому объекту относятся, да и сам экземпляр класса может быть не создан;
- Для обращения к статическим полям и методам достаточно имени класса, в котором
  они определены;
- Переопределение статических методов невозможно, так как обращение к
  статическому методу осуществляется посредством имени класса, которому они
  принадлежат;
- для вызова нестатического метода из статического надо создать экземпляр
  класса;

```java
class Example {
    void nonStaticMethod() { /* Здесь производится что-то интересное */ }

    static void staticMethod() {
        new Example().nonStaticMethod(); // И вот она, статическая магия
    }
}
```

### Методы с переменным числом аргументов

Применяются такие методы в случае, когда необходимо
присвоить\изменить\использовать какое-либо свойство набора объектов, но заранее
неизвестно, сколько таких объектов будет представлено. В некоторых ситуациях
параметризованные методы являются альтернативой циклу.
Существует возможность передачи в метод нефиксированного числа параметров, что
позволяет отказаться от предварительного создания сложного объекта для его
последующей передачи в метод. Набор объектов, переданный в такой метод,
преобразуется в массив с типом и именем, которые указаны в качестве параметров
метода.

```java
public class ExampleStart {
    public static int defineArgsCount(Integer... args) {
        if (args.length != 0) {
            for (int element : args) {
                System.out.printf("args:%d ", element);
            }
        } else {
            System.out.println("No arguments given");
        }
        return args.length;
    }

    public static void main(String... args) {
        System.out.println("N= " + defineArgsCount(7, 42, 555));
        Integer[] arr = {1, 2, 3, 4, 5, 42, 7};
        System.out.println("N= " + defineArgsCount(arr));
        System.out.println(defineArgsCount());
    }
}

```

## Отношения классов

### IS-A отношения

В ООП принцип IS-A основан на наследовании классов или реализации интерфейсов.
Например, если класс HeavyBox наследует Box, мы говорим, что HeavyBox является
Box (HeavyBox IS-A Box). Или другой пример - класс Lorry расширяет класс Car. В
этом случае Lorry IS-A Car.
То же самое относится и к реализации интерфейсов. Если класс Transport реализует
интерфейс Moveable, то они находятся в отношении Transport IS-A Moveable.

### HAS-A отношения

HAS-A отношения основаны на использовании. Выделяют три варианта отношения
HAS-A: ассоциация, агрегация и композиция.

**Ассоциация**    
В этих отношениях объекты двух классов могут ссылаться друг на друга. Например,
класс Horse HAS-A Halter если код в классе Horse содержит ссылку на экземпляр
класса Halter:

```java
public class Halter {
}

public class Horse {
    private Halter halter;
}
```
Агрегация и композиция являются частными случаями ассоциации. Агрегация -
отношение когда один объект является частью другого. А композиция - еще более
тесная связь, когда объект не только является частью другого объекта, но и
вообще не может принадлежать другому объекту. Разница будет понятна при
рассмотрении реализации этих отношений.

**Агрегация**  
Объект класса Halter создается извне Horse и передается в конструктор для
установления связи. Если объект класса Horse будет удален, объект класса Halter
может и дальше использоваться, если, конечно, на него останется ссылка:

```java
public class Horse {
    private Halter halter;

    public Horse(Halter halter) {
        this.halter = halter;
    }
}
```

**Композиция**  
Теперь посмотрим на реализацию композиции. Объект класса Halter создается в
конструкторе, что означает более тесную связь между объектами. Объект класса
Halter не может существовать без создавшего его объекта Horse:

```java
public class Horse {
    private Halter halter;

    public Horse() {
        this.halter = new Halter();
    }
}
```