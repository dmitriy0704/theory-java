# Основы ООП

## Модификаторы доступа

Модификаторы:

- private — члены класса доступны только членам данного класса;
- по умолчанию (package-private) — члены класса доступны классам, находящимся в
  том же пакете;
- protected — члены класса доступны классам, находящимся в том же пакете, и
  подклассам — в других пакетах;
- public — члены класса доступны для всех классов в этом и других пакетах.

Член класса (поле, конструктор или метод), объявленный public, доступен из
любого места вне класса. Спецификатор public для методов и конструкторов
public-классов обеспечивает внешний доступ к функциональности пакета, в котором
он объявлен. Если данный спецификатор отсутствует, то класс и его методы могут
использоваться только в текущем пакете.

Все, что объявлено private, доступно только конструкторам и методам внутри
класса и нигде больше. Они выполняют служебную или вспомогательную роль в
пределах класса, и их функциональность (методов и конструкторов) не
предназначена для внешнего использования. Закрытие private-полей обеспечивает
инкапсуляцию.

Если у члена класса вообще не указан спецификатор уровня доступа, то такой член
класса будет виден и доступен из подклассов и классов того же пакета. Именно
такой уровень доступа используется по умолчанию. Такой член класса обеспечивает
исполнение public-методами public-классов своей функциональности.

Если же необходимо, чтобы элемент был доступен из другого пакета, но только
подклассам того класса, которому он принадлежит, нужно объявить такой элемент со
спецификатором protected. Спецификатор применим, если поле часто используется в
подклассе или если метод предназначен для переопределения и использования его
функциональности в другом пакете. Для конструктора наличие protected
обеспечивает саму возможность наследования от этого класса в другом пакете.
Действие спецификатора доступа распространяется только на тот элемент класса,
перед которым стоит такой спецификатор.

## Конструкторы

Конструктор — особого вида метод, который по имени автоматически вызывается при
создании экземпляра класса с помощью оператора new. При корректном
проектировании класса конструктор не должен выполнять никаких
других обязанностей, кроме инициализации полей класса и проверки
непротиворечивости конструирования объекта.

Свойства конструктора:

- Конструктор имеет то же имя, что и класс; вызывается не просто по имени,
  а только вместе с ключевым словом new при создании экземпляра класса.
- Конструктор не возвращает значение, но может иметь параметры и быть
  перегружаемым.
- Конструкторов в классе может быть несколько, но не менее одного.
- Если конструктор в классе явно не определен, то компилятор предоставляет
  конструктор по умолчанию без параметров.
- Если же конструктор с параметрами определен, то конструктор по умолчанию
  становится недоступным, и для его вызова необходимо явное объявление такого
  конструктора.
- Конструктор подкласса при его создании всегда наделяется возможностью
  вызова конструктора суперкласса. Этот вызов может быть явным или неявным и
  располагается только в первой строке кода конструктора подкласса.
- Если конструктору суперкласса нужно передать параметры, то необходим
  явный вызов из конструктора подкласса super(parameters).
- Конструктор может объявляться только со спецификаторами видимости:
  public, private, protected или по умолчанию.
- Конструктор не может быть объявлен как static, final, abstract, synchronized,
  native.
- Если к конструктору добавить возвращаемое значение, то он перестанет
  быть конструктором, а превратится в метод данного класса. Компилятор
  при этом выдаст предупреждение о том, что в классе присутствуют методы
  с таким же именем, как и класс, что является грубым нарушением соглашения о
  написании кода.

## Статические методы и поля

Статические методы можно перегружать и «переопределять» в подклассах,
но их доступность всегда зависит от типа ссылки и атрибута доступа, и никогда —
от типа самого объекта.  
Статические поля являются переменными класса, но не объекта. Могут быть
использованы без создания экземпляра класса. Нестатические методы могут
обращаться к статическим полям.

**Свойства статических методов:**

- статические методы являются методами класса, не привязаны ни к какому объекту
  и не содержат указателя this на конкретный экземпляр, вызвавший метод.
- статические методы реализуют парадигму «раннего связывания», жестко
  определяющую версию метода на этапе компиляции.
- По причине недоступности указателя this статические поля и методы не могут
  обращаться к нестатическим полям и методам напрямую, так как они не «знают», к
  какому объекту относятся, да и сам экземпляр класса может быть не создан;
- Для обращения к статическим полям и методам достаточно имени класса, в котором
  они определены;
- Переопределение статических методов невозможно, так как обращение к
  статическому методу осуществляется посредством имени класса, которому они
  принадлежат;
- для вызова нестатического метода из статического надо создать экземпляр класса;
```java
class Example {
    void nonStaticMethod() { /* Здесь производится что-то интересное */ }
    static void staticMethod() {
        new Example().nonStaticMethod(); // И вот она, статическая магия
    }
}
```

### Методы с переменным числом аргументов

Применяются такие методы в случае, когда необходимо
присвоить\изменить\использовать какое-либо свойство набора объектов, но заранее
неизвестно, сколько таких объектов будет представлено. В некоторых ситуациях
параметризованные методы являются альтернативой циклу.
Существует возможность передачи в метод нефиксированного числа параметров, что
позволяет отказаться от предварительного создания сложного объекта для его
последующей передачи в метод. Набор объектов, переданный в такой метод,
преобразуется в массив с типом и именем, которые указаны в качестве параметров
метода.

```java
public class ExampleStart {
    public static int defineArgsCount(Integer... args) {
        if (args.length != 0) {
            for (int element : args) {
                System.out.printf("args:%d ", element);
            }
        } else {
            System.out.println("No arguments given");
        }
        return args.length;
    }

    public static void main(String... args) {
        System.out.println("N= " + defineArgsCount(7, 42, 555));
        Integer[] arr = {1, 2, 3, 4, 5, 42, 7};
        System.out.println("N= " + defineArgsCount(arr));
        System.out.println(defineArgsCount());
    }
}

```
