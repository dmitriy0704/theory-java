# Внутренние классы

Существуют два типа вложенных классов: статические и нестатические.
Статический вложенный класс - это класс, к которому применяется модификатор
static. Поскольку класс статический, он должен обращаться к нестатическим
членам объемлющего класса через объект. То есть статический вложенный класс не
может напрямую ссылаться на нестатические члены объемлющего класса.

Одной из причин использования внутренних классов является возможность
быть подклассом любого класса независимо от того, подклассом какого класса
является внешний класс.

Если необходимо определить и связать класс с некоторой функциональностью,
очень близкой этому классу, то применяется статическое вложение
класса, делающее независимым объект с вложенной функциональностью от
класса-владельца, но логически через имя внешнего класса связывает с ним.
Объект такого класса можно создать, не создавая объект класса-владельца.

Такие статические вложенные классы объявляются с модификатором static.
Статические классы могут обращаться к нестатическим членам включающего
класса не напрямую, а только через его объект.

Нестатические внутренние классы имеют доступ ко всем переменным и методам
своего внешнего класса-владельца и требуют последовательного создания
объектов внешнего и внутреннего классов.

Применение анонимных классов и их подмножества: лямбда-выражений,
позволяет сократить количество кода. Анонимные классы сокращают число
подклассов, лямбда-выражения записываются еще короче и с более высоким
акцентом на функционал объекта.

## Внутренние(inner) классы

**Нестатические вложенные классы** принято называть внутренними, или _inner
классами_. `Доступ к элементам внутреннего класса возможен из внешнего только
через объект внутреннего класса, который должен быть создан в коде метода
внешнего класса.` Объект внутреннего класса всегда ассоциируется (скрыто хранит
ссылку) с создавшим его объектом внешнего класса — так называемым внешним, или
enclosing объектом.

```java
class Student {
    private int studentId;
    private String name;
    // ,,, getters/setters
    private Address address;

    public class Address {
        private String city;
        private String street;
        // ,,, getters/setters
    }
}

class Code {
    public static void main(String[] args) {
        Student.Address address = new Student().new Address();
    }
}
```

При компиляции внутренний класс получает собственный модуль для интерпретации,
соответствующий внутреннему классу, который получит имя Student$Address.class.
Внешний же класс будет скомпилирован в обычный файл Student.class.

`Методы внутреннего класса имеют прямой доступ ко всем полям и методам
внешнего класса, как будто они его собственные, в то же время внешний класс
может получить доступ к содержимому внутреннего класса только после создания
объекта внутреннего класса`. Доступ будет разрешен по имени, в том числе и к
полям, объявленным как private. Внутренние классы не могут содержать статические
поля и методы, кроме final static. Внутренние классы имеют право наследовать
другие классы, реализовывать интерфейсы и выступать в роли объектов
наследования. Допустимо наследование следующего вида:

    public class SubStudent extends Student {
        public class SubAddress extends Address {
        }
    }

Если внутренний класс наследуется обычным образом другим классом (после extends
указывается ИмяВнешнегоКласса.ИмяВнутреннегоКласса), то он теряет доступ к полям
своего внешнего класса, в котором был объявлен.

Поля внешнего класса видны внутреннему классу так, будто они его собственные,
модификаторы видимости игнорируются. Применить ссылку this также не получится,
так как this внутри класса Inner указывает на его собственный объект, и ни в
коем случае не на его владельца.

Внешний класс напрямую не видит никаких компонентов своего внутреннего класса.
Вопрос доступа к полям внешнего класса можно рассмотреть путем объявления полей
с одинаковыми именами во внутреннем и внешнем классах, чего на практике делать
не рекомендуется.

Внутренний класс может быть объявлен также внутри метода или логического блока
внешнего (owner) класса. Видимость такого класса регулируется областью видимости
блока, в котором он объявлен. Но внутренний класс сохраняет доступ ко всем полям
и методам внешнего класса, а также ко всем константам, объявленным в текущем
блоке кода. Класс, объявленный внутри метода, не может быть объявлен как static,
а также не может содержать статические поля и методы.

**Свойства внутренних классов:**

- Доступ к элементам внутреннего класса возможен только из внешнего класса через
  объект внутреннего класса;
- Методы внутреннего класса имеют прямой доступ ко всем полям и методам внешнего
  класса;
- Объект внутреннего класса имеет ссылку на объект своего внешнего класса (
  enclosing);
- Внутренние классы не могут содержать static-полей и методов, кроме final
  static;
- Внутренние классы могут быть производными от других классов;
- Внутренние классы могут быть суперклассами;
- Внутренние классы могут реализовывать интерфейсы;
- Внутренние классы могут быть объявлены с параметрами final, abstract, private,
  protected, public;
- Если необходимо создать объект внутреннего класса где-нибудь, кроме внешнего
  нестатического метода класса, то нужно определить тип объекта как
  OwnerType.InnerType;
- Внутренний класс может быть объявлен внутри метода или логического блока
  внешнего класса, видимость класса регулируется видимостью того блока, в
  котором он объявлен. Однако внутренний класс сохраняет доступ ко всем полям и
  методам внешнего класса, а также final-переменным, объявленным в текущем блоке
  кода;
- Локальному внутреннему классу, объявленному внутри метода или логического
  блока, модификатор доступа не требуется, так как он все равно не доступен
  напрямую вне метода.

## Вложенные(nested) классы

Если не существует жесткой необходимости в одновременном обязательном
существовании объекта внутреннего класса и объекта внешнего класса, то есть
смысл сделать такой внутренний класс статическим, который будет тогда называться
вложенным, или nested классом.
Вложенный класс логически связан с классом-владельцем, но его объект может быть
использован независимо от объекта внешнего класса. Такой класс обычно определяет
дополнительный функционал для класса-владельца.

При объявлении такого внутреннего класса присутствует служебное слово static, и
такой класс называется вложенным (nested).

Если класс объявлен внутри интерфейса, то он получает спецификаторы public
static по умолчанию.

Такой класс способен наследовать другие классы, реализовывать интерфейсы и
являться объектом наследования для любого класса, обладающего необходимыми
правами доступа.

`В то же время статический вложенный класс для доступа к нестатическим членам и
методам внешнего класса должен создавать объект внешнего класса, а напрямую
иметь доступ только к статическим полям и методам внешнего класса.`
Для создания объекта вложенного класса объект внешнего класса создавать нет
необходимости.

Подкласс вложенного класса не способен унаследовать возможность доступа к членам
внешнего класса, которыми наделен его суперкласс.

Если предполагается использовать внутренний класс в качестве подкласса, следует
исключить использование в его теле любых прямых обращений к членам
класса-владельца.

```java
class Student {
    private int studentId;
    private String name;

    public int getStudentId() {
        return studentId;
    }

    public void setStudentId(int studentId) {
        this.studentId = studentId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Student(int studentId, String name) {
        this.studentId = studentId;
        this.name = name;
    }

    public static class NameComparator implements Comparator<Student> {
        @Override
        public int compare(Student o1, Student o2) {
            return o1.name.compareTo(o2.name);
        }
    }
}

class Code {
    public static void main(String[] args) {
        Student st1 = new Student(1, "John", 1);
        Student st2 = new Student(2, "Jane", 2);
        Student.NameComparator nameComparator = new Student.NameComparator();
        int result1 = nameComparator.compare(st1, st2);
        System.out.println(st1.getName() + " [" + result1 + "] " + st2.getName());
    }
}
```

Объект nameComparator вложенного класса создается с использованием имени
внешнего класса без вызова его конструктора. Если во вложенном классе объявлен
статический метод, то он просто вызывается при указании полного относительного
пути к нему.

```java
public class Owner {
    private int value = 1;
    static int statValue = 2;

    public static class Nested {
        {
            statValue++;
            // value++; invisible
        }
    }
}
```

Статическому классу доступно только статическое содержимое класса-владельца.
Класс, вложенный в интерфейс, по умолчанию статический. На него не накладывается
никаких особых ограничений, и он может содержать поля и методы как статические,
так и нестатические.

Свойства вложенных классов:

- Вложенный класс может быть базовым, производным, реализующим интерфейсы;
- Статический вложенный класс для доступа к нестатическим членам и методам
  внешнего класса должен создавать объект внешнего класса;
- Вложенный класс имеет доступ к статическим полям и методам внешнего класса;
- Подкласс вложенного класса не наследует возможность доступа к членам внешнего
  класса, которыми наделен его суперкласс;
- Класс, вложенный в интерфейс, статический по умолчанию;
- Статический метод вложенного класса вызывается при указании полного
  относительного пути к нему.

## Анонимные классы

Анонимные (безымянные) внутренние классы применяются для придания
уникальной функциональности отдельно взятому экземпляру, для обработки
событий, реализации блоков прослушивания, реализации интерфейсов, запуска
потоков и т.д. Можно объявить анонимный класс, который будет расширять
другой класс или реализовывать интерфейс при объявлении одного-единственного
объекта, когда остальным объектам этого класса будет соответствовать
реализация метода, определенная в самом классе. Объявление анонимного
класса выполняется одновременно с созданием его объекта посредством оператора
new.

С появлением функциональных интерфейсов появилось понятие анонимного
объекта-функции, то есть объекта, основное назначение которого передать
реализацию конкретной функциональности в анонимном виде:

    FunctionalInterface lambdaFunction = () -> doAction();

Анонимные классы эффективно используются, как правило, для реализации
(переопределения) одного или нескольких методов. Этот прием эффективен
В случае, когда необходимо переопределение метода, но создавать новый класс нет
необходимости из-за узкой области или одномоментного применения объекта.
Анонимные классы, как и остальные внутренние, допускают вложенность друг
в друга, что может сильно запутать код и сделать эти конструкции непонятными,
поэтому в практике программирования данная техника не используется.
Конструктор анонимного класса определить невозможно. Нельзя создать
анонимный класс для final-класса.

```java
class StudentAction {
    private static final int BASE_COEFFICIENT = 6;

    public double defineScholarship(float averageMark) {
        double value = 100;
        if (averageMark > BASE_COEFFICIENT) {
            value *= 1 + (BASE_COEFFICIENT / 10.0);
        }
        return value;
    }
}

class StudentActionMain {
    public static void main(String[] args) {
        StudentAction action = new StudentAction();
        StudentAction actionAnon = new StudentAction() {
            int base = 9;

            @Override
            public double defineScholarship(float averageMark) {
                double value = 100;
                if (averageMark > base) {
                    value *= 1 + (base / 10.0);
                }
                return value;
            }
        };
        System.out.println(action.defineScholarship(9.05f));
        System.out.println(actionAnon.defineScholarship(9.05f));
    }
}

```

Анонимный класс может использовать только неизменяемые параметры
и локальные переменные метода, в котором он создан. При запуске приложения
происходит объявление объекта actionAnon c применением анонимного класса,
в котором переопределяется метод defineScholarship(). Вызов данного метода на
объекте actionAnon приводит к вызову версии метода из анонимного класса, который
компилируется в объектный модуль с именем StudentActionMain$1.class. Процесс
создания второго объекта с анонимным типом применяется в программировании
значительно чаще, особенно при реализации классов-адаптеров и реализации
интерфейсов в блоках прослушивания. В анонимном классе разрешено
объявлять собственные поля и методы, которые не доступны объекту вне этого
класса.

Для перечисления инициализация всех элементов происходит при первом обращении к
типу. Поэтому и анонимный класс реализуется только внутри объявления типа enum.

```java
enum Shape {
    RECTANGLE(2, 3) {
        public double computeSquare() {
            return this.getA() * this.getB();
        }
    },
    TRIANGLE(2, 3) {
        public double computeSquare() {
            return this.getA() * this.getB() / 2;
        }
    };
    private double a;
    private double b;

    Shape(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double getA() {
        return a;
    }

    public void setA(double a) {
        this.a = a;
    }

    public double getB() {
        return b;
    }

    public void setB(double b) {
        this.b = b;
    }

    public abstract double computeSquare();

    @Override
    public String toString() {
        return new StringJoiner(", ", Shape.class.getSimpleName() + "[", "]")
                .add("a=" + a).add("b=" + b).toString();
    }
}

class Code {
    public static void main(String[] args) {
        Arrays.stream(Shape.values()).forEach(s -> System.out.println(s.computeSquare()));
    }
}
```

Свойства анонимных классов:

- расширяет другой класс или реализует интерфейс при объявлении одного
  единственного объекта, остальным объектам будет соответствовать реализация,
  определенная в самом классе;
- объявление анонимного объекта выполняется одновременно с созданием его объекта
  с помощью оператора new;
- конструкторы анонимных классов ни определить, ни переопределить нельзя;
- анонимные классы допускают вложенность друг в друга (нежелательно
  использовать);
- объявление анонимного класса в перечислении отличается от простого анонимного
  класса, поскольку инициализация всех элементов происходит при
  первом обращении к типу.

Ситуации, в которых следует использовать внутренние классы:

- выделение самостоятельной логической части сложного класса;
- сокрытие реализации;
- одномоментное использование переопределенных методов;
- реализация обработчиков событий;
- запуск потоков выполнения;
- отслеживание внутреннего состояния, например, с помощью enum.