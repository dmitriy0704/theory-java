# ООП

## Классы и объекты

*Спецификатор класса:*

- public
- (не ставится, но означает)friendly/private-package - класс доступен только в
  пакете
- final - класс не может иметь подклассов
- abstract - класс содержит абстрактные нереализованные методы, объект такого
  класса создать нельзя

*Уровни доступа для членов классов:*

- public - доступен везде
- private - переменная доступна в рамках класса
- protected - доступ только внутри пакета и подклассам в других пакетах

## Статические методы и поля

Статические поля являются переменными класса, но не объекта. Могут быть
использованы без создания экземпляра класса. Нестатические методы могут
обращаться к статическим полям.

**Свойства статических методов:**

- статические методы являются методами класса, не привязаны ни к какому объекту
  и не содержат указателя this на конкретный экземпляр, вызвавший метод.
- статические методы реализуют парадигму «раннего связывания», жестко
  определяющую версию метода на этапе компиляции.
- По причине недоступности указателя this статические поля и методы не могут
  обращаться к нестатическим полям и методам напрямую, так как они не «знают», к
  какому объекту относятся, да и сам экземпляр класса может быть не создан;
- Для обращения к статическим полям и методам достаточно имени класса, в котором
  они определены;
- Переопределение статических методов невозможно, так как обращение к
  статическому методу осуществляется посредством имени класса, которому они
  принадлежат;

## Optional

Класс Optional представляет собой оболочку для любого объектного типа. Помогает
работать в ситуации, когда объект возвращает null.

```java
class Order {
    long id;
    String name;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public Order(long id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Order{" + "id=" + id + ", name='" + name + '\'' + '}';
    }
}

public class ExampleStart {
    public static void main(String[] args) {
        List<Order> orders = new ArrayList<>();
        orders.add(new Order(1L, "Alex"));
        orders.add(new Order(2L, "Bob"));
        orders.add(new Order(3L, "Charles"));
        Optional<Order> o = findById(orders, 4l);
        System.out.println(o);
    }

    public static Optional<Order> findById(List<Order> orders, long id) {
// Без Optional:      Order order = null;

        List<Order> result = orders
                .stream().filter(o -> id == o.getId())
                .toList();

//        Без Optional:
//        if (result.size() != 0) {
//            order = result.get(0);
//        }

        Optional<Order> optionalOrder =
                result.size() != 0
                        ? Optional.of(result.get(0))
                        : Optional.empty();

        return optionalOrder;
    }
}
```

**Методы:**

- **static \<T> Optional<T> empty()** - создает пустой объект;
- **static \<T> Optional\<T> of(T value)** - создает объект с ненулевым
  содержимым;
- **static \<T> Optional\<T> ofNullable(T value)** - создает объект, содержимое,
  которого может быть null;
- **boolean equals(Object optional)** - возвращает true, если вызывающий объект
  равен optional;
- **\<T> get()** - извлекает объект из оболочки, генерирует
  NullPointerException, если оболочка пуста;
- **boolean isEmpty** - возвращает true, если объект не содержит значение;
- **boolean isPresent** - возвращает true, если объект содержит значение;
- **void ifPresent(Consumer\<? super T> action)** - если объект присутствует -
  выполняет над ним действие;
- **void ifPresentOrElse(Consumer\<? super T> action, Runnable emptyAction)** -
  если объект присутствует - выполняет над ним действие action, если
  отсутствует - emptyAction;
- **T orElse(T other)** - возвращает объект other;
- **T orElseGet(Supplier\<? extends T> getFunc)** - если вызывающий объект
  содержит значение, то оно возвращается. В противном случае возвращается
  значение полученное из getFunc;
- **T orElseThrow(), \<T extends Throwable> T orElseThrow(Supplier\<? extends X>
  exception)** - генерирует исключение NoSuchElements или заданное исключение;
- **Optional\<T> filter(Predicate\<? super T> condition)** - Возвращает
  экземпляр Optional, который содержит то же самое значение, что и вызывающий
  объект, если это значение удовлетворяет условию, указанному в condition. В
  противном случае возвращается пустой объект;
- **U Optional\<U> flatMap(Function\<? super T, Optional\<U>> mapFunc)** -
  Применяет функцию сопоставления, указанную в mapFunc, к вызывающему объекту,
  если этот объект содержит значение, и возвращает результат. В противном случае
  возвращается пустой объект;
- **U Optional\<U> map(Function\<? super T, ? extends U>> mapFunc)** - Применяет
  функцию сопоставления, указанную в mapFunc, к вызывающему объекту, если
  этот объект содержит значение, и возвращает результат. В противном случае
  возвращается пустой объект;
- **\<Х extends Throwable> Т orElseThrow (Supplier\<? extends Х> excFunc) throws
  Х extends Throwable Stream\<T> stream()** - Возвращает поток данных, который
  содержит значение вызывающего объекта. Если значение отсутствует, тогда поток
  не будет содержать значений;

## Модификатор Final

Методы объявленные как final нельзя замещать в подклассах. От класса с
модификатором final нельзя создать подкласс. Константа может быть объявлена как
поле класса, но не проинициализирована. В этом случае она должна быть
проинициализирована в логическом блоке класса, заключенном в {}, или
конструкторе, но только в одном из указанных мест. Значение по умолчанию
константа получить не может в отличие от переменных класса. Константы могут быть
объявлены в методах как локальные или как параметры метода. В обоих случаях
значения таких констант изменять нельзя.

## Перегрузка методов

**Перегрузка метода** - статический полиморфизм - одинаковое название, но разные
параметры и возвращаемое значение. **Переопределение метода** - динамический
полиморфизм - одинаковые параметры. Статические методы могут перегружаться
нестатическими, и наоборот, без ограничений.

## Методы с переменным числом аргументов

Применяются такие методы в случае, когда необходимо
присвоить\изменить\использовать какое-либо свойство набора объектов, но заранее
неизвестно, сколько таких объектов будет представлено. В некоторых ситуациях
параметризованные методы являются альтернативой циклу.
Существует возможность передачи в метод нефиксированного числа параметров, что
позволяет отказаться от предварительного создания сложного объекта для его
последующей передачи в метод. Набор объектов, переданный в такой метод,
преобразуется в массив с типом и именем, которые указаны в качестве параметров
метода.

```java
public class ExampleStart {
    public static int defineArgsCount(Integer... args) {
        if (args.length != 0) {
            for (int element : args) {
                System.out.printf("args:%d ", element);
            }
        } else {
            System.out.println("No arguments given");
        }
        return args.length;
    }

    public static void main(String... args) {
        System.out.println("N= " + defineArgsCount(7, 42, 555));
        Integer[] arr = {1, 2, 3, 4, 5, 42, 7};
        System.out.println("N= " + defineArgsCount(arr));
        System.out.println(defineArgsCount());
    }
}

```

## Enum

Типобезопасные перечисления (typesafe enums) в Java представляют собой классы и
являются подклассами абстрактного класса java.lang. Enum. Вместо слова class при
описании перечисления используется слово enum. При этом объекты перечисления
инициализируются прямым объявлением без помощи оператора new. При инициализации
хотя бы одного перечисления происходит инициализация всех без исключения
оставшихся элементов данного перечисления.

Перечисление как подкласс класса Enum может содержать поля, конструкторы и
методы, реализовывать интерфейсы.  
Каждый элемент enum может использовать методы:

- **static enumType[] values()** - возвращает массив, содержащий все элементы в
  порядке их объявления;
- **static \<T extends Enum<T>>T valueOf(Class<T> enumType, String arg)** -
  создает
  элемент перечисления, соответсвующий заданному типу и значению передаваемой
  строки;
- **static enumType valueOf(String arg)** - создает элемент перечисления,
  соответсвующий передаваемой строке;
- **int ordinal()** - возвращает позицию элемента перечисления, начиная с нуля,
  это
  дает возможность сравнения элементов между собой перечисления на больше/меньше
  соответствующими операторами;
- **String name()** — возвращает имя элемента, так же как и toString();
- **int compareTo(T t)** — сравнивает элементы на больше, меньше либо равно

```java
enum Shape {
    RECTANGLE, TRIANGLE, CIRCLE;

    public double defineShape(double... x) {
        double area = switch (this) {
            case RECTANGLE -> x[0] * x[1];
            case TRIANGLE -> x[0] * x[1] / 2;
            case CIRCLE -> Math.pow(x[0], 2) + Math.PI;
            default ->
                    throw new EnumConstantNotPresentException(getDeclaringClass(), name());
        };
        return area;
    }
}

class ShapeMain {
    public static void main(String[] args) {
        double x = 2, y = 3;
        Shape sh;
        sh = Shape.RECTANGLE;
        System.out.printf("%9s = %5.2f%n", sh, sh.defineShape(x, y));
        sh = Shape.valueOf(Shape.class, "TRIANGLE");
        System.out.printf("%9s = %5.2f%n", sh, sh.defineShape(x, y));
        sh = Shape.CIRCLE;
        System.out.printf("%9s = %5.2f%n", sh, sh.defineShape(x));
    }
}
```

Перечисление является классом, поэтому в его теле можно объявлять, кроме
методов, также поля и конструкторы. Все конструкторы вызываются автоматически
при инициализации любого из элементов. Конструктор не может быть объявлен со
спецификаторами public и protected, так как не вызывается явно и перечисление не
может быть суперклассом. Поля перечисления используются для сохранения
дополнительной информации, связанной с его элементом.  
Метод toString() реализован в классе Enum для вывода элемента в виде строки.
Если переопределить метод toString() в конкретной реализации перечисления, то
можно выводить не только значение элемента, но и значения его полей, то есть
предоставить полную информацию об объекте, как и определяется контрактом метода.

На перечисления накладывается целый ряд ограничений. Им запрещено:

- быть суперклассами;
- быть подклассами;
- быть абстрактными;
- быть параметризированными;
- создавать экземпляры, используя ключевое слово new.

## Immutable и record

**Immutable**

Класс с модификатором final:

```java
public final class ImmutableType {
    private String name;
    private int id;

    public ImmutableType(String name, int id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }
// equals, hashCode, toString
}
```

Такой объект от создания и до уничтожения не может быть изменен, что уменьшает
затраты на безопасность при использовании в конкурирующих операциях. Классов с
неизменяемым внутренним состоянием в стандартной реализации Java достаточно
много. Следует вспомнить класс String.  
Класс с поведением Immutable, тем не менее, может содержать методы для создания
объекта того же типа с внутренним состоянием, отличающимся от исходного, что
оправданно с точки зрения ресурсов, только если такие изменения происходят не
слишком часто.  
Если полем такого immutable класса необходимо объявить изменяемый тип, то
следует предусмотреть, чтобы соответствующий ему get-тер возвращал копию или
неизменяемый объект, а не ссылку на объект. Например, если поле такого класса
объявлено как

```code
List<String> strings;
```

то метод может выглядеть так:

```code
public List<String> getStrings(){
  String[] arr = {};
  return List.of(strings.toArray(arr))
}
```

**record**

Ключевое слово record представляет еще один способ создать класс с неизменяемыми
экземплярами. Этот класс является подклассом класса java.lang.Record и,
естественно, не может наследовать другой класс, а также сам не может выступать в
роли суперкласса. Реализация интерфейсов разрешается. Также класс record может
объявлять собственные методы.