# ООП

## Классы и объекты

*Спецификатор класса:*

- public
- (не ставится, но означает)friendly/private-package - класс доступен только в
  пакете
- final - класс не может иметь подклассов
- abstract - класс содержит абстрактные нереализованные методы, объект такого
  класса создать нельзя

*Уровни доступа для членов классов:*

- public - доступен везде
- private - переменная доступна в рамках класса
- protected - доступ только внутри пакета и подклассам в других пакетах

## Статические методы и поля

Статические поля являются переменными класса, но не объекта. Могут быть
использованы без создания экземпляра класса. Нестатические методы могут
обращаться к статическим полям.

**Свойства статических методов:**

- статические методы являются методами класса, не привязаны ни к какому объекту
  и не содержат указателя this на конкретный экземпляр, вызвавший метод.
- статические методы реализуют парадигму «раннего связывания», жестко
  определяющую версию метода на этапе компиляции.
- По причине недоступности указателя this статические поля и методы не могут
  обращаться к нестатическим полям и методам напрямую, так как они не «знают», к
  какому объекту относятся, да и сам экземпляр класса может быть не создан;
- Для обращения к статическим полям и методам достаточно имени класса, в котором
  они определены;
- Переопределение статических методов невозможно, так как обращение к
  статическому методу осуществляется посредством имени класса, которому они
  принадлежат;

## Optional

Класс Optional представляет собой оболочку для любого объектного типа. Помогает
работать в ситуации, когда объект возвращает null.

```java
class Order {
    long id;
    String name;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public Order(long id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Order{" + "id=" + id + ", name='" + name + '\'' + '}';
    }
}

public class ExampleStart {
    public static void main(String[] args) {
        List<Order> orders = new ArrayList<>();
        orders.add(new Order(1L, "Alex"));
        orders.add(new Order(2L, "Bob"));
        orders.add(new Order(3L, "Charles"));
        Optional<Order> o = findById(orders, 4l);
        System.out.println(o);
    }

    public static Optional<Order> findById(List<Order> orders, long id) {
// Без Optional:      Order order = null;

        List<Order> result = orders
                .stream().filter(o -> id == o.getId())
                .toList();

//        Без Optional:
//        if (result.size() != 0) {
//            order = result.get(0);
//        }

        Optional<Order> optionalOrder =
                result.size() != 0
                        ? Optional.of(result.get(0))
                        : Optional.empty();

        return optionalOrder;
    }
}
```

**Методы:**

- **static \<T> Optional<T> empty()** - создает пустой объект;
- **static \<T> Optional\<T> of(T value)** - создает объект с ненулевым
  содержимым;
- **static \<T> Optional\<T> ofNullable(T value)** - создает объект, содержимое,
  которого может быть null;
- **boolean equals(Object optional)** - возвращает true, если вызывающий объект
  равен optional;
- **\<T> get()** - извлекает объект из оболочки, генерирует
  NullPointerException, если оболочка пуста;
- **boolean isEmpty** - возвращает true, если объект не содержит значение;
- **boolean isPresent** - возвращает true, если объект содержит значение;
- **void ifPresent(Consumer\<? super T> action)** - если объект присутствует -
  выполняет над ним действие;
- **void ifPresentOrElse(Consumer\<? super T> action, Runnable emptyAction)** -
  если объект присутствует - выполняет над ним действие action, если
  отсутствует - emptyAction;
- **T orElse(T other)** - возвращает объект other;
- **T orElseGet(Supplier\<? extends T> getFunc)** - если вызывающий объект
  содержит значение, то оно возвращается. В противном случае возвращается
  значение полученное из getFunc;
- **T orElseThrow(), \<T extends Throwable> T orElseThrow(Supplier\<? extends X>
  exception)** - генерирует исключение NoSuchElements или заданное исключение;
- **Optional\<T> filter(Predicate\<? super T> condition)** - Возвращает
  экземпляр Optional, который содержит то же самое значение, что и вызывающий
  объект, если это значение удовлетворяет условию, указанному в condition. В
  противном случае возвращается пустой объект;
- **U Optional\<U> flatMap(Function\<? super T, Optional\<U>> mapFunc)** -
  Применяет функцию сопоставления, указанную в mapFunc, к вызывающему объекту,
  если этот объект содержит значение, и возвращает результат. В противном случае
  возвращается пустой объект;
- **U Optional\<U> map(Function\<? super T, ? extends U>> mapFunc)** - Применяет
  функцию сопоставления, указанную в mapFunc, к вызывающему объекту, если
  этот объект содержит значение, и возвращает результат. В противном случае
  возвращается пустой объект;
- **\<Х extends Throwable> Т orElseThrow (Supplier\<? extends Х> excFunc) throws
  Х extends Throwable Stream\<T> stream()** - Возвращает поток данных, который
  содержит значение вызывающего объекта. Если значение отсутствует, тогда поток
  не будет содержать значений;

## Модификатор Final

Методы объявленные как final нельзя замещать в подклассах. От класса с
модификатором final нельзя создать подкласс. Константа может быть объявлена как
поле класса, но не проинициализирована. В этом случае она должна быть
проинициализирована в логическом блоке класса, заключенном в {}, или
конструкторе, но только в одном из указанных мест. Значение по умолчанию
константа получить не может в отличие от переменных класса. Константы могут быть
объявлены в методах как локальные или как параметры метода. В обоих случаях
значения таких констант изменять нельзя.

## Перегрузка методов

**Перегрузка метода** - статический полиморфизм - одинаковое название, но разные
параметры и возвращаемое значение. **Переопределение метода** - динамический
полиморфизм - одинаковые параметры. Статические методы могут перегружаться
нестатическими, и наоборот, без ограничений.

## Методы с переменным числом аргументов

Применяются такие методы в случае, когда необходимо
присвоить\изменить\использовать какое-либо свойство набора объектов, но заранее
неизвестно, сколько таких объектов будет представлено. В некоторых ситуациях
параметризованные методы являются альтернативой циклу.
Существует возможность передачи в метод нефиксированного числа параметров, что
позволяет отказаться от предварительного создания сложного объекта для его
последующей передачи в метод. Набор объектов, переданный в такой метод,
преобразуется в массив с типом и именем, которые указаны в качестве параметров
метода.

```java
public class ExampleStart {
    public static int defineArgsCount(Integer... args) {
        if (args.length != 0) {
            for (int element : args) {
                System.out.printf("args:%d ", element);
            }
        } else {
            System.out.println("No arguments given");
        }
        return args.length;
    }

    public static void main(String... args) {
        System.out.println("N= " + defineArgsCount(7, 42, 555));
        Integer[] arr = {1, 2, 3, 4, 5, 42, 7};
        System.out.println("N= " + defineArgsCount(arr));
        System.out.println(defineArgsCount());
    }
}

```

## Автоупаковка. Оболочки типов.

К оболочкам типов относятся Double, Float, Long, Integer, Short, Byte, Character
и Boolean из пакета java.lang. Перечисленные классы предлагают широкий набор
методов, позволяющих полностью интегрировать примитивные типы в иерархию
объектов Java.
Все оболочки числовых типов унаследованы от абстрактного класса Number. В классе
Number определены методы, которые возвращают значение объекта каждого числового
типа:

- byte byteValue()
- double doubleValue()
- float floatValue()
- int intValue()
- long longValue()
- short shortValue()

Процесс инкапсуляции значения внутри объекта называется _упаковкой_.
Используется метод valueOf().
Процесс извлечения значения из оболочки типа называется _распаковкой_.
Используется метод intValue().

```java
class Wrap {
    public static void main(String[] args) {
        Intger iOb = new Integer.valueOf(100);
        //Вручную упаковать значение 100
        int i = iOb.intValue(); // Вручную распаковать значение из iOb
        System.out.println(i + " " + iOb); // выводит 100 100
    }
}
```

### Основы автоупаковки

Автоупаковка - это процесс, с помощью которого примитивный тип автоматически
инкапсулируется (упаковывается) в эквивалентную ему оболочку типа всякий раз,
когда требуется объект такого типа. Нет необходимости явно создавать объект.
Автораспаковка представляет собой процесс, при котором значение упакованного
объекта автоматически извлекается (распаковывается) из оболочки типа, когда
значение необходимо. Не придется вызывать методы вроде intValue() или
doubleValue().

    Integer i = 100; <-- Автоупковка

