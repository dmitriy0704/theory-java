# Базовые понятия ООП


## Модификаторы доступа

*Спецификатор класса:*

- public
- (не ставится, но означает)friendly/private-package - класс доступен только в
  пакете
- final - класс не может иметь подклассов
- abstract - класс содержит абстрактные нереализованные методы, объект такого
  класса создать нельзя

*Уровни доступа для членов классов:*

- public - доступен везде
- private - переменная доступна в рамках класса
- protected - доступ только внутри пакета и подклассам в других пакетах

Модификаторы:

- private — члены класса доступны только членам данного класса;
- по умолчанию (package-private) — члены класса доступны классам, находящимся в
  том же пакете;
- protected — члены класса доступны классам, находящимся в том же пакете, и
  подклассам — в других пакетах;
- public — члены класса доступны для всех классов в этом и других пакетах.

Член класса (поле, конструктор или метод), объявленный public, доступен из
любого места вне класса. Спецификатор public для методов и конструкторов
public-классов обеспечивает внешний доступ к функциональности пакета, в котором
он объявлен. Если данный спецификатор отсутствует, то класс и его методы могут
использоваться только в текущем пакете.

Все, что объявлено private, доступно только конструкторам и методам внутри
класса и нигде больше. Они выполняют служебную или вспомогательную роль в
пределах класса, и их функциональность (методов и конструкторов) не
предназначена для внешнего использования. Закрытие private-полей обеспечивает
инкапсуляцию.

Если у члена класса вообще не указан спецификатор уровня доступа, то такой член
класса будет виден и доступен из подклассов и классов того же пакета. Именно
такой уровень доступа используется по умолчанию. Такой член класса обеспечивает
исполнение public-методами public-классов своей функциональности.

Если же необходимо, чтобы элемент был доступен из другого пакета, но только
подклассам того класса, которому он принадлежит, нужно объявить такой элемент со
спецификатором protected. Спецификатор применим, если поле часто используется в
подклассе или если метод предназначен для переопределения и использования его
функциональности в другом пакете. Для конструктора наличие protected
обеспечивает саму возможность наследования от этого класса в другом пакете.
Действие спецификатора доступа распространяется только на тот элемент класса,
перед которым стоит такой спецификатор.

## Конструкторы

Конструктор — особого вида метод, который по имени автоматически вызывается при
создании экземпляра класса с помощью оператора new. При корректном
проектировании класса конструктор не должен выполнять никаких
других обязанностей, кроме инициализации полей класса и проверки
непротиворечивости конструирования объекта.

Свойства конструктора:

- Конструктор имеет то же имя, что и класс; вызывается не просто по имени,
  а только вместе с ключевым словом new при создании экземпляра класса.
- Конструктор не возвращает значение, но может иметь параметры и быть
  перегружаемым.
- Конструкторов в классе может быть несколько, но не менее одного.
- Если конструктор в классе явно не определен, то компилятор предоставляет
  конструктор по умолчанию без параметров.
- Если же конструктор с параметрами определен, то конструктор по умолчанию
  становится недоступным, и для его вызова необходимо явное объявление такого
  конструктора.
- Конструктор подкласса при его создании всегда наделяется возможностью
  вызова конструктора суперкласса. Этот вызов может быть явным или неявным и
  располагается только в первой строке кода конструктора подкласса.
- Если конструктору суперкласса нужно передать параметры, то необходим
  явный вызов из конструктора подкласса super(parameters).
- Конструктор может объявляться только со спецификаторами видимости:
  public, private, protected или по умолчанию.
- Конструктор не может быть объявлен как static, final, abstract, synchronized,
  native.
- Если к конструктору добавить возвращаемое значение, то он перестанет
  быть конструктором, а превратится в метод данного класса. Компилятор
  при этом выдаст предупреждение о том, что в классе присутствуют методы
  с таким же именем, как и класс, что является грубым нарушением соглашения о
  написании кода.

## Статические методы и поля

Статические методы можно перегружать и «переопределять» в подклассах,
но их доступность всегда зависит от типа ссылки и атрибута доступа, и никогда —
от типа самого объекта.  
Статические поля являются переменными класса, но не объекта. Могут быть
использованы без создания экземпляра класса. Нестатические методы могут
обращаться к статическим полям.

**Свойства статических методов:**

- статические методы являются методами класса, не привязаны ни к какому объекту
  и не содержат указателя this на конкретный экземпляр, вызвавший метод.
- статические методы реализуют парадигму «раннего связывания», жестко
  определяющую версию метода на этапе компиляции.
- По причине недоступности указателя this статические поля и методы не могут
  обращаться к нестатическим полям и методам напрямую, так как они не «знают», к
  какому объекту относятся, да и сам экземпляр класса может быть не создан;
- Для обращения к статическим полям и методам достаточно имени класса, в котором
  они определены;
- Переопределение статических методов невозможно, так как обращение к
  статическому методу осуществляется посредством имени класса, которому они
  принадлежат;
- для вызова нестатического метода из статического надо создать экземпляр
  класса;

```java
class Example {
    void nonStaticMethod() { /* Здесь производится что-то интересное */ }

    static void staticMethod() {
        new Example().nonStaticMethod(); // И вот она, статическая магия
    }
}
```

## Методы с переменным числом аргументов

Применяются такие методы в случае, когда необходимо
присвоить\изменить\использовать какое-либо свойство набора объектов, но заранее
неизвестно, сколько таких объектов будет представлено. В некоторых ситуациях
параметризованные методы являются альтернативой циклу.
Существует возможность передачи в метод нефиксированного числа параметров, что
позволяет отказаться от предварительного создания сложного объекта для его
последующей передачи в метод. Набор объектов, переданный в такой метод,
преобразуется в массив с типом и именем, которые указаны в качестве параметров
метода.

```java
public class ExampleStart {
    public static int defineArgsCount(Integer... args) {
        if (args.length != 0) {
            for (int element : args) {
                System.out.printf("args:%d ", element);
            }
        } else {
            System.out.println("No arguments given");
        }
        return args.length;
    }

    public static void main(String... args) {
        System.out.println("N= " + defineArgsCount(7, 42, 555));
        Integer[] arr = {1, 2, 3, 4, 5, 42, 7};
        System.out.println("N= " + defineArgsCount(arr));
        System.out.println(defineArgsCount());
    }
}

```

## Отношения классов

### IS-A отношения

Наследование описывает связь "является" (IS A). Лев является животным. Animal
будет родительским классом для Lion.

### HAS-A отношения

Отношение "является частью"("HAS A") описывает принадлежность объекта к другому
как его части, например, клавиатура часть компьютера. Отношения HAS A можно
описать в коде, используя механизмы композиции и агрегирования. Разница между
ними заключается в «строгости» этих связей.

Три вида связи:

- ассоциация;
- агрегация;
- композиция

_**Ассоциация**_ означает, что объекты двух классов могут ссылаться один на
другой,
иметь некоторую связь между друг другом. Например, Менеджер может выписать Счет.
Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример —
Преподаватель и Студент - т.е. какой-то Студент учится у какого-то
Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент
учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны
между собой и это надо как-то описать.

Агрегация и композиция - частные случаи ассоциации. Это более конкретизированные
отношения между объектами.

**_Агрегация_** — отношение когда один объект является частью другого. Например
Студент входит в Группу любителей физики.
Car — машина. У каждой машины есть
двигатель. Кроме того, у каждой машины есть пассажиры внутри.
В чем же принципиальная разница между полями Engine engine и Passenger[]
passengers? Если у машины внутри сидит пассажир А, это не значит, что в ней не
могут находиться пассажиры B и C. Одна машина может соответствовать нескольким
пассажирам. Кроме того, если всех пассажиров высадить из машины, она продолжит
спокойно функционировать. Связь между классом Car и массивом пассажиров
Passenger[] passengers менее строгая. Она называется _**агрегацией**_. Еще один
хороший пример агрегации. Допустим, у нас есть класс Student, обозначающий
студента, и класс StudentsGroup (группа студентов). Студент может входить и в
клуб любителей физики, и в студенческий фан-клуб «Звездных войн» или команду
КВН.

**_Композиция_** — еще более «жесткое отношение, когда объект не только является
частью другого объекта, но и вообще не может принадлежать еще кому-то. Например
Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет
быть в двух или трех машинах одновременно. В отличие от студента, который может
входить и в другие группы тоже. Такие описания всегда несколько условны, но тем
не менее.

```java
package dev.folomkin.core.oop.oop;

class Robot {
    private double x = 0;
    private double y = 0;
    protected double course = 0;
    // Робот управляется оператором
    private Operator operator;

    public Robot(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // Можно узнать какой оператор управляет роботом
    public Operator getOperator() {
        return operator;
    }

    // Можно установить оператора для робота
    public void setOperator(Operator operator) {
        this.operator = operator;
    }

    public void forward(int distance) {
        x = x + distance * Math.cos(course / 180 * Math.PI);
        y = y + distance * Math.sin(course / 180 * Math.PI);
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getCourse() {
        return course;
    }

    public void setCourse(double course) {
        this.course = course;
    }

    public void printCoordinates() {
        System.out.println(x + "," + y);
    }
}

class Operator {
    private String firstName;
    private String lastName;
    // Оператор управляет конкретным роботом
    private Robot robot;

    public Operator(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    // У оператора можно спросить каким роботом он управляет
    public Robot getRobot() {
        return robot;
    }

    // Оператору можно поручить управлять роботом
    public void setRobot(Robot robot) {
        this.robot = robot;
    }
}

```