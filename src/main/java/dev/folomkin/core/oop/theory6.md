# Внутренние классы

Одной из причин использования внутренних классов является возможность
быть подклассом любого класса независимо от того, подклассом какого класса
является внешний класс.

Если необходимо определить и связать класс с некоторой функциональностью,
очень близкой этому классу, то применяется статическое вложение
класса, делающее независимым объект с вложенной функциональностью от
класса-владельца, но логически через имя внешнего класса связывает с ним.
Объект такого класса можно создать, не создавая объект класса-владельца.

Такие статические вложенные классы объявляются с модификатором static.
Статические классы могут обращаться к нестатическим членам включающего
класса не напрямую, а только через его объект.

Нестатические внутренние классы имеют доступ ко всем переменным и методам
своего внешнего класса-владельца и требуют последовательного создания
объектов внешнего и внутреннего классов.

Применение анонимных классов и их подмножества: лямбда-выражений,
позволяет сократить количество кода. Анонимные классы сокращают число
подклассов, лямбда-выражения записываются еще короче и с более высоким
акцентом на функционал объекта.

## Внутренние(inner) классы

**Нестатические вложенные классы** принято называть внутренними, или _inner
классами_. Доступ к элементам внутреннего класса возможен из внешнего только
через объект внутреннего класса, который должен быть создан в коде метода
внешнего класса. Объект внутреннего класса всегда ассоциируется (скрыто хранит
ссылку) с создавшим его объектом внешнего класса — так называемым внешним, или
enclosing объектом.

```java
class Student {
    private int studentId;
    private String name;
    // ,,, getters/setters
    private Address address;

    public class Address {
        private String city;
        private String street;
        // ,,, getters/setters
    }
}

class Code {
    public static void main(String[] args) {
        Student.Address address = new Student().new Address();
    }
}
```

При компиляции внутренний класс получает собственный модуль для интерпретации,
соответствующий внутреннему классу, который получит имя Student$Address.class.
Внешний же класс будет скомпилирован в обычный файл Student.class.

Методы внутреннего класса имеют прямой доступ ко всем полям и методам
внешнего класса, как будто они его собственные, в то же время внешний класс
может получить доступ к содержимому внутреннего класса только после создания
объекта внутреннего класса. Доступ будет разрешен по имени, в том числе и к
полям, объявленным как private. Внутренние классы не могут содержать статические
поля и методы, кроме final static. Внутренние классы имеют право наследовать
другие классы, реализовывать интерфейсы и выступать в роли объектов
наследования. Допустимо наследование следующего вида:

    public class SubStudent extends Student {
        public class SubAddress extends Address {
        }
    }

Если внутренний класс наследуется обычным образом другим классом (после extends
указывается ИмяВнешнегоКласса.ИмяВнутреннегоКласса), то он теряет доступ к полям
своего внешнего класса, в котором был объявлен.

Поля внешнего класса видны внутреннему классу так, будто они его собственные,
модификаторы видимости игнорируются. Применить ссылку this также не получится,
так как this внутри класса Inner указывает на его собственный объект, и ни в
коем случае не на его владельца.

Внешний класс напрямую не видит никаких компонентов своего внутреннего класса.
Вопрос доступа к полям внешнего класса можно рассмотреть путем объявления полей
с одинаковыми именами во внутреннем и внешнем классах, чего на практике делать
не рекомендуется.

Внутренний класс может быть объявлен также внутри метода или логического блока
внешнего (owner) класса. Видимость такого класса регулируется областью видимости
блока, в котором он объявлен. Но внутренний класс сохраняет доступ ко всем полям
и методам внешнего класса, а также ко всем константам, объявленным в текущем
блоке кода. Класс, объявленный внутри метода, не может быть объявлен как static,
а также не может содержать статические поля и методы.

**Свойства внутренних классов:**

- Доступ к элементам внутреннего класса возможен только из внешнего класса через
  объект внутреннего класса;
- Методы внутреннего класса имеют прямой доступ ко всем полям и методам внешнего
  класса;
- Объект внутреннего класса имеет ссылку на объект своего внешнего класса(
  enclosing);
- Внутренние классы не могут содержать static-полей и методов, кроме final
  static;
- Внутренние классы могут быть производными от других классов;
- Внутренние классы могут быть суперклассами;
- Внутренние классы могут реализовывать интерфейсы;
- Внутренние классы могут быть объявлены с параметрами final, abstract, private,
  protected, public;
- Если необходимо создать объект внутреннего класса где-нибудь, кроме внешнего
  нестатического метода класса, то нужно определить тип объекта как
  OwnerType.InnerType;
- Внутренний класс может быть объявлен внутри метода или логического блока
  внешнего класса, видимость класса регулируется видимостью того блока, в
  котором он объявлен. Однако внутренний класс сохраняет доступ ко всем полям и
  методам внешнего класса, а также final-переменным, объявленным в текущем блоке
  кода;
- Локальному внутреннему классу, объявленному внутри метода или логического
  блока, модификатор доступа не требуется, так как он все равно не доступен
  напрямую вне метода.


