# Основы ООП

## Наследование

Отношение между классами, при котором характеристики одного класса
(суперкласса) передаются другому классу (подклассу) без необходимости их
повторного определения, называется **_наследованием_**.

Подкласс наследует поля и методы суперкласса, используя ключевое слово extends.
Класс может также реализовать любое число интерфейсов, используя ключевое слово
implements. Подкласс имеет прямой доступ ко всем открытым переменным и методам
родительского класса, как будто они находятся в подклассе. Исключение составляют
члены класса, помеченные private (во всех случаях) и «по умолчанию» для
подкласса в другом пакете. В любом случае (даже если ключевое слово extends
отсутствует) класс автоматически наследует свойства суперкласса всех классов —
класса Object.

**_Перегрузка или статический полиморфизм_**  
Подкласс дополняет члены суперкласса своими полями и\или методами
и\или переопределяет методы суперкласса. Если имена методов совпадают,
а параметры различаются, то такое явление называется перегрузкой методов
(статическим полиморфизмом).

**_Переопределение или динамическим полиморфизмом_**  
Если же совпадают имена и параметры методов, то этот механизм называется
динамическим полиморфизмом. То есть в подклассе можно объявить (переопределить)
метод с тем же именем, списком параметров и возвращаемым значением, что и у
метода суперкласса.

Способность ссылки динамически определять версию
переопределенного метода в зависимости от переданного по ссылке типа объекта
называется **_полиморфизмом_**.

```java
class CardAction {
    public void doPayment(double amountPayment) {
        System.out.println("complete from debt card");
    }
}

class CreditCardAction extends CardAction {
    @Override
    public void doPayment(double amountPayment) { // override method
        System.out.println("complete from credit card");
    }

    public boolean checkCreditLimit() { // own method
        return true;
    }
}

public class Code {
    public static void main(String[] args) {
        CardAction action1 = new CardAction();
        CardAction action2 = new CreditCardAction();
        CreditCardAction cc = new CreditCardAction();
        // CreditCardAction cca = new CardAction(); // compile error: class cast
        action1.doPayment(15.5); // method of CardAction
        action2.doPayment(21.2); // polymorphic method: CreditCardAction
        // dc2.checkCreditLimit(); // compile error: non-polymorphic method
        ((CreditCardAction) action2).checkCreditLimit(); // ок
        cc.doPayment(7.0); // polymorphic method: CreditCardAction
        cc.checkCreditLimit(); // non-polymorphic method CreditCardAction
        ((CreditCardAction) action1).checkCreditLimit(); // runtime error: class cast
    }
}

```

Объект по ссылке action1 создается при помощи вызова конструктора класса
CardAction и, соответственно, при вызове метода doPayment() вызывается версия
метода из класса CardAction.
При создании объекта action2 ссылка типа CardAction инициализируется объектом
типа CreditCardAction.
При таком способе инициализации ссылка на суперкласс получает доступ к методам,
переопределенным в подклассе.
При объявлении совпадающих по сигнатуре (имя, тип, область видимости) полей в
суперклассе и подклассах их значения не переопределяются и никак не
пересекаются, т.е. существуют в одном объекте независимо друг от друга.
Для доступа к полям текущего объекта можно использовать указатель **this**, для
доступа к полям суперкласса — указатель **super**.

### Модификатор Final

Методы объявленные как final нельзя замещать в подклассах. От класса с
модификатором final нельзя создать подкласс. Константа может быть объявлена как
поле класса, но не проинициализирована. В этом случае она должна быть
проинициализирована в логическом блоке класса, заключенном в {}, или
конструкторе, но только в одном из указанных мест. Значение по умолчанию
константа получить не может в отличие от переменных класса. Константы могут быть
объявлены в методах как локальные или как параметры метода. В обоих случаях
значения таких констант изменять нельзя.

#### Классы и методы final

Запрещено переопределять метод в порожденном классе, если в суперклассе он
объявлен со спецификатором final:

Применение final-методов также показательно при разработке конструктора класса.
Процесс инициализации экземпляра должен быть строго определен
и не подвергаться изменениям. Исключить подмену реализации метода, вызываемого в
конструкторе, следует объявлением метода как final, т.е. при этом
метод не может быть переопределен в подклассе. Подобное объявление гарантирует
обращение именно к этой реализации.

```java
class AutenticationService {
    public AutenticationService() {
        authenticate();
    }

    public final void authenticate() {
        //appeal to the database
    }
}
```

## this и super

Главное отличие между this и super в Java в том, что this представляет текущий
экземпляр класса, в то время как super - текущий экземпляр родительского класса.
Внутри класса для вызова своего конструктора без аргументов используется this(),
тогда как super()используется для вызова конструктора без аргументов, или как
его ещё называют, конструктора по умолчанию родительского класса.
Таким способом вызывать можно не только конструктор без аргументов, а и вообще
любой другой конструктор, передав ему соответствующие параметры.

this и super в Java используются для обращения к переменным экземпляра класса и
его родителя. Вообще-то, к ним можно обращаться и без префиксов super и this, но
только если в текущем блоке такие переменные не перекрываются другими
переменными, т.е. если в нем нет локальных переменных с такими же именами, в
противном же случае использовать имена с префиксами придется обязательно, но это
не беда, т.к. в таком виде они даже более читабельны. Классическим примером
такого подхода является использование this внутри конструктора, который
принимает параметр с таким же именем, как и у переменной экземпляра.

### Схожесть this и super

1. И this, и super — это нестатические переменные, соответственно их нельзя
   использовать в статическом контексте, а это означает, что их нельзя
   использовать в методе main. Это приведет к ошибке во время компиляции "на
   нестатическую переменную this нельзя ссылаться из статического контекста". То
   же самое произойдет, если в методе main воспользоваться ключевым словом
   super.
2. И this, и super могут использоваться внутри конструкторов для вызова других
   конструкторов по цепочке, нпр., this() и super() вызывают конструктор без
   аргументов наследующего и родительского классов соответственно.

```java
class A {
    A() {
        System.out.println("Конструктор без аргументов класса A");
    }

    A(String args) { // 3 - шаг
        System.out.println("Конструктор с одним аргументом класса A"); // <- отрабатывает
    }
}

class B extends A {

    B() {
        this(""); // 1 шаг - тут this("") - это конструктор в классе B - B(String args){} - вызывается он
        System.out.println("Конструктор без аргументов класса B");// 5 шаг - <- ход программы возвращается
    }

    B(String args) {
        super("");// 2 шаг - вызывается конструктор наследуемого класса с параметром
        System.out.println("Конструктор с одним аргументом класса B");// 4 шаг - <- отрабатывает по ходу программы
    }
}

public class Code {
    public static void main(String[] args) {
        B b = new B(); // 0 шаг - вызывается конструктор класса B без параметров
    }
}
```

3. Внутри конструктора this и super должны стоять выше всех других выражений, в
   самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует,
   что в одном конструкторе не может быть одновременно и this(), и super().

### Различия this и super

1. Переменная this ссылается на текущий экземпляр класса, в котором она
   используется, тогда как super — на текущий экземпляр родительского класса.

2. Каждый конструктор при отсутствии явных вызовов других конструкторов неявно
   вызывает с помощью super() конструктор без аргументов родительского класса,
   при этом у вас всегда остается возможность явно вызвать любой другой
   конструктор с помощью либо this(), либо super().

### Использование super и this

Ключевое слово super применяется для обращения к конструктору суперкласса и для
доступа к полю или методу суперкласса.

    super(parameters); // вызов суперкласса конструктора
    super.id = 42; // ссылка на атрибут суперкласса
    super.getId(); // вызов метода суперклассa

Первая форма super применяется только в конструкторах для обращения
к конструктору суперкласса только в качестве первой строки кода конструктора
и только один раз.

Вторая форма super используется для доступа из подкласса к переменной id
суперкласса.

Третья форма специфична для Java и обеспечивает вызов из подкласса метода
суперкласса, что позволяет избежать рекурсивного вызова в случае,
если вызываемый с помощью super метод переопределен в данном подклассе.

Причем, если в суперклассе этот метод не определен, то будет осуществляться
поиск по цепочке наследования до тех пор, пока он не будет найден.
Во всех случаях с использованием super можно обратиться только к ближайшему
суперклассу, т.е. «перескочить» через суперкласс, чтобы обратиться
к его суперклассу, невозможно.

```java
class Point1D {
    private int x;

    public Point1D(int x) {
        this.x = x;
    }
}

class Point2D extends Point1D {
    private int y;

    public Point2D(int x, int y) {
        super(x);
        this.y = y;
    }
}

class Point3D extends Point2D {
    private int z;

    public Point3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    public Point3D() {
        this(-1, -1, -1); // вызов конструктора с параметрами
    }
}
```

В классе Point3D второй конструктор для завершения инициализации объекта
обращается к первому конструктору. Такая конструкция применяется
в случае, когда в класс требуется добавить конструктор по умолчанию с
обязательным использованием уже существующего конструктора.

Ссылка this используется, если в методе объявлены локальные переменные с тем
же именем, что и переменные экземпляра класса. Локальная переменная имеет
преимущество перед полем класса и закрывает к нему доступ. Чтобы получить
доступ к полю класса, требуется воспользоваться явной ссылкой this перед именем
поля, так как поле класса является частью объекта, а локальная переменная нет.

Инструкция this() должна быть единственной в вызывающем конструкторе и быть
первой по счету выполняемой операцией, иначе возникает возможность вызова
нескольких конструкторов суперкласса или ветвления при обращении к конструктору
суперкласса. Компилятор выполнять подобные действия запрещает.

## Полиморфизм

### Связывание. Позднее и раннее.

Связывание означает наличие связи между ссылкой и кодом. Например, переменная,
на которую вы ссылаетесь, привязана к коду, в котором она определена.
Аналогично, вызываемый метод привязан к месту в коде, где он определен.

Существует два типа связывания методов в языке Java: ранее связывание (его ещё
называют статическим) и позднее (соответственно, динамическое) связывание. Вызов
метода в Java означает, что этот метод привязывается к конкретному коду или в
момент компиляции, или во время выполнения, при запуске программы и создании
объектов.

Можно понять из названия, статическое связывание носит более статический
характер, так как происходит во время компиляции, то есть код «знает», какой
метод вызывать после компиляции исходного кода на Java в файлы классов. А
поскольку это относится к ранней стадии жизненного цикла программы, то
называется также ранним связыванием (early binding).

С другой стороны, динамическое связывание происходит во время выполнения, после
запуска программы виртуальной машиной Java. В этом случае то, какой метод
вызвать, определяется конкретным объектом, так что в момент компиляции
информация недоступна, ведь объекты создаются во время выполнения. А поскольку
это происходит на поздней стадии жизненного цикла программы, то называется в
языке Java поздним связыванием (late binding).

Фундаментальное различие между статическим и динамическим связыванием в Java
состоит в том, что первое происходит рано, во время компиляции на основе типа
ссылочной переменной, а второе – позднее, во время выполнения, с использованием
конкретных объектов.

Привязка виртуальных методов не происходит во время компиляции при помощи
статического связывания, поскольку в этом случае вызывался бы метод из
суперкласса, как происходит со статическими методами, которые связываются рано.
Если будет вызван метод из подкласса, то для связывания функции использовался
конкретный объект во время выполнения, а, следовательно, для связывания
виртуальных функций используется динамическое связывание.

```java
public class Code {
    public static void main(String[] args) {
        // Пример статического и динамического связывания в Java
        Insurance current = new CarInsurance();
        // Динамическое связывание на основе объекта
        int premium = current.premium();
        // Статическое связывание на основе класса
        String category = current.category();
        System.out.println("premium : " + premium);
        System.out.println("category : " + category);
    }
}

class Insurance {
    public static final int LOW = 100;

    public int premium() {
        return LOW;
    }

    public static String category() {
        return "Insurance";
    }
}

class CarInsurance extends Insurance {
    public static final int HIGH = 200;

    public int premium() {
        return HIGH;
    }

    public static String category() {
        return "Car Insurance";
    }

}
```

Вызов метода premium() привел к выполнению метода из подкласса, в то время как
вызов метода category() привел к выполнению метода суперкласса. Это происходит
из-за того, что premium() – виртуальный метод, который разрешается при помощи
позднего связывания, в то время как category() – статический метод, который
разрешается при помощи статического связывания во время компиляции по имени
класса.

### Различия между ранним и поздним связыванием в языке Java

1. Статическое связывание происходит во время компиляции, а динамическое – во
   время выполнения.

2. Поскольку статическое связывание происходит на ранней стадии жизненного цикла
   программы, его называют ранним связыванием. Аналогично, динамическое
   связывание называют также поздним связыванием, поскольку оно происходит
   позже, во время работы программы.

3. **Статическое связывание используется в языке Java для разрешения
   перегруженных
   методов, в то время как динамическое связывание используется в языке Java для
   разрешения переопределенных методов.**

4. Аналогично, приватные, статические и терминальные методы разрешаются при
   помощи статического связывания, поскольку их нельзя переопределять, а все
   виртуальные методы разрешаются при помощи динамического связывания.

5. В случае статического связывания используются не конкретные объекты, а
   информация о типе, то есть для обнаружения нужного метода используется тип
   ссылочной переменной. С другой стороны, при динамическом связывании для
   нахождения нужного метода в Java используется конкретный объект.

### Переопределение методов

Способность Java делать выбор метода, исходя из типа объекта во время
выполнения, называется «поздним связыванием». При вызове метода его поиск
происходит сначала в данном классе, затем в суперклассе, пока метод не будет
найден или не достигнут Object — суперкласс для всех классов.

Если два метода с одинаковыми именами и возвращаемыми значениями находятся в
одном классе, то списки их параметров должны отличаться. То же относится к
методам, наследуемым из суперкласса. Такие методы являются**перегружаемыми** (
overloading). При обращении вызывается доступный метод, список параметров
которого совпадает со списком параметров вызова.

Если объявление метода подкласса полностью, включая параметры, совпадает с
объявлением метода суперкласса (порождающего класса), то метод подкласса
переопределяет (overriding) метод суперкласса. Переопределение методов является
основой концепции динамического связывания, реализующей полиморфизм. Когда
переопределенный метод вызывается через ссылку суперкласса, Java определяет,
какую версию метода вызвать, основываясь на типе объекта, на который имеется
ссылка. Таким образом, тип объекта определяет версию метода на этапе выполнения.
Пример реализация полиморфизма на основе динамического связывания. Так как
суперкласс содержит методы, переопределенные подклассами, то объект суперкласса
будет вызывать методы различных подклассов в зависимости от того, на объект
какого подкласса у него имеется ссылка.

### Перегрузка методов

**Перегрузка метода** - статический полиморфизм - одинаковое название, но разные
параметры и возвращаемое значение. **Переопределение метода** - динамический
полиморфизм - одинаковые параметры. Статические методы могут перегружаться
нестатическими, и наоборот, без ограничений.

### Переопределение статических методов

Для статических методов принципы «позднего связывания» не работают.
Динамический полиморфизм к статическим методам класса неприменим, так
как обращение к статическому атрибуту или методу осуществляется по типу
ссылки, а не по типу объекта, через который производится обращение. Версия
вызываемого статического метода всегда определяется на этапе компиляции.
При использовании ссылки для доступа к статическому члену компилятор при
выборе метода учитывает тип ссылки, а не тип объекта, ей присвоенного.

```java
class StaticDumb {
    public static void go() {
        System.out.println("go() from StaticDumb ");
    }
}

class StaticDumber extends StaticDumb {
    //@Override – compile error
    public static void go() { // similar to dynamic polymorphism
        System.out.println("go() from StaticDumber ");
    }
}

public class Code {
    public static void main(String[] args) {
        StaticDumb dumb = new StaticDumber();
        dumb.go(); // warning: static member accessed via instance reference
        StaticDumber dumber = null;
        dumber.go(); // will not NullPointerException !
    }
}
```

## Абстракция

Абстракция - это принцип ООП, согласно которому при проектировании классов и
создании объектов необходимо выделять только главные свойства сущности, и
отбрасывать второстепенные.  
Класс является абстрактным, если хотя бы один из его методов является
абстрактным.  
Если метод помечен словом abstract, каждый класс-наследник должен его
реализовать или быть объявленным как абстрактный. Иначе компилятор выбросит
ошибку.
Каждый класс может наследоваться только от одного абстрактного класса, так что в
плане наследования разницы между абстрактными и обычными классами нет. Неважно,
наследуемся мы от абстрактного класса или от обычного, класс-родитель может быть
только один.

```java
abstract class Car {
    private int maxSpeed;

    public abstract void gas();

    public int getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(int maxSpeed) {
        this.maxSpeed = maxSpeed;
    }
}

class Sedan extends Car {
    @Override
    public void gas() {
        System.out.println("Седан газует!");
    }
}
```

Абстрактные классы объявляются с ключевым словом abstract и содержат
объявления абстрактных методов, которые не реализованы в этих классах,
а будут реализованы в подклассах. Абстрактный класс может и не содержать
вовсе абстрактных методов. Предназначение такого класса — быть вершиной
иерархии его различных реализаций.  
Объекты таких классов нельзя создать с помощью оператора new, но можно
создать объекты подклассов, которые реализуют все эти методы.  
При этом допустимо объявлять ссылку на абстрактный класс, но инициализировать ее
можно только объектом производного от него класса. Абстрактные классы могут
содержать и полностью реализованные методы, а также конструкторы
и поля данных.  
С помощью абстрактного класса объявляется контракт (требования к
функциональности) для его подклассов. Примером может служить
уже рассмотренный выше абстрактный класс Number и его подклассы Byte, Float и
другие.
Класс Number объявляет контракт на реализацию ряда методов по преобразованию
данных к значению конкретного базового типа, например, floatValue().
Можно предположить, что реализация метода будет различной для каждого из
классов-оболочек. Объект класса Number нельзя создать явно при помощи его
собственного конструктора.

```java
abstract class AbstractCardAction {
    private long actionId;

    public AbstractCardAction() {
    }

    public void check() {
    }

    public abstract void doPayment(double amountPayment);
}

class CreditCardAction extends AbstractCardAction {
    @Override
    public void doPayment(double amountPayment) {
        // code
    }
}

public class Code {
    public static void main(String[] args) {
        AbstractCardAction action;
// action = new AbstractCardAction(); //compile error: cannot create object!
        action = new CreditCardAction();
        action.doPayment(7);
    }
}
```

Ссылка action на абстрактный суперкласс инициализируется объектом подкласса, в
котором реализованы все абстрактные методы суперкласса.
С помощью этой ссылки могут вызываться также и неабстрактные методы
абстрактного класса, если они не переопределены в подклассе:
action.check();

#### Абстрактные классы и интерфейсы

Интерфейс — это конструкция в языке Java, которая помогает реализовать
абстрактные методы и статические константы.    
Абстрактные классы похожи на обычные классы, с тем отличием, что они могут
включать абстрактные методы, то есть методы без тела. Абстрактные классы не
могут быть созданы.

**Что такое интерфейс**

По своей сути, интерфейс — это контракт, поэтому он зависит от реализации,
которая определяет цель его создания. Интерфейс не может использовать изменяемые
переменные экземпляра, он может использовать только конечные переменные.

**Когда использовать интерфейсы**

Интерфейсы очень полезны для разделения кода и реализации полиморфизма.
Многие классы принадлежат родительскому классу с одними и теми же действиями
методов, но с разным поведением. В таких ситуациях рекомендуется использовать
интерфейс.

**Переопределение метода интерфейса**

Интерфейс — это своего рода контракт, который должен быть реализован конкретным
классом. Методы интерфейса неявно абстрактны и требуют конкретной реализации
класса.

```java
class Code {
    public static void main(String[] args) {
        Challenger challenger = new JavaChallenger();
        challenger.doChallenge();
    }
}

interface Challenger {
    void doChallenge();
}

class JavaChallenger implements Challenger {
    @Override
    public void doChallenge() {
        System.out.println("Challenge done!");
    }
}
```

Интерфейс может содержать только постоянные переменные. Переменные являются
неявными final и static. Это означает, что они являются константами, не зависят
от экземпляра и не могут быть изменены.

**Методы по умолчанию**

