# Основы ООП

## Наследование

Отношение между классами, при котором характеристики одного класса
(суперкласса) передаются другому классу (подклассу) без необходимости их
повторного определения, называется **_наследованием_**.

Подкласс наследует поля и методы суперкласса, используя ключевое слово extends.
Класс может также реализовать любое число интерфейсов, используя ключевое слово
implements. Подкласс имеет прямой доступ ко всем открытым переменным и методам
родительского класса, как будто они находятся в подклассе. Исключение составляют
члены класса, помеченные private (во всех случаях) и «по умолчанию» для
подкласса в другом пакете. В любом случае (даже если ключевое слово extends
отсутствует) класс автоматически наследует свойства суперкласса всех классов —
класса Object.

**_Перегрузка или статический полиморфизм_**  
Подкласс дополняет члены суперкласса своими полями и\или методами
и\или переопределяет методы суперкласса. Если имена методов совпадают,
а параметры различаются, то такое явление называется перегрузкой методов
(статическим полиморфизмом).

**_Переопределение или динамическим полиморфизмом_**  
Если же совпадают имена и параметры методов, то этот механизм называется
динамическим полиморфизмом. То есть в подклассе можно объявить (переопределить)
метод с тем же именем, списком параметров и возвращаемым значением, что и у
метода суперкласса.

Способность ссылки динамически определять версию
переопределенного метода в зависимости от переданного по ссылке типа объекта
называется **_полиморфизмом_**.

## Полиморфизм

### Перегрузка методов

**Перегрузка метода** - статический полиморфизм - одинаковое название, но разные
параметры и возвращаемое значение. **Переопределение метода** - динамический
полиморфизм - одинаковые параметры. Статические методы могут перегружаться
нестатическими, и наоборот, без ограничений.

### Методы с переменным числом аргументов

Применяются такие методы в случае, когда необходимо
присвоить\изменить\использовать какое-либо свойство набора объектов, но заранее
неизвестно, сколько таких объектов будет представлено. В некоторых ситуациях
параметризованные методы являются альтернативой циклу.
Существует возможность передачи в метод нефиксированного числа параметров, что
позволяет отказаться от предварительного создания сложного объекта для его
последующей передачи в метод. Набор объектов, переданный в такой метод,
преобразуется в массив с типом и именем, которые указаны в качестве параметров
метода.

```java
public class ExampleStart {
    public static int defineArgsCount(Integer... args) {
        if (args.length != 0) {
            for (int element : args) {
                System.out.printf("args:%d ", element);
            }
        } else {
            System.out.println("No arguments given");
        }
        return args.length;
    }

    public static void main(String... args) {
        System.out.println("N= " + defineArgsCount(7, 42, 555));
        Integer[] arr = {1, 2, 3, 4, 5, 42, 7};
        System.out.println("N= " + defineArgsCount(arr));
        System.out.println(defineArgsCount());
    }
}

```


### Статические методы и поля

Статические поля являются переменными класса, но не объекта. Могут быть
использованы без создания экземпляра класса. Нестатические методы могут
обращаться к статическим полям.

**Свойства статических методов:**

- статические методы являются методами класса, не привязаны ни к какому объекту
  и не содержат указателя this на конкретный экземпляр, вызвавший метод.
- статические методы реализуют парадигму «раннего связывания», жестко
  определяющую версию метода на этапе компиляции.
- По причине недоступности указателя this статические поля и методы не могут
  обращаться к нестатическим полям и методам напрямую, так как они не «знают», к
  какому объекту относятся, да и сам экземпляр класса может быть не создан;
- Для обращения к статическим полям и методам достаточно имени класса, в котором
  они определены;
- Переопределение статических методов невозможно, так как обращение к
  статическому методу осуществляется посредством имени класса, которому они
  принадлежат;


## Модификатор Final

Методы объявленные как final нельзя замещать в подклассах. От класса с
модификатором final нельзя создать подкласс. Константа может быть объявлена как
поле класса, но не проинициализирована. В этом случае она должна быть
проинициализирована в логическом блоке класса, заключенном в {}, или
конструкторе, но только в одном из указанных мест. Значение по умолчанию
константа получить не может в отличие от переменных класса. Константы могут быть
объявлены в методах как локальные или как параметры метода. В обоих случаях
значения таких констант изменять нельзя.
