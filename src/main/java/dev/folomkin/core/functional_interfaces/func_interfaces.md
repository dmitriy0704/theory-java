# Функциональные интерфейсы

Функциональный интерфейс в Java — это интерфейс, который содержит **ровно один абстрактный метод** (и может содержать любое количество методов по умолчанию или статических методов). Функциональные интерфейсы играют ключевую роль в функциональном программировании в Java, особенно с введением лямбда-выражений и Stream API в Java 8. Они используются для представления функций как объектов, что позволяет передавать поведение в методы или хранить его в переменных.

---

### 1. **Определение**
- Функциональный интерфейс — это интерфейс, помеченный аннотацией `@FunctionalInterface` (необязательно, но рекомендуется для явного указания).
- Он должен содержать **только один абстрактный метод** (SAM — Single Abstract Method).
- Может включать:
  - Методы по умолчанию (`default`), которые имеют реализацию.
  - Статические методы (`static`).
  - Методы, унаследованные от класса `Object` (например, `toString()`, `equals()`), которые не считаются абстрактными.

---

### 2. **Пример функционального интерфейса**
```java
@FunctionalInterface
public interface MyFunction {
    void doSomething(String input); // Единственный абстрактный метод
    default void defaultMethod() { // Метод по умолчанию
        System.out.println("This is a default method");
    }
    static void staticMethod() { // Статический метод
        System.out.println("This is a static method");
    }
}
```
- В этом примере `MyFunction` — функциональный интерфейс, так как он содержит только один абстрактный метод `doSomething`.

---

### 3. **Использование функциональных интерфейсов**
Функциональные интерфейсы часто используются с **лямбда-выражениями**, **ссылками на методы** и в API, таких как Stream API. Они позволяют компактно задавать поведение.

#### Пример с лямбда-выражением:
```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        // Лямбда-выражение для сложения
        Calculator add = (a, b) -> a + b;
        System.out.println(add.calculate(5, 3)); // Выведет: 8

        // Лямбда-выражение для умножения
        Calculator multiply = (a, b) -> a * b;
        System.out.println(multiply.calculate(5, 3)); // Выведет: 15
    }
}
```
- Лямбда-выражение `(a, b) -> a + b` реализует метод `calculate` интерфейса `Calculator`.

#### Пример со ссылкой на метод:
```java
public class Main {
    public static void main(String[] args) {
        // Ссылка на статический метод
        Calculator add = Integer::sum;
        System.out.println(add.calculate(5, 3)); // Выведет: 8
    }
}
```

---

### 4. **Встроенные функциональные интерфейсы**
Java 8 предоставляет множество встроенных функциональных интерфейсов в пакете `java.util.function`. Они покрывают большинство типичных сценариев использования. Вот основные из них:

| Интерфейс         | Абстрактный метод                     | Описание                                   | Пример использования                     |
|--------------------|---------------------------------------|--------------------------------------------|------------------------------------------|
| `Predicate<T>`    | `boolean test(T t)`                  | Проверяет условие, возвращает `true`/`false` | Фильтрация в Stream API                 |
| `Function<T, R>`  | `R apply(T t)`                       | Преобразует входной тип `T` в выходной `R` | Маппинг значений в Stream API           |
| `Consumer<T>`     | `void accept(T t)`                   | Выполняет действие над объектом типа `T`   | Вывод элементов, логирование             |
| `Supplier<T>`     | `T get()`                            | Возвращает объект типа `T` без входных данных | Генерация значений                      |
| `BiFunction<T, U, R>` | `R apply(T t, U u)`               | Принимает два аргумента, возвращает результат | Сложные преобразования                  |

#### Пример использования встроенного интерфейса:
```java
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        Predicate<Integer> isEven = n -> n % 2 == 0;
        System.out.println(isEven.test(4)); // Выведет: true
        System.out.println(isEven.test(5)); // Выведет: false
    }
}
```

---

### 5. **Аннотация `@FunctionalInterface`**
- Аннотация `@FunctionalInterface` не обязательна, но её использование:
  - Гарантирует, что интерфейс содержит ровно один абстрактный метод (компилятор выдаст ошибку, если это не так).
  - Делает код более читаемым, явно указывая, что интерфейс предназначен для функционального программирования.
- Если интерфейс соответствует требованиям (один абстрактный метод), он автоматически считается функциональным, даже без аннотации.

#### Пример ошибки:
```java
@FunctionalInterface
public interface InvalidFunction {
    void method1();
    void method2(); // Ошибка: больше одного абстрактного метода
}
```
- Компилятор выдаст ошибку, так как функциональный интерфейс не может иметь более одного абстрактного метода.

---

### 6. **Преимущества функциональных интерфейсов**
- **Компактность**: Лямбда-выражения и ссылки на методы сокращают объем кода по сравнению с анонимными классами.
- **Гибкость**: Позволяют передавать поведение как параметр в методы.
- **Интеграция с Stream API**: Используются для обработки коллекций (фильтрация, маппинг, агрегация).
- **Поддержка функционального программирования**: Упрощают написание декларативного кода.

---

### 7. **Сравнение с анонимными классами**
До Java 8 для реализации интерфейса часто использовались анонимные классы, что делало код громоздким. Функциональные интерфейсы с лямбда-выражениями упрощают эту задачу.

#### Анонимный класс:
```java
public class Main {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Running!");
            }
        };
        runnable.run();
    }
}
```

#### Лямбда-выражение:
```java
public class Main {
    public static void main(String[] args) {
        Runnable runnable = () -> System.out.println("Running!");
        runnable.run();
    }
}
```
- Лямбда-выражение короче и читабельнее.

---

### 8. **Когда использовать функциональные интерфейсы**
- Когда нужно передать поведение как параметр (например, в методах `Stream.filter()`, `Stream.map()`).
- Для реализации паттернов, таких как "Стратегия" или "Обратный вызов".
- Для упрощения кода с помощью лямбда-выражений или ссылок на методы.
- При работе с многопоточностью (например, интерфейс `Runnable` или `Callable`).

---

### 9. **Пример в Stream API**
```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
        Function<Integer, Integer> square = x -> x * x;

        numbers.stream()
               .map(square) // Применяем функциональный интерфейс Function
               .forEach(System.out::println); // Выведет: 1, 4, 9, 16
    }
}
```

---

### 10. **Ключевые моменты**
- Функциональный интерфейс должен иметь **ровно один абстрактный метод**.
- Используется с лямбда-выражениями и ссылками на методы для компактной передачи поведения.
- Встроенные интерфейсы в `java.util.function` покрывают большинство сценариев.
- Аннотация `@FunctionalInterface` помогает избежать ошибок и улучшает читаемость.

Если нужно углубиться в конкретный пример, использование в многопоточности или сравнение с другими механизмами, дайте знать!