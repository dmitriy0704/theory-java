# Лямбда выражения

## Введение

Ключевым аспектом для понимания реализации лямбда-выражений в Java являются две
конструкции: собственно лямбда - выражение и функциональный интерфейс. Начнем с
простого определения каждого из них.

**_Лямбда-выражение_** - анонимный (т.е. безымянный) метод. Используется для
реализации метода, определенного функциональным интерфейсом. Таким образом,
лямбда-выражение приводит к форме анонимного класса. Лямбда-выражения также
часто называют замыканиями.

**_Функциональный интерфейс_** это интерфейс, который содержит один и только
один абстрактный метод, обычно устанавливающий предполагаемое назначение
интерфейса. Соответственно функциональный интерфейс, как правило, представляет
одиночное действие. Например, стандартный интерфейс Runnable является
функциональным интерфейсом, поскольку в нем определен только один метод: run().
Следовательно, run() определяет действие Runnable. Кроме того, функциональный
интерфейс задает целевой тип лямбда-выражения. Важно понимать, что
лямбда-выражение может применяться только в контексте, в котором указан его
целевой тип. И еще один момент: функциональный интерфейс иногда называют
типом SAM, где SAM означает Single Abstract Method - единственный абстрактный
метод.

## Основы лямбда-выражений

Лямбда-выражение опирается на синтаксический элемент и операцию. Операцию иногда
называется лямбда-операцией или операцией стрелки и обозначается с помощью ->.
Она делит лямбда-выражение на две части. В левой части указываются любые
параметры, требующиеся в лямбда-выражении. В правой части находится тело
лямбда-выражения, которое определяет действия лямбда-выражения. В Java
определены два вида тела лямбда-выражения с **одиночным выражением** и с *
*блоком
кода**.

    // Код 
    double method() {
        return 98.6;
    }

    // можно заменить на
    () -> 98.6;

Когда лямбда-выражению необходим параметр, он указывается в списке параметров
слева от лямбда-операции:

    n -> (n % 2) == 0

## Блочные лямбда-выражения

Тело в лямбда-выражениях, состоящее из единственного выражения называется
**_телом-выражением_**, а лямбда-выражение с телом-выражением **_одиночным
лямбда-выражением_**. В теле-выражении код в правой части лямбда-операции
должен содержать одно выражение. Но иногда требуется более одного выражения.
Для обработки таких случаев в Java поддерживается второй вид лямбда-выражений,
где в правой части лямбда-операции находится блок кода, который может содержать
более одного оператора. Тело этого вида называется **_блочным_**.
Лямбда-выражения с блочными телами иногда называются
**_блочными лямбда-выражениями_**.

За исключением того, что блочные лямбда-выражения разрешают указывать несколько
операторов, они используются почти так же, как только что рассмотренные
одиночные лямбда-выражения. Тем не менее, есть одно ключевое отличие: вы обязаны
явно применять оператор return, чтобы возвратить значение. Поступать так
необходимо, потому что тело блочного лямбда-выражения не представляет одиночное
выражение.

Блочное лямбда-выражение используется с целью нахождения наименьшего
положительного делителя для значения типа int. В нем применяется интерфейс
NumericFunc с методом func(), который принимает один аргумент типа int и
возвращает результат типа int. Таким образом, NumericFunc поддерживает числовую
функцию для значений типа int.

```java
// Блочное лямбда выражение находит наименьший положительный делитель для значения типа int.
interface NumericFunc {
    int func(int n);
}

public class Code {
    public static void main(String[] args) {
        // Это блочное лямбда-выражение возвращает наименьший
        // положительный делитель для значения.
        NumericFunc numericFunc = (n) -> {
            int result = 1;
            // Получаем абсолютное значение n.
            n = n < 0 ? -n : n;
            for (int i = 2; i < n / i; i++) {
                if ((n % 1) == 0) {
                    result = i;
                    break;
                }
            }
            return result;
        };
        System.out.println("Наименьший делитель 12" + numericFunc.func(12));
        System.out.println("Наименьший делитель 11" + numericFunc.func(11));
    }
}
```

## Лямбда-выражения и захват переменных. Замыкания

Переменные, определенные в объемлющей области действия лямбда-выражения,
доступны внутри лямбда-выражения. Лямбда-выражение может задействовать
переменную экземпляра или статическую переменную, определенную в объемлющем
классе. Лямбда-выражение также имеет доступ к ссылке this(явно и неявно),
которая ссылается на вызывающий экземпляр класса, включающего лямбда-выражение.
Таким образом, лямбда-выражение может получать либо устанавливать значение
переменной экземпляра или статической переменной и вызывать метод, определенный
в объемлющем классе.

Когда в лямбда-выражении используется локальная переменная из его объемлющей
области видимости, то возникает особая ситуация, называемая захватом переменной.
В таком случае лямбда-выражение может работать только с локальными переменными,
которые являются фактически финальными. Фактически финальная переменная
представляет собой переменную, значение которой не меняется после ее первого
присваивания. Явно объявлять такую переменную как final нет никакой
необходимости, хотя поступать так не будет ошибкой. (Параметр this объемлющей
области видимости автоматически будет фактически финальным, а лямбда-выражения
не имеют собственной ссылки this.)
Локальная переменная из объемлющей области не может быть модифицирована
лямбда-выражением, поскольку в таком случае исчез бы ее статус фактически
финальной, из-за чего она стала бы незаконной для захвата.

```java
// Пример захвата локальной переменной из объемлющей области видимости ,
interface MyFunc {
    int func(int n);
}

class Code {
    public static void main(String[] args) {
        // Локальная переменная, которая может быть захвачена,
        int num = 10;
        MyFunc myLambda = (n) -> {
            // Использовать num подобным образом разрешено.
            // Переменная num не модифицируется,
            int v = num + n;
            // Однако следующая строка кода недопустима из-за того, что в ней
            // предпринимается попытка модифицировать значение num.
            // num++;
            return v;
        };
        // Использовать лямбда-выражение. Отобразится число 18.
        System.out.println(myLambda.func(8));
    }
    // Следующая строка кода тоже вызовет ошибку, потому что в ней
    // устраняется статус переменной num как фактически финальной.
    // num = 9;
}
```

В комментариях указано, что переменная num является фактически финальной и
потому может применяться внутри myLambda. Именно по этой причине оператор
printlnO выводит число 18. Когда метод func() вызывается с аргументом 8,
значение v внутри лямбда- выражения устанавливается путем сложения переменной
num (равной 10)и значения , переданного в п (равного 8). В итоге func()
возвращает 18. Такая работа объясняется тем, что num не изменяется после
инициализации. Однако если значение num будет изменено внутри лямбда-выражения
или за его пределами, то переменная num утратит свой статус фактически
финальной, что вызовет ошибку и программа не скомпилируется.
___ 

Блок кода, представляющий собой лямбда-выражение вместе со значениями локальных
переменных и параметров метода, в котором он объявлен, называется замыканием,
или closure. Объект-функция создается во время исполнения, и применен может быть
уже после того как объект, его создавший, прекратит существование. Такая
ситуация требует, чтобы переменные, которые использует лямбда-выражение, не
могли быть изменены. Значения переменных фиксируются замыканием и изменены быть
не могут.

```java
    public static Function<String, Integer> build(String strNum) {
    int count = 1;
    return t -> {
        int res = Integer.parseInt(strNum + t) + count;
        return res;
    };
}
// Или
// return t -> Integer.valueOf(strNum + t) + count;
```

При формировании объекта функции Function, как возвращаемого значения
метода build(), значения параметров сохраняются, и функция будет
использовать эти зафиксированные значения strNum и count в тот момент, когда
произойдет ее вызов.

```java

class Code {
    public static void main(String[] args) {
        Function<String, Integer> function = build("100");
        int res = function.apply("77");
        System.out.println(res);
    }

    public static Function<String, Integer> build(String strNum) {
        int count = 1;
        return t -> {
            int res = Integer.parseInt(strNum + t) + count;
            System.out.println(t);
            System.out.println(res);
            return res;

            // Переменные count и strNum не должны изменяться
        };
    }
}
```
Эти переменные должны иметь константные значения, как если бы они были
объявлены как final. Отсюда и название — замыкание.
Замыкания не запрещают использования полей класса как статических, так
и нестатических.

```java
public class FunctionBuilder<T> {
    static int count = 1;

    public static Function<String, Integer> build(String strNum) {
        count++;
        return t -> Integer.valueOf(strNum + t) + ++count;
    }
}
```
### Генерация исключений в лямбда-выражениях

Лямбда-выражение может генерировать исключение. Тем не менее, если инициируется
проверяемое исключение, то оно должно быть совместимым с исключением или
исключениями, которые перечислены в конструкции throws абстрактного метода в
функциональном интерфейсе. Например, если лямбда-выражение генерирует исключение
IOException, то в конструкции throws абстрактного метода в функциональном
интерфейсе должно быть указано IOException.

```java
interface MyIOAction {
    boolean ioAction(Reader rdr) throws IOException;
}

class Code {
    public static void main(String[] args) {

        // Это блочное лямбда-выражение может сгенерировать исключение IOException.
        // Следовательно, IOException должно быть указано в конструкции throws
        // метода ioAction() в MyAction.
        MyIOAction myIOAction = (rdr) -> {  // <-- Это лямбда выражение
            // может сгенерировать исключение

            int ch = rdr.read();            // может сгенерировать исключение
            // IOException;
            // ...
            return true;
        };
    }
}
```
Поскольку вызов read() может привести к генерации исключения IOException,
конструкция throws метода ioAction() в функциональном интерфейсе MylOAction
должна включать IOException. В противном случае программа не скомпилируется,
потому что лямбда - выражение больше не будет совместимым с ioAction().
