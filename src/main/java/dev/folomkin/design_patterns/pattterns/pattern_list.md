# Паттерны проектирования

## ВИДЫ ПАТТЕРНОВ:

**_Порождающие (creational):_** - Эти паттерны отвечают за удобное и безопасное
создание новых объектов или даже целых семейств объектов:

- Фабричный метод (factory method)
- Строитель (builder)
- Абстрактная фабрика (abstract factory)
- Прототип (prototype)
- Одиночка (singleton)

**_Структурные (structural):_** - Эти паттерны отвечают за построение удобных в
поддержке иерархий классов.

- Адаптер (adapter)
- Мост (bridge)
- Компоновщик/Составной метод (composite)
- Декоратор (decorator)
- Фасад (facade)
- Приспособленец/Легковес (flyweight)
- Прокси/Заместитель (proxy)

**_Поведенческие (behavioral):_** - заботятся об эффективной коммуникации между
объектами:

- Цепочка обязанностей (chain of responsibility)
- Команда (command)
- Итератор (iterator)
- Посредник (mediator)
- Хранитель (memento)
- Наблюдатель (observer)
- Состояние (state)
- Стратегия (strategy)
- Шаблонный метод (template method) -
- Посетитель (visitor)


## ПОРОЖДАЮЩИЕ ПАТТЕРНЫ

- Фабричный метод (Factory method) - определяет общий интерфейс для создания
  объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
- Абстрактная фабрика (Abstract factory) - Класс, который представляет собой
  интерфейс для создания других классов.
- Строитель (Builder) - Класс, который представляет собой интерфейс для создания
  сложного объекта.
- Прототип (Prototype) - Определяет интерфейс создания объекта через
  клонирование другого объекта вместо создания через конструктор.
- Одиночка (Singleton) - Класс, который может иметь только один экземпляр.

## СТРУКТУРНЫЕ ПАТТЕРНЫ

- Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других
  объектов, один из которых использует, а другой предоставляет несовместимый с
  первым интерфейс. Это структурный паттерн проектирования,
  который позволяет объектам с несовместимыми интерфейсами работать вместе.
- Мост (Bridge) - Структура, позволяющая изменять интерфейс обращения и
  интерфейс реализации класса независимо.
- Компоновщик (Composite) - Объект, который объединяет в себе объекты, подобные
  ему самому.
- Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без
  использования наследования.
- Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами,
  объединяя их в единое целое.
- Приспособленец (Flyweight) - Это объект, представляющий себя как уникальный
  экземпляр в разных местах программы, но по факту не являющийся таковым.
- Заместитель (Proxy) - Объект, который является посредником между двумя другими
  объектами, и который реализует/ограничивает доступ к объекту, к которому
  обращаются через него.

## ПОВЕДЕНЧЕСКИЕ ПАТТЕРНЫ

- Цепочка обязанностей (Chain of responsibility) - Предназначен для организации
  в системе уровней ответственности.
- Команда (Command) - Представляет действие. Объект команды заключает в себе
  само действие и его параметры.
- Интерпретатор (Interpreter) - Решает часто встречающуюся, но подверженную
  изменениям, задачу.
- Итератор (Iterator) - Представляет собой объект, позволяющий получить
  последовательный доступ к элементам объекта-агрегата без использования
  описаний каждого из объектов, входящих в состав агрегации.
- Посредник (Mediator) - Обеспечивает взаимодействие множества объектов,
  формируя при этом слабую связанность и избавляя объекты от необходимости явно
  ссылаться друг на друга.
- Хранитель (Memento) - Позволяет, не нарушая инкапсуляцию зафиксировать и
  сохранить внутренние состояния объекта так, чтобы позднее восстановить его в
  этих состояниях.
- Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между
  объектами таким образом, что при изменении состояния одного объекта все
  зависящие от него оповещаются об этом событии.
- Состояние (State) - Используется в тех случаях, когда во время выполнения
  программы объект должен менять своё поведение в зависимости от своего
  состояния.
- Стратегия (Strategy) - Предназначен для определения семейства алгоритмов,
  инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
- Шаблонный метод (Template method) - Определяет основу алгоритма и позволяет
  наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру
  в целом.
- Посетитель (Visitor) - Описывает операцию, которая выполняется над объектами
  других классов. При изменении класса Visitor нет необходимости изменять
  обслуживаемые

**Примечание**

В Java-разработке существует множество шаблонов проектирования (design
patterns), которые помогают решать распространенные проблемы проектирования и
архитектуры. Вот некоторые из самых популярных шаблонов:

1. Создающие шаблоны (Creational Patterns)
   Singleton: Обеспечивает создание единственного экземпляра класса и
   предоставляет глобальную точку доступа к этому экземпляру.

Factory Method: Определяет интерфейс для создания объектов, но позволяет
подклассам изменять тип создаваемых объектов.

Abstract Factory: Предоставляет интерфейс для создания семейств связанных или
зависимых объектов без указания их конкретных классов.

Builder: Позволяет создавать сложные объекты поэтапно, отделяя конструирование
от представления.

Prototype: Позволяет копировать существующие объекты без необходимости их
создания заново.

2. Структурные шаблоны (Structural Patterns)
   Adapter: Позволяет объектам с несовместимыми интерфейсами работать вместе,
   преобразуя интерфейс одного класса в интерфейс, ожидаемый клиентом.

Decorator: Позволяет добавлять новые функциональные возможности объектам
динамически, оборачивая их в классы-декораторы.

Facade: Предоставляет упрощенный интерфейс к сложной системе классов, скрывая ее
сложность.

Composite: Позволяет объединять объекты в древовидные структуры для
представления иерархий "часть-целое".

Proxy: Создает суррогат или заместитель для другого объекта, чтобы
контролировать доступ к нему.

3. Поведенческие шаблоны (Behavioral Patterns)
   Observer: Определяет зависимость "один ко многим" между объектами, так что
   при изменении состояния одного объекта все его зависимые уведомляются и
   обновляются автоматически.

Strategy: Определяет семейство алгоритмов, инкапсулирует каждый из них и делает
их взаимозаменяемыми. Позволяет изменять алгоритмы независимо от клиентов,
которые их используют.

Command: Инкапсулирует запрос как объект, позволяя параметризовать клиентов с
различными запросами, ставить запросы в очередь или логировать их.

State: Позволяет объекту изменять свое поведение при изменении его внутреннего
состояния. Объект будет казаться изменившим свой класс.

Chain of Responsibility: Позволяет передавать запросы по цепочке обработчиков.
Каждый обработчик решает, обрабатывать ли запрос или передать его следующему
обработчику в цепи.

Эти шаблоны проектирования помогают разработчикам создавать более гибкие и
поддерживаемые приложения. Знание и умение применять эти паттерны может
значительно улучшить качество кода и архитектуру программного обеспечения.