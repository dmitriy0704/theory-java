# Наблюдатель (Observer)

- это поведенческий паттерн
  проектирования, который создаёт механизм подписки,
  позволяющий одним объектам следить и реагировать на
  события, происходящие в других объектах.

При этом наблюдатели могут свободно подписываться и отписываться от этих
оповещений.

Применимость: Наблюдатель можно часто встретить в Java коде, особенно там, где
применяется событийная модель отношений между компонентами. Наблюдатель
позволяет отдельным компонентам реагировать на события, происходящие в других
компонентах.

Примеры Наблюдателя в стандартных библиотеках Java:

java.util.Observer/java.util.Observable (редко используется в реальной жизни)
Все реализации java.util.EventListener (практически во всём Swing-е)
javax.servlet.http.HttpSessionBindingListener
javax.servlet.http.HttpSessionAttributeListener
javax.faces.event.PhaseListener

Признаки применения паттерна: Наблюдатель можно определить по механизму подписки
и методам оповещения, которые вызывают компоненты программы.

## Структура

[design_patterns](/img/design_pattern/design_patterns)

1. Издатель владеетвнутреннимсостоянием,изменениекото-
   рого интересно отслеживать подписчикам. Издатель содер-
   жит механизм подписки: список подписчиков и методы
   подписки/отписки.
2. Когда внутреннее состояние издателя меняется, он опове-
   щает своих подписчиков. Для этого издатель проходит по
   списку подписчиков и вызывает их метод оповещения,
   заданный в общем интерфейсеподписчиков.
3. Подписчик определяет интерфейс, которым пользуется
   издательдляотправкиоповещения.Вбольшинствеслучаев
   для этого достаточно единственногометода.
4. Конкретные подписчики выполняют что-то в ответ на опо-
   вещение, пришедшее от издателя. Эти классы должны
   сле-доватьобщемуинтерфейсуподписчиков,чтобыиздательне
   зависел от конкретных классовподписчиков.
5. Поприходуоповещенияподписчикунужнополучитьобнов-
   лённое состояние издателя. Издатель может передать это
   состояниечерезпараметрыметодаоповещения.Болеегиб-
   кий вариант — передавать через параметры весь объект
   издателя, чтобы подписчик мог сам получить требуемые
   данные. Как вариант, подписчик может постоянно хранить
   ссылку на объект издателя, переданный ему вконструкторе.
6. Клиент создаёт объекты издателей и подписчиков, а затем
   регистрирует подписчиков на обновления виздателях.

## Пример кода

ВэтомпримереНаблюдатель позволяетобъектутекстового
редактораоповещатьдругиеобъектыобизмененияхсвоего
состояния.

![observer_example.png](/img/design_pattern/design_patterns/observer_example.png)

Пример оповещения объектов о событиях в других объектах.

Список подписчиков составляется динамически, объекты
могут как подписываться на определённые события, так и
отписываться от них прямо во время выполнения
программы.

В этой реализации редактор не ведёт список подписчиков
самостоятельно, а делегирует это вложенному объекту. Это
даёт возможность использовать механизм подписки не
только в классе редактора, но и в других классах
программы.

Длядобавлениявпрограммуновыхподписчиковненужно
менятьклассыиздателей,покаониработаютсподписчика-
ми через общийинтерфейс.

В этом примере Наблюдатель используется для передачи событий между объектами
текстового редактора. Всякий раз когда объект редактора меняет своё состояние,
он оповещает своих наблюдателей. Объекты EmailNotificationListener и
LogOpenListener следят за этими уведомлениями и выполняют полезную работу в
ответ.

Классы подписчиков не связаны с классом редактора и могут быть повторно
использованы в других приложениях если потребуется. Класс Editor зависит только
от общего интерфейса подписчиков. Это позволяет добавлять новые типы подписчиков
не меняя существующего кода редактора.

```java
//->  publisher
//->  publisher/EventManager.java: Базовый издатель

/**
 * Базовый класс-издатель. Содержит код управления подписчиками и их оповещения.
 */
public class EventManager {
    Map<String, List<EventListener>> listeners = new HashMap<>();

    public EventManager(String... operations) {
        for (String operation : operations) {
            this.listeners.put(operation, new ArrayList<>());
        }
    }

    public void subscribe(String eventType, EventListener listener) {
        List<EventListener> users = listeners.get(eventType);
        users.add(listener);
    }

    public void unsubscribe(String eventType, EventListener listener) {
        List<EventListener> users = listeners.get(eventType);
        users.remove(listener);
    }

    public void notify(String eventType, File file) {
        List<EventListener> users = listeners.get(eventType);
        for (EventListener listener : users) {
            listener.update(eventType, file);
        }
    }
}


//-> editor
//->  editor/Editor.java: Конкретный издатель, изменение которого хотят отслеживать наблюдатели

/**
 *  Конкретный класс-издатель, содержащий интересную для других компонентов 
 *  бизнес-логику. Мы могли бы сделать его прямым потомком EventManager, 
 *  но в реальной жизни это не всегда возможно (например, если у класса 
 *  уже есть родитель). Поэтому здесь мы подключаем механизм подписки при 
 *  помощи композиции.
 */

public class Editor {
    public EventManager events;
    private File file;

    public Editor() {
        this.events = new EventManager("open", "save");
    }

    /**
     *  Методы бизнес-логики, которые оповещают подписчиков об изменениях.
     */
    public void openFile(String filePath) {
        this.file = new File(filePath);
        events.notify("open", file);
    }

    public void saveFile() throws Exception {
        if (this.file != null) {
            events.notify("save", file);
        } else {
            throw new Exception("Please open a file first.");
        }
    }
}


//-> listeners
//-> listeners/EventListener.java: Интерфейс подписчиков

/**
 * Общий интерфейс подписчиков. Во многих языках, поддерживающих 
 * функциональные типы, можно обойтись без этого интерфейса и конкретных
 * классов, заменив объекты подписчиков функциями.
 */

public interface EventListener {
    void update(String eventType, File file);
}

//-> listeners/EmailNotificationListener.java: Слушатель, рассылающий email-уведомления

/**
 * Набор конкретных подписчиков. Они реализуют добавочную функциональность,
 * реагируя на извещения от издателя.
 */

public class EmailNotificationListener implements EventListener {
    private String email;

    public EmailNotificationListener(String email) {
        this.email = email;
    }

    @Override
    public void update(String eventType, File file) {
        System.out.println("Email to " + email + ": Someone has performed " + eventType + " operation with the following file: " + file.getName());
    }
}

//-> listeners/LogOpenListener.java: Слушатель, записывающий лог операций

public class LogOpenListener implements EventListener {
    private File log;

    public LogOpenListener(String fileName) {
        this.log = new File(fileName);
    }

    @Override
    public void update(String eventType, File file) {
        System.out.println("Save to log " + log + ": Someone has performed " + eventType + " operation with the following file: " + file.getName());
    }
}

//-> Demo.java: Клиентский код

public class Demo {
    public static void main(String[] args) {
        Editor editor = new Editor();
        editor.events.subscribe("open", new LogOpenListener("/path/to/log/file.txt"));
        editor.events.subscribe("save", new EmailNotificationListener("admin@example.com"));

        try {
            editor.openFile("test.txt");
            editor.saveFile();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

## Шаги реализации

1. Разбейтевашуфункциональностьнадвечасти:независимое
   ядро и опциональные зависимые части. Независимое ядро
   станет издателем. Зависимые части станутподписчиками.
2. Создайтеинтерфейсподписчиков.Обычновнёмдостаточно
   определить единственный методоповещения.
3. Создайте интерфейс издателей и опишите в нём операции
   управленияподпиской.Помните,чтоиздательдолженрабо-
   тать только с общим интерфейсомподписчиков.
4. Вам нужно решить, куда поместить код ведения подписки,
   ведьонобычнобываетодинаковдлявсехтиповиздателей.
   Самыйочевидныйспособ—вынестиэтоткодвпромежуточ-
   ныйабстрактныйкласс,откоторогобудутнаследоватьсявсе
   издатели.
   Но если вы интегрируете паттерн в существующие классы,
   то создать новый базовый класс может быть затруднитель-
   но. В этом случае вы можете поместить логику подписки
   во вспомогательный объект и делегировать ему работу из
   издателей.
5. Создайте классы конкретных издателей. Реализуйте их так,
   чтобы после каждого изменения состояния они отправляли
   оповещения всем своимподписчикам.
6. Реализуйте метод оповещения в конкретных подписчиках.
   Незабудьтепредусмотретьпараметры,черезкоторыеизда-
   тель мог бы отправлять какие-то данные, связанные с про-
   исшедшимсобытием.
   Возможенидругойвариант,когдаподписчик,получивопо-
   вещение,самвозьмётизобъектаиздателянужныеданные.
   Но в этом случае вы будете вынуждены привязать класс
   подписчика к конкретному классуиздателя.
7. Клиентдолженсоздаватьнеобходимоеколичествообъектов
   подписчиков и подписывать их уиздателей.