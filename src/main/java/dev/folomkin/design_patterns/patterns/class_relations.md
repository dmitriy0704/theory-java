# ОТНОШЕНИЯ КЛАССОВ

- Зависимость: Класс А могут затронуть изменения в классе B.
  • Ассоциация: Объект А знает об объекте B. Класс А зависит от B.
  • Агрегация: Объект А знает об объекте B и состоит из него. Класс А зависит от
  B.
  • Композиция: Объект А знает об объекте B, состоит из него и управляет его
  жизненным циклом. Класс А зависит от B.
- Реализация: Класс А определяет методы объявленные интерфейсом B. Объекты А
  можно рассматривать через интерфейс B. Класс А зависит от B.
  • Наследование: Класс А наследует интерфейс и реализацию
  класса B, но может переопределить её. Объекты А можно
  рассматривать через интерфейс класса B. Класс А зависит от B.

![relations.png](/img/design_pattern/class_relations/relations.png)

## Зависимость(dependency)

![dependency.png](/img/design_pattern/class_relations/dependency.png)

Профессор зависит от курса

Зависимость — это базовая связь между классами, которая показывает, что один
класс скорее всего придётся менять при изменении названия или сигнатуры методов
второго. Зависимость появляется там, где вы указываете конкретные названия
классов — в вызовах конструкторов, при указании типов параметров и возвращаемых
значений методов и так далее. Степень зависимости можно ослабить, если вместо
конкретных классов ссылаться на абстрактные классы или интерфейсы.

Класс реализует интерфейс. Зависимость (dependency) — изменение в одной
сущности (независимой) может влиять на состояние или поведение другой сущности (
зависимой). Со стороны стрелки указывается независимая сущность.

## IS-A отношения(наследование)

Наследование классов или реализация интерфейсов.

![generalization.png](/img/design_pattern/class_relations/is-a-relations.png)

Например, если класс HeavyBox наследует Box, мы говорим, что HeavyBox является
Box (HeavyBox IS-A Box):

<img src="/img/design_pattern/class_relations/is-a-example.png" alt="is-a-example" width="200"/> 

```java
class Box {
    private double width;
    private double height;
    private double depth;
    //…
}

class HeavyBox extends Box {
    private int weight;
    //…
}
```

## HAS-A отношения

HAS-A отношения основаны на использовании.

Например, класс Car содержит переменную типа Engine:

<img src="/img/design_pattern/class_relations/has-a-exemple.png" width="200" alt="has-a-example">

Отношение "является частью"("HAS A") описывает принадлежность объекта к другому
как его части, например, клавиатура часть компьютера. Отношения HAS A можно
описать в коде, используя механизмы композиции и агрегирования. Разница между
ними заключается в «строгости» этих связей.

```java
class Car {
    Engine engine;
    //…
}

class Engine {
    //…
}
```

_Если объект A является частью объекта B то, B содержит поле A._

Три вида связи:

- ассоциация;
- агрегация;
- композиция

### Ассоциация

_**Ассоциация**_ означает, что объекты двух классов могут ссылаться один на
другой, иметь некоторую связь между друг другом. Например, Менеджер может
выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом.
Еще пример — Преподаватель и Студент - т.е. какой-то Студент учится у какого-то
Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент
учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны
между собой и это надо как-то описать.

<img src="/img/design_pattern/class_relations/association.png" alt="association" width="200">

```java
class Person {
    private String name;
    private Car car;
    // …
}

class Car {
    // …
}
```

Если один класс имеет поле-ссылку на другой класс, вы можете отобразить эту
связь ассоциацией. Эта связь постоянна, один объект всегда может достучаться до
второго через это поле. Причём, роль поля может отыгрывать и метод, который
возвращает объекты определённого класса.

<img src="/img/design_pattern/class_relations/association-example.png" alt="association" width="200">

Агрегация и композиция являются частными случаями ассоциации. Агрегация -
отношение когда один объект является частью другого. А композиция - еще более
тесная связь, когда объект не только является частью другого объекта, но и
вообще не может принадлежать другому объекту.

### Агрегация

![aggregation.png](/img/design_pattern/class_relations/aggregation.png)

Агрегация — это специализированная разновидность ассо- циации, которая
описывает отношения один-ко-многим, многие-ко-многим, часть-целое между
несколькими объектами, тогда как ассоциация устанавливает связь только между
двумя объектами.

Обычно при агрегации один объект содержит другие, то есть
выступает контейнером или коллекцией. Здесь контейнер не
управляет жизненным циклом компонентов и компоненты
вполне могут существовать отдельно от контейнера. В UML
агрегация обозначается линией со стрелкой на одном конце
и пустым ромбом на другом конце. Ромб направлен в сторону контейнера, а
стрелка — в сторону включаемого объекта.

Объект класса Keyboard создается извне PC и передается в конструктор для
установления связи. Если объект класса PC будет удален, объект класса Keyboard
может и дальше использоваться, если, конечно, на него останется ссылка:

<img src="/img/design_pattern/class_relations/agregation-example.png" alt="agregation" width="200">

```java
public class PC {
    private Keyboard keyboard;

    public PC(Keyboard keyboard) {
        this.keyboard = keyboard;
    }
}
```

### Композиция

![composition.png](/img/design_pattern/class_relations/composition.png)

**_Композиция_** — еще более «жесткое отношение, когда объект не только является
частью другого объекта, но и вообще не может принадлежать еще кому-то. Например,
Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет
быть в двух или трех машинах одновременно. В отличие от студента, который может
входить и в другие группы тоже. Такие описания всегда несколько условны, но тем
не менее.

Объект класса Keyboard создается в конструкторе, что означает более тесную связь
между объектами. Объект класса Keyboard не может существовать без создавшего его
объекта PC:

<img src="/img/design_pattern/class_relations/compositon-example.png" alt="composition" width="200">

```java
public class PC {
    private Keyboard keyboard;

    public PC() {
        this.keyboard = new Keyboard();
    }
}
```