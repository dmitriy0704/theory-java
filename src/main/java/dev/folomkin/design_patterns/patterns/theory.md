# Паттерны проектирования

## ОТНОШЕНИЯ КЛАССОВ

![i1.png](/img/design_pattern/class_relations/i1.png)

Агрегация (aggregation) — описывает связь «часть»–«целое», в котором «часть»
может существовать отдельно от «целого». Ромб указывается со стороны «целого».

![i1.png](/img/design_pattern/class_relations/i2.png)

Композиция (composition) — подвид агрегации, в которой «части» не могут
существовать отдельно от «целого».

![i1.png](/img/design_pattern/class_relations/i3.png)

Зависимость (dependency) — изменение в одной сущности (независимой) может влиять
на состояние или поведение другой сущности (зависимой). Со стороны стрелки
указывается независимая сущность.

![i1.png](/img/design_pattern/class_relations/i4.png)

Обобщение (generalization) — отношение наследования или реализации интерфейса.
Со стороны стрелки находится суперкласс или интерфейс.

## Виды отношений:

### IS-A - Является

В ООП принцип IS-A основан на наследовании классов или реализации интерфейсов.
Sedan is a Car

### HAS-A отношения

HAS-A отношения основаны на использовании. Выделяют три варианта отношения
HAS-A: **ассоциация**, **агрегация** и **композиция**.

#### АССОЦИАЦИЯ

Ассоциация означает, что объекты двух классов могут ссылаться один на другой,
иметь некоторую связь между друг другом. Например Менеджер может выписать Счет.
Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример —
Преподаватель и Студент — т.е. какой-то Студент учится у какого-то
Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент
учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны
между собой и это надо как-то описать.  
В этих отношениях объекты двух классов могут ссылаться друг на друга. Например,
класс Horse HAS-A Halter если код в классе Horse содержит ссылку на экземпляр
класса Halter:

```java
public class Halter {
}

public class Horse {
    private Halter halter;
}
```

Агрегация и композиция являются частными случаями ассоциации. Агрегация -
отношение когда один объект является частью другого. А композиция - еще более
тесная связь, когда объект не только является частью другого объекта, но и
вообще не может принадлежать другому объекту. Разница будет понятна при
рассмотрении реализации этих отношений.

#### АГРЕГАЦИЯ и КОМПОЗИЦИЯ

**Агрегация** - отношение когда один объект является частью другого. Например,
Студент входит в Группу любителей физики.

**Композиция** — еще более «жесткое отношение, когда объект не только является
частью другого объекта, но и вообще не может принадлежать еще кому-то. Например,
Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет
быть в двух или трех машинах одновременно. В отличии от студента, который может
входить и в другие группы тоже. Такие описания всегда несколько условны, но тем
не менее.

В одном классе делается ссылка на другой и наоборот (не всегда). Дальше идет
развитие данной идеи в зависимости например от количества связей. В машине
четыре колеса и она имеет связь со всеми — значит в машине будет ссылка на
список колес (или массив). Давайте соединим нашего робота с оператором, который
им управляет. Между ними можно установить ассоциацию через ссылки в одном классе
на другой класс. Т.е. класс Robot имеет ссылку на класс Operator и наоборот —
класс Operator имеет ссылку на класс Robot.

```java


class Robot {
    private double x = 0;
    private double y = 0;
    protected double course = 0;
    // Робот управляется оператором
    private Operator operator;

    public Robot(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // Можно узнать какой оператор управляет роботом
    public Operator getOperator() {
        return operator;
    }

    // Можно установить оператора для робота
    public void setOperator(Operator operator) {
        this.operator = operator;
    }

    public void forward(int distance) {
        x = x + distance * Math.cos(course / 180 * Math.PI);
        y = y + distance * Math.sin(course / 180 * Math.PI);
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getCourse() {
        return course;
    }

    public void setCourse(double course) {
        this.course = course;
    }

    public void printCoordinates() {
        System.out.println(x + "," + y);
    }
}


class Operator {
    private String firstName;
    private String lastName;
    // Оператор управляет конкретным роботом
    private Robot robot;

    public Operator(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    // У оператора можно спросить каким роботом он управляет
    public Robot getRobot() {
        return robot;
    }

    // Оператору можно поручить управлять роботом
    public void setRobot(Robot robot) {
        this.robot = robot;
    }
}

```

## ВИДЫ ПАТТЕРНОВ:

- **_Creational (C)_** - порождающие - заботятся о гибком создании объектов без
  внесения в программу лишних зависимостей;
- **_Structural (S)_** - структурные - показывают различные способы построения
  связей между объектами;
- **_Behavioral (B)_** - поведенческие - заботятся об эффективной коммуникации
  между объектами.;

**_Порождающие:_**

- Строитель (builder)
- Фабричный метод (factory method)
- Абстрактная фабрика (abstract factory)
- Прототип (prototype)
- Одиночка (singleton)

**_Структурные:_**

- Адаптер (adapter)
- Мост (bridge)
- Компоновщик (composite)
- Декоратор (decorator)
- Фасад (facade)
- Приспособленец (flyweight)
- Прокси (proxy)

**_Поведенческие:_**

- Хранитель (memento)
- Цепочка обязанностей (chain of responsibility)
- Наблюдатель (observer)
- Команда (command)
- Состояние (state)
- Интерпретатор (interpreter)
- Стратегия (strategy)
- Итератор (iterator)
- Шаблонный метод (template method) -
- Посетитель (visitor)
- Посредник (mediator)

## ПАТТЕРНЫ И АНТИППАТЕРНЫ

GoF и GRASP шаблоны представляют собой две различные точки зрения
на организацию классов. GRASP представляют обобщенный взгляд на организацию
самих классов и их взаимодействия вне зависимости от целевой задачи,
решаемой этими классами. GoF представляют собой рецепты решения конкретных, и
при этом достаточно узких, проблем. Тем не менее, если их использовать
совместно, то качество и удобочитаемость кода повысятся.

### ПАТТЕРНЫ GRASP (GENERAL RESPONSIBILITY ASSIGNMENT SOFTWARE PATTERNS)

### _Expert_

Все классы делятся на две большие группы: классы-носители информации,
классы, производящие действия. Классов-носителей значительно меньше, но они
играют роли отображения сущностей реального мира в системе анимирования
«неживых» сущностей и, как правило, должны быть представителями Java Beans.  
Классы-носители информации, в общем, не должны выполнять действий
по манипулированию значениями своих полей.  
При проектировании классов на первом этапе необходимо определить общий принцип
распределения обязанностей между классами проекта, а именно:
в первую очередь определить кандидатов в информационные **_эксперты_** -
классы, обладающие информацией, требуемой для выполнения функциональности
программной системы.  
Например, в подсистеме прохождения назначенного теста некоторому классу
необходимо знать число вопросов, на которые получен ответ на текущий
момент времени в процессе тестирования. Количество вопросов из теста, на которые
дан ответ, есть число созданных объектов класса Quest. Такую информацию можно
поместить в описание класса Test, но в данной ситуации это приведет к
загромождению класса. Итак, класс Test ответствен за общие характеристики теста.
Класс CurrentStateTest будет владеть информацией о текущем состоянии теста.

```java
class Test {
    private int idTest;
    private String testName;
    private int questNumber;
    private long time;
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

class CurrentStateTest {
    private int idT;
    private int idS;
    private int idCurrentQuest;
    private long timeRemain;
    private Queue<Long> idListQuest;
// конструкторы и методы
}

```

Преимущества следования шаблону Expert:

- сохранение инкапсуляции информации при назначении ответственности
  классам, которые уже обладают необходимой информацией для обеспечения своей
  функциональности;
- уклонение от новых зависимостей способствует обеспечению низкой степени
  связанности между классами (Low Coupling);
- добавление соответствующего метода или внутреннего класса способствует
  высокому зацеплению (Highly Cohesive) классов, если класс уже обладает
  информацией для обеспечения необходимой функциональности.

### _Creator_

Существует большая вероятность того, что класс станет проще, если он будет
большую часть своего жизненного цикла ссылаться на создаваемые объекты.  
После определения информационных экспертов следует определить классы,
ответственные за создание нового экземпляра некоторого класса. Следует
назначить классу B обязанность создавать экземпляры класса A, если выполняется
одно из следующих условий:

- класс В содержит или получает данные инициализации (has the initializing
  data), которые будут передаваться объектам класса А при его создании;
- класс В записывает или активно использует (records or closely uses) экземпляры
  объектов А;
- класс В агрегирует (aggregate) объекты А;
- класс В содержит (contains) объекты А;
- классы B и A относятся к одному и тому же типу, и их экземпляры составляют,
  агрегируют, содержат или напрямую используют другие экземпляры того же класса.

Если выполняется одно из указанных условий, то класс В – создатель (creator)
объектов А.

В соответствии с шаблоном необходимо найти класс, который должен отвечать за
создание нового экземпляра объекта Quest, например, агрегирующий экземпляры
объектов Quest. Поскольку объект BuildTest использует объект Quest,
согласно шаблону Creator он является кандидатом на выполнение обязанности,
связанной с созданием экземпляров объектов Quest. В этом случае обязанности
могут быть распределены следующим образом:

```java
class BuildTest {
    public void build(Queue<Quest> queue) {
        queue.add(makeQuest(параметры));
        // реализация
    }

    private Quest makeQuest() {
        // реализация
        return new Quest(параметры);
    }
}

class Test {
    private int idTest;
    private String testName;
    private int questNumber;
    private long time;
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

```

Шаблон Creator способствует низкой зависимости между классами (Low Coupling),
так как экземпляры класса, которым необходимо содержать ссылку на некоторые
объекты, должны создавать эти объекты. Если класс создает некоторый объект
самостоятельно, то тем самым он перестает быть зависимым от класса, отвечающего
за создание объектов для него.

### _Low Coupling_

Степень связанности классов определяет, насколько класс связан с другими
классами и какой информацией о других классах он обладает. При проектиро-
вании отношений между классами следует распределить обязанности таким
образом, чтобы степень связанности оставалась низкой.
Наличие классов с высокой степенью связанности нежелательно, так как:

- изменения в связанных классах приводят к локальным изменениям в данном классе;
- затрудняется понимание каждого класса в отдельности;
- усложняется повторное использование, поскольку для этого требуется
  дополнительный анализ классов, с которыми связан данный класс.

Учебный курс содержит тесты, которые состоят из вопросов. Пусть требуется
создать экземпляр класса Quest и добавить его в экземпляр класса Test.
В предметной области регистрация объекта Test выполняется объектом Course.

Далее экземпляр объекта Course должен передать сообщение makeQuest()
объекту Test. Это значит, что в текущем тесте были получены идентификаторы
всех вопросов, составляющих тест, и становится возможным создание объектов
типа Quest и наполнение собственно теста.

```java
class Test {
    // поля, методы
    public void addQuest(Quest quest) {
        // реализация
    }
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

class Course {
    public void makeTest(int id) {
        Test test = new Test(параметры);
        // реализация
        while (условие) {
            Quest quest = new Quest(параметры);
            // реализация
            test.addQuest(quest);
        }
    }
}

//// 2 вариант 

class Course {
    // Поля
    public void makeTest(int id) {
        Test test = new Test(параметры);
        // реализация
        test.createTest();
        // реализация
    }
}

class Test {
    // поля, методы
    public void createTest() {
        // реализация
        while (условия) {
            Quest quest = new Quest(параметры);
            // реализация
        }
    }
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

```

При таком распределении обязанностей предполагается, что класс Course
связан с классом Quest.

В обоих случаях предполагается, что объекту Test должно быть известно
о существовании объекта Quest.
При использовании первого способа, когда объект Quest создается объектом
Course, между этими двумя объектами добавляется новая связь, тогда как
второй способ степень связывания объектов не увеличивает. Более предпочтителен
второй способ, так как он обеспечивает низкую связываемость.
В ООП имеются некоторые стандартные способы связывания объектов A и B:

- объект A содержит атрибут, который ссылается на экземпляр объекта B;

- объект A содержит метод, который ссылается на экземпляр объекта B, что
  подразумевает использование B в качестве типа параметра, локальной переменной
  или возвращаемого значения;
- класс объекта A является подклассом объекта B;
- B является интерфейсом, а класс объекта A реализует этот интерфейс.

Шаблон Low Coupling нельзя рассматривать изолированно от других шаблонов (
Expert, Creator, High Cohesion). Не существует абсолютной меры для
определения слишком высокой степени связывания.

Преимущества следования шаблону Low Coupling:

- изменение компонентов класса мало сказывается на других классах;
- принципы работы и функции компонентов можно понять, не изучая другие
  классы.

### _High Cohesion_

С помощью этого шаблона можно обеспечить возможность управления сложностью,
распределив обязанности, поддерживать высокую степень зацепления.
Зацепление — мера специализированности класса на своих обязанностях.
При высоком зацеплении обязанности класса тесно связаны между собой,
и класс не выполняет работ непомерных объемов. Класс с низкой степенью
зацепления выполняет много разнородных действий или не связанных между
собой обязанностей.

Возникают проблемы, связанные с тем, что класс:

- труден в понимании, так как необходимо уделять внимание несвязным (
  неродственным) идеям;
- сложен в поддержке и повторном использовании из-за того, что он должен быть
  использован вместе с зависимыми классами;
- ненадежен, постоянно подвержен изменениям.

Классы со слабым зацеплением выполняют обязанности, которые можно
легко распределить между другими классами.
Пусть необходимо создать экземпляр класса Quest и связать его с заданным
тестом. Какой класс должен выполнять эту обязанность? В предметной области
сведения о вопросах на текущий момент времени при прохождении теста
записываются в объекте Course, согласно шаблону для создания экземпляра
объекта Quest можно использовать объект Course. Тогда экземпляр объекта
Course сможет отправить сообщение makeTest() объекту Test. За прохождение
теста отвечает объект Course, т. е. объект Course частично несет
ответственность за выполнение операции makeTest(). Однако если и далее возлагать
на класс Course обязанности по выполнению все новых функций, связанных
с другими системными операциями, то этот класс будет слишком перегружен
и будет обладать низкой степенью зацепления.

Этот шаблон необходимо применять при оценке эффективности каждого
проектного решения.

Виды зацепления:

1. Очень слабое зацепление. Единоличное выполнение множества разнород­
   ных операций;

```java
public class Initializer {
    public void createTCPServer(String port) {
        // реализация
    }

    public int connectToDB(URL url) {
        // реализация
    }

    public void initXMLDocument(String fileName) {
        // реализация
    }
}
```

2. Слабое зацепление. Единоличное выполнение сложной задачи из одной
   функциональной области;

```java
public class NetLogicCreator {
    public void createTCPServer() {
        // реализация
    }

    public void createTCPClient() {
        // реализация
    }

    public void createUDPServer() {
        // реализация
    }

    public void createUDPClient() {
        // реализация
    }
}
```

3. среднее зацепление. Несложные обязанности в нескольких различных
   областях, логически связанных с концепцией этого класса, но не связанных
   между собой;

```java
public class TCPServerHelper {
    public void createTCPServer() {
        // реализация
    }

    public void receiveData() {
        // реализация
    }

    public void sendData() {
        // реализация
    }

    public void compression() {
        // реализация
    }

    public void decompression() {
        // реализация
    }
}
```

4. Высокое зацепление. Среднее количество обязанностей из одной функциональной
   области при взаимодействии с другими классами.

```java
public class TCPServerCreator {
    public void createTCPServer() {
        // реализация
    }
}

public class DataTransmission {
    public void receiveData() {
        // реализация
    }

    public void sendData() {
        // реализация
    }
}

public class CodingData {
    public void compression() {
        // реализация
    }

    public void decompression() {
        // реализация
    }
}
```

### _Controller_

Одной из базовых задач при проектировании информационных систем
является определение класса, отвечающего за обработку системных событий.

При необходимости посылки внешнего события прямо объекту приложения,
которое обрабатывает это событие, как минимум один из объектов должен
содержать ссылку на другой объект, что может послужить причиной очень
негибкого дизайна, если обработчик событий зависит от типа источника событий
или источник событий зависит от типа обработчика событий.

В простейшем случае зависимость между внешним источником событий
и внутренним обработчиком событий заключается исключительно в передаче
событий. Довольно просто обеспечить необходимую степень независимости
между источником событий и обработчиком событий, используя интерфейсы.
Интерфейсов может оказаться недостаточно для обеспечения поведенческой
независимости между источником и обработчиком событий, когда отношения
между этими источником и обработчиком достаточно сложны.

Можно избежать зависимости между внешним источником событий и
внутренним обработчиком событий путем введения между ними дополнительного
объекта, который будет работать в качестве посредника при передаче событий.
Этот объект должен быть способен справляться с любыми другими сложными
аспектами взаимоотношений между объектами.

Согласно шаблону Controller, производится делегирование обязанностей
по обработке системных сообщений классу, если он:

- представляет всю организацию или всю систему в целом (внешний контроллер);
- представляет активный объект из реального мира, который может участво- вать в
  решении задачи (контроллер роли);
- представляет искусственный обработчик всех системных событий преце- дента и
  называется ПрецедентHandler (контроллер прецедента) .

Для всех системных событий в рамках одного прецедента используется один и тот же
контролер.

Controller — это класс, не относящийся к интерфейсу пользователя и отвечающий за
обработку системных событий. Использование объекта-контроллера обеспечивает
независимость между внешними источниками событий и внутренними обработчиками
событий, их типом и поведением. Выбор определяется зацеплением и связыванием.

**_Антишаблон_**: Раздутый контроллер (н-р, волшебный сервлет) выполняет
слишком много обязанностей. Признаки:

- в системе имеется единственный класс контроллера, получающий все системные
  сообщения, которых поступает слишком много (внешний или ролевой контроллер);
- контроллер имеет много полей (информации) и методов (ассоциаций),
  которые необходимо распределить между другими классами.

## АНТИШАБЛОНЫ

**Big ball of mud.** «Большой Ком Грязи» — термин для системы или просто
программы, которая не имеет хоть немного различимой архитектуры. Как правило,
включает в себя более одного антишаблона. Этим страдают системы, разработанные
людьми без подготовки в области архитектуры ПО.

**Software Bloat.** «Распухание ПО» — термин, используемый для описания
тенденций развития новейших программ в направлении использования бóльших объемов
системных ресурсов (место на диске, ОЗУ), чем предшествующие версии. В более
общем контексте применяется для описания программ, которые используют больше
ресурсов, чем необходимо.

**Yo-Yo problem.** «Проблема Йо-Йо» возникает, когда необходимо разобраться в
программе, иерархия наследования и вложенность вызовов методов которой очень
длинны и сложны. Программисту вследствие этого необходимо лавировать между
множеством различных классов и методов, чтобы контролировать поведение
программы. Термин происходит от названия игрушки йо-йо.

**Magic Button.** Возникает, когда код обработки формы сконцентрирован в одном
месте и, естественно, никак не структурирован.

**Magic Number.** Наличие в коде многократно повторяющихся одинаковых чисел или
чисел, объяснение происхождения которых отсутствует.

**Gas Factory.** «Газовый Завод» — необязательный сложный дизайн для простой
задачи.

**Analiys paralisys.** В разработке ПО «Паралич анализа» проявляет себя через
чрезвычайно длинные фазы планирования проекта, сбора необходимых для этого
артефактов, программного моделирования и дизайна, которые не имеют особого
смысла для достижения итоговой цели.

**Interface Bloat.** «Распухший Интерфейс» — термин, используемый для описания
интерфейсов, которые пытаются вместить в себя все возможные операции над
данными.

**Smoke And Mirrors.** Термин «Дым и Зеркала» используется, чтобы описать
программу либо функциональность, которая еще не существует, но выставляется за
таковую. Часто используется для демонстрации финального проекта и его
функционала.

**Improbability Factor.** «Фактор Неправдоподобия» — ситуация, при которой в
системе наблюдается некоторая проблема. Часто программисты знают о проблеме, но
им не разрешено ее исправить отчасти из-за того, что шанс всплыть наружу у этой
проблемы очень мал. Как правило (следуя закону Мерфи), она всплывает и наносит
ущерб.

**Сreeping featurism.** Используется для описания ПО, которое выставляет
напоказ вновь разработанные элементы, доводя до высокой степени ущербности по
сравнению с ними другие аспекты дизайна — простоту, компактность и отсутствие
ошибок. Как правило, существует вера в то, что каждая новая маленькая черта
информационной системы увеличит ее стоимость.

**Accidental complexity.** «Случайная сложность» — проблема в программировании,
которой легко можно было избежать. Возникает вследствие неправильного понимания
проблемы или неэффективного планирования.

**Ambiguous viewpoint.** Объектно-ориентированные модели анализа и дизайна
представляются без внесения ясности в особенности модели. Изначально эти модели
обозначаются с точки зрения визуализации структуры программы. Двусмысленные
точки зрения не поддерживают фундаментального разделения интерфейсов и деталей
представления.

**Boat anchor.** «Корабельный Якорь» — часть бесполезного компьютерного
«железа», единственное применение которого — отправить на утилизацию. Этот
термин появился в то время, когда компьютеры были больших размеров. В настоящее
время термин «Корабельный Якорь» стал означать классы и методы, которые по
различным причинам не имеют какого-либо применения в приложении и в принципе
бесполезны. Они только отвлекают внимание от действительно важного кода.

**Busy spin.** Техника, при которой процесс непрерывно проверяет изменение
некоторого состояния, например, ожидает ввода с клавиатуры или разблокировки
объекта. В результате повышается загрузка процессора, ресурсы которого можно
было бы перенаправить на исполнения другого процесса. Альтернативным
путем является использование сигналов. Большинство ОС поддерживают
погружение потока в состояние «сон» до тех пор, пока ему отправит сигнал другой
поток в результате изменения своего состояния.

**Caching Failure.** «Кэширование Ошибки» — тип программного бага (bug),
при котором приложение сохраняет (кэширует) результаты, указывающие
на ошибку даже после того, как она исправлена. Программист исправляет
ошибку, но флаг ошибки не меняет своего состояния, поэтому приложение все
еще не работает.