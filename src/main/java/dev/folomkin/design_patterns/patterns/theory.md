# Паттерны проектирования

## ОТНОШЕНИЯ КЛАССОВ

![i1.png](/img/design_pattern/class_relations/i1.png)

Агрегация (aggregation) — описывает связь «часть»–«целое», в котором «часть»
может существовать отдельно от «целого». Ромб указывается со стороны «целого».

![i1.png](/img/design_pattern/class_relations/i2.png)

Композиция (composition) — подвид агрегации, в которой «части» не могут
существовать отдельно от «целого».

![i1.png](/img/design_pattern/class_relations/i3.png)

Зависимость (dependency) — изменение в одной сущности (независимой) может влиять
на состояние или поведение другой сущности (зависимой). Со стороны стрелки
указывается независимая сущность.

![i1.png](/img/design_pattern/class_relations/i4.png)

Обобщение (generalization) — отношение наследования или реализации интерфейса.
Со стороны стрелки находится суперкласс или интерфейс.

## ВИДЫ ПАТТЕРНОВ:

- Behavioral (B) - поведенческие;
- Creational (C) - порождающие;
- Structural (S) - структурные;

**_Поведенческие:_**

- Хранитель (memento)
- Цепочка обязанностей (chain of responsibility)
- Наблюдатель (observer)
- Команда (command)
- Состояние (state)
- Интерпретатор (interpreter)
- Стратегия (strategy)
- Итератор (iterator)
- Шаблонный метод (template method) -
- Посетитель (visitor)
- Посредник (mediator)

**_Порождающие:_**

- Строитель (builder)
- Фабричный метод (factory method)
- Абстрактная фабрика (abstract factory)
- Прототип (prototype)
- Одиночка (singleton)

**_Структурные:_**

- Адаптер (adapter)
- Мост (bridge)
- Компоновщик (composite)
- Декоратор (decorator)
- Фасад (facade)
- Приспособленец (flyweight)
- Прокси (proxy)

## ПАТТЕРНЫ И АНТИППАТЕРНЫ

GoF и GRASP шаблоны представляют собой две различные точки зрения
на организацию классов. GRASP представляют обобщенный взгляд на организацию
самих классов и их взаимодействия вне зависимости от целевой задачи,
решаемой этими классами. GoF представляют собой рецепты решения конкретных, и
при этом достаточно узких, проблем. Тем не менее, если их использовать
совместно, то качество и удобочитаемость кода повысятся.

### ПАТТЕРНЫ GRASP (GENERAL RESPONSIBILITY ASSIGNMENT SOFTWARE PATTERNS)

### _Expert_

Все классы делятся на две большие группы: классы-носители информации,
классы, производящие действия. Классов-носителей значительно меньше, но они
играют роли отображения сущностей реального мира в системе анимирования
«неживых» сущностей и, как правило, должны быть представителями Java Beans.  
Классы-носители информации, в общем, не должны выполнять действий
по манипулированию значениями своих полей.  
При проектировании классов на первом этапе необходимо определить общий принцип
распределения обязанностей между классами проекта, а именно:
в первую очередь определить кандидатов в информационные **_эксперты_** -
классы, обладающие информацией, требуемой для выполнения функциональности
программной системы.  
Например, в подсистеме прохождения назначенного теста некоторому классу
необходимо знать число вопросов, на которые получен ответ на текущий
момент времени в процессе тестирования. Количество вопросов из теста, на которые
дан ответ, есть число созданных объектов класса Quest. Такую информацию можно
поместить в описание класса Test, но в данной ситуации это приведет к
загромождению класса. Итак, класс Test ответствен за общие характеристики теста.
Класс CurrentStateTest будет владеть информацией о текущем состоянии теста.

```java
class Test {
    private int idTest;
    private String testName;
    private int questNumber;
    private long time;
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

class CurrentStateTest {
    private int idT;
    private int idS;
    private int idCurrentQuest;
    private long timeRemain;
    private Queue<Long> idListQuest;
// конструкторы и методы
}

```

Преимущества следования шаблону Expert:

- сохранение инкапсуляции информации при назначении ответственности
  классам, которые уже обладают необходимой информацией для обеспечения своей
  функциональности;
- уклонение от новых зависимостей способствует обеспечению низкой степени
  связанности между классами (Low Coupling);
- добавление соответствующего метода или внутреннего класса способствует
  высокому зацеплению (Highly Cohesive) классов, если класс уже обладает
  информацией для обеспечения необходимой функциональности.

### _Creator_

Существует большая вероятность того, что класс станет проще, если он будет
большую часть своего жизненного цикла ссылаться на создаваемые объекты.  
После определения информационных экспертов следует определить классы,
ответственные за создание нового экземпляра некоторого класса. Следует
назначить классу B обязанность создавать экземпляры класса A, если выполняется
одно из следующих условий:

- класс В содержит или получает данные инициализации (has the initializing
  data), которые будут передаваться объектам класса А при его создании;
- класс В записывает или активно использует (records or closely uses) экземпляры
  объектов А;
- класс В агрегирует (aggregate) объекты А;
- класс В содержит (contains) объекты А;
- классы B и A относятся к одному и тому же типу, и их экземпляры составляют,
  агрегируют, содержат или напрямую используют другие экземпляры того же класса.

Если выполняется одно из указанных условий, то класс В – создатель (creator)
объектов А.

В соответствии с шаблоном необходимо найти класс, который должен отвечать за
создание нового экземпляра объекта Quest, например, агрегирующий экземпляры
объектов Quest. Поскольку объект BuildTest использует объект Quest,
согласно шаблону Creator он является кандидатом на выполнение обязанности,
связанной с созданием экземпляров объектов Quest. В этом случае обязанности
могут быть распределены следующим образом:

```java
class BuildTest {
    public void build(Queue<Quest> queue) {
        queue.add(makeQuest(параметры));
        // реализация
    }

    private Quest makeQuest() {
        // реализация
        return new Quest(параметры);
    }
}

class Test {
    private int idTest;
    private String testName;
    private int questNumber;
    private long time;
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

```

### _Low Coupling_

