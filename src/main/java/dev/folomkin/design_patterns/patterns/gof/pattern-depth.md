# Паттерны проектирования

## ОТНОШЕНИЯ КЛАССОВ

![i1.png](/img/design_pattern/class_relations/i1.png)

Агрегация (aggregation) — описывает связь «часть»–«целое», в котором «часть»
может существовать отдельно от «целого». Ромб указывается со стороны «целого».

![i1.png](/img/design_pattern/class_relations/i2.png)

HAS-A. Композиция (composition) — подвид агрегации, в которой «части» не могут
существовать отдельно от «целого».

![i1.png](/img/design_pattern/class_relations/i3.png)

Класс реализует интерфейс. Зависимость (dependency) — изменение в одной
сущности (независимой) может влиять
на состояние или поведение другой сущности (зависимой). Со стороны стрелки
указывается независимая сущность.

![i1.png](/img/design_pattern/class_relations/i4.png)

Обобщение (generalization) — отношение наследования или реализации интерфейса.
Со стороны стрелки находится суперкласс или интерфейс.

### IS-A отношения

Наследование описывает связь "является" (IS A). Лев является животным. Animal
будет родительским классом для Lion.

### HAS-A отношения

Отношение "является частью"("HAS A") описывает принадлежность объекта к другому
как его части, например, клавиатура часть компьютера. Отношения HAS A можно
описать в коде, используя механизмы композиции и агрегирования. Разница между
ними заключается в «строгости» этих связей.

_Если объект A является частью объекта B то, B содержит поле A._

Три вида связи:

- ассоциация;
- агрегация;
- композиция

_**Ассоциация**_ означает, что объекты двух классов могут ссылаться один на
другой,
иметь некоторую связь между друг другом. Например, Менеджер может выписать Счет.
Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример —
Преподаватель и Студент - т.е. какой-то Студент учится у какого-то
Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент
учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны
между собой и это надо как-то описать.

Агрегация и композиция - частные случаи ассоциации. Это более конкретизированные
отношения между объектами.

**_Агрегация_** — отношение когда один объект является частью другого. Например
Студент входит в Группу любителей физики.
Car — машина. У каждой машины есть
двигатель. Кроме того, у каждой машины есть пассажиры внутри.
В чем же принципиальная разница между полями Engine engine и Passenger[]
passengers? Если у машины внутри сидит пассажир А, это не значит, что в ней не
могут находиться пассажиры B и C. Одна машина может соответствовать нескольким
пассажирам. Кроме того, если всех пассажиров высадить из машины, она продолжит
спокойно функционировать. Связь между классом Car и массивом пассажиров
Passenger[] passengers менее строгая. Она называется _**агрегацией**_. Еще один
хороший пример агрегации. Допустим, у нас есть класс Student, обозначающий
студента, и класс StudentsGroup (группа студентов). Студент может входить и в
клуб любителей физики, и в студенческий фан-клуб «Звездных войн» или команду
КВН.

**_Композиция_** — еще более «жесткое отношение, когда объект не только является
частью другого объекта, но и вообще не может принадлежать еще кому-то. Например
Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет
быть в двух или трех машинах одновременно. В отличие от студента, который может
входить и в другие группы тоже. Такие описания всегда несколько условны, но тем
не менее.

```java
package dev.folomkin.core.oop.oop;

class Robot {
    private double x = 0;
    private double y = 0;
    protected double course = 0;
    // Робот управляется оператором
    private Operator operator;

    public Robot(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // Можно узнать какой оператор управляет роботом
    public Operator getOperator() {
        return operator;
    }

    // Можно установить оператора для робота
    public void setOperator(Operator operator) {
        this.operator = operator;
    }

    public void forward(int distance) {
        x = x + distance * Math.cos(course / 180 * Math.PI);
        y = y + distance * Math.sin(course / 180 * Math.PI);
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getCourse() {
        return course;
    }

    public void setCourse(double course) {
        this.course = course;
    }

    public void printCoordinates() {
        System.out.println(x + "," + y);
    }
}

class Operator {
    private String firstName;
    private String lastName;
    // Оператор управляет конкретным роботом
    private Robot robot;

    public Operator(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    // У оператора можно спросить каким роботом он управляет
    public Robot getRobot() {
        return robot;
    }

    // Оператору можно поручить управлять роботом
    public void setRobot(Robot robot) {
        this.robot = robot;
    }
}

```

## ВИДЫ ПАТТЕРНОВ:

- Behavioral (B) - поведенческие;
- Creational (C) - порождающие;
- Structural (S) - структурные;

**_Поведенческие (behavioral):_**

- Хранитель (memento)
- Цепочка обязанностей (chain of responsibility)
- Наблюдатель (observer)
- Команда (command)
- Состояние (state)
- Интерпретатор (interpreter)
- Стратегия (strategy)
- Итератор (iterator)
- Шаблонный метод (template method) -
- Посетитель (visitor)
- Посредник (mediator)

**_Порождающие (creational):_**

- Строитель (builder)
- Фабричный метод (factory method)
- Абстрактная фабрика (abstract factory)
- Прототип (prototype)
- Одиночка (singleton)

**_Структурные (structural):_**

- Адаптер (adapter)
- Мост (bridge)
- Компоновщик (composite)
- Декоратор (decorator)
- Фасад (facade)
- Приспособленец (flyweight)
- Прокси (proxy)

## ПАТТЕРНЫ И АНТИППАТЕРНЫ

GoF и GRASP шаблоны представляют собой две различные точки зрения
на организацию классов. GRASP представляют обобщенный взгляд на организацию
самих классов и их взаимодействия вне зависимости от целевой задачи,
решаемой этими классами. GoF представляют собой рецепты решения конкретных, и
при этом достаточно узких, проблем. Тем не менее, если их использовать
совместно, то качество и удобочитаемость кода повысятся.

## ПОРОЖДАЮЩИЕ ШАБЛОНЫ

Шаблоны проектирования GoF — это многократно используемые решения широко
распространенных проблем, возникающих при разработке программного обеспечения.
Многие разработчики искали пути повышения гибкости и степени повторного
использования своих программ. Найденные решения воплощены в краткой и легко
применимой на практике форме.

В общем случае шаблон состоит из четырех основных элементов:

1) имя. Точное имя предоставляет возможность сразу понять проблему и определить
   решение. Уровень абстракции при проектировании повышается;
2) задача. Область применения в рамках решения конкретной проблемы;
3) решение. Абстрактное описание элементов дизайна задачи проектирования
   и способа ее решения с помощью обобщенного набора классов;
4) результаты.

Порождающие шаблоны предназначаются для организации процесса создания объектов и
все до единого соответствуют шаблону Creator из GRASP.



