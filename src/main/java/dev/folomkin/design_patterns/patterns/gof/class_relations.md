# Паттерны проектирования

## ОТНОШЕНИЯ КЛАССОВ

### Зависимость(dependency)

![dependency.png](/img/design_pattern/class_relations/dependency.png)

Профессор зависит от курса

Зависимость — это базовая связь между классами, которая показывает, что один
класс скорее всего придётся менять при изменении названия или сигнатуры методов
второго. Зависимость появляется там, где вы указываете конкретные названия
классов — в вызовах конструкторов, при указании типов параметров и возвращаемых
значений методов и так далее. Степень зависимости можно ослабить, если вместо
конкретных классов ссылаться на абстрактные классы или интерфейсы.

Класс реализует интерфейс. Зависимость (dependency) — изменение в одной
сущности (независимой) может влиять на состояние или поведение другой сущности (
зависимой). Со стороны стрелки указывается независимая сущность.

### IS-A отношения(наследование)

Наследование описывает связь "является" (IS A). Лев является животным. Animal
будет родительским классом для Lion. Класс наследуется от другого класса или
класс реализует интерфейс.

![generalization.png](/img/design_pattern/class_relations/generalization.png)

Обобщение (generalization) — отношение наследования или реализации интерфейса.
Со стороны стрелки находится суперкласс или интерфейс.

### HAS-A отношения

Отношение "является частью"("HAS A") описывает принадлежность объекта к другому
как его части, например, клавиатура часть компьютера. Отношения HAS A можно
описать в коде, используя механизмы композиции и агрегирования. Разница между
ними заключается в «строгости» этих связей.

_Если объект A является частью объекта B то, B содержит поле A._

Три вида связи:

- ассоциация;
- агрегация;
- композиция

#### Ассоциация

_**Ассоциация**_ означает, что объекты двух классов могут ссылаться один на
другой, иметь некоторую связь между друг другом. Например, Менеджер может
выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом.
Еще пример — Преподаватель и Студент - т.е. какой-то Студент учится у какого-то
Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент
учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны
между собой и это надо как-то описать.

Агрегация и композиция - частные случаи ассоциации. Это более конкретизированные
отношения между объектами.

```java
class Person {
    private String name;
    private Car car;
    // …
}

class Car {
    // …
}
```


#### Агрегация

![aggregation.png](/img/design_pattern/class_relations/aggregation.png)

**_Агрегация_** — отношение когда один объект является частью другого. Например,
Студент входит в Группу любителей физики. Car — машина. У каждой машины есть
двигатель. Кроме того, у каждой машины есть пассажиры внутри.
В чем же принципиальная разница между полями Engine engine и Passenger[]
passengers? Если у машины внутри сидит пассажир А, это не значит, что в ней не
могут находиться пассажиры B и C. Одна машина может соответствовать нескольким
пассажирам. Кроме того, если всех пассажиров высадить из машины, она продолжит
спокойно функционировать. Связь между классом Car и массивом пассажиров
Passenger[] passengers менее строгая. Она называется _**агрегацией**_. Еще один
хороший пример агрегации. Допустим, у нас есть класс Student, обозначающий
студента, и класс StudentsGroup (группа студентов). Студент может входить и в
клуб любителей физики, и в студенческий фан-клуб «Звездных войн» или команду
КВН.

#### Композиция

![composition.png](/img/design_pattern/class_relations/composition.png)

**_Композиция_** — еще более «жесткое отношение, когда объект не только является
частью другого объекта, но и вообще не может принадлежать еще кому-то. Например,
Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет
быть в двух или трех машинах одновременно. В отличие от студента, который может
входить и в другие группы тоже. Такие описания всегда несколько условны, но тем
не менее.

**Примеры кода:**

```java

class Robot {
    private double x = 0;
    private double y = 0;
    protected double course = 0;
    // Робот управляется оператором
    private Operator operator;

    public Robot(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // Можно узнать какой оператор управляет роботом
    public Operator getOperator() {
        return operator;
    }

    // Можно установить оператора для робота
    public void setOperator(Operator operator) {
        this.operator = operator;
    }

    public void forward(int distance) {
        x = x + distance * Math.cos(course / 180 * Math.PI);
        y = y + distance * Math.sin(course / 180 * Math.PI);
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getCourse() {
        return course;
    }

    public void setCourse(double course) {
        this.course = course;
    }

    public void printCoordinates() {
        System.out.println(x + "," + y);
    }
}

class Operator {
    private String firstName;
    private String lastName;
    // Оператор управляет конкретным роботом
    private Robot robot;

    public Operator(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    // У оператора можно спросить каким роботом он управляет
    public Robot getRobot() {
        return robot;
    }

    // Оператору можно поручить управлять роботом
    public void setRobot(Robot robot) {
        this.robot = robot;
    }
}

```
