# Паттерны проектирования

**_Шаблон_** (паттерн) проектирования (design pattern) — это проверенное и
готовое к использованию решение. Это не класс и не библиотека, которую можно
подключить к проекту, это нечто большее - он не зависит от языка
программирования, не является законченным образцом, который может быть прямо
преобразован в код и может быть реализован по-разному в разных языках
программирования.

## ВИДЫ ПАТТЕРНОВ:

- **_Structural_** - структурные - показывают различные способы построения
  связей между объектами;
  - Адаптер
  - S — Декоратор  
  - S — Мост 
  - S — Компоновщик  
  - S — Фасад  
  - S — Приспособленец
  - S — Прокси
  - S — Наблюдатель


- **_Behavioral (B)_** - поведенческие - заботятся об эффективной коммуникации
  между объектами;
  - Цепочка обязанностей  
  - Команда  
  - Интерпретатор  
  - Итератор  
  - Посредник  
  - Хранитель  
  - Состояние  
  - Стратегия  
  - Шаблонный метод
  - Посетитель

- **_Creational (C)_** - порождающие - заботятся о гибком создании объектов без
  внесения в программу лишних зависимостей;
  - Абстрактная фабрика
  - Строитель
  - Фабричный метод
  - Прототип
  - Одиночка


## ПОРОЖДАЮЩИЕ ПАТТЕРНЫ

- Абстрактная фабрика (Abstract factory) - Класс, который представляет собой
  интерфейс для создания других классов.
- Строитель (Builder) - Класс, который представляет собой интерфейс для создания
  сложного объекта.
- Фабричный метод (Factory method) - Делегирует создание объектов наследникам
  родительского класса. Это позволяет использовать в коде программы не
  специфические классы, а манипулировать абстрактными объектами на более высоком
  уровне.
- Прототип (Prototype) - Определяет интерфейс создания объекта через
  клонирование другого объекта вместо создания через конструктор.
- Одиночка (Singleton) - Класс, который может иметь только один экземпляр.

## СТРУКТУРНЫЕ ПАТТЕРНЫ

- Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других
  объектов, один из которых использует, а другой предоставляет несовместимый с
  первым интерфейс.
- Мост (Bridge) - Структура, позволяющая изменять интерфейс обращения и
  интерфейс реализации класса независимо.
- Компоновщик (Composite) - Объект, который объединяет в себе объекты, подобные
  ему самому.
- Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без
  использования наследования.
- Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами,
  объединяя их в единое целое.
- Приспособленец (Flyweight) - Это объект, представляющий себя как уникальный
  экземпляр в разных местах программы, но по факту не являющийся таковым.
- Заместитель (Proxy) - Объект, который является посредником между двумя другими
  объектами, и который реализует/ограничивает доступ к объекту, к которому
  обращаются через него.

## ПОВЕДЕНЧЕСКИЕ ПАТТЕРНЫ

- Цепочка обязанностей (Chain of responsibility) - Предназначен для организации
  в системе уровней ответственности.
- Команда (Command) - Представляет действие. Объект команды заключает в себе
  само действие и его параметры.
- Интерпретатор (Interpreter) - Решает часто встречающуюся, но подверженную
  изменениям, задачу.
- Итератор (Iterator) - Представляет собой объект, позволяющий получить
  последовательный доступ к элементам объекта-агрегата без использования
  описаний каждого из объектов, входящих в состав агрегации.
- Посредник (Mediator) - Обеспечивает взаимодействие множества объектов,
  формируя при этом слабую связанность и избавляя объекты от необходимости явно
  ссылаться друг на друга.
- Хранитель (Memento) - Позволяет, не нарушая инкапсуляцию зафиксировать и
  сохранить внутренние состояния объекта так, чтобы позднее восстановить его в
  этих состояниях.
- Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между
  объектами таким образом, что при изменении состояния одного объекта все
  зависящие от него оповещаются об этом событии.
- Состояние (State) - Используется в тех случаях, когда во время выполнения
  программы объект должен менять своё поведение в зависимости от своего
  состояния.
- Стратегия (Strategy) - Предназначен для определения семейства алгоритмов,
  инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
- Шаблонный метод (Template method) - Определяет основу алгоритма и позволяет
  наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру
  в целом.
- Посетитель (Visitor) - Описывает операцию, которая выполняется над объектами
  других классов. При изменении класса Visitor нет необходимости изменять
  обслуживаемые

## РАЗОБРАТЬ

### СТРУКТУРНЫЕ:

### _Адаптер (adapter)_

Адаптер (adapter) - структурный шаблон проектирования, предназначенный для
организации использования функций объекта, недоступного для модификации, через
специально созданный интерфейс. Паттерн проектирования, который позволяет
объектам с несовместимыми интерфейсами работать вместе.
![adapter.png](/img/design_pattern/design_patterns/adapter.png)

Используется для организации использования функций объекта, недоступного для
модификации, через специально созданный интерфейс. Создается дополнительный
класс, у которого есть нужный интерфейс. А этот класс уже в свою очередь
вызывает методы нужного объекта (у которого нет требуемого интерфейса).

Важно! Если в коде встретить у класса суффикс Adapter, то можно считать, что
этот класс выполняет роль адаптера и связан с группой классов, которые работают
по описанной выше схеме.

**Применяется в случаях**, когда система поддерживает требуемые данные и
поведение, но имеет неподходящий интерфейс. Чаще всего шаблон Адаптер
применяется, если необходимо создать класс, унаследованный от нового или уже
существующего абстрактного класса.

**Сильные стороны:**

- Переход на использование других внешних классов не требует переделки самой
  системы, достаточно реализовать еще один класс Adapter.
- Независимость от реализации внешних классов (классов из библиотек, чей код мы
  не можем поменять). Программа становится независимой от интерфейса внешних
  классов.

### _Декоратор_

Декоратор (decorator) - структурный шаблон проектирования, предназначенный для
динамического подключения дополнительного поведения к объекту. Шаблон Декоратор
предоставляет хорошую и гибкую альтернативу практике создания подклассов с целью
расширения функциональности.
![decorator.png](/img/design_pattern/design_patterns/decorator.png)

Используется для динамического подключения к объекту дополнительных
обязательств.

**Сильные стороны паттерна Decorator:**

Нет необходимости создавать подклассы для расширения функциональности объекта.
Возможность динамически подключать новую функциональность в любом месте: до или
после основной функциональности объекта ConcreteComponent.

### _Прокси_

Заместитель (Proxy) — структурный шаблон проектирования, предоставляющий объект,
который контролирует доступ к другому объекту, перехватывая и пропуская через
себя все его вызовы.
![proxy.png](/img/design_pattern/design_patterns/proxy.png)

Паттерн Proxy предоставляет объект-заменитель вместо настоящего объекта. Этот
объект контролирует доступ к оригинальному объекту. Используется очень часто.

В фреймворке Mockito перехватывается обращение к реальному объекту с помощью
метода Mockito.spy() или аннотации @Spy. Именно тогда и создавался специальный
Proxy-объект, через который проходили все вызовы к оригинальному объекту.

И мы тогда с помощью добавления объекту правил могли этими вызовами управлять.
Именно так – оригинальный объект не меняется, а работа с ним становится
значительно гибче. Особенно полезно бывает, когда не мы из нашего кода вызываем
proxy-объект, а передаем его куда-то. Контролируя таким образом общение двух
независимых от нас объектов.

_Виды прокси по назначению:_

Протоколирующий прокси: сохраняет в лог все вызовы “Субъекта” с их параметрами.
Удаленный заместитель (remote proxies): обеспечивает связь с “Субъектом”,
который находится в другом адресном пространстве или на удаленной машине. Также
может отвечать за кодирование запроса и его аргументов и отправку
закодированного запроса реальному “Субъекту”.
Виртуальный заместитель (virtual proxies): обеспечивает создание реального
“Субъекта” только тогда, когда он действительно понадобится. Также может
кэшировать часть информации о реальном “Субъекте”, чтобы отложить его создание.
Копировать-при-записи: обеспечивает копирование “субъекта” при выполнении
клиентом определенных действий (частный случай “виртуального прокси”).
Защищающий заместитель (protection proxies): может проверять, имеет ли
вызывающий объект необходимые для выполнения запроса права.
Кэширующий прокси: обеспечивает временное хранение результатов расчета до отдачи
их множественным клиентам, которые могут разделить эти результаты.
Экранирующий прокси: защищает “Субъект” от опасных клиентов (или наоборот).
Синхронизирующий прокси: производит синхронизированный контроль доступа к
“Субъекту” в асинхронной многопоточной среде.
“Умная” ссылка (smart reference proxy): производит дополнительные действия,
когда на “Субъект” создается ссылка, например, рассчитывает количество активных
ссылок на “Субъект”.

### _Bridge_

**Мост (bridge)** - структурный шаблон проектирования, используемый чтобы
“разделять абстракцию и реализацию так, чтобы они могли изменяться независимо”.

Шаблон мост использует инкапсуляцию, агрегирование и может использовать
наследование для того, чтобы разделить ответственность между классами.

![bridge.png](/img/design_pattern/design_patterns/bridge.png)

Когда абстракция и реализация разделены, они могут изменяться независимо.
Другими словами, при реализации через шаблон мост, изменение структуры
интерфейса не мешает изменению структуры реализации.

Рассмотрим такую абстракцию как фигура. Существует множество типов фигур, каждая
со своими свойствами и методами. Однако есть что-то, что объединяет все фигуры.
Например, каждая фигура должна уметь рисовать себя, масштабироваться и так
далее.

В то же время рисование графики может отличаться в зависимости от типа ОС или
графической библиотеки. Фигуры должны иметь возможность рисовать себя в
различных графических средах. Но реализовывать в каждой фигуре все способы
рисования или модифицировать фигуру каждый раз при изменении способа рисования
непрактично.

В этом случае помогает шаблон мост, позволяя создавать новые классы, которые
будут реализовывать рисование в различных графических средах. При использовании
такого подхода очень легко можно добавлять как новые фигуры, так и способы их
рисования.

Связь, изображаемая стрелкой на диаграммах, может иметь 2 смысла: а)
“разновидность”, в соответствии с принципом подстановки Лисков и б) одна из
возможных реализаций абстракции. Обычно в языках используется наследование для
реализации как а), так и б), что приводит к разбуханию иерархий классов.

Мост служит именно для решения этой проблемы: объекты создаются парами из
объекта класса иерархии А и иерархии B, наследование внутри иерархии А имеет
смысл “разновидность” по Лисков, а для понятия “реализация абстракции”
используется ссылка из объекта A в парный ему объект B.

### _Фасад_

Фасад (facade) - Шаблон Фасад (Facade) — структурный шаблон проектирования,
позволяющий скрыть сложность системы путем сведения всех возможных внешних
вызовов к одному объекту, делегирующему их соответствующим объектам системы.
![facade.png](/img/design_pattern/design_patterns/facade.png)

Как обеспечить унифицированный интерфейс с набором разрозненных реализаций или
интерфейсов, например, с подсистемой, если нежелательно сильное связывание с
этой подсистемой или реализация подсистемы может измениться?

Определить одну точку взаимодействия с подсистемой — фасадный объект,
обеспечивающий общий интерфейс с подсистемой, и возложить на него обязанность по
взаимодействию с ее компонентами. Фасад — это внешний объект, обеспечивающий
единственную точку входа для служб подсистемы.

Реализация других компонентов подсистемы закрыта и не видна внешним компонентам.
Фасадный объект обеспечивает реализацию GRASP паттерна Устойчивый к изменениям с
точки зрения защиты от изменений в реализации подсистемы.

Важно! Этот шаблон применяется, когда мы хотим полностью скрыть какую-то группу
объектов и всю коммуникацию с ними пропустить через наш объект. Если же вы
просто хотите обеспечить некоторый контроль процесса коммуникации объектов и
скрывать их не обязательно, то лучше воспользоваться паттерном Proxy.

Компоновщик (composite)
![16_composite.png](/img/design_pattern/design_patterns/16_composite.png)

Приспособленец (flyweight)
![22_flyweight.png](/img/design_pattern/design_patterns/22_flyweight.png)

### ПОРОЖДАЮШИЕ:

### _Одиночка_

Одиночка (singleton) - порождающий шаблон проектирования, гарантирующий, что в
однопоточном приложении будет единственный экземпляр некоторого класса, и
предоставляющий глобальную точку доступа к этому экземпляру.
![singleton.png](/img/design_pattern/design_patterns/singleton.png)

Статический класс – класс, содержащий только статические методы. У такого
подхода есть ряд минусов – например, нельзя передать ссылку на объект такого
класса, такие методы тяжело тестировать и тому подобное.

Класс, у которого может быть только один объект. При попытке создания этого
объекта он создается только в том случае, если еще не существует, в противном
случае возвращается ссылка на уже существующий экземпляр.

Существенно то, что можно пользоваться именно экземпляром класса, так как при
этом во многих случаях становится доступной более широкая функциональность.
Например, этот класс может реализовывать некоторые интерфейсы и его объект можно
передать в другие методы, как имплементацию интерфейса. Что нельзя сделать с
набором статических методов.

**_Плюсы:_**

- Методы привязаны к объекту, а не к статическому классу – можно передавать
  объект по ссылке.
- Методы объекта значительно легче тестировать и мокировать.
- Объект создается только по необходимости: отложенная инициализация объекта.
- Ускорение начального запуска программы, если есть множество одиночек, которые
  не нужны для запуска.
- Одиночку можно в дальнейшем превратить в шаблон-стратегию или несколько таких
  объектов.

**_Минусы:_**

- Усложняется контроль над межпоточными гонками и задержками.
- Многопоточного “одиночку” сложно писать “из головы”: доступ к давно
  построенному одиночке в идеале не должен открывать мьютекс. Лучше проверенные
  решения.
- Конфликт двух потоков за недостроенного одиночку приведет к задержке.
- Если объект создается долго, задержка может мешать пользователю или нарушать
  реальное время. В таком случае его создание лучше перенести в стадию
  инициализации программы.
- Требуются особые функции для модульного тестирования — например, чтобы
  перевести библиотеку в “не-одинокий” режим и полностью изолировать тесты друг
  от друга.
- Требуется особая тактика тестирования готовой программы, ведь пропадает даже
  понятие “простейшая запускаемость”, ведь запускаемость зависит от
  конфигурации.

### _Фабричный метод_

Фабричный метод (factory method) - порождающий шаблон проектирования,
предоставляющий подклассам (классам-наследникам) интерфейс для создания
экземпляров некоторого класса. В момент создания наследники могут определить,
какой класс создавать.

Иными словами, данный шаблон делегирует создание объектов наследникам
родительского класса. Это позволяет использовать в коде программы не конкретные
классы, а манипулировать абстрактными объектами на более высоком уровне.
![factory.png](/img/design_pattern/design_patterns/factory.png)

Этот паттерн определяет интерфейс для создания объекта, но оставляет подклассам
решение о том, на основании какого класса создавать объект. Фабричный метод
позволяет классу делегировать создание подклассов.

Используется, когда:

- классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
- класс спроектирован так, чтобы объекты, которые он создает, специфицировались
  подклассами.
- класс делегирует свои обязанности одному из нескольких вспомогательных
  подклассов, и планируется определить, какой класс принимает эти обязанности на
  себя.

### _Абстрактная фабрика_

Абстрактная фабрика (abstract factory) - порождающий шаблон проектирования,
предоставляет интерфейс для создания семейств взаимосвязанных или
взаимозависимых объектов, не специфицируя их конкретных классов.

Шаблон реализуется созданием абстрактного класса Factory, который представляет
собой интерфейс для создания компонентов системы (например, для оконного
интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие
этот интерфейс.
![abstract_factory.png](/img/design_pattern/design_patterns/abstract_factory.png)

Применяется в случаях, когда программа должна быть независимой от процесса и
типов создаваемых новых объектов. Когда необходимо создать семейства или группы
взаимосвязанных объектов, исключая возможность одновременного использования
объектов из разных этих наборов в одном контексте.

Сильные стороны:

- изолирует конкретные классы;
- упрощает замену семейств продуктов;
- гарантирует сочетаемость продуктов.

Допустим, твоя программа работает с файловой системой. Тогда для работы в Linux
тебе нужны объекты LinuxFile, LinuxDirectory, LinuxFileSystem. А для работы в
Windwos тебе нужны классы WindowsFile, WindowsDirectory, WindowsFileSystem.

Класс Path, который создается через Path.of(), — это как раз тот случай. Path —
это на самом деле не класс, а интерфейс и у него есть реализации WindowsPath и
LinuxPath. А какой именно объект будет создан, скрыто от твоего кода и будет
решаться во время работы программы.

### _Прототип (prototype)_

Прототип (prototype) - порождающий шаблон проектирования.
![prototype.png](/img/design_pattern/design_patterns/prototype.png)

Этот паттерн задает виды создаваемых объектов с помощью экземпляра-прототипа и
создает новые объекты путем копирования этого прототипа. Он позволяет уйти от
реализации и следовать принципу “программирование через интерфейсы”.

В качестве возвращающего типа указывается интерфейс/абстрактный класс на вершине
иерархии, а классы-наследники могут подставить туда наследника, реализующего
этот тип. Проще говоря, это паттерн создания объекта через клонирование другого
объекта вместо создания через конструктор.

Паттерн используется чтобы:

- избежать дополнительных усилий по созданию объекта стандартным путем (имеется
  в виду использование конструктора, так как в этом случае также будут вызваны
  конструкторы всей иерархии предков объекта), когда это непозволительно дорого
  для приложения.

- избежать наследования создателя объекта (object creator) в клиентском
  приложении, как это делает паттерн abstract factory.

Используй этот шаблон проектирования, когда твоей программе безразлично, как
именно в ней создаются, компонуются и представляются продукты:

- инстанцируемые классы определяются во время выполнения, например, с помощью
  динамической загрузки;
- ты хочешь избежать построения иерархий классов или фабрик, параллельных
  иерархии классов продуктов;
- экземпляры класса могут находиться в одном из нескольких различных состояний.
  Может оказаться удобнее установить соответствующее число прототипов и
  клонировать их, а не инстанцировать каждый раз класс вручную в подходящем
  состоянии.

### _Строитель (builder)_

Строитель (builder) - порождающий шаблон проектирования, который предоставляет
способ создания составного объекта.

Отделяет конструирование сложного объекта от его представления так, что в
результате одного и того же процесса конструирования могут получаться разные
представления.

![builder.png](/img/design_pattern/design_patterns/builder.png)

**_Сильные стороны:_**

- позволяет изменять внутреннее представление продукта;
- изолирует код, реализующий конструирование и представление;
- дает более тонкий контроль над процессом конструирования.

**_Слабые стороны:_**

- алгоритм создания сложного объекта не должен зависеть от того, из каких частей
  состоит объект и как они стыкуются между собой;
- процесс конструирования должен обеспечивать различные представления
  конструируемого объекта.

Хороший пример – это класс HttpRequest, у него есть подкласс
HttpRequest.Builder, с помощью которого можно создавать экземпляры класса
HttpRequest и гарантировать их валидность.

### _Lazy Initialization_

Отложенная (ленивая) инициализация (Lazy initialization) — приём в
программировании, когда некоторая ресурсоёмкая операция (создание объекта,
вычисление значения) выполняется непосредственно перед тем, как будет
использован её результат.  
Таким образом инициализация выполняется “по требованию”, а не заблаговременно.
Аналогичная идея находит применение в самых разных областях: например,
компиляция “на лету” и логистическая концепция “Точно в срок”.

![lazy_initialization.png](/img/design_pattern/design_patterns/lazy_initialization.png)

Частный случай ленивой инициализации — создание объекта в момент обращения к
нему — является одним из порождающих шаблонов проектирования. Как правило он
используется в сочетании с такими шаблонами, как Фабричный метод, Одиночка и
Заместитель.

Сильные стороны:

- Инициализация выполняется только в тех случаях, когда она действительно
  необходима;
- Ускоряется начальная инициализация приложения: все, что можно отложить,
  откладываем.

Слабые стороны:

- Невозможно явным образом задать порядок инициализации объектов;
- Возникает задержка при первом обращении к объекту, что может оказаться
  критичным при параллельном выполнении другой ресурсоёмкой операции. Из-за
  этого требуется тщательно просчитывать целесообразность использования
  “ленивой” инициализации в многопоточных программных системах.

Помнишь, как при написании web.xml там можно было указать порядок старта
сервлетов? Это как раз и есть следствие ленивой загрузки. Tomcat создаст объекты
сервлетов при первом к ним обращении.

### _Object pool_

Объектный пул (object pool) — порождающий шаблон проектирования, набор
инициализированных и готовых к использованию объектов. Когда системе требуется
объект, он не создаётся, а берётся из пула. Когда объект больше не нужен, он не
уничтожается, а возвращается в пул.

![object_pool.png](/img/design_pattern/design_patterns/object_pool.png)

Объектный пул применяется для повышения производительности, когда создание
объекта в начале работы и уничтожение его в конце приводит к большим затратам.
Особенно заметно повышение производительности, когда объекты часто
создаются-уничтожаются, но одновременно существует лишь небольшое их число.  
Объектный пул удобен, если объект владеет другими ресурсами, кроме памяти —
например, сетевыми сокетами. Либо если коллекция объектов отнимает значительную
часть памяти компьютера и “мусора” создаётся действительно много.  
Как ты помнишь, Tomcat выполняет каждый запрос в отдельном потоке. Но потоки не
создаются каждый раз заново, а хранятся в пуле потоков. Это позволяет быстрее
выполнять запросы: когда поток нужен, он просто берется из пула. Кстати, вопрос:
а как бы ты поместил запущенные поток в пул и взял его из пула?

### ПОВОДЕНЧЕСКИЕ:

### _Итератор (iterator)_

Итератор (iterator) - поведенческий шаблон проектирования. Представляет собой
объект, позволяющий получить последовательный доступ к элементам
объекта-агрегата без использования описаний каждого из агрегированных объектов.
![iterator.png](/img/design_pattern/design_patterns/iterator.png)

Например, такие элементы как дерево, связанный список, хеш-таблица и массив
могут быть пролистаны (и модифицированы) с помощью объекта Итератор.  
Перебор элементов выполняется объектом итератора, а не самой коллекцией. Это
упрощает интерфейс и реализацию коллекции, а также способствует более логичному
разделению обязанностей.  
Особенностью полноценно реализованного итератора является то, что код,
использующий итератор, может ничего не знать о типе итерируемого агрегата.  
Такой подход используется очень часто. Например, ты отправляешь базе данных
SQL-запрос, а в ответ она возвращает тебе итератор (в терминах SQL его обычно
называют курсором). И ты с помощью полученного итератора можешь поочередно брать
стоки из SQL-ответа.

### _Команда (command)_

Команда (command) - поведенческий шаблон проектирования, используемый при
объектно-ориентированном программировании, представляющий действие. Объект
команды заключает в себе само действие и его параметры.
![command.png](/img/design_pattern/design_patterns/command.png)

Чтобы вызывать какой-то метод, обычно нужны:

- ссылка на объект
- имя метода (ссылка на метод)
- значения параметров метода
- ссылка на контекст, который содержит используемые объекты

Все эти данные нужно упаковать в один объект — Команда (command).
Но и это еще не все: ведь команду должен кто-то выполнить. Так что в состав
этого паттерна входят еще четыре сущности: команды (command), приёмник команд (
receiver), вызывающий команды (invoker) и клиент (client).  
Объект Command знает о приёмнике и вызывает метод приемника. Значения параметров
приёмника сохраняются в команде. Вызывающий объект (invoker) знает, как
выполнить команду и, возможно, делает учёт и запись выполненных команд.
Вызывающий объект (invoker) ничего не знает о конкретной команде, он знает
только об интерфейсе.  
Оба объекта (вызывающий объект и несколько объектов команд) принадлежат объекту
клиента (client). Клиент решает, какие команды выполнить и когда. Чтобы
выполнить команду, он передает объект команды вызывающему объекту (invoker).  
Использование командных объектов упрощает построение общих компонентов, которые
необходимо делегировать или выполнять вызовы методов в любое время без
необходимости знать методы класса или параметров метода.  
Использование вызывающего объекта (invoker) позволяет вести учёт выполненных
команд без необходимости знать клиенту об этой модели учёта (такой учёт может
пригодиться, например, для реализации отмены и повтора команд).  
Например, ты пишишь программу, которая позволяет выполнять различные задания по
расписанию. С одной стороны твоя программа ведет учет заданий и управляет их
запуском, с другой у нее может быть несколько исполнителей, каждый из которых
умеет выполнять команды своего типа. Например, рассылка SMS, рассылка писем,
рассылка сообщений в Telegram и т. п.

### _Наблюдатель (observer)_

Наблюдатель (observer) - поведенческий шаблон проектирования. Реализует механизм
класса, который позволяет объекту этого класса получать оповещения об изменении
состояния других объектов и тем самым наблюдать за ними.
![observer.png](/img/design_pattern/design_patterns/observer.png)

Классы, на события которых другие классы подписываются, называются субъектами (
Subjects), а подписывающиеся классы называются наблюдателями (Observers).
При реализации шаблона Наблюдатель обычно используются следующие классы:

- Observable — интерфейс, определяющий методы для добавления, удаления и
  оповещения наблюдателей;
- Observer — интерфейс, с помощью которого наблюдатель получает оповещение;
- ConcreteObservable — конкретный класс, который реализует интерфейс Observable;
- ConcreteObserver — конкретный класс, который реализует интерфейс Observer.

Шаблон Наблюдатель применяется в тех случаях, когда в системе:

- существует как минимум один объект, рассылающий сообщения;
- имеется не менее одного получателя сообщений, причём их количество и состав
  могут изменяться во время работы приложения;
- позволяет избежать сильного зацепления взаимодействующих классов.

Этот шаблон часто применяют в ситуациях, в которых отправителя сообщений не
интересует, что делают получатели с предоставленной им информацией.

### _Посетитель (visitor)_

Посетитель (visitor) - поведенческий шаблон проектирования, описывающий
операцию, которая выполняется над объектами других классов. При изменении
visitor нет необходимости изменять обслуживаемые классы.
Шаблон демонстрирует классический приём восстановления информации о потерянных
типах, не прибегая к понижающему приведению типов при помощи двойной
диспетчеризации.
![visitor.png](/img/design_pattern/design_patterns/visitor.png)

Необходимо сделать какие-то несвязные операции над рядом объектов, но нужно
избежать загрязнения их кода. И нет возможности или желания запрашивать тип
каждого узла и осуществлять приведение указателя к правильному типу, прежде чем
выполнить нужную операцию.

Шаблон следует использовать, если:

- имеются различные объекты разных классов с разными интерфейсами, но над ними
  нужно совершать операции, зависящие от конкретных классов;
- над структурой необходимо выполнить различные усложняющие структуру операции;
- часто добавляются новые операции над структурой.

### _Посредник (mediator)_

Посредник (mediator) - поведенческий шаблон проектирования, обеспечивающий
взаимодействие множества объектов, формируя при этом слабое зацепление и
избавляя объекты от необходимости явно ссылаться друг на друга.
![mediator.png](/img/design_pattern/design_patterns/mediator.png)

Паттерн Посредник позволяет обеспечить взаимодействие множества объектов,
сформировав при этом слабую связанность и избавив объекты от необходимости явно
ссылаться друг на друга.  
Посредник определяет интерфейс для обмена информацией с объектами Коллеги,
Конкретный посредник координирует действия объектов Коллеги.  
Каждый класс Коллеги знает о своем объекте Посредник, все Коллеги обмениваются
информацией только с посредником, при его отсутствии им пришлось бы обмениваться
информацией напрямую.  
Коллеги посылают запросы Посреднику и получают запросы от него. Посредник
реализует кооперативное поведение, пересылая каждый запрос одному или нескольким
Коллегам.

### _Состояние (state)_

Состояние (state) - поведенческий шаблон проектирования. Используется в тех
случаях, когда во время выполнения программы объект должен менять своё поведение
в зависимости от своего состояния.
![state.png](/img/design_pattern/design_patterns/state.png)

Паттерн состоит из 3 блоков:

Context — класс, объекты которого должны менять своё поведение в зависимости от
состояния.  
State — интерфейс, который должен реализовать каждое из конкретных состояний.
Через этот интерфейс объект Context взаимодействует с состоянием, делегируя ему
вызовы методов. Интерфейс должен содержать средства для обратной связи с
объектом, поведение которого нужно изменить.  
Для этого используется событие (паттерн Publisher — Subscriber). Это необходимо
для того, чтобы в процессе выполнения программы заменять объект состояния при
появлении событий. Возможны случаи, когда сам Context периодически опрашивает
объект состояния на наличие перехода.  
ConcreteState1, ConcreteState2 — классы конкретных состояний. Должны содержать
информацию о том, при каких условиях и в какие состояния может переходить объект
из текущего состояния. Например, из ConcreteState1 объект может переходить в
состояние ConcreteState2 и ConcreteState3, а из ConcreteState2 — обратно в
ConcreteState1 и так далее. Объект одного из них должен содержать Context при
создании.  
Например, ты пишешь игру, где персонаж может бегать, плавать и летать. Если твой
персонаж попал в воду, то разумно ограничить его поведение в воде: он теперь не
может стрелять, но у него сохранились какие-то действия: плыть вперед, вправо,
влево и т.п.  
Состояние твоего персонажа можно описать объектом State, у которого есть методы,
которые можно вызывать и которые будут что-то делать. И после того, как твой
персонаж залез в воду, ты просто меняешь у него внутри ссылку на другой объект
State — и он меняет свое состояние.

### _Стратегия (strategy)_

Стратегия (strategy) - поведенческий шаблон проектирования, предназначенный для
определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их
взаимозаменяемости. Это позволяет выбирать алгоритм путём определения
соответствующего класса.

Шаблон Strategy позволяет менять выбранный алгоритм независимо от
объектов-клиентов, которые его используют.
![07_strategy.png](/img/design_pattern/design_patterns/07_strategy.png)

Паттерн Стратегия позволяет использовать различные бизнес-правила или алгоритмы
в зависимости от контекста. Применяется в случаях, когда в одном и том же месте
в зависимости от текущего состояния системы (или её окружения) должны
использоваться различные алгоритмы.

Сильные стороны:

- инкапсуляция реализации различных алгоритмов, система становится независимой
  от возможных изменений бизнес-правил;
- вызов всех алгоритмов одним стандартным образом;
- отказ от использования переключателей и/или условных операторов.

Этот паттерн чем-то похож на паттерн State, однако тут акцент сделан не на
состояние, а на поведение. Допустим, персонаж в твоей игре может менять оружие.
Тогда при смене оружия можно просто поменять ссылку на объект, которые
описывает, как это оружие работает.

### _Шаблонный метод (template method)_

Шаблонный метод (template method)
![template_method.png](/img/design_pattern/design_patterns/template_method.png)

Abstract class (абстрактный класс) — определяет абстрактные операции, замещаемые
в наследниках для реализации шагов алгоритма; реализует шаблонный метод,
определяющий скелет алгоритма. Шаблонный метод вызывает замещаемые и другие,
определенные в Abstract class, операции.  
Concrete class (конкретный класс) — реализует замещаемые операции необходимым
для реализации способом. Concrete class предполагает, что инвариантные шаги
алгоритма будут выполнены в AbstractClass.  
Этот паттерн часто используется, когда надо:

- Однократное использование инвариантной части алгоритма с оставлением
  изменяющейся части на усмотрение наследникам.
- Локализация и вычленение общего для нескольких классов кода для избегания
  дублирования.
- Разрешение расширения кода наследниками только в определенных местах.

Да, этот паттерн описывает использование пары: абстрактный класс и его
реализация.

### _Цепочка обязанностей (chain of responsibility)_

Цепочка обязанностей (chain of responsibility) - поведенческий шаблон
проектирования, предназначенный для организации в системе уровней
ответственности
![chain of responsibility.png](/img/design_pattern/design_patterns/chain of responsibility.png)

Шаблон рекомендован для использования в условиях, когда:

- в разрабатываемой системе имеется группа объектов, которые могут обрабатывать
  сообщения определенного типа;
- все сообщения должны быть обработаны хотя бы одним объектом системы;
- сообщения в системе обрабатываются по схеме “обработай сам или перешли
  другому”, то есть одни сообщения обрабатываются на том уровне, где они
  получены, а другие пересылаются объектам другого уровня.

### _Хранитель (memento)_

Хранитель (memento) - поведенческий шаблон проектирования, позволяющий не
нарушая инкапсуляцию зафиксировать и сохранить внутреннее состояние объекта так,
чтобы позднее восстановить его в это состояние.
![memento.png](/img/design_pattern/design_patterns/memento.png)

Шаблон Хранитель используется, когда:

- необходимо сохранить снимок состояния объекта (или его части) для последующего
  восстановления;
- прямой интерфейс получения состояния объекта раскрывает детали реализации и
  нарушает инкапсуляцию объекта.


- Интерпретатор (interpreter)
  ![06_interpreter.png](/img/design_pattern/design_patterns/06_interpreter.png)

## Многопоточные паттерны

### _Active object_

Активный объект (Active object) — это шаблон проектирования, который отделяет
поток выполнения метода от потока, в котором он был вызван. Цель этого шаблона —
предоставлять параллельность выполнения, используя асинхронные вызовы методов и
планировщик обработки запросов.

Упрощённый вариант:

[active_object_1.png](/img/design_pattern/design_patterns/active_object_1.png)

Классический вариант:

[active_object_2.png](/img/design_pattern/design_patterns/active_object_2.png)

Этот шаблон состоит из шести элементов:

- Объект-заместитель (proxy), который предоставляет интерфейс к
  публично-доступным методам клиента.
- Интерфейс, который определяет методы доступа к активному объекту.
- Список поступающих запросов от клиентов.
- Планировщик (scheduler), который определяет порядок выполнения запросов.
- Реализация методов активного объекта.
- Процедура обратного вызова (callback) или переменная (variable) для получения
  клиентом результата.

### _Lock_

Паттерн Блокировка (Lock) — механизм синхронизации, позволяющий обеспечить
исключительный доступ к разделяемому ресурсу между несколькими потоками.
Блокировки — это один из способов обеспечить политику управления
распараллеливанием.

В основном, используется мягкая блокировка, при этом предполагается что каждый
поток пытается “захватить блокировку” перед доступом к соответствующему
разделяемому ресурсу.

Однако в некоторых системах предоставляется механизм обязательной блокировки,
при его использовании попытка несанкционированного доступа к заблокированному
ресурсу будет прервана через создание исключения в потоке, который пытался
получить доступ.

Семафор — самый простой тип блокировки. С точки зрения доступа к данным не
делается никаких различий между режимами доступа: общим (только чтение) или
эксклюзивным (чтение и запись). В режиме общего доступа несколько потоков могут
запросить блокировку для доступа к данным в режиме “только чтение”. Также
используется эксклюзивный режим доступа в алгоритмах обновления и удаления.

![semaphor.png](/img/design_pattern/design_patterns/semaphor.png)

Типы блокировок различают по стратегии блокировки продолжения исполнения потока.
В большинстве реализаций запрос блокировки препятствует дальнейшему исполнению
потока, пока не появится доступ к заблокированному ресурсу.

Спинлок — это блокировка, которая ожидает в цикле, пока не появится доступ.
Такая блокировка очень эффективна, если поток ожидает блокировку незначительный
интервал времени, это позволяет избежать избыточной перепланировки потоков.
Затраты на ожидание доступа будут значительными при длительном удержании
блокировки одним из потоков.

![spinlock.png](/img/design_pattern/design_patterns/spinlock.png)

Для эффективной реализации механизма блокировки требуется поддержка на
аппаратном уровне. Аппаратная поддержка может быть реализована в виде одной или
нескольких атомарных операций, таких как “test-and-set”, “fetch-and-add” или
“compare-and-swap”. Такие инструкции позволяют без прерываний проверить, что
блокировка свободна, и если это так, то занять блокировку.

### _Monitor_

Паттерн Монитор — высокоуровневый механизм взаимодействия и синхронизации
процессов, обеспечивающий доступ к разделяемым ресурсам. Подход к синхронизации
двух или более компьютерных задач, использующих общий ресурс, обычно аппаратуру
или набор переменных.

При многозадачности, основанной на мониторах, компилятор или интерпретатор
прозрачно для программиста вставляет код блокировки-разблокировки в оформленные
соответствующим образом процедуры, избавляя программиста от явного обращения к
примитивам синхронизации.

![monitor.png](/img/design_pattern/design_patterns/monitor.png)

Монитор состоит из:

- набора процедур, взаимодействующих с общим ресурсом
- мьютекса
- переменных, связанных с этим ресурсом
- инварианта, который определяет условия, позволяющие избежать состояние гонки

Процедура монитора захватывает мьютекс перед началом работы и держит его или до
выхода из процедуры, или до момента ожидания определенного условия. Если каждая
процедура гарантирует, что перед освобождением мьютекса инвариант истинен, то
никакая задача не может получить ресурс в состоянии, ведущем к гонке.

Именно так в Java работает оператор synchronized в паре с методами wait() и
notify().

### _Double check locking_

Блокировка с двойной проверкой (Double checked locking) — параллельный шаблон
проектирования, предназначающийся для уменьшения накладных расходов, связанных с
получением блокировки.

Сначала проверяется условие блокировки без какой-либо синхронизации. Поток
пытается получить блокировку, только если результат проверки говорит о том, что
получение блокировки необходимо.

```java
//Double-Checked Locking
public final class Singleton {
    private static Singleton instance; //Don't forget volatile modifier

    public static Singleton getInstance() {
        if (instance == null) {                //Read

            synchronized (Singleton.class) {    //
                if (instance == null) {         //Read Write
                    instance = new Singleton(); //
                }
            }
        }
    }
```

Как создать объект-синглетон в потокобезопасной среде?

```java
public static Singleton getInstance() {
    if (instance == null)
        instance = new Singleton();
}
```

Если ты создаешь объект Singleton из разных потоков, то может возникнуть
ситуация, когда создастся несколько объектов одновременно, а это неприемлемо.
Поэтому разумно обернуть создание объекта в оператор synchronized.

```java
public static Singleton getInstance() {
    synchronized (Singleton.class) {
        if (instance == null)
            instance = new Singleton();
    }
}
```

Такой подход будет работать, однако у него есть небольшой минус. После того, как
объект создан, каждый раз при попытке его получить в будущем будет выполняться
проверка в блоке synchronized, а значит будет лочиться текущий поток и все, что
с этим связано. Так что этот код можно немного оптимизировать:

```java
public static Singleton getInstance() {
    if (instance != null)
        return instance;

    synchronized (Singleton.class) {
        if (instance == null)
            instance = new Singleton();
    }
}
```

На некоторых языках и/или на некоторых машинах невозможно безопасно реализовать
этот шаблон. Поэтому иногда его называют анти-паттерном. Такие особенности
привели к появлению отношения строгого порядка “happens before” в Java Memory
Model и C++ Memory Model.

Обычно он используется для уменьшения накладных расходов при реализации ленивой
инициализации в многопоточных программах, например, в составе шаблона
проектирования Одиночка. При ленивой инициализации переменной инициализация
откладывается до тех пор, пока значение переменной не понадобится при
вычислениях.

### _Scheduler_

Планировщик (Scheduler) — параллельный шаблон проектирования, обеспечивающий
механизм реализации политики планирования, но при этом не зависящий ни от одной
конкретной политики. Управляет порядком, в соответствии с которым потокам
предстоит выполнить последовательный код, используя для этого объект, который
явным образом задаёт последовательность ожидающих потоков.

![scheduler.png](/img/design_pattern/design_patterns/scheduler.png)