# ШАБЛОНЫ ПРОЕКТИРОВАНИЯ

## ОТНОШЕНИЯ КЛАССОВ

![i1.png](/img/design_pattern/class_relations/i1.png)

Агрегация (aggregation) — описывает связь «часть»–«целое», в котором «часть»
может существовать отдельно от «целого». Ромб указывается со стороны «целого».

![i1.png](/img/design_pattern/class_relations/i2.png)

Композиция (composition) — подвид агрегации, в которой «части» не могут
существовать отдельно от «целого».

![i1.png](/img/design_pattern/class_relations/i3.png)

Зависимость (dependency) — изменение в одной сущности (независимой) может влиять
на состояние или поведение другой сущности (зависимой). Со стороны стрелки
указывается независимая сущность.

![i1.png](/img/design_pattern/class_relations/i4.png)

Обобщение (generalization) — отношение наследования или реализации интерфейса.
Со стороны стрелки находится суперкласс или интерфейс.

## ВИДЫ ПАТТЕРНОВ:

- **_Structural (S)_** - структурные - показывают различные способы построения
  связей между объектами;
- **_Behavioral (B)_** - поведенческие - заботятся об эффективной коммуникации
  между объектами;
- **_Creational (C)_** - порождающие - заботятся о гибком создании объектов без
  внесения в программу лишних зависимостей;

## СПИСОК ПАТТЕРНОВ:

S — Адаптер  
S — Декоратор  
S — Мост  
S — Компоновщик  
S — Фасад  
S — Приспособленец  
S — Прокси  
S — Наблюдатель

C — Абстрактная фабрика  
C — Строитель  
C — Фабричный метод  
C — Прототип  
C — Одиночка

B — Цепочка обязанностей  
B — Команда  
B — Интерпретатор  
B — Итератор  
B — Посредник  
B — Хранитель  
B — Состояние  
B — Стратегия  
B — Шаблонный метод  
B — Посетитель

### СТРУКТУРНЫЕ:

### _Адаптер_

Адаптер (adapter) - структурный шаблон проектирования, предназначенный для
организации использования функций объекта, недоступного для модификации, через
специально созданный интерфейс. Паттерн проектирования, который позволяет
объектам с несовместимыми интерфейсами работать вместе.
![12_adapter.png](/img/design_pattern/design_patterns/adapter.png)

Используется для организации использования функций объекта, недоступного для
модификации, через специально созданный интерфейс. Создается дополнительный
класс, у которого есть нужный интерфейс. А этот класс уже в свою очередь
вызывает методы нужного объекта (у которого нет требуемого интерфейса).

Важно! Если в коде встретить у класса суффикс Adapter, то можно считать, что
этот класс выполняет роль адаптера и связан с группой классов, которые работают
по описанной выше схеме.

**Применяется в случаях**, когда система поддерживает требуемые данные и
поведение, но имеет неподходящий интерфейс. Чаще всего шаблон Адаптер
применяется, если необходимо создать класс, унаследованный от нового или уже
существующего абстрактного класса.

**Сильные стороны:**

- Переход на использование других внешних классов не требует переделки самой
  системы, достаточно реализовать еще один класс Adapter.
- Независимость от реализации внешних классов (классов из библиотек, чей код мы
  не можем поменять). Программа становится независимой от интерфейса внешних
  классов.

### _Декоратор_

Декоратор (decorator) - структурный шаблон проектирования, предназначенный для
динамического подключения дополнительного поведения к объекту. Шаблон Декоратор
предоставляет хорошую и гибкую альтернативу практике создания подклассов с целью
расширения функциональности.
![18_decorator.png](/img/design_pattern/design_patterns/decorator.png)

Используется для динамического подключения к объекту дополнительных
обязательств.

**Сильные стороны паттерна Decorator:**

Нет необходимости создавать подклассы для расширения функциональности объекта.
Возможность динамически подключать новую функциональность в любом месте: до или
после основной функциональности объекта ConcreteComponent.

### _Прокси_

Заместитель (Proxy) — структурный шаблон проектирования, предоставляющий объект,
который контролирует доступ к другому объекту, перехватывая и пропуская через
себя все его вызовы.
![13_proxy.png](/img/design_pattern/design_patterns/proxy.png)

Паттерн Proxy предоставляет объект-заменитель вместо настоящего объекта. Этот
объект контролирует доступ к оригинальному объекту. Используется очень часто.

В фреймворке Mockito перехватывается обращение к реальному объекту с помощью
метода Mockito.spy() или аннотации @Spy. Именно тогда и создавался специальный
Proxy-объект, через который проходили все вызовы к оригинальному объекту.

И мы тогда с помощью добавления объекту правил могли этими вызовами управлять.
Именно так – оригинальный объект не меняется, а работа с ним становится
значительно гибче. Особенно полезно бывает, когда не мы из нашего кода вызываем
proxy-объект, а передаем его куда-то. Контролируя таким образом общение двух
независимых от нас объектов.

_Виды прокси по назначению:_

Протоколирующий прокси: сохраняет в лог все вызовы “Субъекта” с их параметрами.
Удаленный заместитель (remote proxies): обеспечивает связь с “Субъектом”,
который находится в другом адресном пространстве или на удаленной машине. Также
может отвечать за кодирование запроса и его аргументов и отправку
закодированного запроса реальному “Субъекту”.
Виртуальный заместитель (virtual proxies): обеспечивает создание реального
“Субъекта” только тогда, когда он действительно понадобится. Также может
кэшировать часть информации о реальном “Субъекте”, чтобы отложить его создание.
Копировать-при-записи: обеспечивает копирование “субъекта” при выполнении
клиентом определенных действий (частный случай “виртуального прокси”).
Защищающий заместитель (protection proxies): может проверять, имеет ли
вызывающий объект необходимые для выполнения запроса права.
Кэширующий прокси: обеспечивает временное хранение результатов расчета до отдачи
их множественным клиентам, которые могут разделить эти результаты.
Экранирующий прокси: защищает “Субъект” от опасных клиентов (или наоборот).
Синхронизирующий прокси: производит синхронизированный контроль доступа к
“Субъекту” в асинхронной многопоточной среде.
“Умная” ссылка (smart reference proxy): производит дополнительные действия,
когда на “Субъект” создается ссылка, например, рассчитывает количество активных
ссылок на “Субъект”.

### _Bridge_

**Мост (bridge)** - структурный шаблон проектирования, используемый чтобы
“разделять абстракцию и реализацию так, чтобы они могли изменяться независимо”.

Шаблон мост использует инкапсуляцию, агрегирование и может использовать
наследование для того, чтобы разделить ответственность между классами.

![15_bridge.png](/img/design_pattern/design_patterns/bridge.png)

Когда абстракция и реализация разделены, они могут изменяться независимо.
Другими словами, при реализации через шаблон мост, изменение структуры
интерфейса не мешает изменению структуры реализации.

Рассмотрим такую абстракцию как фигура. Существует множество типов фигур, каждая
со своими свойствами и методами. Однако есть что-то, что объединяет все фигуры.
Например, каждая фигура должна уметь рисовать себя, масштабироваться и так
далее.

В то же время рисование графики может отличаться в зависимости от типа ОС или
графической библиотеки. Фигуры должны иметь возможность рисовать себя в
различных графических средах. Но реализовывать в каждой фигуре все способы
рисования или модифицировать фигуру каждый раз при изменении способа рисования
непрактично.

В этом случае помогает шаблон мост, позволяя создавать новые классы, которые
будут реализовывать рисование в различных графических средах. При использовании
такого подхода очень легко можно добавлять как новые фигуры, так и способы их
рисования.

Связь, изображаемая стрелкой на диаграммах, может иметь 2 смысла: а)
“разновидность”, в соответствии с принципом подстановки Лисков и б) одна из
возможных реализаций абстракции. Обычно в языках используется наследование для
реализации как а), так и б), что приводит к разбуханию иерархий классов.

Мост служит именно для решения этой проблемы: объекты создаются парами из
объекта класса иерархии А и иерархии B, наследование внутри иерархии А имеет
смысл “разновидность” по Лисков, а для понятия “реализация абстракции”
используется ссылка из объекта A в парный ему объект B.

### _Фасад_

Фасад (facade) - Шаблон Фасад (Facade) — структурный шаблон проектирования,
позволяющий скрыть сложность системы путем сведения всех возможных внешних
вызовов к одному объекту, делегирующему их соответствующим объектам системы.
![21_facade.png](/img/design_pattern/design_patterns/facade.png)

Как обеспечить унифицированный интерфейс с набором разрозненных реализаций или
интерфейсов, например, с подсистемой, если нежелательно сильное связывание с
этой подсистемой или реализация подсистемы может измениться?

Определить одну точку взаимодействия с подсистемой — фасадный объект,
обеспечивающий общий интерфейс с подсистемой, и возложить на него обязанность по
взаимодействию с ее компонентами. Фасад — это внешний объект, обеспечивающий
единственную точку входа для служб подсистемы.

Реализация других компонентов подсистемы закрыта и не видна внешним компонентам.
Фасадный объект обеспечивает реализацию GRASP паттерна Устойчивый к изменениям с
точки зрения защиты от изменений в реализации подсистемы.

Важно! Этот шаблон применяется, когда мы хотим полностью скрыть какую-то группу
объектов и всю коммуникацию с ними пропустить через наш объект. Если же вы
просто хотите обеспечить некоторый контроль процесса коммуникации объектов и
скрывать их не обязательно, то лучше воспользоваться паттерном Proxy.

Компоновщик (composite)
![16_composite.png](/img/design_pattern/design_patterns/16_composite.png)

- Приспособленец (flyweight)
  ![22_flyweight.png](/img/design_pattern/design_patterns/22_flyweight.png)

### ПОВОДЕНЧЕСКИЕ:

- **_Хранитель (memento)_**
  ![01_memento.png](/img/design_pattern/design_patterns/01_memento.png)

- **_Цепочка обязанностей (chain of responsibility)_**
  ![02_chain.png](/img/design_pattern/design_patterns/02_chain.png)

- Наблюдатель (observer)
  ![03_observer.png](/img/design_pattern/design_patterns/03_observer.png)

- Команда (command)
  ![04_command.png](/img/design_pattern/design_patterns/04_command.png)

- Состояние (state)
  ![05_state.png](/img/design_pattern/design_patterns/05_state.png)

- Интерпретатор (interpreter)
  ![06_interpreter.png](/img/design_pattern/design_patterns/06_interpreter.png)

- Стратегия (strategy)
  ![07_strategy.png](/img/design_pattern/design_patterns/07_strategy.png)

- Итератор (iterator)
  ![08_iterator.png](/img/design_pattern/design_patterns/08_iterator.png)

- Шаблонный метод (template method) -
  ![09_templatemethod.png](/img/design_pattern/design_patterns/09_templatemethod.png)

- Посетитель (visitor)
  ![10_visitor.png](/img/design_pattern/design_patterns/10_visitor.png)

- Посредник (mediator)
  ![11_mediator.png](/img/design_pattern/design_patterns/11_mediator.png)

### ПОРОЖДАЮШИЕ:

- Строитель (builder)
  ![17_builder.png](/img/design_pattern/design_patterns/17_builder.png)

- Фабричный метод (factory method)
  ![19_factorymethod.png](/img/design_pattern/design_patterns/19_factorymethod.png)

- Абстрактная фабрика (abstract factory)
  ![14_abstractfactory.png](/img/design_pattern/design_patterns/14_abstractfactory.png)

- Прототип (prototype)
  ![20_prototype.png](/img/design_pattern/design_patterns/20_prototype.png)

- Одиночка (singleton)
  ![23_singleton.png](/img/design_pattern/design_patterns/23_singleton.png)
