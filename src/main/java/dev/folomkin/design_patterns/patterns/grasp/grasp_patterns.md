# ПАТТЕРНЫ GRASP (GENERAL RESPONSIBILITY ASSIGNMENT SOFTWARE PATTERNS)

## ПАТТЕРНЫ И АНТИППАТЕРНЫ

GoF и GRASP шаблоны представляют собой две различные точки зрения
на организацию классов. GRASP представляют обобщенный взгляд на организацию
самих классов и их взаимодействия вне зависимости от целевой задачи,
решаемой этими классами. GoF представляют собой рецепты решения конкретных, и
при этом достаточно узких, проблем. Тем не менее, если их использовать
совместно, то качество и удобочитаемость кода повысятся.

## _Expert_

Все классы делятся на две большие группы: классы-носители информации,
классы, производящие действия. Классов-носителей значительно меньше, но они
играют роли отображения сущностей реального мира в системе анимирования
«неживых» сущностей и, как правило, должны быть представителями Java Beans.  
Классы-носители информации, в общем, не должны выполнять действий
по манипулированию значениями своих полей.  
При проектировании классов на первом этапе необходимо определить общий принцип
распределения обязанностей между классами проекта, а именно:
в первую очередь определить кандидатов в информационные **_эксперты_** -
классы, обладающие информацией, требуемой для выполнения функциональности
программной системы.  
Например, в подсистеме прохождения назначенного теста некоторому классу
необходимо знать число вопросов, на которые получен ответ на текущий
момент времени в процессе тестирования. Количество вопросов из теста, на которые
дан ответ, есть число созданных объектов класса Quest. Такую информацию можно
поместить в описание класса Test, но в данной ситуации это приведет к
загромождению класса. Итак, класс Test ответствен за общие характеристики теста.
Класс CurrentStateTest будет владеть информацией о текущем состоянии теста.

```java
class Test {
    private int idTest;
    private String testName;
    private int questNumber;
    private long time;
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

class CurrentStateTest {
    private int idT;
    private int idS;
    private int idCurrentQuest;
    private long timeRemain;
    private Queue<Long> idListQuest;
// конструкторы и методы
}

```

Преимущества следования шаблону Expert:

- сохранение инкапсуляции информации при назначении ответственности
  классам, которые уже обладают необходимой информацией для обеспечения своей
  функциональности;
- уклонение от новых зависимостей способствует обеспечению низкой степени
  связанности между классами (Low Coupling);
- добавление соответствующего метода или внутреннего класса способствует
  высокому зацеплению (Highly Cohesive) классов, если класс уже обладает
  информацией для обеспечения необходимой функциональности.

## _Creator_

Существует большая вероятность того, что класс станет проще, если он будет
большую часть своего жизненного цикла ссылаться на создаваемые объекты.  
После определения информационных экспертов следует определить классы,
ответственные за создание нового экземпляра некоторого класса. Следует
назначить классу B обязанность создавать экземпляры класса A, если выполняется
одно из следующих условий:

- класс В содержит или получает данные инициализации (has the initializing
  data), которые будут передаваться объектам класса А при его создании;
- класс В записывает или активно использует (records or closely uses) экземпляры
  объектов А;
- класс В агрегирует (aggregate) объекты А;
- класс В содержит (contains) объекты А;
- классы B и A относятся к одному и тому же типу, и их экземпляры составляют,
  агрегируют, содержат или напрямую используют другие экземпляры того же класса.

Если выполняется одно из указанных условий, то класс В – создатель (creator)
объектов А.

В соответствии с шаблоном необходимо найти класс, который должен отвечать за
создание нового экземпляра объекта Quest, например, агрегирующий экземпляры
объектов Quest. Поскольку объект BuildTest использует объект Quest,
согласно шаблону Creator он является кандидатом на выполнение обязанности,
связанной с созданием экземпляров объектов Quest. В этом случае обязанности
могут быть распределены следующим образом:

```java
class BuildTest {
    public void build(Queue<Quest> queue) {
        queue.add(makeQuest(параметры));
        // реализация
    }

    private Quest makeQuest() {
        // реализация
        return new Quest(параметры);
    }
}

class Test {
    private int idTest;
    private String testName;
    private int questNumber;
    private long time;
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

```

Шаблон Creator способствует низкой зависимости между классами (Low Coupling),
так как экземпляры класса, которым необходимо содержать ссылку на некоторые
объекты, должны создавать эти объекты. Если класс создает некоторый объект
самостоятельно, то тем самым он перестает быть зависимым от класса, отвечающего
за создание объектов для него.

## _Low Coupling_

Степень связанности классов определяет, насколько класс связан с другими
классами и какой информацией о других классах он обладает. При проектиро-
вании отношений между классами следует распределить обязанности таким
образом, чтобы степень связанности оставалась низкой.
Наличие классов с высокой степенью связанности нежелательно, так как:

- изменения в связанных классах приводят к локальным изменениям в данном классе;
- затрудняется понимание каждого класса в отдельности;
- усложняется повторное использование, поскольку для этого требуется
  дополнительный анализ классов, с которыми связан данный класс.

Учебный курс содержит тесты, которые состоят из вопросов. Пусть требуется
создать экземпляр класса Quest и добавить его в экземпляр класса Test.
В предметной области регистрация объекта Test выполняется объектом Course.

Далее экземпляр объекта Course должен передать сообщение makeQuest()
объекту Test. Это значит, что в текущем тесте были получены идентификаторы
всех вопросов, составляющих тест, и становится возможным создание объектов
типа Quest и наполнение собственно теста.

```java
class Test {
    // поля, методы
    public void addQuest(Quest quest) {
        // реализация
    }
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

class Course {
    public void makeTest(int id) {
        Test test = new Test(параметры);
        // реализация
        while (условие) {
            Quest quest = new Quest(параметры);
            // реализация
            test.addQuest(quest);
        }
    }
}

//// 2 вариант 

class Course {
    // Поля
    public void makeTest(int id) {
        Test test = new Test(параметры);
        // реализация
        test.createTest();
        // реализация
    }
}

class Test {
    // поля, методы
    public void createTest() {
        // реализация
        while (условия) {
            Quest quest = new Quest(параметры);
            // реализация
        }
    }
}

class Quest {
    private int idQuest;
    private int idTest;
// реализация конструкторов и методов
}

```

При таком распределении обязанностей предполагается, что класс Course
связан с классом Quest.

В обоих случаях предполагается, что объекту Test должно быть известно
о существовании объекта Quest.
При использовании первого способа, когда объект Quest создается объектом
Course, между этими двумя объектами добавляется новая связь, тогда как
второй способ степень связывания объектов не увеличивает. Более предпочтителен
второй способ, так как он обеспечивает низкую связываемость.
В ООП имеются некоторые стандартные способы связывания объектов A и B:

- объект A содержит атрибут, который ссылается на экземпляр объекта B;

- объект A содержит метод, который ссылается на экземпляр объекта B, что
  подразумевает использование B в качестве типа параметра, локальной переменной
  или возвращаемого значения;
- класс объекта A является подклассом объекта B;
- B является интерфейсом, а класс объекта A реализует этот интерфейс.

Шаблон Low Coupling нельзя рассматривать изолированно от других шаблонов (
Expert, Creator, High Cohesion). Не существует абсолютной меры для
определения слишком высокой степени связывания.

Преимущества следования шаблону Low Coupling:

- изменение компонентов класса мало сказывается на других классах;
- принципы работы и функции компонентов можно понять, не изучая другие
  классы.

## _High Cohesion_

С помощью этого шаблона можно обеспечить возможность управления сложностью,
распределив обязанности, поддерживать высокую степень зацепления.
Зацепление — мера специализированности класса на своих обязанностях.
При высоком зацеплении обязанности класса тесно связаны между собой,
и класс не выполняет работ непомерных объемов. Класс с низкой степенью
зацепления выполняет много разнородных действий или не связанных между
собой обязанностей.

Возникают проблемы, связанные с тем, что класс:

- труден в понимании, так как необходимо уделять внимание несвязным (
  неродственным) идеям;
- сложен в поддержке и повторном использовании из-за того, что он должен быть
  использован вместе с зависимыми классами;
- ненадежен, постоянно подвержен изменениям.

Классы со слабым зацеплением выполняют обязанности, которые можно
легко распределить между другими классами.
Пусть необходимо создать экземпляр класса Quest и связать его с заданным
тестом. Какой класс должен выполнять эту обязанность? В предметной области
сведения о вопросах на текущий момент времени при прохождении теста
записываются в объекте Course, согласно шаблону для создания экземпляра
объекта Quest можно использовать объект Course. Тогда экземпляр объекта
Course сможет отправить сообщение makeTest() объекту Test. За прохождение
теста отвечает объект Course, т. е. объект Course частично несет
ответственность за выполнение операции makeTest(). Однако если и далее возлагать
на класс Course обязанности по выполнению все новых функций, связанных
с другими системными операциями, то этот класс будет слишком перегружен
и будет обладать низкой степенью зацепления.

Этот шаблон необходимо применять при оценке эффективности каждого
проектного решения.

Виды зацепления:

1. Очень слабое зацепление. Единоличное выполнение множества разнород­
   ных операций;

```java
public class Initializer {
    public void createTCPServer(String port) {
        // реализация
    }

    public int connectToDB(URL url) {
        // реализация
    }

    public void initXMLDocument(String fileName) {
        // реализация
    }
}
```

2. Слабое зацепление. Единоличное выполнение сложной задачи из одной
   функциональной области;

```java
public class NetLogicCreator {
    public void createTCPServer() {
        // реализация
    }

    public void createTCPClient() {
        // реализация
    }

    public void createUDPServer() {
        // реализация
    }

    public void createUDPClient() {
        // реализация
    }
}
```

3. среднее зацепление. Несложные обязанности в нескольких различных
   областях, логически связанных с концепцией этого класса, но не связанных
   между собой;

```java
public class TCPServerHelper {
    public void createTCPServer() {
        // реализация
    }

    public void receiveData() {
        // реализация
    }

    public void sendData() {
        // реализация
    }

    public void compression() {
        // реализация
    }

    public void decompression() {
        // реализация
    }
}
```

4. Высокое зацепление. Среднее количество обязанностей из одной функциональной
   области при взаимодействии с другими классами.

```java
public class TCPServerCreator {
    public void createTCPServer() {
        // реализация
    }
}

public class DataTransmission {
    public void receiveData() {
        // реализация
    }

    public void sendData() {
        // реализация
    }
}

public class CodingData {
    public void compression() {
        // реализация
    }

    public void decompression() {
        // реализация
    }
}
```

## _Controller_

Одной из базовых задач при проектировании информационных систем
является определение класса, отвечающего за обработку системных событий.

При необходимости посылки внешнего события прямо объекту приложения,
которое обрабатывает это событие, как минимум один из объектов должен
содержать ссылку на другой объект, что может послужить причиной очень
негибкого дизайна, если обработчик событий зависит от типа источника событий
или источник событий зависит от типа обработчика событий.

В простейшем случае зависимость между внешним источником событий
и внутренним обработчиком событий заключается исключительно в передаче
событий. Довольно просто обеспечить необходимую степень независимости
между источником событий и обработчиком событий, используя интерфейсы.
Интерфейсов может оказаться недостаточно для обеспечения поведенческой
независимости между источником и обработчиком событий, когда отношения
между этими источником и обработчиком достаточно сложны.

Можно избежать зависимости между внешним источником событий и
внутренним обработчиком событий путем введения между ними дополнительного
объекта, который будет работать в качестве посредника при передаче событий.
Этот объект должен быть способен справляться с любыми другими сложными
аспектами взаимоотношений между объектами.

Согласно шаблону Controller, производится делегирование обязанностей
по обработке системных сообщений классу, если он:

- представляет всю организацию или всю систему в целом (внешний контроллер);
- представляет активный объект из реального мира, который может участво- вать в
  решении задачи (контроллер роли);
- представляет искусственный обработчик всех системных событий преце- дента и
  называется ПрецедентHandler (контроллер прецедента) .

Для всех системных событий в рамках одного прецедента используется один и тот же
контролер.

Controller — это класс, не относящийся к интерфейсу пользователя и отвечающий за
обработку системных событий. Использование объекта-контроллера обеспечивает
независимость между внешними источниками событий и внутренними обработчиками
событий, их типом и поведением. Выбор определяется зацеплением и связыванием.

**_Антишаблон_**: Раздутый контроллер (н-р, волшебный сервлет) выполняет
слишком много обязанностей. Признаки:

- в системе имеется единственный класс контроллера, получающий все системные
  сообщения, которых поступает слишком много (внешний или ролевой контроллер);
- контроллер имеет много полей (информации) и методов (ассоциаций),
  которые необходимо распределить между другими классами.

