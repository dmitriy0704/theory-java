# Фабричный метод

- это порождающий паттерн проектирования, который определяет общий интерфейс для
  создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых
  объектов. Это паттерн проектирования, который позволяет создавать объекты, не
  указывая конкретный класс создаваемого объекта. Вместо этого, он определяет
  интерфейс для создания объекта, позволяя подклассам решать, какой класс
  инстанцировать.

Общая структура:
![factory_method_2.png](/img/design_pattern/design_patterns/factory_method_2.png)

1. Продукт определяет общий интерфейс объектов, которые может произвести
   создатель и его подклассы.
2. Конкретные продукты содержат код различных продуктов. Продукты будут
   отличаться реализацией, но интерфейс у них будет общий.
3. Создатель объявляет фабричный метод, который должен возвращать новые объекты
   продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом
   продуктов. Зачастую фабричный метод объявляют абстрактным, чтобы заставить
   все подклассы реализовать его по-своему. Но он может возвращать и некий
   стандартный продукт. Несмотря на название, важно понимать, что создание
   продуктов не является единственной функцией создателя. Обычно он содержит и
   другой полезный код работы с продуктом. Аналогия: большая софтверная компания
   может иметь центр подготовки программистов, но основная задача компании —
   создавать программные продукты, а не готовить программистов.
4. Конкретные создатели по-своему реализуют фабричный метод, производя те или
   иные конкретные продукты.<br> Фабричный метод не обязан всё время создавать
   новые объекты. Его можно переписать так, чтобы возвращать существующие
   объекты из какого-то хранилища или кэша.

```java
package dev.folomkin.design_patterns.pattterns2.creational.factory_method;


// Шаблон продукта
// 1. Это интерфейс, который определяет метод doShift(), который будут реализовывать конкретные продукты.
interface Product {
    void doShift();
}

// Конкретные продукты
// 2. ConcreteProductA и ConcreteProductB — это конкретные реализации интерфейса Product.
class ConcreteProductA implements Product {
    @Override
    public void doShift() {
        System.out.println("Используется продукт A");
    }
}

class ConcreteProductB implements Product {
    @Override
    public void doShift() {
        System.out.println("Используется продукт B");
    }
}

// Создатель
// 3. Creator — это абстрактный класс, который объявляет фабричный метод
// factoryMethod(). Он также содержит метод someOperation(), который использует
// продукт.
abstract class Creator {
    public abstract Product factoryMethod();

    public void someOperation() {
        // Вызываем фабричный метод для создания продукта
        Product product = factoryMethod();
        // Используем продукт
        product.doShift();
    }

}

// Конкретные создатели
// 4. ConcreteCreatorA и ConcreteCreatorB — это конкретные создатели, которые
// реализуют фабричный метод и создают соответствующие продукты.
class ConcreteCreatorA extends Creator {
    @Override
    public Product factoryMethod() {
        return new ConcreteProductA();
    }
}

class ConcreteCreatorB extends Creator {
    @Override
    public Product factoryMethod() {
        return new ConcreteProductB();
    }
}

// Клиентский код
// 5. В классе FactoryMethodExample создаются экземпляры конкретных создателей,
// и вызывается метод someOperation(), который создает и использует продукт.

public class FactoryMethodExample {
    public static void main(String[] args) {
        Creator creatorA = new ConcreteCreatorA();
        creatorA.someOperation(); // Используется продукт A

        Creator creatorB = new ConcreteCreatorB();
        creatorB.someOperation(); // Используется продукт B

    }
}
```

## Объяснение кода:

1. Product — это интерфейс, который определяет метод doShift(), который будут
   реализовывать конкретные продукты.
2. ConcreteProductA и ConcreteProductB — это конкретные реализации интерфейса
   Product.
3. Creator — это абстрактный класс, который объявляет фабричный метод
   factoryMethod(). Он также содержит метод someOperation(), который использует
   продукт.
4. ConcreteCreatorA и ConcreteCreatorB — это конкретные создатели, которые
   реализуют фабричный метод и создают соответствующие продукты.
5. В классе FactoryMethodExample создаются экземпляры конкретных создателей, и
   вызывается метод someOperation(), который создает и использует продукт.

Этот паттерн позволяет легко добавлять новые продукты и создатели, не изменяя
существующий код.

## Шаги реализации

1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В
   качестве возвращаемого типа укажите общий интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты.
   Поочерёдно замените эти участки вызовами фабричного метода, перенося в него
   код создания различных продуктов.<br>
   В фабричный метод, возможно, придётся добавить несколько параметров,
   контролирующих, какой из продуктов нужно создать.<br>
   На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём
   будет жить большой условный оператор, выбирающий класс создаваемого продукта.
   Но не волнуйтесь, мы вот-вот исправим это.
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный
   метод. Переместите туда код создания соответствующего продукта из
   суперкласса.
5. Если создаваемых продуктов слишком много для существующих подклассов
   создателя, вы можете подумать о введении параметров в фабричный метод,
   которые позволят возвращать различные продукты в пределах одного
   подкласса.<br>
   Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта , а
   также классы продуктов Самолёт , Грузовик и Поезд. Авиа соответствует
   Самолётам , но для НаземнойПочты есть сразу два продукта.Вы могли бы создать
   новый подкласс почты для поездов, но проблему можно решить и по-другому.
   Клиентский код может передавать в фабричный метод НаземнойПочты аргумент,
   контролирующий тип создаваемого продукта.
6. Если после всех перемещений фабричный метод стал
   пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда,
   это будет его реализацией по
   умолчанию.
      