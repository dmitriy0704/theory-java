# Адаптер (Adapter)

— это структурный паттерн проектирования, который позволяет объектам с
несовместимыми интерфейсами работать вместе.

Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в
вызовы понятные другому.

Это объект-переводчик, который трансформирует интерфейс или данные одного
объекта в такой вид, чтобы он стал понятен другому объекту.

При этом адаптер оборачивает один из объектов, так что
другойобъектдаженезнаетоналичиипервого. Например, вы можете обернуть объект,
работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и
помогать объектам с разными интерфейсами работать сообща. Это работает так:

1. Адаптер имеет интерфейс, который совместим с одним из объектов.
2. Поэтому этот объект может свободно вызывать методы адаптера.
3. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том
   формате и последовательности, которые понятны второму объекту.
4. Иногда возможно создать даже двухсторонний адаптер, который работал бы в обе
   стороны.

**Применимость**: Паттерн можно часто встретить в Java-коде, особенно там, где
требуется конвертация разных типов данных или совместная работа классов с
разными интерфейсами.

Примеры Адаптеров в стандартных библиотеках Java:

java.util.Arrays#asList()
java.util.Collections#list()
java.util.Collections#enumeration()
java.io.InputStreamReader(InputStream) (возвращает объект Reader)
java.io.OutputStreamWriter(OutputStream) (возвращает объект Writer)
javax.xml.bind.annotation.adapters.XmlAdapter#marshal() и #unmarshal()

**Признаки применения паттерна**: Адаптер получает конвертируемый объект в
конструкторе или через параметры своих методов. Методы Адаптера обычно
совместимы с интерфейсом одного объекта. Они делегируют вызовы вложенному
объекту, превратив перед этим параметры вызова в формат, поддерживаемый
вложенным объектом.

## Структура

Адаптер объектов

Эта реализация использует агрегацию: объект адаптера
«оборачивает», то есть содержит ссылку на служебный объект. Такой подход
работает во всех языках программирования.

![adapter_structure.png](/img/design_pattern/design_patterns/adapter_object_structure.png)

1. Клиент — это класс, который содержит существующую бизнес-логику программы.
2. Клиентский интерфейс описывает протокол, через который
   клиент может работать с другими классами.
3. Сервис — это какой-то полезный класс, обычно сторонний.
   Клиент не может использовать этот класс напрямую, так как сервис имеет
   непонятный ему интерфейс.
4. Адаптер — это класс, который может одновременно работать и с клиентом, и с
   сервисом. Он реализует клиентский интерфейс и содержит ссылку на объект
   сервиса. Адаптер получает вызовы от клиента через методы клиентского
   интерфейса, а затем переводит их в вызовы методов обёрнутого объекта в
   правильном формате.
5. Работая с адаптером через интерфейс, клиент не привязывается к конкретному
   классу адаптера. Благодаря этому, вы можете добавлять в программу новые виды
   адаптеров, независимо от клиентского кода. Это может пригодиться, если
   интерфейс сервиса вдруг изменится, например, после выхода новой версии
   сторонней библиотеки.

Адаптер классов

Эта реализация базируется на наследовании: адаптер наследует оба интерфейса
одновременно. Такой подход возможен только в языках, поддерживающих
множественное наследование, например, C++.

![adapter_classes_structure.png](/img/design_pattern/design_patterns/adapter_classes_structure.png)

Адаптер классов не нуждается во вложенном объекте, так
как он может одновременно наследовать и часть существующего класса, и часть
сервиса.