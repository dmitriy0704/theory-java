# ___Коллекции___

__Иерархия колллекций:__
![collection.jpg](/img/collection.jpg)

## ___Iterable___

Объявляет один абстрактный метод _iterator()_ для извлечения объекта,
реализующего интерфейс Iterator.

## ___Iterator___

**Основные методы:**

- hasNext();
- next();
- remove();

__Пример кода:__

```java
public class ExampleStart {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);

        Integer y = 3;
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        // или
        for (Integer i : list) {
            System.out.println(i);
        }
        System.out.println(list);
    }
}
```

## ___Интерфейс Collections___

***Основные подинтерфейсы:***

- **List\<E>** - список - моделирует массив изменяемого размера, для которого
  разрешаается доступ по индексу. *Может содержать повторяющиеся элементы. Часто
  используемые реализации:ArrayList, LinkedList, Vector и Stack.
- **Set\<E>** - множество, моделирует математическое множество. Повторяющиеся
  элементы не допустимы. Часто используемые реализации: HashSet, LinkedHashSet.
  Подинтерфейс SortedSet<E> моделирует отсортированное упорядоченное множество
  элементов, реализованное TreeSet.
- **Queue\<E>** - очередь - моделирует очереди, организованные по принципу First
  In First Out(FIFO) - первым вошел - первым вышел. Подинтерфейс Deque<E>
  моделирует очереди, с котороми можно работать с двух концов. Реализации
  включают PriorityQueue, ArrayDeque и LinkedList.

***Основные методы:***

- **int size()** - возвращает количество элементов данной колеекции
- **void clear()** - удаляет все элементы данной коллекции
- **boolean isEmpty()** - возвращает true, если коллекция не пуста
- **boolean add(E element)** - подтверждает. что данная коллекция содержит
  заданный элемент
- **boolean remove(Object element)** - Удаляет заданный элемент, если он имеется
  в коллекции
- **boolean contains(Object element)** - Возвращает true, если коллекция
  содержит заданный элемент

***Методы работы с другой коллекцией:***

- **boolean containsAll(Collection<?> c)** - Проверяет, содержит ли данная
  коллекция все элементы заданной коллекции, __**c**__ - коллекция элементы,
  которой будут проверяться на вхождение
- **boolean addAll(Collection<? extends E> c)** - метод добавляет все элементы
  указанной коллекции в конец коллекции Collection типа E или ее подтипам, c -
  коллекция, которая будет добавляться в конец исходной
- **boolean removeAll(Collection<?> c)** - метод для удаления всех элементов
  указанной коллекции
- **boolean retainsAll(Collection<?> c)** - оставляет только те элементы,
  которые содержатся в указанной коллекции __**с**__

***Методы сравнения:***

- **boolean equals(Object o)**
- **int hashCode()**

***Методы работы с массивами:***

- **Object[] toArrays()** - возвращает массив, содержащий все элементы данной
  коллекции типа Object[];
- **<T>T[] toArray(T[] a)** - возвращает массив, содержащий все элементы данной
  коллекции заданного типа T; тип возвращаемого массива

## ___Интерфейс Map___

Map<K,V> - принимает два дженерика типа K и V. Повторящися элементы запрещены.
Часто используемые реализации включают HashMap, Hashtable и LinkedHashMap. Их
подинтерфейс SortedMap<K, V> моделирует упорядоченную и отсортированную карту на
основании ключа, реализованного в TreeMap.

### ___Интерфейс List\<E>___

***Методы с указанием индекса:***

- **void add(int index, E element)** - добавляет
- **E set(int index, E element)** - заменяет
- **E get(int index)** - извлекает без удаления
- **E remove(int index)** - удаляет последний извлеченный
- **int indexOf(Object obj)** - возвращает индекс первого вхождения объекта obj
  в список. Если объект не найден, то возвращается -1
- **int lastIndexOf(Object obj)** - возвращает индекс последнего вхождения
  объекта obj в список. Если объект не найден, то возвращается -1
- **static \<E> List\<E> of(элементы)** - создает из набора элементов объект
  List
- **void sort(Comparator\<? super E> comp)** - сортирует список с помощью
  компаратора comp
- **ListIterator\<E> listIterator()** - возвращает объект ListIterator для
  обхода элементов списка

***Методы работы с диапазоном значений от fromIndex до toIndex(не включая):***

- **List\<E> subList(int start, int end)** - получает набор элементов, которые
  находятся в списке между индексами start и end

***Методы наследуемые из Collection:***

- **int size()**;
- **boolean isEmpty()**;
- **boolean add(E element)**;
- **boolean remove(Object o)**;
- **boolean contains(Object o)**;
- **void clear()**;

### ___ArrayList\<E>___

Массив с изменяющимся размером. Несинхронизированный.

***Констукторы:***

- **ArrayList()** - создает пустой список, размером 10;
- **ArrayList(Collection<? extends E> c)** - создает список из указанной
  коллекции
- **ArrayList(int initialCapacity)** - создает пустой список с изначально
  указанным объемом

***Методы:***

- **boolean add(E e)** - добавляет указанный элемент в конец списка;
- **void add(int index, E e)** - вставляет указанный элемент на указанную
  позицию;
- **boolean addAll(Collection<? extends E> c)** – добавляет все элементы
  указанной коллекции в конец данного списка в порядке, определенном итератором
  Iterator данной коллекции;
- **boolean addAll(int index, Collection<? extends E> c)** – добавляет все
  элементы указанной коллекции в список, начиная с указанной по- зиции;
- **void clear()** – удаляет все элементы из списка;
- **Object clone()** – возвращает копию объекта с теми же значениями полей, что
  у данного экземпляра ArrayList;
- **boolean contains(Object o)** – возвращает true, если данный список содержит
  указанный элемент;
- **void ensureCapacity(int minCapacity)** - увеличивает объем данного
  экземпляра ArrayList, если это необходимо, чтобы удостовериться, что он может
  содержать, по меньшей мере, число элементов, указанное в аргументе
  minCapacity;
- **E get(int index)** – возвращает элемент, находящийся на указаной позиции в
  списке;
- **int indexOf(Object o)** – возвращает индекс первого вхождения указанного
  элемента данного списка или -1, если данный список не содержит указанный
  элемент;
- **boolean isEmpty()** – возвращает true, если данный список не содержит
  элементов;
- **Iterator<E> iterator()** – возвращает итератор для правильного прохода по
  списку;
- **int lastIndexOf(Object o)** – возвращает индекс последнего вхождения
  указанного элемента данного списка или -1, если список не содержит данный
  элемент;
- **ListIterator<E> listIterator()** – возвращает итератор списка (для прохода в
  правильной последовательности);
- **ListIterator\<E> listIterator(int index)** – возвращает итератор списка (для
  прохода в правильной последовательности), начиная с указанной позиции в
  списке;
- **E remove(int index)** – удаляет элемент из указанной позиции в списке;
- **boolean remove(Object o)** – удаляет первый встретившийся указанный элемент
  из списка, если он там имеется;
- **boolean removeAll(Collection<?> c)** – удаляет из списка все элементы,
  которые содержатся в указанной коллекции;
- **protected void removeRange(int fromIndex, int toIndex)** – удаляет из списка
  все элементы, чей индекс находится от fromIndex, включительно, до toIndex, не
  включая его;
- **boolean retainAll(Collection<?> c)** – оставляет в данном списке только те
  элементы, которые содержатся в указанной коллекции;
- **E set(int index, E element)** – заменяет элемент на указанной позиции в
  списке на указанный элемент;
- **int size()** – возвращает количество элементов данного списка;
- **List\<E> subList(int fromIndex, int toIndex)** – возвращает представление
  данного списка в виде подсписка, начиная с элемента с индексом fromIndex,
  включительно, до элемента с индексом toIndex, не включая его;
- **Object[] toArray()** – возвращает массив всех элементов данного списка в
  правильной последовательности (т.е. от первого до последнего элемента);
- **\<T> T[] toArray(T[] a)** – возвращает массив, содержащий все элементы
  данного списка в правильной последовательности (от первого до последнего
  элемента); тип возвращенного массива при выполнении – тот же самый, что и у
  указанного массива;
- **void trimToSize()** – сокращает массив до размера данного экземпляра
  ArrayList, который и будет текущим размером списка (так как при удалении
  элементов размер списка не изменяется).

**Методы, унаследованные из класса java.util.AbstractList:**

- **boolean equals(Object o)** – сравнивает указанный объект с данным списком (
  на предмет равенства);
- **int hashCode()** – возвращает хэш-код для данного списка.

**Методы, унаследованные из класса java.util.AbstractCollection**

- **containsAll** – возвращает true, если данный список содержит все элементы
  указанной коллекции;
- **toString** – возвращает представление коллекции в виде строки символов.
  Строковое представление состоит из списка элементов коллекции в порядке, в
  котором они возвращаются итератором, список заключается в квадратные
  скобки («[]»), соседние элементы разделяются символами «, » (запятая и
  пробел). Элементы преобразуются в строку таким же образом, как и в
  “String.valueOf(Object).

**Методы, унаследованные из класса java.lang.Object:**

- **protected void finalize()** – генерирует исключение Throwable, этот метод
  вызывается, когда Java – сборщик мусора обнаруживает, что на объект нет
  ссылок; подкласс переопределяет метод finalize, чтобы запросить системные
  ресурсы или выполнить другие операции по очистке памяти;
- **public final Class<?> getClass()** – возвращает класс объекта во время
  выполнения, например,
- **public final void notify()** – «просыпается» один поток, который ожидает на
  «мониторе» данный объект; если несколько потоков ожидают данный объект, то для
  «просыпания» выбирается один из них;
- **public final void notifyAll()** – пробуждает все потоки;
- **public final void wait(long timeout)** – генерирует исключение
  InterruptedException. У метода wait() есть три вариации. Один метод wait()
  бесконечно ждет другой поток, пока не будет вызван метод notify() или
  notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток
  в ожидание на определенное время. По истечении этого времени поток просыпается
  и продолжает работу.

**Методы, унаследованные из интерфейса java.util.List:**

- **boolean containsAll(Collection<?> c)** – возвращает true, если данный список
  содержит все элементы данной коллекции;
- **boolean equals(Object o)** – сравнивает указанный объект со списком в смысле
  их равенства. Возвращает true тогда и только тогда, когда указанный объект
  является также списком, оба списка имеют одинаковый размер и все
  соответствующие пары элементов в обоих списках равны (Два элемента e1 и e2
  считаются равными, если (e1==null ? e2==null : e1.equals(e2)).)
- **int hashCode()** – возвращает значение хэш-кода для данного списка, хэш-код
  для списка определяется как результат следующих вычислений:

  int hashCode= 1;
  for(E e : list)
  hashCode = 31*hashCode + (e == null ? 0 : e.hashCode())

**Преобразование списка в массив - toArray():**

```java
public class ExampleStart {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        Object[] strArray = list.toArray();
        System.out.println(Arrays.toString(strArray));
        String[] strArray2 = list.toArray(new String[list.size()]);
        System.out.println(Arrays.toString(strArray2));
    }
}
```

**Представление массива в виде списка:**

```java
public class ExampleStart {
    public static void main(String[] args) {
        String[] strings = {"a", "b", "c", "d"};
        List<String> list = Arrays.asList(strings);
        List<String> list2 = Arrays.asList("fd", "fgfd", "gfgsd");
        System.out.println(list);
    }
}
```

### ___Vector\<E>___

Класс *Vector\<E>* реализует увеличивающийся или уменьшающийся массив объектов.
Как и массив, он содержит элементы, доступ к которым возможен по индексу. Однако
размер вектора может расти или уменьшаться в зависимости от добавления или
удаления элементов после того, как Vector уже был создан. Класс вектор является
синхронизированной реализацией интерфейса List.

***Конструкторы:***

- *Vector()* – создает пустой вектор таким образом, что внутренний массив имеет
  размер 10, а его стандартный инкремент объема равен нулю;
- *Vector(Collection<? extends E> c)* – создает вектор, содержащий элементы
  указанной коллекции в порядке, возвращенном итератором;
- *Vector(int initialCapacity)* – создает пустой вектор с указанным начальным
  объемом и со стандартным инкрементом объема, равным нулю;
- *Vector(int initialCapacity, int capacityIncrement)* – создает пустой вектор с
  указанными начальным объемом и инкрементом объема.

**Методы:**

- **void addElement(E obj)** – добавляет указанный компонент в конец вектора,
  увеличивая его размер на 1;
- **boolean removeElement(Object obj)** – удаляет первый, т.е. имеющий
  минимальный индекс, встретившийся аргумент из вектора;
- **void setElementAt(E obj, int index)** – вставляет элемент, представляющий
  собой указанный объект, на определенное индексом место в векторе;
- **public E elementAt(int index)** – возвращает элемент с указанным индексом;
  этот метод идентичен методу get(int), являющемуся частью интерфейса List;
- **public E firstElement()** – возвращает первый элемент (с индексом 0) данного
  вектора;
- **public E lastElement()** – возвращает последний элемент вектора;
- **public void insertElementAt(E obj,int index)** – вставляет указанный объект
  как элемент данного вектора на место, определенное индексом. Каждый элемент
  данного вектора с индексом, большим или равным указанному индексу, получает
  индекс, больший предыдущего на 1.

```
Vector v = new Vector(3, 2);
System.out.println("Начальный размер " + v.size());
System.out.println("Начальный объем " + v.capacity());
v.addElement(1);
v.addElement(2);
v.addElement(3);
v.addElement(4);
System.out.println("Новый объем " + v.capacity());
// Enumeration - доступ к серии элементов одновременно;
Enumeration e = v.elements();
while (e.hasMoreElements()) {
  System.out.println(e.nextElement());
}
```

**Различия между классами ArrayList и Vector:**

| ArrayList                                                                                            | Vector                                                                                                                                                               |
|------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ArrayList не синхронизирован                                                                         | Vector синхронизирован                                                                                                                                               |
| ArrayList увеличивает на 50% <br/> текущий размер массива, если число элементов превышает его размер | Vector увеличивает на 100% <br/> текущий размер массива, если число элементов превышает его размер                                                                   |
| ArrayList не является классом-наследником                                                            | Vector является классом наследником                                                                                                                                  |
| ArrayList является быстрым, потому что он не синхронизированный                                      | Vector является медленным, таккак он синхронизирован, т.е. при многопоточности он будет удерживать другие потоки до тех пор, пока не освободит от блокировки объект. |
| ArrayList использует интерфейс Iterator для прохода по элементам                                     | Vector использует интерфейс Enumeration для перемещения по элементам. Но может также использовать и интерфейс Iterator.                                              |

### ___Stack\<E>___

**Stack\<E>** – класс, определенный для структуры данных «стек», организованной
по принципу LIFO (last-in-first-out – последним вошел – первым вышел). Класс
Stack является наследником класса Vector, который является синхронизированным
массивом с изменяющимся размером.

**Методы:**

- **E void push(E element)** – помещает указанный элемент на вершину стека;
- **E pop()** – удаляет и возвращает элемент с вершины стека;
- **E peek()** – возвращает элемент с вершины стека без его удаления;
- **boolean empty()** – проверяет, является ли стек пустым;
- **int search(Object obj)** – возвращает расстояние от указанного объекта до
  вершины стека (от 1 для вершины стека) или –1, если элемент не найден.

### ___LinkedList\<E>___ - реализация класса для интерфейса List\<E>

LinkedList\<E> является реализацией двусвязного списка для интерфейса List\<E>,
который работает эффективно как для вставки элементов, так и для удаления,
используя, как издержки, более сложную структуру. LinkedList\<E> также реализует
интерфейсы Queue\<E> и Deque\<E> и может работать с обоих концов очереди. Он
может работать с очередью как по принципу FIFO, так и по принципу LIFO.

## ___Упорядочение, сортировка и поиск___

Для упорядочения используются способы:

- коллекция или массив с использованием методов Collections.sort() или
  Arrays.sort(),
  упорядочивающих по заданной спецификации.

```java
public class ExampleStart {
    public static void main(String[] args) {
        int[] numbers = {1, 3, 2, 45, 67, 8, 9, 10};
        // Отсортировать массив
        // Arrays.sort(numbers);
        System.out.println(Arrays.toString(numbers));
        List<Integer> numbersList = new ArrayList<>();
        for (int i = 0; i < numbers.length; i++) {
            numbersList.add(numbers[i]);
        }
        // Или коллекцию
        Collections.sort(numbersList);
        System.out.println(numbersList);
    }
}
```

- использование таких упорядоченных коллекций как SortedSet(TreeSet) и
  SortedMap(TreeMap).

Так же упорядочение можно реализовать:

- Заставить объекты реализовать интерфейс java.lang.Comparable и переопределить
  метод compareTo() для указания порядка сравнения двух объектов;
- создать объект Comparator с методом compare()

### ___Comparable\<T>___

Интерфейс java.lang.Comparable<T> указывает, как два объекта должны сравниваться
в смысле упорядочения. Этот интерфейс определяет один абстрактный метод:

- int compareTo(T o) - возвращает отрицательное целое, ноль или положительное
  целое число, если данный объект меньше, равен или больше заданного.

Этот способ ссылается на естественный порядок сравнения, и метод compareTo()
ссылается на метод естественного сравнения.
Строго рекомендуется, чтобы метод compareTo() был совместимым с equals() и
hashCode() (наследуемых из java.lang.Object):

1. Если compareTo() возвращает ноль, то equals() должен воз вращать true.
2. Если equals() возвращает true, то hashCode() будет создавать то же int.

Все восемь классов-оболочек базовых типов (Byte, Short, Integer, Long, Float,
Double, Character и Boolean) реализуют интерфейс Comparable с методом
compareTo(), использующим порядок номеров.

