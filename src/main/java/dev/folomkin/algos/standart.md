# Алгоритмы Java

## Сложность алгоритмов

## Ключевые

1. Алгоритмы сортировки массива:
    * пузырьковая сортировка,
    * сортировка выбором,
    * сортировка вставкой,
    * сортировка Шелла,
    * быстрая сортировка,
    * сортировка слиянием.

2. Жадный алгоритм.
3. Алгоритмы поиска пути
    * обход в глубину,
    * обход в ширину.
4. Транспортный алгоритм — алгоритм Дейкстры.

Также:

- среднее арифметическое;
- числа Фибоначчи;
- метод swap;
- реверс массива;
- сортировка выбором;
- поиск элемента в массиве.

## Алгоритмы сортировки

### Пузырьковая сортировка

Данный алгоритм сортировки прост, но имеет одну из наиболее низких скоростей
выполнения. Представим себе цепочку случайно расставленных чисел в возрастающем
порядке, для которых будут выполняться следующие шаги, начиная с начала цепочки:

- сравнить два числа;
- если число слева больше, то поменять их местами;
- перейти на одну позицию вправо.

После прохождения по всей цепочке наибольшее число окажется в конце нашего ряда
чисел. Далее шаги повторяются. Но не включается последний элемент списка, так
как он самый большой и уже стоит на последнем месте, как и должен.
Опять, же мы получим последний элемент в конце нашего ряда рассматриваемых
чисел. Соответственно, уже два наибольших числа будут стоять на своих местах.
И опять запускается проход по цепочке за исключением элементов, которые уже на
своих местах, до тех пор, пока все элементы не будут стоять в необходимом
порядке.

```java
public class Code {
    public static void main(String[] args) {
        int[] testArr = new int[]{6, 3, 8, 2, 6, 9, 4, 11, 1};
        bubbleSort(testArr);
        System.out.println(Arrays.toString(testArr));

    }

    public static void bubbleSort(int[] arr) {
        int tmp = 0, k = arr.length - 2;
        boolean is_swap = false;
        for (int i = 0; i <= k; i++) {
            is_swap = false;
            for (int j = k; j >= i; j--) {
                if (arr[j] > arr[j + 1]) {
                    tmp = arr[j + 1];
                    arr[j + 1] = arr[j];
                    arr[j] = tmp;
                    is_swap = true;
                }
            }

            // Если перестановок не было, то выходим
            if (is_swap == false) break;
        }
    }
}
```

Временная сложность O(N²), так как имеются вложенные циклы. Внешний проход по
элементам выполняется за N раз, внутренний — тоже N раз, и в итоге мы получаем
N*N, N² итераций.

### Сортировка методом выбора

Дан ряд чисел, которые необходимо расставить в возрастающем порядке.
Суть алгоритма заключается в последовательном переборе всех чисел и выборе
наименьшего элемента, который мы возьмём и поменяем местами с крайним элементом
слева (0 элементом). Тут у нас получается ситуация, схожая с пузырьковой
сортировкой, но в данном случае отсортированным элементом у нас будет
наименьший. Поэтому, следующий проход по элементам будет начинаться с элемента
под индексом 1. Опять же, данные проходы будет повторяться до тех пор, пока все
элементы не будут отсортированы.

```java
public class Solution {
    public static void main(String[] args) {
        int[] testArr = new int[]{6, 3, 8, 2, 6, 9, 4, 11, 1};
        sortBySelect(testArr);
        for (int i : testArr) {
            System.out.println(i);
        }
    }

    public static void sortBySelect(int[] array) {

        for (int i = 0; i < array.length - 1; i++) { // внешний обычный  цикл
            int min = i;

            for (int j = i + 1; j < array.length; j++) { // обычный цикл, но с отчетом с сортированных чисел
                if (array[j] < array[min]) {
                    min = j;
                }
            }
            int temp = array[i];     // вставка отссортиованного числа, в положеную ему ячейку
            array[i] = array[min];
            array[min] = temp;
        }
    }
}

```

Данный алгоритм превосходит пузырьковую сортировку, ведь тут количество
необходимых перестановок сокращается с O(N²) до O(N): мы не гоняем один элемент
через весь список, но тем не менее, количество сравнений остается O(N²).

### Сортировка методом вставки

Дан ряд чисел, которые необходимо расставить в возрастающем порядке. Данный
алгоритм заключается в выставлении маркера, слева
от которого элементы будут уже частично отсортированы между собой. На каждом
шаге алгоритма будет выбираться один из элементов и помещаться на нужную позицию
в уже отсортированной последовательности. Таким образом, отсортированная часть
будет увеличиваться до тех пор, пока не будут просмотрены все элементы. Вы
спросите: а где же взять ту часть элементов, которые уже отсортированы и
после которых и нужно ставить маркер?

Но ведь массив из первого элемента уже отсортирован, не так ли?

```java
public class Solution {
    public static void main(String[] args) {
        int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
        insertionSort(testArr);
        for (int i : testArr) {
            System.out.println(i);
        }
    }

    public static void insertionSort(int[] array) {

        for (int i = 1; i < array.length; i++) { // i - разделяющий маркер
            int temp = array[i]; // делаем копию помеченного элемента
            int j = i;
            while (j > 0 && array[j - 1] >= temp) { // пока не будет найден меньший элемент
                array[j] = array[j - 1]; // сдвигаем элементы вправо
                --j;
            }
            array[j] = temp;   // вставляем отмеченный элемент, в положеное ему место
        }
    }
}
```

Данный вид сортировки превосходит вышеописанные, так как несмотря на то, что
время работы такое же — O(N²), этот алгоритм работает вдвое быстрее пузырьковой
сортировки и немного быстрее сортировки выбором.

### Сортировка Шелла

Данная сортировка, по своей природе является модифицированной сортировкой
методом вставки. Выбирается шаг, причем к у этого выбора есть много подходов.
Слишком подробно разбираться в этом вопросе не будем. Поделим наш массив пополам
и получим некоторое число — это и будет нашим шагом. Итак, если у нас в массиве
9 элементов, то наш шаг будет 9/2 = 4,5. Дробную часть мы отбросим и получим 4,
так как индексы массивов — только целые
числа.
С помощью данного шага мы составим связи для наших групп. Если элемент имеет
индекс 0, то индекс следующего элемента в его группе — 0+4, то есть 4. Третий
элемент будет иметь индекс 4+4, четвертый — 8+4, и так далее.

У второй группы первый элемент будет 1,5,9….

В третьей и четвертой группе дела будут обстоять точно так же.

В итоге из массива чисел {6,3,8,8,6,9,4,11,1} мы получим четыре группы:
I — {6,6,1}
II — {3,9}
III — {8,4}
IV — {8,11}

Свои места в общем массиве они сохраняют, но для нас они помечены как участники
одной группы:
{6,3,8,8,6,9,4,11,1}

Далее внутри этих групп происходит описанная выше сортировка вставками, после
которой группы будут иметь вид:
I — {1,6,6}
II — {3,9}
III — {4,8}
IV — {8,11}

В общем массиве ячейки, занимаемые группами, останутся теми же, но внутри них
изменится порядок, согласно порядку групп выше:
{1,3,4,8,6,9,8,11,6}

Массив стал немного более упорядоченным, не так ли?

Следующий шаг, будет поделен на 2:
4/2 = 2

Имеем две группы:
I — {1,4,6,8,6}
II — {3,8,9,11}

B общий массив:
{1,3,4,8,6,9,8,11,6}

Проходим по обеим группам алгоритмом сортировки вставкой, и получаем массив:
{1,3,4,8,6,9,6,11,8}

Сейчас наш массив почти отсортирован. Осталась последняя итерация алгоритма:
делим шаг на 2: 2/2 = 1.

Мы получаем группу, весь массив:
{1,3,4,8,6,9,6,11,8}

По которому проходим алгоритмом сортировки вставкой и получаем:
{1,3,4,6,6,8,8,9,11}

Давайте посмотрим, как мы может отобразить данную сортировку в Java-коде:

```java
public class Solution {
    public static void main(String[] args) {
        int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
        sortBySelect(testArr);
        for (int i : testArr) {
            System.out.println(i);
        }
    }

    public static void sortBySelect(int[] array) {
        int length = array.length;
        int step = length / 2;
        while (step > 0) {
            for (int numberOfGroup = 0; numberOfGroup < length - step; numberOfGroup++) {// проходим по всем нашим группам
                int j = numberOfGroup;
                while (j >= 0 && array[j] > array[j + step]) {//сортировка вставкой внутри группы
                    int temp = array[j];
                    array[j] = array[j + step];
                    array[j + step] = temp;
                    j--;
                }
            }
            step = step / 2; // уменьшаем наш шаг
        }
    }
}
```

На данный момент толком не обоснована эффективность сортировки Шелла, так как в
разных ситуациях результаты отличаются. Оценки, полученные на основании
экспериментов, лежат в интервале от O(N3/2) до O(N7/6).

### Быстрая сортировка

Это один из самых популярных алгоритмов, и поэтому на него стоит обратить особое
внимание.

Суть данного алгоритма заключается в том, что в списке с элементами выбирается
опорный элемент — по сути любой элемент, относительно которого нужно
отсортировать остальные значения. Значения меньше его — слева, значения больше —
справа.

Далее у правой и левой части также выбирается по опорному элементу и происходит
то же самое: сортируются значения относительно этих элементов, потом у
образовавшихся частей выбираются опорные элементы — и так до тех пор, пока мы не
получим отсортированный ряд.

Данный алгоритм в Java реализуется с помощью рекурсии:

```java
public class Solution {
    public static void main(String[] args) {
        int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
        fastSort(testArr);
        for (int i : testArr) {
            System.out.println(i);
        }
    }

    public static void fastSort(int[] array) {
        recursionFastSort(array, 0, array.length - 1);
    }


    public static void recursionFastSort(int[] array, int min, int max) {
        if (array.length == 0)// условие выхода из рекурсии,  если длина массива равна 0
            return;

        if (min >= max) //выходим, так как нечего уже делить
            return;


        int middle = min + (max - min) / 2;  // выбираем середину
        int middleElement = array[middle];


        int i = min, j = max;
        while (i <= j) {  // относительно элемента middle определяемменьшие элементы слева, большие справа
            while (array[i] < middleElement) {
                i++;
            }
            while (array[j] > middleElement) {
                j--;
            }

            if (i <= j) {      //меняем местами
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                i++;
                j--;
            }
        }

        if (min < j) // запускаем рекурсию с элементами меньшими чем middle
            recursionFastSort(array, min, j);

        if (max > i)// запускаем рекурсию с элементами большими чем middle
            recursionFastSort(array, i, max);
    }
}
```

Вне всяких сомнений, алгоритм быстрой сортировки считается самым популярным, так
как в большинстве ситуаций он выполняется быстрее остальных, за время O(N*logN).

### Сортировка слиянием

Эта сортировка тоже популярна. Она относится к одному из видов алгоритмов,
работающих по принципу «разделяй и властвуй»: в них мы в первую очередь делим
задачи на минимальные части (также представителем таких алгоритмов является
быстрая сортировка).

Итак, в чём же суть данного алгоритма?

**_Разделяй_**:  
Массив разбивается на две части примерно одинакового размера, каждая из этих
двух частей делится еще на две, и так далее, пока не останутся наименьшие
неделимые части.

Наименьшие неделимые части — это когда в каждом массиве есть по одному элементу,
а значит, такой массив автоматически считается отсортированным.
**_Властвуй:**_  
Тут и начинается процесс, задавший название алгоритму — слияние. Для этого
берутся два получившиеся упорядоченных массива и сливаются в один. При этом
наименьший из первых элементов двух массивов записывается в результирующий
массив, и эта операция повторяется, пока не закончатся элементы в этих двух
массивах.

То есть, если у нас есть два минимальных массива {6} и {4}, их значения будут
сравнены и записан результат: {4,6}.

Если будут отсортированные массивы {4,6} и {2,8}, то сперва сравнится значение 4
и 2, из которых 2 будет записано в результирующий массив. После этого будет
сравниваться 4 и 8, 4 будет записано, и в конце сравнится 6 и 8. Соответственно,
6 будет записано, и только после него — 8. В итоге мы получим результирующий
массив: {2,4,6,8}.

Каким же образом это будет выглядеть в Java-коде?

Для обработки данного алгоритма нам будет удобно воспользоваться рекурсией:

```java
public class Solution {
    public static void main(String[] args) {
        int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
        testArr = mergeSort(testArr);
        for (int i : testArr) {
            System.out.println(i);
        }
    }

    public static int[] mergeSort(int[] array1) {
        int[] sortArr = Arrays.copyOf(array1, array1.length);// массив для сортировки
        int[] bufferArr = new int[array1.length];// буферный массив
        return recurtionMergeSort(sortArr, bufferArr, 0, array1.length);
    }


    public static int[] recurtionMergeSort(int[] sortArr, int[] bufferArr,
                                           int startIndex, int endIndex) {
        if (startIndex >= endIndex - 1) {// выход из массива, когда в рассматриваемом промежутке массива, только один элемент
            return sortArr;
        }

        // запускаем рекурсию, чтобы получить два отсортированных массива:
        int middle = startIndex + (endIndex - startIndex) / 2;
        int[] firstSortArr = recurtionMergeSort(sortArr, bufferArr, startIndex, middle);
        int[] secondSortArr = recurtionMergeSort(sortArr, bufferArr, middle, endIndex);

        // Слияние отсортированных массивов:
        int firstIndex = startIndex;
        int secondIndex = middle;
        int destIndex = startIndex;
        int[] result = firstSortArr == sortArr ? bufferArr : sortArr;
        while (firstIndex < middle && secondIndex < endIndex) {
            result[destIndex++] = firstSortArr[firstIndex] < secondSortArr[secondIndex]
                    ? firstSortArr[firstIndex++] : secondSortArr[secondIndex++];
        }
        while (firstIndex < middle) {
            result[destIndex++] = firstSortArr[firstIndex++];
        }
        while (secondIndex < endIndex) {
            result[destIndex++] = secondSortArr[secondIndex++];
        }
        return result;
    }
}
```

Как и в быстрой сортировке, мы выносим рекурсивный метод в промежуточный, чтобы
пользователю не нужно было заморачиваться над заданием дополнительных дефолтных
аргументов, а можно было всего лишь задать массив, который необходимо
отсортировать.

Так как данный алгоритм имеет схожесть с быстрей сотрировкой, то и скорость его
выполнения та же — O(N*logN).

## Жадный алгоритм

Жадный алгоритм — это подход, при котором на каждом этапе принимаются локально
оптимальные решения и допускается, что конечное решение также окажется
оптимальным. “Оптимальное” решение — то, которое предлагает наиболее очевидную и
немедленную выгоду на определенном шаге/этапе.

Чтобы рассмотреть данный алгоритм, выберем довольно распространенную задачу — о
рюкзаке.

Давайте на секунду представим, что вы вор. Вы вломились ночью в магазин с
рюкзаком, и перед вами некоторое множество товаров, которые вы можете украсть.
Но при этом вместимость рюкзака ограничена — не более 30 условных единиц. В тоже
время вы хотите унести набор товаров максимальной стоимости, которые только
влезут в рюкзак.

Как вы определите, что положить?

Итак, жадный алгоритм для задачи о рюкзаке состоит в следующих шагах (считаем,
что все предметы помещаются в рюкзак):

1. Выбрать максимально дорогой предмет из еще не затронутых.
2. Если он помещается в рюкзак, положить его туда, если нет — пропускаем.
3. Все предметы перебрали? Если нет — возвращаемся к 1 пункту, если да — бежим
   из магазина, так как наша цель тут выполнена.

Так будет выглядеть класс предмета Item:

```java
public class Item implements Comparable<Item> {
    private String name;
    private int weight;
    private int cost;

    public Item(String name, int weight, int cost) {
        this.name = name;
        this.weight = weight;
        this.cost = cost;
    }

    public String getName() {
        return name;
    }

    public int getWeight() {
        return weight;
    }

    public int getCost() {
        return cost;
    }

    @Override
    public int compareTo(Item o) {
        return this.cost > o.cost ? -1 : 1;
    }
}
```

Тут ничего особого: три поля — name, weight, cost — для задания характеристик
предмета.

Также, как вы можете видеть, тут реализован интерфейс Comparable таким образом,
чтобы мы могли сортировать наши Item по цене.

Дальше смотрим на класс нашего рюкзака — Bag:

```java
public class Bag {
    private final int maxWeight;
    private List<Item> items;
    private int currentWeight;
    private int currentCost;

    public Bag(int maxWeight) {
        this.maxWeight = maxWeight;
        items = new ArrayList<>();
        currentCost = 0;
    }

    public int getMaxWeight() {
        return maxWeight;
    }

    public int getCurrentCost() {
        return currentCost;
    }

    public int getCurrentWeight() {
        return currentWeight;
    }

    public void addItem(Item item) {
        items.add(item);
        currentWeight += item.getWeight();
        currentCost += item.getCost();
    }
}

```

- maxWeight — вместимость нашего рюкзака, которая задаётся при создании объекта;
- items — объекты находящиеся в рюкзаке;
- currentWeight, currentCost — текущий вес и стоимость всех вещей в рюкзаке,
  которые мы увеличиваем при добавлении нового предмета в методе addItem.

Собственно перейдем в класс, где и происходит всё действие:

```java
public class Solution {

    public static void main(String[] args) {
        List<Item> items = new ArrayList<>();
        items.add(new Item("гитара", 7, 800));
        items.add(new Item("утюг", 6, 500));
        items.add(new Item("чайник", 3, 300));
        items.add(new Item("лампа", 4, 500));
        items.add(new Item("телевизор", 15, 2000));
        items.add(new Item("ваза", 2, 450));
        items.add(new Item("миксер", 1, 400));
        items.add(new Item("блендер", 3, 200));

        Collections.sort(items);

        Bag firstBag = new Bag(30);

        fillBackpack(firstBag, items);

        System.out.println("Вес рюкзака состовляет - " + firstBag.getCurrentWeight() +
                ", общая стоимость вещей в рюкзаке - " + firstBag.getCurrentCost());
    }
}
```

Для начала мы создаем список элементов, сортируем его. Создаем объект сумки с
вместимость 30 единиц.

Далее отправляем элементы и объект сумки в метод fillBackpack, в котором,
собственно, и заполняется рюкзак по жадному алгоритму:

```java
public static void fillBackpack(Bag bag, List<Item> items) {
    for (Item item : items) {
        if (bag.getMaxWeight() > bag.getCurrentWeight() + item.getWeight()) {
            bag.addItem(item);
        }
    }
}

```

Всё предельно просто: мы начинаем проходить по отсортированному по стоимости
списку элементов и складывать их в сумку, если позволяет вместимость. Если же не
позволяет, элемент будет пропущен и продолжится проход по остальным элементам до
конца списка.

Запустив main, мы получим вывод в консоль:

    Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 3700

Собственно, это и есть пример жадного алгоритма: на каждом шагу выбирается
локально-оптимальное решение, а в итоге вы получаете глобально-оптимальное
решение.  
В нашем случае оптимальный вариант — это наиболее дорогой предмет.    
Но является ли это лучшим решением? Вам не кажется, что можно немного
модернизировать наше решение, чтобы можно было укомплектовать рюкзак с более
высокой суммарной стоимостью?  
Давайте взглянем, как это можно сделать:

```java
public static void effectiveFillBackpack(Bag bag, List<Item> items) {
    Map<Double, Item> sortByRatio = new TreeMap(Collections.reverseOrder());
    for (Item item : items) {
        sortByRatio.put((double) item.getCost() / item.getWeight(), item);
    }

    for (Map.Entry<Double, Item> entry : sortByRatio.entrySet()) {
        if (bag.getMaxWeight() > bag.getCurrentWeight() + entry.getValue().getWeight()) {
            bag.addItem(entry.getValue());
        }
    }
}
```

Тут мы в первую очередь вычисляем соотношение веса и цены для каждого предмета.
Так сказать, сколько стоит одна единица данного предмета. И уже по этим
значениям мы сортируем наши предметы и добавляем в нашу сумку.

Запустим:

```code
Bag secondBag = new Bag(30); 
effectiveFillBackpack(secondBag, items);
System.out.println("Вес рюкзака составляет - " + secondBag.getCurrentWeight() +
  ", общая стоимость вещей в рюкзаке - " + secondBag.getCurrentCost());

```

Получаем вывод в консоль:

    Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 4150

Немного лучше, не правда ли?

Жадный алгоритм на каждом шагу делает локально оптимальный выбор в расчете на
то, что итоговое решение также будет оптимальным. Это не всегда оправдано, но
для многих задач жадные алгоритмы действительно дают оптимум.

Временная сложность данного алгоритма — O(N), довольно неплохо, не так ли?



____

## Граф

Граф — одна из самых гибких и универсальных структур в программировании.

Граф G обычно задается при помощи пары множеств G = (V, R), где:

- V — множество вершин;
- R — множество линий, соединяющих пары вершин.

Обычные соединяющие линии называют ребрами:

____

## Алгоритмы поиска

### Линейный поиск

```java
public static void main(String[] args) {
    int i = linearSearch(new int[]{1, 2, 3, 4, 5}, 3);
    System.out.println(i);
}

public static void print(int elementToSearch, int index) {
    if (index == -1) {
        System.out.println(elementToSearch + " not found.");
    } else {
        System.out.println(elementToSearch + " found at index: " + index);
    }
}

public static int linearSearch(int arr[], int elementToSearch) {
    for (int index = 0; index < arr.length; index++) {
        if (arr[index] == elementToSearch)
            return index;
    }
    return -1;
}
```

Сложности:

- Чтобы получить позицию искомого компонента, будет перебираться набор из N
  элементов.
- При худшем сценарии для соответствующего алгоритма искомый компонент –
  последний в массиве.
- Для последней описанной ситуации потребуется N итераций.

Сложность линейного варианта – O(N).

**Применение**

Линейный поиск можно использовать для малого, несортированного набора данных,
который не увеличивается в размерах.
Несмотря на простоту, алгоритм не находит применения в проектах из-за линейного
увеличения временной сложности.

### Двоичный поиск (Логарифмический/"разделяй и властвуй")

Этот вид поиска использует подход «Разделяй и властвуй», требует предварительной
сортировки набора данных.
Алгоритм делит входную коллекцию на равные половины, и с каждой итерацией
сравнивает целевой элемент с элементом в середине. Поиск заканчивается при
нахождении элемента. Иначе продолжаем искать элемент, разделяя и выбирая
соответствующий раздел массива. Целевой элемент сравнивается со средним.
Вот почему важно иметь отсортированную коллекцию при использовании двоичного
поиска.
Поиск заканчивается, когда firstIndex (указатель) достигает lastIndex (
последнего элемента). Значит мы проверили весь массив Java и не нашли элемента.
Есть два способа реализации этого алгоритма: итеративный и рекурсивный.
Временная и пространственная сложности одинаковы для обоих способов в реализации
на Java.

**Временная сложность**

Временная сложность алгоритма двоичного поиска равна O(log (N)) из-за деления
массива пополам. Она превосходит O(N) линейного алгоритма.

**Пространственная сложность**

Одна единица пространства требуется для хранения искомого элемента.
Следовательно, пространственная сложность равна O(1).
Рекурсивный двоичный поиск хранит вызов метода в стеке. В худшем случае
пространственная сложность потребует O(log (N)).

**Применение**

Этот алгоритм используется в большинстве библиотек и используется с
отсортированными структурами данных.
Двоичный поиск реализован в методе Arrays.binarySearch Java API.

Работает так:

1. Входная коллекция делится на равные половины.
2. С каждой итерацией происходит сравнение целевого элемента с тем, что в
   середине.
3. Поиск заканчивается при нахождении компонента.
4. Если не получилось обнаружить компонент, его поиск происходит далее путем
   разделения и выбора соответствующего раздела массива.

**_Итеративный_**:

```java
public class Code {
    public static void main(String[] args) {
        int index = linearSearch(new int[]{1, 2, 3, 4, 5}, 3);
        print(67, index);
    }

    public static void print(int elementToSearch, int index) {
        if (index == -1) {
            System.out.println(elementToSearch + " not found.");
        } else {
            System.out.println(elementToSearch + " found at index: " + index);
        }
    }

    public static int binarySearch(int arr[], int elementToSearch) {

        int firstIndex = 0;
        int lastIndex = arr.length - 1;

        // условие прекращения (элемент не представлен)
        while (firstIndex <= lastIndex) {
            int middleIndex = (firstIndex + lastIndex) / 2;
            // если средний элемент - целевой элемент, вернуть его индекс
            if (arr[middleIndex] == elementToSearch) {
                return middleIndex;
            }

            // если средний элемент меньше
            // направляем наш индекс в middle+1, убирая первую часть из рассмотрения
            else if (arr[middleIndex] < elementToSearch)
                firstIndex = middleIndex + 1;

                // если средний элемент больше
                // направляем наш индекс в middle-1, убирая вторую часть из рассмотрения
            else if (arr[middleIndex] > elementToSearch)
                lastIndex = middleIndex - 1;
        }
        return -1;
    }
}

```

**_Рекурсивный_**:

Рекурсивный подход отличается вызовом самого метода при получении нового
раздела. В итеративном подходе всякий раз, когда мы определяли новый раздел, мы
изменяли первый и последний элементы, повторяя процесс в том же цикле.
Другое отличие – рекурсивные вызовы помещаются в стек и занимают одну единицу
пространства за вызов.

```java

public static int recursiveBinarySearch(int arr[], int firstElement, int lastElement, int elementToSearch) {
    // условие прекращения
    if (lastElement >= firstElement) {
        int mid = firstElement + (lastElement - firstElement) / 2;

        // если средний элемент - целевой элемент, вернуть его индекс
        if (arr[mid] == elementToSearch)
            return mid;

        // если средний элемент больше целевого
        // вызываем метод рекурсивно по суженным данным
        if (arr[mid] > elementToSearch)
            return recursiveBinarySearch(arr, firstElement, mid - 1, elementToSearch);

        // также, вызываем метод рекурсивно по суженным данным
        return recursiveBinarySearch(arr, mid + 1, lastElement, elementToSearch);
    }
    return -1;
}

```

### Алгоритм Кнута – Морриса – Пратта

Алгоритм КМП осуществляет поиск текста по заданному шаблону. Он разработан
Дональдом Кнутом, Воном Праттом и Джеймсом Моррисом: отсюда и название.
В этом поиске сначала компилируется заданный шаблон. Компилируя шаблон, мы
пытаемся найти префикс и суффикс строки шаблона. Это поможет в случае
несоответствия – не придётся искать следующее совпадение с начального индекса.
Вместо этого мы пропускаем часть текстовой строки, которую уже сравнили, и
начинаем сравнивать следующую. Необходимая часть определяется по префиксу и
суффиксу, поэтому известно, какая часть уже прошла проверку и может быть
безопасно пропущена.
КМП работает быстрее алгоритма перебора благодаря пропускам.

**Реализация:**

```java
package dev.folomkin.algos;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Code {
    public static void main(String[] args) {

/*
        В текстовом шаблоне AAABAAA наблюдается и кодируется в массив шаблонов следующий шаблон:
        Шаблон A (Одиночная A) повторяется в 1 и 4 индексах.
        Паттерн AA (Двойная A) повторяется во 2 и 5 индексах.
        Шаблон AAA (Тройная A) повторяется в индексе 6.
        Описанный выше шаблон ясно показан в скомпилированном массиве.
        С помощью этого массива КМП ищет заданный шаблон в тексте, не возвращаясь в начало текстового массива.
*/
        String pattern = "AAABAAA";
        String text = "ASBNSAAAAAABAAAAABAAAAAGAHUHDJKDDKSHAAJF";
        List<Integer> foundIndexes = Code.performKMPSearch(text, pattern);

        if (foundIndexes.isEmpty()) {
            System.out.println("Pattern not found in the given text String");
        } else {
            System.out.println("Pattern found in the given text String at positions: " +.stream().map(Object::toString).collect(Collectors.joining(", ")))
            ;
        }
    }

    public static int[] compilePatternArray(String pattern) {

//    Скомпилированный массив Java можно рассматривать как массив, хранящий шаблон
//    символов. Цель – найти префикс и суффикс в шаблоне. Зная эти элементы, можно
//    избежать сравнения с начала текста после несоответствия и приступать к сравнению
//    следующего символа.
//    Скомпилированный массив сохраняет позицию предыдущего местонахождения текущего
//    символа в массив шаблонов.

        int patternLength = pattern.length();
        int len = 0;
        int i = 1;
        int[] compliedPatternArray = new int[patternLength];
        compliedPatternArray[0] = 0;

        while (i < patternLength) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                compliedPatternArray[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = compliedPatternArray[len - 1];
                } else {
                    compliedPatternArray[i] = len;
                    i++;
                }
            }
        }
        System.out.println("Compiled Pattern Array " + Arrays.toString(compliedPatternArray));
        return compliedPatternArray;
    }

    public static List<Integer> performKMPSearch(String text, String pattern) {

    /*    Здесь мы последовательно сравниваем символы в шаблоне и
        текстовом массиве. Мы продолжаем двигаться вперёд, пока не получим
        совпадение. Достижение конца массива при сопоставлении означает
        нахождение шаблона в тексте.

        Если обнаружено несоответствие при сравнении двух массивов, индекс
        символьного массива перемещается в значение compiledPatternArray().
        Затем мы переходим к следующему символу в текстовом массиве.
        КМП превосходит метод грубой силы однократным сравнением текстовых
        символов при несоответствии.
    */

        int[] compliedPatternArray = compilePatternArray(pattern);

        int textIndex = 0;
        int patternIndex = 0;

        List<Integer> foundIndexes = new ArrayList<>();

        while (textIndex < text.length()) {
            if (pattern.charAt(patternIndex) == text.charAt(textIndex)) {
                patternIndex++;
                textIndex++;
            }
            if (patternIndex == pattern.length()) {
                foundIndexes.add(textIndex - patternIndex);
                patternIndex = compliedPatternArray[patternIndex - 1];
            } else if (textIndex < text.length() && pattern.charAt(patternIndex) != text.charAt(textIndex)) {
                if (patternIndex != 0)
                    patternIndex = compliedPatternArray[patternIndex - 1];
                else
                    textIndex = textIndex + 1;
            }
        }
        return foundIndexes;
    }

}

```

**Временная сложность**     
Для поиска шаблона алгоритму нужно сравнить все элементы в заданном тексте.
Необходимое для этого время составляет O(N). Для составления строки шаблона нам
нужно проверить каждый символ в шаблоне – это еще одна итерация O(M).
O (M + N) – общее время алгоритма.

**Пространственная сложность**  
O(M) пространства необходимо для хранения скомпилированного шаблона для
заданного шаблона размера M.

**Применение**  
Этот алгоритм используется в текстовых инструментах для поиска шаблонов в
текстовых файлах.

### Поиск прыжками

От двоичного поиска этот алгоритм отличает движение исключительно
вперёд. Такой поиск требует отсортированной коллекции.  
Мы прыгаем вперёд на интервал sqrt(arraylength), пока не достигнем элемента
большего, чем текущий элемент или конца массива. При каждом прыжке записывается
предыдущий шаг.  
Прыжки прекращаются, когда найден элемент больше искомого. Затем запускаем
линейный поиск между предыдущим и текущим шагами.  
Это уменьшает поле поиска и делает линейный поиск жизнеспособным вариантом.

**Временная сложность**  
Поскольку в каждой итерации мы перепрыгиваем на шаг, равный sqrt(arraylength),
временная сложность этого поиска составляет O(sqrt (N)).

**Пространственная сложность**  
Искомый элемент занимает одну единицу пространства, поэтому пространственная
сложность алгоритма составляет O(1).

**Применение**  
Этот поиск используется поверх бинарного поиска, когда прыжки в обратную сторону
затратны.

```java

public static void main(String[] args) {
    int index = jumpSearch(new int[]{3, 22, 27, 47, 57, 67, 89, 91, 95, 99}, 67);
    print(67, index);
}

public static int jumpSearch(int[] integers, int elementToSearch) {
/*
   Мы начинаем с jumpstep размером с корень квадратный от длины массива и 
   продолжаем прыгать вперёд с тем же размером, пока не найдём элемент, 
   который будет таким же или больше искомого элемента.
   
   Сначала проверяется элемент integers[jumpStep], затем integers[2jumpStep], 
   integers[3jumpStep] и так далее. Проверенный элемент сохраняется в 
   переменной previousStep.
   
   Когда найдено значение, при котором
   integers[previousStep] < elementToSearch < integers[jumpStep], 
   производится линейный поиск между integers[previousStep] и 
   integers[jumpStep] или элементом большим, чем elementToSearch.
 */

    int arrayLength = integers.length;
    int jumpStep = (int) Math.sqrt(integers.length);
    int previousStep = 0;

    while (integers[Math.min(jumpStep, arrayLength) - 1] < elementToSearch) {
        previousStep = jumpStep;
        jumpStep += (int) (Math.sqrt(arrayLength));
        if (previousStep >= arrayLength)
            return -1;
    }
    while (integers[previousStep] < elementToSearch) {
        previousStep++;
        if (previousStep == Math.min(jumpStep, arrayLength))
            return -1;
    }

    if (integers[previousStep] == elementToSearch)
        return previousStep;
    return -1;
}

```

### Интерполяционный поиск

Интерполяционный поиск используется для поиска элементов в отсортированном
массиве. Он полезен для равномерно распределенных в структуре данных.
При равномерно распределенных данных местонахождение элемента определяется
точнее. Тут и вскрывается отличие алгоритма от бинарного поиска, где мы пытаемся
найти элемент в середине массива.
Для поиска элементов в массиве алгоритм использует формулы интерполяции.
Эффективнее применять эти формула для больших массивов. В противном случае
алгоритм работает как линейный поиск.

```java
public static void main(String[] args) {
    int index = interpolationSearch(new int[]{1, 2, 3, 4, 5, 6, 7, 8}, 6);
    print(67, index);
}

public static int interpolationSearch(int[] integers, int elementToSearch) {

    int startIndex = 0;
    int lastIndex = (integers.length - 1);

    while ((startIndex <= lastIndex) && (elementToSearch >= integers[startIndex]) &&
            (elementToSearch <= integers[lastIndex])) {
        // используем формулу интерполяции для поиска возможной лучшей позиции для существующего элемента
        int pos = startIndex + (((lastIndex - startIndex) /
                (integers[lastIndex] - integers[startIndex])) *
                (elementToSearch - integers[startIndex]));

        if (integers[pos] == elementToSearch)
            return pos;

        if (integers[pos] < elementToSearch)
            startIndex = pos + 1;

        else
            lastIndex = pos - 1;
    }
    return -1;
}

```

Смотрите, как работают формулы интерполяции, чтобы найти 6:

    startIndex = 0  
    lastIndex = 7  
    integers[lastIndex] = 8  
    integers[startIndex] = 1  
    elementToSearch = 6

Теперь давайте применим эти значения к формулам для оценки индекса элемента
поиска:

index=0+(7−0)/(8−1)∗(6−1)=5

Элемент integers[5] равен 6 — это элемент, который мы искали. Индекс для
элемента рассчитывается за один шаг из-за равномерной распределенности данных.

**Временная сложность**  
В лучшем случае временная сложность такого алгоритма – O(log log N). При
неравномерном распределении элементов сложность сопоставима с временной
сложностью линейного алгоритма, которая = O(N).

**Пространственная сложность**  
Алгоритм требует одну единицу пространства для хранения элемента для поиска. Его
пространственная сложность = O(1).

**Применение**  
Алгоритм полезно применять для равномерно распределенных данных вроде телефонной
книги.

### Экспоненциальный поиск

Экспоненциальный поиск используется для поиска элементов путём перехода в
экспоненциальные позиции, то есть во вторую степень.
В этом поиске мы пытаемся найти сравнительно меньший диапазон и применяем на нем
двоичный алгоритм для поиска элемента.
Для работы алгоритма коллекция должна быть отсортирована.

```java
public static void main(String[] args) {
    int index = exponentialSearch(new int[]{3, 22, 27, 47, 57, 67, 89, 91, 95, 99}, 67);
    print(67, index);
}

public static int exponentialSearch(int[] integers, int elementToSearch) {
    if (integers[0] == elementToSearch)
        return 0;
    if (integers[integers.length - 1] == elementToSearch)
        return integers.length;
    int range = 1;
    while (range < integers.length && integers[range] <= elementToSearch) {
        range = range * 2;
    }
    return Arrays.binarySearch(integers, range / 2, Math.min(range, integers.length), elementToSearch);
}

```

Мы пытаемся найти элемент больше искомого. Зачем? Для минимизации диапазона
поиска. Увеличиваем диапазон, умножая его на 2, и снова проверяем, достигли ли
мы элемента больше искомого или конца массива. При нахождении элемента мы
выходим из цикла. Затем выполняем бинарный поиск с startIndex в качестве range/2
и lastIndex в качестве range.
В нашем случае значение диапазона достигается в элементе 8, а элемент в
integers[8] равен 95. Таким образом, диапазон, в котором выполняется бинарный
поиск:

    startIndex = range/2 = 4
    lastIndex = range = 8

При этом вызываем бинарный поиск:

    Arrays.binarySearch(integers, 4, 8, 6);

Здесь важно отметить, что можно ускорить умножение на 2, используя оператор
левого сдвига range << 1 вместо *.

**Временная сложность**  
В худшем случае временная сложность этого поиска составит O(log (N)).

**Пространственная сложность**  
Итеративный алгоритм двоичного поиска требует O(1) места для хранения искомого
элемента.
Для рекурсивного двоичного поиска пространственная сложность становится равной
O(log (N)).

**Применение**  
Экспоненциальный поиск используется с большими массивами, когда бинарный поиск
затратен. Экспоненциальный поиск разделяет данные на более доступные для поиска
разделы.

## Алгоритмы сортировки