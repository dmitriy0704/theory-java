# Алгоритмы сортировки Java

1. Алгоритмы сортировки массива:
    * пузырьковая сортировка
    * сортировка вставкой
    * быстрая сортировка
    * сортировка слиянием
    * сортировка выбором
    * пирамидальная сортировка
    * встроенные функции сортировки Java
    * сортировка Шелла

2. Жадный алгоритм.
3. Алгоритмы поиска пути
    * обход в глубину,
    * обход в ширину.
4. Транспортный алгоритм — алгоритм Дейкстры.

Также:

- среднее арифметическое;
- числа Фибоначчи;
- метод swap;
- реверс массива;
- сортировка выбором;
- поиск элемента в массиве.

## Пузырьковая сортировка

Данный алгоритм сортировки прост, но имеет одну из наиболее низких скоростей
выполнения. Представим себе цепочку случайно расставленных чисел в возрастающем
порядке, для которых будут выполняться следующие шаги, начиная с начала цепочки:

- сравнить два числа;
- если число слева больше, то поменять их местами;
- перейти на одну позицию вправо.

После прохождения по всей цепочке наибольшее число окажется в конце нашего ряда
чисел. Далее шаги повторяются. Но не включается последний элемент списка, так
как он самый большой и уже стоит на последнем месте, как и должен.
Опять, же мы получим последний элемент в конце нашего ряда рассматриваемых
чисел. Соответственно, уже два наибольших числа будут стоять на своих местах.
И опять запускается проход по цепочке за исключением элементов, которые уже на
своих местах, до тех пор, пока все элементы не будут стоять в необходимом
порядке.
Для сортировки массива из пяти элементов необходимо максимум четыре прохода и
десять сравнений. Если после прохода не было ни одной перестановки, то
сортировку можно прервать. В этом случае для сортировки ранее уже
отсортированного массива нужен всего один проход.
Алгоритм пузырьковой сортировки является одним из самых медленных. Если массив
состоит из N элементов, то на первом проходе будет выполнено N-1 сравнений, на
втором N-2, далее N-3 и т.д. То есть всего будет произведено проходов:

(N-1) + (N-2) + (N-3) + … + 1 = N x (N-1)/2

Таким образом, при сортировке алгоритм выполняет около 0.5х(N^2) сравнений. Для
N = 5, количество сравнений будет примерно 10, для N = 10 количество сравнений
вырастит до 45. Таким образом, с увеличением количества элементов сложность
сортировки значительно увеличивается.

На скорость алгоритма влияет не только количество проходов, но и количество
перестановок, которые потребуется совершить. Для случайных данных количество
перестановок в среднем составляет (N^2) / 4, то есть примерно в половину меньше,
чем количество проходов. Однако, в худшем случае количество перестановок также
может составить N^2 / 2 – это в том случае, если данные изначально отсортированы
в обратном порядке.

![Sortirovka-puzyrkom.gif](/img/algos/sort/Sortirovka-puzyrkom.gif)

```java
public static void bubbleSort(int[] sortArr) {
    for (int i = 0; i < sortArr.length - 1; i++) {
        for (int j = 0; j < sortArr.length - i - 1; j++) {
            if (sortArr[j + 1] < sortArr[j]) {
                int swap = sortArr[j];
                sortArr[j] = sortArr[j + 1];
                sortArr[j + 1] = swap;
            }
        }
    }
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    bubbleSort(sortArr);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}
```

Объяснение
Как видим из кода, метод bubbleSort() принимает массив в качестве входных данных
для сортировки — sortArr. Далее мы создаём внешний цикл for, который перебирает
каждый элемент массива, тогда как внутренний цикл for начинается с первого
элемента массива до предпоследнего индекса: sortArr.length - i - 1. С помощью
условия if мы проверяем, больше ли элемент слева элемента справа или нет. Если
элемент слева действительно больше, он меняется местами с правым элементом.

Примечание Внешний цикл for будет перебирать все элементы массива, даже если
массив уже полностью отсортирован.

Массив, который принимает метод bubbleSort(), может быть любым. В нашем примере
мы передаём значения 12, 6, 4, 1, 15, 10.

Алгоритм хорошо себя показывает с большими наборами данных, где элементы почти
отсортированы и требуется всего одна итерация, чтобы определить, отсортирован ли
список до конца.
В случае с совершенно неотсортированным списком, для пузырьковой сортировки он
должен быть хотя бы небольшим.

![bubbleSort.png](/img/algos/sort/bubbleSort.png)

Временная сложность O(N²), так как имеются вложенные циклы. Внешний проход по
элементам выполняется за N раз, внутренний — тоже N раз, и в итоге мы получаем
N*N, N² итераций.

## Сортировка методом вставки

Дан ряд чисел, которые необходимо расставить в возрастающем порядке. Данный
алгоритм заключается в выставлении маркера, слева от которого элементы будут уже
частично отсортированы между собой. На каждом шаге алгоритма будет выбираться
один из элементов и помещаться на нужную позицию в уже отсортированной
последовательности. Таким образом, отсортированная часть будет увеличиваться до
тех пор, пока не будут просмотрены все элементы.

```java
// ======= //
public static void insertionSort(int[] sortArr) {
    int j;
    //сортировку начинаем со второго элемента, т.к. считается, что первый элемент уже отсортирован
    for (int i = 1; i < sortArr.length; i++) {
        //сохраняем ссылку на индекс предыдущего элемента
        int swap = sortArr[i];
        for (j = i; j > 0 && swap < sortArr[j - 1]; j--) {
            //элементы отсортированного сегмента перемещаем вперёд, если они больше элемента для вставки
            sortArr[j] = sortArr[j - 1];
        }
        sortArr[j] = swap;
    }
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    insertionSort(sortArr);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}
```

Объяснение
Предполагается, что первый элемент списка отсортирован. Переходим к следующему
элементу, обозначим его i. Если х больше первого, оставляем его на своём месте.
Если он меньше, копируем его на вторую позицию, а i устанавливаем в качестве
первого элемента.

Переходя к другим элементам несортированного сегмента, перемещаем более крупные
элементы в отсортированном сегменте вверх по списку, пока не встретим элемент
меньше i или не дойдём до конца списка. В первом случае i помещается на
правильную позицию.

Основная идея этого алгоритма — разделение массива на две части,
отсортированную и неотсортированную. На каждом шаге алгоритма число переходит от
неотсортированной к отсортированной части.

Все элементы считаются неотсортированными.

1. Возьмем первое неотсортированное значение (3) и вставим его в
   отсортированный подмассив. На этом шаге весь отсортированный подмассив, его
   начало и конец и будут этой самой тройкой.
2. Поскольку 3 < 5, мы вставим 5 в отсортированный подмассив справа от 3.
3. Теперь работаем над вставкой числа 2 в наш отсортированный массив.
   Сравниваем 2 со значениями справа налево, чтобы найти правильную позицию.
   Поскольку 2 < 5 и 2 < 3 и мы дошли до начала отсортированного подмассива.
   Следовательно, мы должны вставить 2 слева от 3. Для этого подвигаем 3 и 5
   вправо, чтобы появилось место для двойки и вставляем её в начало массива.
4. Нам повезло: 6 > 5, поэтому мы можем вставить это число сразу за
   числом 5.
5. 4 < 6 и 4 < 5, но 4 > 3. Следовательно, мы знаем, что 4 нужно вставить
   справа от 3.

Снова мы вынуждены подвинуть 5 и 6 вправо, чтобы создать лакуну для 4.

Несмотря на то, что время работы такое же — O(N²), этот алгоритм работает вдвое
быстрее пузырьковой сортировки и немного быстрее сортировки выбором.

В самом плохом случае мы сделаем одно сравнение со вторым элементом, два
сравнения с третьим и так далее. Таким образом, наша скорость равна O(n2).
В лучшем случае мы будем работать с уже отсортированным массивом.
Отсортированная часть, которую мы строим слева направо без вставок и
передвижений элементов займет время Ω(n).

Сложность алгоритма: О(n2) для сравнений и перестановок.

## Быстрая сортировка

Это один из самых популярных алгоритмов, и поэтому на него стоит обратить особое
внимание.

Суть данного алгоритма заключается в том, что в списке с элементами выбирается
опорный элемент — по сути любой элемент, относительно которого нужно
отсортировать остальные значения. Значения меньше его — слева, значения больше —
справа.

Далее у правой и левой части также выбирается по опорному элементу и происходит
то же самое: сортируются значения относительно этих элементов, потом у
образовавшихся частей выбираются опорные элементы — и так до тех пор, пока мы не
получим отсортированный ряд.  
Данный алгоритм в Java реализуется с помощью рекурсии:

```java
public static void quickSort(int[] sortArr, int low, int high) {
    //завершить,если массив пуст или уже нечего делить
    if (sortArr.length == 0 || low >= high) return;

    //выбираем опорный элемент
    int middle = low + (high - low) / 2;
    int border = sortArr[middle];

    //разделияем на подмассивы и меняем местами
    int i = low, j = high;
    while (i <= j) {
        while (sortArr[i] < border) i++;
        while (sortArr[j] > border) j--;
        if (i <= j) {
            int swap = sortArr[i];
            sortArr[i] = sortArr[j];
            sortArr[j] = swap;
            i++;
            j--;
        }
    }

    //рекурсия для сортировки левой и правой части
    if (low < j) quickSort(sortArr, low, j);
    if (high > i) quickSort(sortArr, i, high);
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    quickSort(sortArr, 0, sortArr.length - 1);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}

```

Вне всяких сомнений, алгоритм быстрой сортировки считается самым популярным, так
как в большинстве ситуаций он выполняется быстрее остальных, за время O(N*logN).

Сложность алгоритма: O(n log n)

Быстрая сортировка считается самой быстрой, но она не всегда O(n log n), так как
в худших случаях она становится О(n2).

Быстрая сортировка более эффективна для наборов данных, которые помещаются в
доступную память. Для больших наборов она неэффективна, и в этом случае более
предпочтительна, например, сортировка слиянием.

Быстрая сортировка — это сортировка на месте (т. е. она не требует
дополнительной памяти), поэтому её целесообразно использовать для массивов.

## Сортировка слиянием

Эта сортировка тоже популярна. Она относится к одному из видов алгоритмов,
работающих по принципу «разделяй и властвуй»: в них мы в первую очередь делим
задачи на минимальные части (также представителем таких алгоритмов является
быстрая сортировка).

Итак, в чём же суть данного алгоритма?

**_Разделяй_**:  
Массив разбивается на две части примерно одинакового размера, каждая из этих
двух частей делится еще на две, и так далее, пока не останутся наименьшие
неделимые части. Наименьшие неделимые части — это когда в каждом массиве есть по
одному элементу, а значит, такой массив автоматически считается отсортированным.

**_Властвуй:_**  
Тут и начинается процесс, задавший название алгоритму — слияние. Для этого
берутся два получившиеся упорядоченных массива и сливаются в один. При этом
наименьший из первых элементов двух массивов записывается в результирующий
массив, и эта операция повторяется, пока не закончатся элементы в этих двух
массивах. То есть, если у нас есть два минимальных массива {6} и {4}, их
значения будут сравнены и записан результат: {4,6}.
Если будут отсортированные массивы {4,6} и {2,8}, то сперва сравнится значение 4
и 2, из которых 2 будет записано в результирующий массив. После этого будет
сравниваться 4 и 8, 4 будет записано, и в конце сравнится 6 и 8. Соответственно,
6 будет записано, и только после него — 8. В итоге мы получим результирующий
массив: {2,4,6,8}.

Java-коде:

Для обработки данного алгоритма нам будет удобно воспользоваться рекурсией:

```java
import java.util.Arrays;

public class Main {
    public static int[] mergeSort(int[] sortArr) {
        int[] buffer1 = Arrays.copyOf(sortArr, sortArr.length);
        int[] buffer2 = new int[sortArr.length];
        int[] result = mergeSortInner(buffer1, buffer2, 0, sortArr.length);
        return result;
    }

    public static int[] mergeSortInner(int[] buffer1, int[] buffer2, int startIndex, int endIndex) {
        if (startIndex >= endIndex - 1) {
            return buffer1;
        }

        //уже отсортирован
        int middle = startIndex + (endIndex - startIndex) / 2;
        int[] sorted1 = mergeSortInner(buffer1, buffer2, startIndex, middle);
        int[] sorted2 = mergeSortInner(buffer1, buffer2, middle, endIndex);

        //слияние
        int index1 = startIndex;
        int index2 = middle;
        int destIndex = startIndex;
        int[] result = sorted1 == buffer1 ? buffer2 : buffer1;
        while (index1 < middle && index2 < endIndex) {
            result[destIndex++] = sorted1[index1] < sorted2[index2]
                    ? sorted1[index1++] : sorted2[index2++];
        }
        while (index1 < middle) {
            result[destIndex++] = sorted1[index1++];
        }
        while (index2 < endIndex) {
            result[destIndex++] = sorted2[index2++];
        }
        return result;
    }

    public static void main(String args[]) {
        int[] sortArr = {12, 6, 4, 1, 15, 10};
        int[] result = mergeSort(sortArr);
        System.out.println(Arrays.toString(result));
    }
}

```

Сортировка осуществляется путём сравнения наименьших элементов каждого
подмассива. Первые элементы каждого подмассива сравниваются первыми. Наименьший
элемент перемещается в результирующий массив. Счётчики результирующего массива и
подмассива, откуда был взят элемент, увеличиваются на один.

Как и в быстрой сортировке, мы выносим рекурсивный метод в промежуточный, чтобы
пользователю не нужно было заморачиваться над заданием дополнительных дефолтных
аргументов, а можно было всего лишь задать массив, который необходимо
отсортировать.

Так как данный алгоритм имеет схожесть с быстрей сотрировкой, то и скорость его
выполнения та же — O(N*logN).

## Сортировка методом выбора

1. Разбиваем массив на отсортированную и неотсортированную части.
2. Находим в неотсортированной части минимальный элемент.
3. Меняем его местами с тем элементом, который находится на нулевой позиции —
   в конец отсортированного массива.
4. Далее находим следующий по величине элемент и меняем его с элементом на
   первой позиции, etc., пока не закончатся неотсортированные значения.
   Реализация сортировки выбором на языке программирования Java:

```java
public static void selectionSort(int[] sortArr) {
    for (int i = 0; i < sortArr.length; i++) {
        int pos = i;
        int min = sortArr[i];
        //цикл выбора наименьшего элемента
        for (int j = i + 1; j < sortArr.length; j++) {
            if (sortArr[j] < min) {
                //pos - индекс наименьшего элемента
                pos = j;
                min = sortArr[j];
            }
        }
        sortArr[pos] = sortArr[i];
        //меняем местами наименьший с sortArr[i]
        sortArr[i] = min;
    }
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    selectionSort(sortArr);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}
```

Сложность алгоритма: О(n2)

## Алгоритм пирамидальной сортировки

Чтобы реализовать алгоритм пирамидальной сортировки (Heapsort) на Java, нужно
сперва понять принцип. Алгоритм сегментирует массив на отсортированный и
неотсортированный. Неотсортированный сегмент преобразовывается в кучу (heap),
что позволяет эффективно определить самый большой элемент.

Пирамидальная сортировка на Java с использованием класса java.util.Arrays:

```java
//вернуть левого потомка `A[i]`
private static int LEFT(int i) {
    return (2 * i + 1);
}

//вернуть правого потомка `A[i]`
private static int RIGHT(int i) {
    return (2 * i + 2);
}

//вспомогательная функция для замены двух индексов в массиве
private static void swap(int[] sortArr, int i, int j) {
    int swap = sortArr[i];
    sortArr[i] = sortArr[j];
    sortArr[j] = swap;
}

//рекурсивный алгоритм heapify-down. Узел с индексом `i` и 2 его прямых потомка нарушают свойство кучи
private static void heapify(int[] sortArr, int i, int size) {
    // получить левый и правый потомки узла с индексом `i`
    int left = LEFT(i);
    int right = RIGHT(i);
    int largest = i;

    //сравниваем `A[i]` с его левым и правым дочерними элементами и находим наибольшее значение
    if (left < size && sortArr[left] > sortArr[i]) largest = left;
    if (right < size && sortArr[right] > sortArr[largest]) largest = right;

    //поменяться местами с потомком, имеющим большее значение и вызовите heapify-down для дочернего элемента
    if (largest != i) {
        swap(sortArr, i, largest);
        heapify(sortArr, largest, size);
    }
}

//функция для удаления элемента с наивысшим приоритетом (присутствует в корне)
public static int pop(int[] sortArr, int size) {
    //если в куче нет элементов
    if (size <= 0) {
        return -1;
    }
    int top = sortArr[0];

    //заменяем корень кучи последним элементом массива
    sortArr[0] = sortArr[size-1];
    //вызовите heapify-down на корневом узле
    heapify(sortArr, 0, size - 1);
    return top;
}

//функция для выполнения пирамидальной сортировки массива `A` размера `n`
public static void heapSort(int[] sortArr) {
    //строим приоритетную очередь и инициализируем ее заданным массивом
    int n = sortArr.length;

    //build-heap: вызывать heapify, начиная с последнего внутреннего
    //узел до корневого узла
    int i = (n - 2) / 2;
    while (i >= 0) {
        heapify(sortArr, i--, n);
    }

    //несколько раз извлекаем из кучи, пока она не станет пустой
    while (n > 0) {
        sortArr[n - 1] = pop(sortArr, n);
        n--;
    }
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    heapSort(sortArr);
    for(int i = 0; i < sortArr.length; i++){
        System.out.print(sortArr[i] + "\n");
    }
}
```
Сложность алгоритма: O(n log n)



## Сортировка в обратном порядке

```java
class Solution {
    public static void main(String[] args) {
        int[] arr = {10, 5, 6, 1, 3};

        int tmp, k = arr.length - 2;
        boolean is_swap;
        for (int i = arr.length - 1; i >= 1; i--) {
            is_swap = false;
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[j + 1]) {
                    tmp = arr[j + 1];
                    arr[j + 1] = arr[j];
                    arr[j] = tmp;
                    is_swap = true;
                }
            }

            System.out.println(Arrays.toString(arr));
            // Если перестановок не было, то выходим
            if (is_swap == false) break;
        }
    }
}
```

### Сортировка Шелла

Данная сортировка, по своей природе является модифицированной сортировкой
методом вставки.  
Выбирается шаг. Поделим наш массив пополам и получим некоторое число — это и
будет нашим шагом. Итак, если у нас в массиве 9 элементов, то наш шаг будет
9/2 = 4,5. Дробную часть мы отбросим и получим 4, так как индексы массивов —
только целые числа.
С помощью данного шага мы составим связи для наших групп. Если элемент имеет
индекс 0, то индекс следующего элемента в его группе — 0+4, то есть 4. Третий
элемент будет иметь индекс 4+4, четвертый — 8+4, и так далее.

У второй группы первый элемент будет 1,5,9….

В третьей и четвертой группе дела будут обстоять точно так же.

В итоге из массива чисел {6,3,8,8,6,9,4,11,1} мы получим четыре группы:
I — {6,6,1}
II — {3,9}
III — {8,4}
IV — {8,11}

Свои места в общем массиве они сохраняют, но для нас они помечены как участники
одной группы:
{6,3,8,8,6,9,4,11,1}

Далее внутри этих групп происходит описанная выше сортировка вставками, после
которой группы будут иметь вид:
I — {1,6,6}
II — {3,9}
III — {4,8}
IV — {8,11}

В общем массиве ячейки, занимаемые группами, останутся теми же, но внутри них
изменится порядок, согласно порядку групп выше:
{1,3,4,8,6,9,8,11,6}

Массив стал немного более упорядоченным, не так ли?

Следующий шаг, будет поделен на 2:
4/2 = 2

Имеем две группы:
I — {1,4,6,8,6}
II — {3,8,9,11}

B общий массив:
{1,3,4,8,6,9,8,11,6}

Проходим по обеим группам алгоритмом сортировки вставкой, и получаем массив:
{1,3,4,8,6,9,6,11,8}

Сейчас наш массив почти отсортирован. Осталась последняя итерация алгоритма:
делим шаг на 2: 2/2 = 1.

Мы получаем группу, весь массив:
{1,3,4,8,6,9,6,11,8}

По которому проходим алгоритмом сортировки вставкой и получаем:
{1,3,4,6,6,8,8,9,11}

Давайте посмотрим, как мы может отобразить данную сортировку в Java-коде:

```java
public class Solution {
    public static void main(String[] args) {
        int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
        sortBySelect(testArr);
        for (int i : testArr) {
            System.out.println(i);
        }
    }

    public static void sortBySelect(int[] array) {
        int length = array.length;
        int step = length / 2;
        while (step > 0) {
            for (int numberOfGroup = 0; numberOfGroup < length - step; numberOfGroup++) {// проходим по всем нашим группам
                int j = numberOfGroup;
                while (j >= 0 && array[j] > array[j + step]) {//сортировка вставкой внутри группы
                    int temp = array[j];
                    array[j] = array[j + step];
                    array[j + step] = temp;
                    j--; // j-=step
                }
            }
            step = step / 2; // уменьшаем наш шаг
        }
    }
}
```

На данный момент толком не обоснована эффективность сортировки Шелла, так как в
разных ситуациях результаты отличаются. Оценки, полученные на основании
экспериментов, лежат в интервале от O(N3/2) до O(N7/6).

## Жадный алгоритм

Жадный алгоритм — это подход, при котором на каждом этапе принимаются локально
оптимальные решения и допускается, что конечное решение также окажется
оптимальным. “Оптимальное” решение — то, которое предлагает наиболее очевидную и
немедленную выгоду на определенном шаге/этапе.

Чтобы рассмотреть данный алгоритм, выберем довольно распространенную задачу — о
рюкзаке.

Давайте на секунду представим, что вы вор. Вы вломились ночью в магазин с
рюкзаком, и перед вами некоторое множество товаров, которые вы можете украсть.
Но при этом вместимость рюкзака ограничена — не более 30 условных единиц. В тоже
время вы хотите унести набор товаров максимальной стоимости, которые только
влезут в рюкзак.

Как вы определите, что положить?

Итак, жадный алгоритм для задачи о рюкзаке состоит в следующих шагах (считаем,
что все предметы помещаются в рюкзак):

1. Выбрать максимально дорогой предмет из еще не затронутых.
2. Если он помещается в рюкзак, положить его туда, если нет — пропускаем.
3. Все предметы перебрали? Если нет — возвращаемся к 1 пункту, если да — бежим
   из магазина, так как наша цель тут выполнена.

Так будет выглядеть класс предмета Item:

```java
public class Item implements Comparable<Item> {
    private String name;
    private int weight;
    private int cost;

    public Item(String name, int weight, int cost) {
        this.name = name;
        this.weight = weight;
        this.cost = cost;
    }

    public String getName() {
        return name;
    }

    public int getWeight() {
        return weight;
    }

    public int getCost() {
        return cost;
    }

    @Override
    public int compareTo(Item o) {
        return this.cost > o.cost ? -1 : 1;
    }
}
```

Тут ничего особого: три поля — name, weight, cost — для задания характеристик
предмета.

Также, как вы можете видеть, тут реализован интерфейс Comparable таким образом,
чтобы мы могли сортировать наши Item по цене.

Дальше смотрим на класс нашего рюкзака — Bag:

```java
public class Bag {
    private final int maxWeight;
    private List<Item> items;
    private int currentWeight;
    private int currentCost;

    public Bag(int maxWeight) {
        this.maxWeight = maxWeight;
        items = new ArrayList<>();
        currentCost = 0;
    }

    public int getMaxWeight() {
        return maxWeight;
    }

    public int getCurrentCost() {
        return currentCost;
    }

    public int getCurrentWeight() {
        return currentWeight;
    }

    public void addItem(Item item) {
        items.add(item);
        currentWeight += item.getWeight();
        currentCost += item.getCost();
    }
}

```

- maxWeight — вместимость нашего рюкзака, которая задаётся при создании объекта;
- items — объекты находящиеся в рюкзаке;
- currentWeight, currentCost — текущий вес и стоимость всех вещей в рюкзаке,
  которые мы увеличиваем при добавлении нового предмета в методе addItem.

Собственно перейдем в класс, где и происходит всё действие:

```java
public class Solution {

    public static void main(String[] args) {
        List<Item> items = new ArrayList<>();
        items.add(new Item("гитара", 7, 800));
        items.add(new Item("утюг", 6, 500));
        items.add(new Item("чайник", 3, 300));
        items.add(new Item("лампа", 4, 500));
        items.add(new Item("телевизор", 15, 2000));
        items.add(new Item("ваза", 2, 450));
        items.add(new Item("миксер", 1, 400));
        items.add(new Item("блендер", 3, 200));

        Collections.sort(items);

        Bag firstBag = new Bag(30);

        fillBackpack(firstBag, items);

        System.out.println("Вес рюкзака состовляет - " + firstBag.getCurrentWeight() +
                ", общая стоимость вещей в рюкзаке - " + firstBag.getCurrentCost());
    }
}
```

Для начала мы создаем список элементов, сортируем его. Создаем объект сумки с
вместимость 30 единиц.

Далее отправляем элементы и объект сумки в метод fillBackpack, в котором,
собственно, и заполняется рюкзак по жадному алгоритму:

```java
public static void fillBackpack(Bag bag, List<Item> items) {
    for (Item item : items) {
        if (bag.getMaxWeight() > bag.getCurrentWeight() + item.getWeight()) {
            bag.addItem(item);
        }
    }
}

```

Всё предельно просто: мы начинаем проходить по отсортированному по стоимости
списку элементов и складывать их в сумку, если позволяет вместимость. Если же не
позволяет, элемент будет пропущен и продолжится проход по остальным элементам до
конца списка.

Запустив main, мы получим вывод в консоль:

    Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 3700

Собственно, это и есть пример жадного алгоритма: на каждом шагу выбирается
локально-оптимальное решение, а в итоге вы получаете глобально-оптимальное
решение.  
В нашем случае оптимальный вариант — это наиболее дорогой предмет.    
Но является ли это лучшим решением? Вам не кажется, что можно немного
модернизировать наше решение, чтобы можно было укомплектовать рюкзак с более
высокой суммарной стоимостью?  
Давайте взглянем, как это можно сделать:

```java
public static void effectiveFillBackpack(Bag bag, List<Item> items) {
    Map<Double, Item> sortByRatio = new TreeMap(Collections.reverseOrder());
    for (Item item : items) {
        sortByRatio.put((double) item.getCost() / item.getWeight(), item);
    }

    for (Map.Entry<Double, Item> entry : sortByRatio.entrySet()) {
        if (bag.getMaxWeight() > bag.getCurrentWeight() + entry.getValue().getWeight()) {
            bag.addItem(entry.getValue());
        }
    }
}
```

Тут мы в первую очередь вычисляем соотношение веса и цены для каждого предмета.
Так сказать, сколько стоит одна единица данного предмета. И уже по этим
значениям мы сортируем наши предметы и добавляем в нашу сумку.

Запустим:

```code
Bag secondBag = new Bag(30); 
effectiveFillBackpack(secondBag, items);
System.out.println("Вес рюкзака составляет - " + secondBag.getCurrentWeight() +
  ", общая стоимость вещей в рюкзаке - " + secondBag.getCurrentCost());

```

Получаем вывод в консоль:

    Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 4150

Немного лучше, не правда ли?

Жадный алгоритм на каждом шагу делает локально оптимальный выбор в расчете на
то, что итоговое решение также будет оптимальным. Это не всегда оправдано, но
для многих задач жадные алгоритмы действительно дают оптимум.

Временная сложность данного алгоритма — O(N), довольно неплохо, не так ли?

## Cтандартные методы сортировки Java

### Collections.sort()

```java
public class Demo {
    void demo() {
        List<ObjectName> list = new ArrayList<ObjectName>();
        Collections.sort(list, new Comparator<ObjectName>() {
            public int compare(ObjectName o1, ObjectName o2) {
                return o1.toString().compareTo(o2.toString());
            }
        });
    }
}
```

### Arrays.sort()

```java
public class Demo {
    void demo() {
        ObjectName[] arr = new ObjectName[10];
        Arrays.sort(arr, new Comparator<ObjectName>() {
            public int compare(ObjectName o1, ObjectName o2) {
                return o1.toString().compareTo(o2.toString());
            }
        });
    }
}
```
