# Бинарный поиск(Логарифмический/"разделяй и властвуй")

В О-нотации сложность алгоритма равна O(log(N)).

Этот вид поиска использует подход «Разделяй и властвуй», требует предварительной
сортировки набора данных.

Алгоритм делит входную коллекцию на равные половины, и с каждой итерацией
сравнивает целевой элемент с элементом в середине. Поиск заканчивается при
нахождении элемента. Иначе продолжаем искать элемент, разделяя и выбирая
соответствующий раздел массива. Целевой элемент сравнивается со средним.
Вот почему важно иметь отсортированную коллекцию при использовании двоичного
поиска.

**Временная сложность**

Временная сложность алгоритма двоичного поиска равна O(log (N)) из-за деления
массива пополам. Она превосходит O(N) линейного алгоритма.

**Пространственная сложность**

Одна единица пространства требуется для хранения искомого элемента.
Следовательно, пространственная сложность равна O(1).
Рекурсивный двоичный поиск хранит вызов метода в стеке. В худшем случае
пространственная сложность потребует O(log (N)).

**Применение**

Этот алгоритм используется в большинстве библиотек и используется с
отсортированными структурами данных.
Двоичный поиск реализован в методе Arrays.binarySearch Java API.

## Реализации

### Итеративно

```java
public class BinarySearch {

    // Метод для выполнения бинарного поиска
    public static int binarySearch(int[] array, int target) {
        int left = 0;
        int right = array.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2; // Избегаем переполнения

            // Проверяем, находится ли целевое значение в середине
            if (array[mid] == target) {
                return mid; // Возвращаем индекс найденного элемента
            }

            // Если целевое значение больше, игнорируем левую половину
            if (array[mid] < target) {
                left = mid + 1;
            } else { // Если целевое значение меньше, игнорируем правую половину
                right = mid - 1;
            }
        }

        return -1; // Возвращаем -1, если элемент не найден
    }

    public static void main(String[] args) {
        int[] array = {2, 3, 4, 10, 40};
        int target = 10;

        int result = binarySearch(array, target);
        if (result == -1) {
            System.out.println("Элемент не найден");
        } else {
            System.out.println("Элемент найден на индексе: " + result);
        }
    }
}
```

Объяснение кода:

1. Метод binarySearch принимает отсортированный массив и целевое значение для
   поиска.
2. Переменные left и right используются для отслеживания границ текущего
   подмассива.
3. В цикле while мы продолжаем искать до тех пор, пока left не станет больше
   right.
4. Мы вычисляем средний индекс mid и сравниваем элемент в этом индексе с целевым
   значением.
5. Если элемент найден, возвращаем его индекс. Если целевое значение больше
   элемента в середине, сдвигаем левую границу вправо. В противном случае
   сдвигаем правую границу влево.
6. Если элемент не найден после завершения цикла, возвращаем -1.

### Рекурсивно

```java
public class RecursiveBinarySearch {

    // Рекурсивный метод для выполнения бинарного поиска
    public static int binarySearch(int[] array, int target, int left, int right) {
        // Базовый случай: если границы пересеклись, элемент не найден
        if (left > right) {
            return -1;
        }

        // Вычисляем средний индекс
        int mid = left + (right - left) / 2;

        // Проверяем, находится ли целевое значение в середине
        if (array[mid] == target) {
            return mid; // Возвращаем индекс найденного элемента
        }

        // Если целевое значение больше, ищем в правой половине
        if (array[mid] < target) {
            return binarySearch(array, target, mid + 1, right);
        } else { // Если целевое значение меньше, ищем в левой половине
            return binarySearch(array, target, left, mid - 1);
        }
    }

    public static void main(String[] args) {
        int[] array = {2, 3, 4, 10, 40};
        int target = 10;

        int result = binarySearch(array, target, 0, array.length - 1);
        if (result == -1) {
            System.out.println("Элемент не найден");
        } else {
            System.out.println("Элемент найден на индексе: " + result);
        }
    }
}
```

Объяснение кода:

1. Метод binarySearch принимает отсортированный массив array, целевое значение
   target, а также границы поиска left и right.
2. Базовый случай рекурсии: если left больше right, это означает, что элемент не
   найден.
3. Мы вычисляем средний индекс mid и сравниваем элемент в этом индексе с целевым
   значением.
4. Если элемент найден, возвращаем его индекс. Если целевое значение больше
   элемента в середине, рекурсивно вызываем метод для правой половины массива. В
   противном случае — для левой половины.
5. В методе main мы вызываем рекурсивный метод с начальными границами (0 и длина
   массива - 1).

## Примечание:

Рекурсивный подход отличается вызовом самого метода при получении нового
раздела. В итеративном подходе всякий раз, когда мы определяли новый раздел, мы
изменяли первый и последний элементы, повторяя процесс в том же цикле.
Другое отличие – рекурсивные вызовы помещаются в стек и занимают одну единицу
пространства за вызов.

Обе реализации бинарного поиска — итеративная и рекурсивная — являются
распространенными и базовыми подходами к решению задачи поиска в отсортированном
массиве. Однако, каждая из них имеет свои особенности и предпочтения в
использовании:

1. Итеративная реализация:

Преимущества:

- Более эффективна по памяти, так как не использует стек вызовов, что может
  привести к переполнению стека при больших размерах массива.
- Обычно быстрее, так как избегает накладных расходов на вызовы функций.

Недостатки:

- Код может быть менее читаемым для некоторых разработчиков, особенно если они
  предпочитают рекурсивные подходы.

2. Рекурсивная реализация:

Преимущества:

1. Код более лаконичен и легче воспринимается, особенно для тех, кто привык к
   рекурсивным алгоритмам.
2. Может быть проще для понимания концепции деления массива на подмассивы.

Недостатки:

1. Использует дополнительную память для хранения информации о каждом вызове
   функции в стеке, что может привести к переполнению стека при больших размерах
   массива.
2. Может быть медленнее из-за накладных расходов на вызовы функций.

Заключение

В большинстве практических случаев итеративная реализация бинарного поиска
является более предпочтительной из-за своей эффективности по памяти и скорости.
Тем не менее, рекурсивный подход также широко используется в учебных целях и в
ситуациях, когда читаемость кода является приоритетом.

Таким образом, можно сказать, что итеративная реализация является более
распространенной в производственном коде, тогда как рекурсивная реализация часто
используется в учебных материалах и для иллюстрации концепций алгоритмов.