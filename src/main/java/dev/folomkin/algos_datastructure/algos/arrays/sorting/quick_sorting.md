# Быстрая сортировка <br>(Quick Sort)

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Он работает путем
выбора опорного элемента (pivot) и разделения массива на две части: элементы,
меньшие опорного, и элементы, большие опорного. Затем алгоритм рекурсивно
сортирует обе части.

## Принцип работы алгоритма

1. Выбор опорного элемента: Обычно выбирается первый, последний или средний
   элемент массива.
2. Разделение: Массив делится на две части: элементы меньше опорного и элементы
   больше опорного. Теперь ключевой элемент находится в правильной позиции — он
   больше любого элемента слева и меньше любого элемента справа.
3. Рекурсия: Рекурсивно применяется быстрая сортировка к обеим частям.
4. Объединение: Объединение происходит неявно, так как элементы уже находятся на
   своих местах.

Давайте посмотрим на работу алгоритма на следующем массиве:

    [3][7][4][4][6][5][8]

Сначала мы случайным образом выбираем ключевой элемент 6:

    [3][7][4][4][6][5][8]

Теперь, когда мы знаем ключевой индекс (4), мы берем значение, находящееся по
этому индексу (6), и переносим значения в массиве так, чтобы все числа больше
или равные ключевому были в правой части, а все числа меньше ключевого — в
левой. В процессе переноса значений индекс ключевого элемента может измениться.

Перемещение значений осуществляется методом `partition`.

    [3][5][4][4]["6"][7][8]

На этом этапе мы знаем, что значение 6 находится на правильной позиции. Теперь
мы повторяем этот процесс для правой и левой частей массива.

Мы рекурсивно вызываем метод quicksort на каждой из частей. Ключевым элементом в
левой части становится пятерка. При перемещении значений она изменит свой
индекс. Главное — помнить, что нам важно именно ключевое значение, а не его
индекс.

    [3]['5'][4][4]["6"][7][8]
    [3][4][4]['5']["6"][7][8]

Снова применяем быструю сортировку:

    ['3'][4][4]["5"]["6"]['7'][8]
    ["3"][4][4]["5"]["6"]["7"]["8"]

И еще раз:

    ["3"]['4'][4]["5"]["6"]["7"]["8"]
    ["3"]["4"][4]["5"]["6"]["7"]["8"]

У нас осталось одно неотсортированное значение, а, поскольку мы знаем, что все
остальное уже отсортировано, алгоритм завершает работу.

```java
public static void quickSort(int[] sortArr, int low, int high) {
    //завершить,если массив пуст или уже нечего делить
    if (sortArr.length == 0 || low >= high) return;

    //выбираем опорный элемент
    int middle = low + (high - low) / 2;
    int border = sortArr[middle];

    //разделияем на подмассивы и меняем местами
    int i = low, j = high;
    while (i <= j) {
        while (sortArr[i] < border) i++;
        while (sortArr[j] > border) j--;
        if (i <= j) {
            int swap = sortArr[i];
            sortArr[i] = sortArr[j];
            sortArr[j] = swap;
            i++;
            j--;
        }
    }

    //рекурсия для сортировки левой и правой части
    if (low < j) quickSort(sortArr, low, j);
    if (high > i) quickSort(sortArr, i, high);
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    quickSort(sortArr, 0, sortArr.length - 1);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}

// === //


public class QuickSort {
    // Метод для сортировки массива с использованием быстрой сортировки
    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Находим индекс опорного элемента
            int pivotIndex = partition(array, low, high);

            // Рекурсивно сортируем элементы до и после опорного элемента
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    // Метод для разделения массива и нахождения индекса опорного элемента
    private static int partition(int[] array, int low, int high) {
        int pivot = array[high]; // Выбираем последний элемент в качестве опорного
        int i = low - 1; // Индекс меньшего элемента

        for (int j = low; j < high; j++) {
            // Если текущий элемент меньше или равен опорному
            if (array[j] <= pivot) {
                i++; // Увеличиваем индекс меньшего элемента
                // Меняем местами элементы
                swap(array, i, j);
            }
        }
        // Меняем местами опорный элемент с элементом, который больше опорного
        swap(array, i + 1, high);
        return i + 1; // Возвращаем индекс опорного элемента
    }

    // Метод для обмена элементов массива
    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    // Метод для вывода массива на экран
    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }

    // Главный метод для тестирования быстрой сортировки
    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10}; // Исходный массив
        System.out.println("Исходный массив:");
        printArray(array);

        quickSort(array, 0, array.length - 1); // Сортируем массив

        System.out.println("Отсортированный массив:");
        printArray(array); // Выводим отсортированный массив
    }
}

```

## Объяснение кода

1. Метод quickSort:
    1. Принимает массив, начальный индекс (low) и конечный индекс (high).
    2. Если low меньше high, вызывается метод partition для разделения массива и
       нахождения индекса опорного элемента.
    3. Рекурсивно вызывает quickSort для левой и правой частей массива.

2. Метод partition:
    1. Выбирает опорный элемент (в данном случае последний элемент).
    2. Проходит по массиву и перемещает элементы, меньшие или равные опорному,
       влево.
    3. В конце меняет местами опорный элемент с элементом, который больше
       опорного, и возвращает индекс опорного элемента.

3. Метод swap:
    1. Обменивает местами два элемента массива.

4. Метод printArray:
    1. Выводит элементы массива на экран.

5. Метод main:
    1. Создает массив, выводит его на экран, сортирует с помощью quickSort, а
       затем снова выводит отсортированный массив.

Вне всяких сомнений, алгоритм быстрой сортировки считается самым популярным, так
как в большинстве ситуаций он выполняется быстрее остальных, за время O(N*logN).

Быстрая сортировка считается самой быстрой, но она не всегда O(n log n), так как
в худших случаях она становится О(n2).

Быстрая сортировка более эффективна для наборов данных, которые помещаются в
доступную память. Для больших наборов она неэффективна, и в этом случае более
предпочтительна, например, сортировка слиянием.

Быстрая сортировка — это сортировка на месте (т. е. она не требует
дополнительной памяти), поэтому её целесообразно использовать для массивов.

Сложность алгоритма: O(n log n)

## Преимущества и недостатки

Преимущества:

1. Временная сложность O(n log n) в среднем случае.
2. Хорошо работает на больших массивах.
3. Не требует дополнительной памяти, как сортировка слиянием.

Недостатки:

1. Временная сложность O(n^2) в худшем случае (например, если массив уже
   отсортирован и опорный элемент выбирается неудачно).
2. Не является стабильным алгоритмом (порядок равных элементов может
   измениться).

Быстрая сортировка — это один из самых популярных алгоритмов сортировки,
используемый в различных приложениях благодаря своей эффективности и простоте
реализации.

| СЛОЖНОСТЬ | Наилучший случай | В среднем     | Наихудший случай |
|-----------|------------------|---------------|------------------|
| Время     | O(n * log n )    | O(n * log n ) | O(n * log n)     |
| Память    | O(1)             | O(1)          | O(1)             |