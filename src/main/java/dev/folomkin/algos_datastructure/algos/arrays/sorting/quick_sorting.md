# Быстрая сортировка <br>(Quick Sort)

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Он работает путем
выбора опорного элемента (pivot) и разделения массива на две части: элементы,
меньшие опорного, и элементы, большие опорного. Затем алгоритм рекурсивно
сортирует обе части.

## Принцип работы алгоритма

1. Выбор опорного элемента: Обычно выбирается первый, последний или средний
   элемент массива.
2. Разделение: Массив делится на две части: элементы меньше опорного и элементы
   больше опорного. Теперь ключевой элемент находится в правильной позиции — он
   больше любого элемента слева и меньше любого элемента справа.
3. Рекурсия: Рекурсивно применяется быстрая сортировка к обеим частям.
4. Объединение: Объединение происходит неявно, так как элементы уже находятся на
   своих местах.

Пример массива:

    [3][7][4][4][6][5][8]

Случайным образом выбираем ключевой элемент 6:

    [3][7][4][4][6][5][8]

Теперь, когда мы знаем ключевой индекс (4), мы берем значение, находящееся по
этому индексу (6), и переносим значения в массиве так, чтобы все числа больше
или равные ключевому были в правой части, а все числа меньше ключевого — в
левой. В процессе переноса значений индекс ключевого элемента может измениться.

Перемещение значений осуществляется методом `partition`.

    [3][5][4][4]["6"][7][8]

На этом этапе мы знаем, что значение 6 находится на правильной позиции. Теперь
мы повторяем этот процесс для правой и левой частей массива.

Мы рекурсивно вызываем метод quicksort на каждой из частей. Ключевым элементом в
левой части становится пятерка. При перемещении значений она изменит свой
индекс. Главное — помнить, что нам важно именно ключевое значение, а не его
индекс.

    [3]['5'][4][4]["6"][7][8]
    [3][4][4]['5']["6"][7][8]

Снова применяем быструю сортировку:

    ['3'][4][4]["5"]["6"]['7'][8]
    ["3"][4][4]["5"]["6"]["7"]["8"]

И еще раз:

    ["3"]['4'][4]["5"]["6"]["7"]["8"]
    ["3"]["4"][4]["5"]["6"]["7"]["8"]

У нас осталось одно неотсортированное значение, а, поскольку мы знаем, что все
остальное уже отсортировано, алгоритм завершает работу.

```java
public static vo    id quickSort(int[] sortArr, int low, int high) {
    //завершить,если массив пуст или уже нечего делить
    if (sortArr.length == 0 || low >= high) return;

    //выбираем опорный элемент
    int middle = low + (high - low) / 2;
    int border = sortArr[middle];

    //разделияем на подмассивы и меняем местами
    int i = low, j = high;
    while (i <= j) {
        while (sortArr[i] < border) i++;
        while (sortArr[j] > border) j--;
        if (i <= j) {
            int swap = sortArr[i];
            sortArr[i] = sortArr[j];
            sortArr[j] = swap;
            i++;
            j--;
        }
    }

    //рекурсия для сортировки левой и правой части
    if (low < j) quickSort(sortArr, low, j);
    if (high > i) quickSort(sortArr, i, high);
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    quickSort(sortArr, 0, sortArr.length - 1);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}

// === AI - рекурсивно ===  //
public class QuickSort {

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Находим индекс опорного элемента
            int pivotIndex = partition(array, low, high);
            // Рекурсивно сортируем элементы до и после опорного элемента
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    private static int partition(int[] array, int low, int high) {
        // Выбираем опорный элемент (в данном случае последний элемент)
        int pivot = array[high];
        int i = (low - 1); // Индекс меньшего элемента

        for (int j = low; j < high; j++) {
            // Если текущий элемент меньше или равен опорному
            if (array[j] <= pivot) {
                i++;
                // Меняем местами
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        // Меняем местами опорный элемент с элементом, следующим за последним меньшим элементом
        int temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;

        return i + 1; // Возвращаем индекс опорного элемента
    }

    public static void main(String[] args) {
        int[] array = {3, 6, 8, 10, 1, 2, 1};
        System.out.println("Исходный массив: " + Arrays.toString(array));

        quickSort(array, 0, array.length - 1);

        System.out.println("Отсортированный массив: " + Arrays.toString(array));
    }
}

Объяснение кода:
Метод quickSort: Это основной метод, который принимает массив и границы (индексы) для сортировки. Он проверяет, если low меньше high, и вызывает метод partition.

Метод partition: Этот метод выбирает опорный элемент (в данном случае последний элемент массива) и переставляет элементы так, чтобы все элементы меньше опорного были слева от него, а все элементы больше — справа. Он возвращает индекс опорного элемента после перестановки.

Метод main: Здесь создается массив, который нужно отсортировать, и вызывается метод quickSort. Результат выводится на экран.

Вы можете запустить этот код в любой среде разработки Java, и он отсортирует массив, выводя исходный и отсортированный массивы.



// === AI - итеративо === //


public class IterativeQuickSort {

    // Метод для итеративной быстрой сортировки
    public static void quickSort(int[] array) {
        // Создаем стек для хранения границ подмассивов
        Stack<int[]> stack = new Stack<>();
        stack.push(new int[]{0, array.length - 1});

        while (!stack.isEmpty()) {
            // Извлекаем границы подмассива
            int[] range = stack.pop();
            int low = range[0];
            int high = range[1];

            if (low < high) {
                // Находим индекс опорного элемента
                int pivotIndex = partition(array, low, high);

                // Добавляем подмассивы в стек
                stack.push(new int[]{low, pivotIndex - 1});
                stack.push(new int[]{pivotIndex + 1, high});
            }
        }
    }

    // Метод для разделения массива и нахождения индекса опорного элемента
    private static int partition(int[] array, int low, int high) {
        int pivot = array[high]; // Опорный элемент
        int i = (low - 1); // Индекс меньшего элемента

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                // Меняем местами
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        // Меняем местами опорный элемент с элементом, следующим за последним меньшим элементом
        int temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;

        return i + 1; // Возвращаем индекс опорного элемента
    }

    public static void main(String[] args) {
        int[] array = {3, 6, 8, 10, 1, 2, 1};
        System.out.println("Исходный массив: " + Arrays.toString(array));

        quickSort(array);

        System.out.println("Отсортированный массив: " + Arrays.toString(array));
    }
}

Объяснение кода:
Метод quickSort: Этот метод инициализирует стек и добавляет в него границы всего массива. Затем он использует цикл while, чтобы обрабатывать подмассивы, пока стек не станет пустым.

Метод partition: Этот метод работает так же, как и в рекурсивной версии. Он выбирает опорный элемент, переставляет элементы массива и возвращает индекс опорного элемента.

Метод main: Здесь создается массив, который нужно отсортировать, и вызывается метод quickSort. Результат выводится на экран.

Эта итеративная реализация быстрой сортировки позволяет избежать проблем с переполнением стека, которые могут возникнуть при глубокой рекурсии.







```

## Объяснение кода

1. Метод quickSort:
    1. Принимает массив, начальный индекс (low) и конечный индекс (high).
    2. Если low меньше high, вызывается метод partition для разделения массива и
       нахождения индекса опорного элемента.
    3. Рекурсивно вызывает quickSort для левой и правой частей массива.

2. Метод partition:
    1. Выбирает опорный элемент (в данном случае последний элемент).
    2. Проходит по массиву и перемещает элементы, меньшие или равные опорному,
       влево.
    3. В конце меняет местами опорный элемент с элементом, который больше
       опорного, и возвращает индекс опорного элемента.

3. Метод swap:
    1. Обменивает местами два элемента массива.

4. Метод printArray:
    1. Выводит элементы массива на экран.

5. Метод main:
    1. Создает массив, выводит его на экран, сортирует с помощью quickSort, а
       затем снова выводит отсортированный массив.

Вне всяких сомнений, алгоритм быстрой сортировки считается самым популярным, так
как в большинстве ситуаций он выполняется быстрее остальных, за время O(N*logN).

Быстрая сортировка считается самой быстрой, но она не всегда O(n log n), так как
в худших случаях она становится О(n2).

Быстрая сортировка более эффективна для наборов данных, которые помещаются в
доступную память. Для больших наборов она неэффективна, и в этом случае более
предпочтительна, например, сортировка слиянием.

Быстрая сортировка — это сортировка на месте (т. е. она не требует
дополнительной памяти), поэтому её целесообразно использовать для массивов.

Сложность алгоритма: O(n log n)

## Преимущества и недостатки

Преимущества:

1. Временная сложность O(n log n) в среднем случае.
2. Хорошо работает на больших массивах.
3. Не требует дополнительной памяти, как сортировка слиянием.

Недостатки:

1. Временная сложность O(n^2) в худшем случае (например, если массив уже
   отсортирован и опорный элемент выбирается неудачно).
2. Не является стабильным алгоритмом (порядок равных элементов может
   измениться).

Быстрая сортировка — это один из самых популярных алгоритмов сортировки,
используемый в различных приложениях благодаря своей эффективности и простоте
реализации.

| СЛОЖНОСТЬ | Наилучший случай | В среднем     | Наихудший случай |
|-----------|------------------|---------------|------------------|
| Время     | O(n * log n )    | O(n * log n ) | O(n * log n)     |
| Память    | O(1)             | O(1)          | O(1)             |