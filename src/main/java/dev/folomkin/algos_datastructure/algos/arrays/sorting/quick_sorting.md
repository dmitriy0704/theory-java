# Быстрая сортировка <br>(Quick Sort)

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Он работает путем
выбора опорного элемента (pivot) и разделения массива на две части: элементы,
меньшие опорного, и элементы, большие опорного. Затем алгоритм рекурсивно
сортирует обе части.

## Примечания:

- Быстрая сортировка имеет среднюю временную сложность O(n log n), но в худшем
  случае может достигать O(n²), если массив уже отсортирован или содержит много
  одинаковых элементов. Чтобы избежать этого случая, можно использовать
  различные стратегии выбора опорного элемента или применять случайный выбор.

### Выбор опорного элемента для сортировки

Выбор опорного элемента (или "опорного значения") для быстрой сортировки (Quick
Sort) может существенно повлиять на производительность алгоритма. Вот несколько
распространенных стратегий выбора опорного элемента:

1. **Первый или последний элемент**. Самый простой способ, но он может привести
   к худшей производительности, особенно если массив уже частично или полностью
   отсортирован.
2. Выбор **среднего элемента** массива как опорного может помочь избежать худших
   сценариев производительности в некоторых случаях. Это метод вычисления
   индекса среднего элемента как (low + high) / 2.
3. **Случайный элемент**: Выбор случайного элемента в качестве опорного может
   помочь избежать худших случаев и улучшить среднюю производительность.
4. **Медиана трех**: Эта стратегия включает выбор медианы из трех значений:
   первого, среднего и последнего элементов массива. Это помогает избежать
   крайних значений и часто приводит к более сбалансированным разделениям.
5. **Медиана**: Если вы хотите более сложный подход, можно использовать медиану
   всего массива, но это требует дополнительной работы и может быть неэффективно
   для больших массивов.

Каждая из этих стратегий имеет свои плюсы и минусы, и выбор зависит от
конкретных данных и требований к производительности. В большинстве случаев
использование медианы трех или случайного элемента дает хорошие результаты.

### Причины перемещения опорного элемента в конец:

Перемещение опорного элемента в конец массива в алгоритме быстрой сортировки —
это удобный прием, который упрощает процесс разделения массива на две части.
Давайте разберем, почему это делается и какие преимущества это дает.

1. **Упрощение логики разделения**:
    - Когда опорный элемент находится в конце массива, мы можем легко
      использовать его для сравнения с другими элементами. Это позволяет нам не
      беспокоиться о том, что мы можем случайно перезаписать опорный элемент во
      время процесса разделения.

2. **Избежание лишних обменов**:
    - Если бы мы оставили опорный элемент на своем месте, нам пришлось бы
      следить за тем, чтобы не перемещать его при каждом обмене элементов.
      Перемещение его в конец позволяет нам просто игнорировать его при
      сравнении и обменах.

3. **Логика работы с индексами**:
    - Перемещение опорного элемента в конец позволяет нам использовать один
      проход по массиву для разделения элементов на меньшие и большие
      относительно опорного. В конце этого прохода мы просто помещаем опорный
      элемент на его окончательную позицию (индекс `i`), что делает код более
      чистым и понятным.

#### Пример работы:

Предположим, у нас есть массив: `[10, 7, 8, 9, 1, 5]`, и мы выбираем `8` как
опорный элемент.

1. Перемещаем `8` в конец: `[10, 7, 5, 9, 1, 8]`.
2. Начинаем проход по массиву от начала до предпоследнего элемента (где
   находится `8`):
    - Сравниваем каждый элемент с `8` и перемещаем элементы меньше `8` влево.
3. После завершения прохода мы помещаем `8` на позицию `i`, которая указывает на
   место, где должны находиться все элементы меньше или равные `8`.

#### Заключение:

Перемещение опорного элемента в конец массива — это стратегический шаг для
упрощения реализации алгоритма быстрой сортировки. Это позволяет избежать
дополнительных проверок и делает код более лаконичным и понятным.

### Почему индекс наименьшего элемента равен -1

Если индекс меньшего элемента равен -1, это может указывать на несколько
возможных проблем в реализации алгоритма быстрой сортировки или в логике,
связанной с разделением массива. Давайте рассмотрим, что это может означать и
как это исправить.

#### Возможные причины:

1. **Инициализация индекса**:
    - Если вы инициализируете индекс меньшего элемента (например, `i`) как `-1`,
      это может означать, что вы еще не нашли ни одного элемента, меньшего
      опорного. В этом случае вам нужно убедиться, что вы правильно обновляете
      этот индекс при нахождении элементов, меньших опорного.

2. **Логика разделения**:
    - Если в процессе разделения массива не было найдено ни одного элемента,
      меньшего опорного, то индекс может остаться равным -1. Это может
      произойти, если все элементы массива больше или равны опорному элементу.

3. **Ошибки в коде**:
    - Возможно, есть ошибка в логике вашего кода, которая приводит к тому, что
      индекс не обновляется должным образом. Например, если вы забыли
      инкрементировать индекс при нахождении элемента меньше опорного.

#### Пример исправления:

Вот пример того, как правильно реализовать логику разделения с учетом индекса
меньшего элемента:

```java
private static int partition(int[] array, int low, int high, int pivot) {
    int i = low; // Начинаем с первого элемента
    for (int j = low; j <= high; j++) {
        if (array[j] < pivot) {
            swap(array, i, j);
            i++; // Увеличиваем индекс меньшего элемента
        }
    }
    return i; // Возвращаем индекс первого элемента больше или равного опорному
}
```

#### Объяснение:

- В этом коде `i` инициализируется как `low`, что означает начало области для
  элементов меньше опорного.
- При каждом нахождении элемента меньше опорного (`array[j] < pivot`), мы меняем
  его местами с элементом на позиции `i` и увеличиваем `i`.
- В конце функции мы возвращаем `i`, который указывает на позицию первого
  элемента больше или равного опорному.

#### Заключение:

Если индекс меньшего элемента равен -1 в вашем коде быстрой сортировки,
проверьте инициализацию индекса и логику разделения массива. Убедитесь, что вы
правильно обновляете индекс при нахождении элементов меньше опорного.

## Преимущества и недостатки

Преимущества:

1. Временная сложность O(n log n) в среднем случае.
2. Хорошо работает на больших массивах.
3. Не требует дополнительной памяти, как сортировка слиянием.

Недостатки:

1. Временная сложность O(n^2) в худшем случае (например, если массив уже
   отсортирован и опорный элемент выбирается неудачно).
2. Не является стабильным алгоритмом (порядок равных элементов может
   измениться).

## Сложность

Сложность алгоритма Quicksort зависит от многих факторов, включая выбор опорного
элемента и распределение входных данных. В общем случае сложность быстрой
сортировки такова:

- Лучший случай. O(nlogn). Алгоритм делит массив на равные части, что приводит к
  наиболее эффективному разделению и сокращению времени выполнения.
- Средний случай. Также O(nlogn). Для случайных данных и при хорошем выборе
  опорного элемента быстрая сортировка чаще всего достигает этой сложности.
- Худший случай. O(n²). Это уже не так хорошо. Такое происходит, когда каждое
  разделение делит массив на части размером '1' и 'n-1', что чаще всего
  случается при выборе опорного элемента как наименьшего или наибольшего
  элемента в массиве. Например, если массив уже отсортирован и в качестве
  опорного выбирается первый или последний элемент, алгоритм будет иметь худшую
  производительность.

## Реализации

### Базовая реализация быстрой сортировки<br> с средним опорным элементом

```java
public static void quickSort(int[] sortArr, int low, int high) {
    //завершить,если массив пуст или уже нечего делить
    if (sortArr.length == 0 || low >= high) return;

    //выбираем опорный элемент
    int middle = low + (high - low) / 2;
    int border = sortArr[middle];

    //Разделяем на подмассивы и меняем местами
    int i = low, j = high;
    while (i <= j) {
        while (sortArr[i] < border) i++;
        while (sortArr[j] > border) j--;
        if (i <= j) {
            int swap = sortArr[i];
            sortArr[i] = sortArr[j];
            sortArr[j] = swap;
            i++;
            j--;
        }
    }

    //рекурсия для сортировки левой и правой части
    if (low < j) quickSort(sortArr, low, j);
    if (high > i) quickSort(sortArr, i, high);
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    quickSort(sortArr, 0, sortArr.length - 1);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}
```

## Реализация "Средний опорный элемент"

Вот пример реализации быстрой сортировки (Quick Sort) на Java с использованием
среднего опорного элемента:

```java
public class QuickSort {

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};
        quickSort(array, 0, array.length - 1);
        System.out.println("Отсортированный массив: ");
        printArray(array);
    }

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Находим индекс опорного элемента
            int pivotIndex = partition(array, low, high);
            // Рекурсивно сортируем элементы до и после опорного элемента
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    public static int partition(int[] array, int low, int high) {
        // Вычисляем средний индекс для выбора опорного элемента
        int mid = low + (high - low) / 2;
        int pivot = array[mid];

        // Перемещаем опорный элемент в конец массива
        swap(array, mid, high);

        int i = low - 1; // Индекс меньшего элемента

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }

        // Перемещаем опорный элемент на его окончательную позицию
        swap(array, i + 1, high);

        return i + 1; // Возвращаем индекс опорного элемента
    }

    public static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

#### Объяснение кода:

1. **Метод `quickSort`**: Это основной метод быстрой сортировки. Он принимает
   массив и границы сортируемой части массива. Если границы корректны (
   `low < high`), он вызывает метод `partition` для разделения массива и
   рекурсивно сортирует полученные подмассивы.

2. **Метод `partition`**: Этот метод выбирает опорный элемент (в данном случае
   средний элемент), перемещает его в конец массива и затем переставляет
   элементы так, чтобы все элементы меньше или равные опорному были слева от
   него, а все большие — справа. В конце он возвращает индекс опорного элемента.

3. **Метод `swap`**: Упрощает обмен значениями двух элементов в массиве.

4. **Метод `printArray`**: Просто выводит массив на экран.

Вы можете запустить этот код в любой среде разработки Java или
онлайн-компиляторе.

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Основная идея
заключается в том, чтобы выбрать опорный элемент (pivot) и разделить массив на
две части: элементы, меньшие опорного, и элементы, большие опорного. Затем
рекурсивно сортируются обе части.

### Реализация "Медиана трех:

Вот реализация быстрой сортировки с использованием метода "медиана трех" на
Java. Этот метод выбирает опорный элемент как медиану из трех значений (первый,
последний и средний элементы), что помогает улучшить производительность
алгоритма в большинстве случаев.

```java
public class QuickSortMedianOfThree {

    public static void quickSort(int[] array) {
        quickSort(array, 0, array.length - 1);
    }

    private static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Находим индекс опорного элемента
            int pivotIndex = medianOfThree(array, low, high);
            pivotIndex = partition(array, low, high, pivotIndex);

            // Рекурсивно сортируем две части массива
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    private static int partition(int[] array, int low, int high, int pivotIndex) {
        int pivotValue = array[pivotIndex];
        swap(array, pivotIndex, high); // Перемещаем опорный элемент в конец
        int storeIndex = low;

        for (int i = low; i < high; i++) {
            if (array[i] < pivotValue) {
                swap(array, storeIndex++, i);
            }
        }
        swap(array, storeIndex, high); // Возвращаем опорный элемент на его место
        return storeIndex;
    }

    private static int medianOfThree(int[] array, int low, int high) {
        int mid = low + (high - low) / 2;

        // Сравниваем и меняем местами элементы для нахождения медианы
        if (array[low] > array[mid]) swap(array, low, mid);
        if (array[low] > array[high]) swap(array, low, high);
        if (array[mid] > array[high]) swap(array, mid, high);

        // Возвращаем индекс медианы
        return mid;
    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};

        System.out.println("Исходный массив:");
        printArray(array);

        quickSort(array);

        System.out.println("Отсортированный массив:");
        printArray(array);
    }

    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

#### Объяснение кода:

1. **Метод `quickSort`**: Это основной метод быстрой сортировки. Он принимает
   массив и границы сортируемой части массива (`low` и `high`). Если границы
   корректны (`low < high`), он вызывает метод `medianOfThree` для выбора
   опорного элемента и затем метод `partition`.

2. **Метод `partition`**: Этот метод выполняет разбиение массива на две части
   относительно опорного элемента. Все элементы меньше опорного перемещаются
   влево от него.

3. **Метод `medianOfThree`**: Этот метод выбирает опорный элемент как медиану из
   трех значений: первого элемента (`low`), среднего элемента (`mid`) и
   последнего элемента (`high`). Он меняет местами элементы так, чтобы медиана
   оказалась на позиции `mid`.

4. **Метод `swap`**: Этот вспомогательный метод меняет местами два элемента в
   массиве.

5. **Метод `printArray`**: Этот метод выводит массив на экран.

#### Примечания:

- Использование медианы из трех помогает избежать худших случаев при уже
  отсортированных данных.
- Эта реализация быстрой сортировки является рекурсивной и может быть
  дополнительно оптимизирована для работы с малыми подмассивами с помощью
  сортировки вставками.

Подробное описание

Конечно! Давайте подробно разберем реализацию быстрой сортировки с
использованием метода "медиана трех" на Java, который я предоставил ранее. Мы
рассмотрим каждый компонент кода и его функциональность.

#### Основные компоненты реализации

1. **Метод `quickSort`**:
    - Это основной метод, который запускает процесс быстрой сортировки.
    - Он принимает массив и границы сортируемой части массива (`low` и `high`).
    - Если `low < high`, это означает, что в массиве есть более одного элемента,
      и мы можем продолжать сортировку.
    - Метод вызывает `medianOfThree`, чтобы выбрать опорный элемент, а затем
      `partition`, чтобы разделить массив.

2. **Метод `partition`**:
    - Этот метод отвечает за разбиение массива на две части относительно
      опорного элемента.
    - Он принимает массив, границы (`low` и `high`) и индекс опорного элемента (
      `pivotIndex`).
    - Опорный элемент перемещается в конец массива для удобства работы.
    - Затем происходит итерация по элементам массива: если элемент меньше
      опорного, он перемещается влево от него.
    - В конце метод возвращает индекс, на котором находится опорный элемент
      после разбиения.

3. **Метод `medianOfThree`**:
    - Этот метод выбирает опорный элемент как медиану из трех значений: первого
      элемента (`low`), среднего элемента (`mid`) и последнего элемента (
      `high`).
    - Сравниваются значения этих трех элементов, и они меняются местами так,
      чтобы медиана оказалась на позиции `mid`.
    - Возвращает индекс медианы, который будет использоваться как опорный
      элемент в процессе разбиения.

4. **Метод `swap`**:
    - Вспомогательный метод для обмена местами двух элементов в массиве.
    - Используется для упрощения кода при перестановке элементов.

5. **Метод `printArray`**:
    - Этот метод просто выводит элементы массива на экран для удобства проверки
      результата.

#### Пример работы алгоритма

Рассмотрим пример работы алгоритма на массиве `{10, 7, 8, 9, 1, 5}`:

1. **Первый вызов `quickSort(array, 0, 5)`**:
    - Выбираем медиану из трех: `{10 (low), 8 (mid), 5 (high)}` → медиана = 8.
    - Разбиваем массив относительно 8. После разбиения получаем:
      `{7, 5, 1 | 8 | 10, 9}` (где | обозначает позицию опорного элемента).

2. **Рекурсивные вызовы**:
    - Сортируем левую часть `{7, 5, 1}`:
        - Медиана = 5 → разбиваем: `{1 | 5 | 7}`.
        - Сортируем `{1}` и `{7}` (они уже отсортированы).

3. **Сортируем правую часть `{10, 9}`**:
    - Медиана = 10 → разбиваем: `{9 | 10}` (они также уже отсортированы).

4. В результате получаем отсортированный массив: `{1, 5, 7, 8, 9, 10}`.

#### Преимущества метода "медиана трех"

- **Снижение вероятности худших случаев**: Выбор опорного элемента как медианы
  из трех помогает избежать ситуации с худшим временем выполнения O(n²), которая
  может возникнуть при использовании крайних значений (например, если массив уже
  отсортирован).
- **Улучшение производительности**: В большинстве случаев это приводит к более
  сбалансированным разделениям массива и улучшает общую производительность
  алгоритма.

#### Заключение

Быстрая сортировка с использованием метода "медиана трех" является эффективным
алгоритмом сортировки с хорошими средними показателями производительности. Она
широко используется благодаря своей простоте и эффективности в большинстве
практических случаев.

========================

## Критерии выбора опорного элемента для сортировки:

Выбор опорного элемента (пивота) в алгоритме быстрой сортировки может
существенно повлиять на производительность алгоритма. Вот несколько
распространенных стратегий выбора опорного элемента и их преимущества:

1. Последний элемент: Это простейший способ, который часто используется в
   учебных примерах. Однако он может привести к плохой производительности (O(
   n²)), если массив уже отсортирован или почти отсортирован.

2. Первый элемент: Аналогично последнему элементу, выбор первого элемента также
   может привести к плохой производительности в случае уже отсортированного
   массива.

3. Случайный элемент: Выбор случайного элемента в качестве опорного может помочь
   избежать худших случаев, связанных с уже отсортированными массивами. Это
   делает алгоритм более устойчивым к различным входным данным.

4. Медиана трех: Эта стратегия включает выбор медианы из трех элементов:
   первого, среднего и последнего. Это позволяет выбрать более "средний"
   элемент, что обычно приводит к лучшему разделению массива и, как следствие, к
   лучшей производительности.

5. Медиана: Если возможно, можно использовать медиану всего массива как опорный
   элемент. Однако это требует дополнительной вычислительной работы и не всегда
   целесообразно.

**Рекомендации:**

Для большинства практических случаев рекомендуется использовать стратегию "
медиана трех", так как она обеспечивает хорошее разделение и минимизирует
вероятность худшего случая.
Если вы работаете с большими массивами или данными, которые могут быть уже
отсортированы или почти отсортированы, стоит рассмотреть использование
случайного выбора или медианы трех.
Пример реализации медианы трех:
Вот как можно изменить метод partition, чтобы использовать медиану трех в
качестве опорного элемента:

```java
private static int partition(int[] array, int low, int high) {
    // Находим медиану из первого, среднего и последнего элементов
    int mid = low + (high - low) / 2;
    int pivot = medianOfThree(array[low], array[mid], array[high]);

    // Перемещаем опорный элемент в конец
    if (pivot == array[low]) {
        swap(array, low, high);
    } else if (pivot == array[mid]) {
        swap(array, mid, high);
    }

    pivot = array[high]; // Теперь последний элемент - это наш опорный
    int i = (low - 1);

    for (int j = low; j < high; j++) {
        if (array[j] <= pivot) {
            i++;
            swap(array, i, j);
        }
    }
    swap(array, i + 1, high);
    return i + 1;
}

private static int medianOfThree(int a, int b, int c) {
    if ((a > b) ^ (a > c)) return a; // a - медиана
    else if ((b > a) ^ (b > c)) return b; // b - медиана
    else return c; // c - медиана
}
```

Индекс меньшего элемента в алгоритме быстрой сортировки инициализируется
значением low - 1 по следующим причинам:

Инициализация: Мы начинаем с предположения, что до начала процесса сортировки
нет элементов, меньших опорного. Установка индекса меньшего элемента на low - 1
позволяет нам легко увеличивать его, когда мы находим элемент, который меньше
или равен опорному.

Упрощение обмена: Когда мы находим элемент, который меньше или равен опорному
элементу, мы увеличиваем индекс меньшего элемента (i) и затем меняем местами
текущий элемент с элементом на позиции i. Это позволяет нам "собирать" все
элементы, которые меньше или равны опорному, в начале массива.

Логика работы: В начале алгоритма индекс i указывает на позицию перед первым
элементом подмассива (то есть перед low). Когда мы находим элемент, который
меньше или равен опорному, мы перемещаем его в "левую" часть массива (в область
меньших элементов), увеличивая индекс i. Таким образом, все элементы до индекса
i будут меньше или равны опорному.

Пример:
Рассмотрим массив [10, 7, 8, 9, 1, 5] и выберем опорный элемент (например,
последний элемент 5).

Изначально low = 0, high = 5, и индекс меньшего элемента (i) будет равен -1.
Мы начинаем проходить массив от индекса low до high - 1.
Если мы встречаем элемент (например, 1), который меньше или равен опорному (5),
мы увеличиваем i до 0, а затем меняем местами элементы на позициях 0 и 1. Теперь
массив выглядит как [1, 7, 8, 9, 10, 5], и индекс меньшего элемента указывает на
первый элемент.
Этот процесс продолжается для всех элементов массива.
Таким образом, использование значения low - 1 для индекса меньшего элемента
позволяет удобно управлять процессом сортировки и упрощает логику обмена
элементов.

## Реализация с последним опорным элементом

```java
public class QuickSort {

    // Метод для выполнения быстрой сортировки
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Находим индекс разделителя
            int pivotIndex = partition(arr, low, high);
            // Рекурсивно сортируем элементы до и после разделителя
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    // Метод для разделения массива и нахождения индекса разделителя
    public static int partition(int[] arr, int low, int high) {
        int pivot = array[high]; // Выбираем последний элемент в качестве опорного
        int i = (low - 1); // Индекс меньшего элемента
        for (int j = low; j < high; j++) {
            // Если текущий элемент меньше или равен опорному
            if (arr[j] <= pivot) {
                i++;
                // Меняем местами элементы
                swap(arr, i, j);
            }
        }
        // Меняем местами опорный элемент с элементом на позиции i + 1
        swap(arr, i + 1, high);
        return i + 1; // Возвращаем индекс разделителя
    }

    // Метод для обмена элементов массива
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};
        System.out.println("Исходный массив:");
        printArray(array);

        quickSort(array, 0, array.length - 1);

        System.out.println("Отсортированный массив:");
        printArray(array);
    }

    // Метод для вывода массива на экран
    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

Объяснение кода:

quickSort(int[] arr, int low, int high):

Это рекурсивная функция, которая выполняет сортировку.
Она принимает массив arr, индекс начала low и индекс конца high сортируемой
части массива.
Если low < high, это означает, что в массиве есть как минимум два элемента для
сортировки.
Функция вызывает partition для разделения массива и получения индекса опорного
элемента.
Затем она рекурсивно вызывает quickSort для сортировки подмассивов до и после
опорного элемента.
partition(int[] arr, int low, int high):

Эта функция выбирает последний элемент arr[high] в качестве опорного.
Она переставляет элементы массива так, чтобы все элементы, меньшие опорного,
оказались перед ним, а все элементы, большие опорного, — после него.
Функция возвращает индекс опорного элемента после разделения.
swap(int[] arr, int i, int j):

Это вспомогательная функция для обмена двух элементов массива.
main(String[] args):

Это основная функция, которая создает массив, вызывает quickSort для его
сортировки и выводит отсортированный массив.
Как работает быстрая сортировка:

Выбор опорного элемента: Из массива выбирается опорный элемент. В этом примере
мы выбираем последний элемент.
Разделение: Массив разделяется на две части: элементы, меньшие опорного, и
элементы, большие опорного.
Рекурсия: Быстрая сортировка рекурсивно применяется к обеим частям массива.
Временная сложность:

Средняя: O(n log n)
Худшая: O(n^2) (возникает, когда опорный элемент всегда является наименьшим или
наибольшим элементом)
Быстрая сортировка обычно является одним из самых быстрых алгоритмов сортировки
для больших массивов.

## Оптимальная реализация с случайным опорным элементом

```java
import java.util.Random;

public class OptimizedQuickSort {

    private static final int INSERTION_SORT_THRESHOLD = 10;

    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    private static void quickSort(int[] arr, int low, int high) {
        while (low < high) {
            if (high - low <= INSERTION_SORT_THRESHOLD) {
                insertionSort(arr, low, high);
                return;
            }

            int pivotIndex = partition(arr, low, high);

            if (pivotIndex - low < high - pivotIndex) {
                quickSort(arr, low, pivotIndex - 1);
                low = pivotIndex + 1;
            } else {
                quickSort(arr, pivotIndex + 1, high);
                high = pivotIndex - 1;
            }
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivotIndex = getRandomPivot(low, high);
        swap(arr, pivotIndex, high);
        int pivot = arr[high];

        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return i + 1;
    }

    private static void insertionSort(int[] arr, int low, int high) {
        for (int i = low + 1; i <= high; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    private static int getRandomPivot(int low, int high) {
        Random random = new Random();
        return random.nextInt(high - low + 1) + low;
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        quickSort(arr);
        System.out.println("Отсортированный массив:");
        for (int value : arr) {
            System.out.print(value + " ");
        }
    }
}
```

Оптимизации:

1. Выбор случайного опорного элемента: Функция getRandomPivot выбирает случайный
   опорный элемент, что помогает избежать худшего случая, когда массив уже
   отсортирован или почти отсортирован.
2. Использование сортировки вставками для небольших подмассивов: Когда размер
   подмассива становится меньше INSERTION_SORT_THRESHOLD, алгоритм переключается
   на сортировку вставками, которая более эффективна для небольших массивов.
3. Итеративная реализация с оптимизацией хвостовой рекурсии: Рекурсия заменена
   на цикл while, а также оптимизирована хвостовая рекурсия, что предотвращает
   переполнение стека для больших массивов.
4. Медиана из трёх: Вместо выбора случайного опорного элемента, можно
   использовать медиану из трёх элементов (первый, средний и последний) для
   выбора опорного элемента, что еще больше уменьшает вероятность худшего
   случая.

Эти оптимизации делают быструю сортировку более эффективной и устойчивой к
различным типам входных данных.

