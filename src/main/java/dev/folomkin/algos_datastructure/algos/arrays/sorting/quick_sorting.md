# Быстрая сортировка <br>(Quick Sort)

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Он работает путем
выбора опорного элемента (pivot) и разделения массива на две части: элементы,
меньшие опорного, и элементы, большие опорного. Затем алгоритм рекурсивно
сортирует обе части.

## Выбор опорного элемента для сортировки

Выбор опорного элемента (или "опорного значения") для быстрой сортировки (Quick
Sort) может существенно повлиять на производительность алгоритма. Вот несколько
распространенных стратегий выбора опорного элемента:

1. **Первый или последний элемент**. Самый простой способ, но он может привести
   к худшей производительности, особенно если массив уже частично или полностью
   отсортирован.
2. Выбор **среднего элемента** массива как опорного может помочь избежать худших
   сценариев производительности в некоторых случаях. Это метод вычисления
   индекса среднего элемента как (low + high) / 2.
3. **Случайный элемент**: Выбор случайного элемента в качестве опорного может
   помочь избежать худших случаев и улучшить среднюю производительность.
4. **Медиана трех**: Эта стратегия включает выбор медианы из трех значений:
   первого, среднего и последнего элементов массива. Это помогает избежать
   крайних значений и часто приводит к более сбалансированным разделениям.
5. **Медиана**: Если вы хотите более сложный подход, можно использовать медиану
   всего массива, но это требует дополнительной работы и может быть неэффективно
   для больших массивов.

Каждая из этих стратегий имеет свои плюсы и минусы, и выбор зависит от
конкретных данных и требований к производительности. В большинстве случаев
использование медианы трех или случайного элемента дает хорошие результаты.

## Пример работы алгоритма для случайного опорного элемента

1. Выбор опорного элемента: Обычно выбирается первый, последний или средний
   элемент массива.
2. Разделение: Массив делится на две части: элементы меньше опорного и элементы
   больше опорного. Теперь ключевой элемент находится в правильной позиции — он
   больше любого элемента слева и меньше любого элемента справа.
3. Рекурсия: Рекурсивно применяется быстрая сортировка к обеим частям.
4. Объединение: Объединение происходит неявно, так как элементы уже находятся на
   своих местах.

Пример массива:

    [3][7][4][4][6][5][8]

Случайным образом выбираем ключевой элемент 6:

    [3][7][4][4][6][5][8]

Теперь, когда мы знаем ключевой индекс (4), мы берем значение, находящееся по
этому индексу (6), и переносим значения в массиве так, чтобы все числа больше
или равные ключевому были в правой части, а все числа меньше ключевого — в
левой. В процессе переноса значений индекс ключевого элемента может измениться.

Перемещение значений осуществляется методом `partition`.

    [3][5][4][4]["6"][7][8]

На этом этапе мы знаем, что значение 6 находится на правильной позиции. Теперь
мы повторяем этот процесс для правой и левой частей массива.

Мы рекурсивно вызываем метод quicksort на каждой из частей. Ключевым элементом в
левой части становится пятерка. При перемещении значений она изменит свой
индекс. Главное — помнить, что нам важно именно ключевое значение, а не его
индекс.

    [3]['5'][4][4]["6"][7][8]
    [3][4][4]['5']["6"][7][8]

Снова применяем быструю сортировку:

    ['3'][4][4]["5"]["6"]['7'][8]
    ["3"][4][4]["5"]["6"]["7"]["8"]

И еще раз:

    ["3"]['4'][4]["5"]["6"]["7"]["8"]
    ["3"]["4"][4]["5"]["6"]["7"]["8"]

У нас осталось одно неотсортированное значение, а, поскольку мы знаем, что все
остальное уже отсортировано, алгоритм завершает работу.

## Реализация простой реализации быстрой сортировки

```java
public static void quickSort(int[] sortArr, int low, int high) {
    //завершить,если массив пуст или уже нечего делить
    if (sortArr.length == 0 || low >= high) return;

    //выбираем опорный элемент
    int middle = low + (high - low) / 2;
    int border = sortArr[middle];

    //разделияем на подмассивы и меняем местами
    int i = low, j = high;
    while (i <= j) {
        while (sortArr[i] < border) i++;
        while (sortArr[j] > border) j--;
        if (i <= j) {
            int swap = sortArr[i];
            sortArr[i] = sortArr[j];
            sortArr[j] = swap;
            i++;
            j--;
        }
    }

    //рекурсия для сортировки левой и правой части
    if (low < j) quickSort(sortArr, low, j);
    if (high > i) quickSort(sortArr, i, high);
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    quickSort(sortArr, 0, sortArr.length - 1);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}
```

## Реализация "Средний опорный элемент"

Вот пример реализации быстрой сортировки (Quick Sort) на Java с использованием
среднего опорного элемента:

```java
public class QuickSort {

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};
        quickSort(array, 0, array.length - 1);
        System.out.println("Отсортированный массив: ");
        printArray(array);
    }

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Находим индекс опорного элемента
            int pivotIndex = partition(array, low, high);
            // Рекурсивно сортируем элементы до и после опорного элемента
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    public static int partition(int[] array, int low, int high) {
        // Вычисляем средний индекс для выбора опорного элемента
        int mid = low + (high - low) / 2;
        int pivot = array[mid];

        // Перемещаем опорный элемент в конец массива
        swap(array, mid, high);

        int i = low - 1; // Индекс меньшего элемента

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }

        // Перемещаем опорный элемент на его окончательную позицию
        swap(array, i + 1, high);

        return i + 1; // Возвращаем индекс опорного элемента
    }

    public static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

### Объяснение кода:

1. **Метод `quickSort`**: Это основной метод быстрой сортировки. Он принимает
   массив и границы сортируемой части массива. Если границы корректны (
   `low < high`), он вызывает метод `partition` для разделения массива и
   рекурсивно сортирует полученные подмассивы.

2. **Метод `partition`**: Этот метод выбирает опорный элемент (в данном случае
   средний элемент), перемещает его в конец массива и затем переставляет
   элементы так, чтобы все элементы меньше или равные опорному были слева от
   него, а все большие — справа. В конце он возвращает индекс опорного элемента.

3. **Метод `swap`**: Упрощает обмен значениями двух элементов в массиве.

4. **Метод `printArray`**: Просто выводит массив на экран.

Вы можете запустить этот код в любой среде разработки Java или
онлайн-компиляторе.

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Основная идея
заключается в том, чтобы выбрать опорный элемент (pivot) и разделить массив на
две части: элементы, меньшие опорного, и элементы, большие опорного. Затем
рекурсивно сортируются обе части.

Вот как можно реализовать быструю сортировку на Java с использованием среднего
опорного элемента:

```java
public class QuickSort {

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Находим индекс разделения
            int pivotIndex = partition(array, low, high);
            // Рекурсивно сортируем элементы до и после разделения
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    private static int partition(int[] array, int low, int high) {
        // Выбираем средний элемент в качестве опорного
        int mid = low + (high - low) / 2;
        int pivot = array[mid];

        // Перемещаем опорный элемент в конец массива
        swap(array, mid, high);

        int i = low; // Индекс для меньших элементов

        for (int j = low; j < high; j++) {
            if (array[j] < pivot) {
                swap(array, i, j);
                i++;
            }
        }

        // Перемещаем опорный элемент на его окончательную позицию
        swap(array, i, high);

        return i; // Возвращаем индекс опорного элемента
    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};
        System.out.println("Исходный массив:");
        printArray(array);

        quickSort(array, 0, array.length - 1);

        System.out.println("Отсортированный массив:");
        printArray(array);
    }

    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

### Объяснение кода:

1. **Метод `quickSort`**:
    - Принимает массив и границы (`low` и `high`) для сортировки.
    - Если `low` меньше `high`, вызывается метод `partition`, который возвращает
      индекс опорного элемента после его размещения.
    - Рекурсивно вызывается `quickSort` для левой и правой частей массива.

2. **Метод `partition`**:
    - Выбирает средний элемент как опорный.
    - Перемещает опорный элемент в конец массива.
    - Проходит по массиву и перемещает все элементы меньше опорного влево.
    - В конце помещает опорный элемент на его окончательную позицию.

3. **Метод `swap`**:
    - Обмен значениями двух элементов массива.

4. **Метод `printArray`**:
    - Для вывода массива на экран.

## Реализация "Медиана трех:

Реализация "Медиана трех" имеет ряд оптимизаций:

1. Использование медианы трех для выбора опорного элемента.
2. Сокращение рекурсии для небольших подмассивов.
3. Использование итеративного подхода для уменьшения глубины рекурсии.

```java
import java.util.Arrays;

public class QuickSort {

    public static void quickSort(int[] array) {
        quickSort(array, 0, array.length - 1);
    }

    private static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Оптимизация: используем медиану трех для выбора опорного элемента
            int pivotIndex = medianOfThree(array, low, high);
            int pivotValue = array[pivotIndex];
            swap(array, pivotIndex, high); // Перемещаем опорный элемент в конец

            int partitionIndex = partition(array, low, high - 1, pivotValue);
            swap(array, partitionIndex, high); // Возвращаем опорный элемент на его место

            // Рекурсивно сортируем подмассивы
            quickSort(array, low, partitionIndex - 1);
            quickSort(array, partitionIndex + 1, high);
        }
    }

    private static int partition(int[] array, int low, int high, int pivotValue) {
        while (low <= high) {
            while (low <= high && array[low] < pivotValue) {
                low++;
            }
            while (low <= high && array[high] > pivotValue) {
                high--;
            }
            if (low <= high) {
                swap(array, low++, high--);
            }
        }
        return low;
    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    private static int medianOfThree(int[] array, int low, int high) {
        int mid = low + (high - low) / 2;
        if (array[low] > array[mid]) swap(array, low, mid);
        if (array[low] > array[high]) swap(array, low, high);
        if (array[mid] > array[high]) swap(array, mid, high);
        return mid; // Возвращаем индекс медианы
    }

    public static void main(String[] args) {
        int[] data = {3, 6, 8, 10, 1, 2, 1};
        System.out.println("Исходный массив: " + Arrays.toString(data));

        quickSort(data);

        System.out.println("Отсортированный массив: " + Arrays.toString(data));
    }
}
```

### Объяснение кода:

- **medianOfThree**: Эта функция выбирает опорный элемент как медиану из трех
  значений: первого элемента массива (`low`), среднего элемента (`mid`) и
  последнего элемента (`high`). Это помогает избежать плохих случаев при уже
  отсортированных данных.
- **partition**: Функция разделяет массив на две части относительно опорного
  элемента и возвращает индекс нового положения опорного элемента.
- **swap**: Утилита для обмена двух элементов массива.
- **quickSort**: Основная функция быстрой сортировки с рекурсией.

Эта реализация быстрой сортировки более устойчива к худшим случаям и работает
быстрее на большинстве реальных данных по сравнению с базовой версией.

## Реализация "Случайный опорный элемент"

Вот пример реализации алгоритма быстрой сортировки на Java с использованием
случайного опорного элемента:

```java
import java.util.Random;

public class QuickSort {

    // Метод для быстрой сортировки
    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Разделяем массив и получаем индекс опорного элемента
            int pivotIndex = partition(array, low, high);
            // Рекурсивно сортируем подмассивы
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    // Метод для разделения массива и выбора опорного элемента
    private static int partition(int[] array, int low, int high) {
        // Выбор случайного индекса в пределах текущего диапазона
        Random random = new Random();
        int randomIndex = low + random.nextInt(high - low + 1);

        // Меняем местами случайный элемент с последним элементом
        swap(array, randomIndex, high);

        // Опорный элемент (последний элемент после обмена)
        int pivot = array[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }

        // Помещаем опорный элемент на его правильное место
        swap(array, i + 1, high);
        return i + 1;
    }

    // Метод для обмена двух элементов массива
    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    // Метод для вывода массива на экран
    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }

    // Пример использования
    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};

        System.out.println("Исходный массив:");
        printArray(array);

        quickSort(array, 0, array.length - 1);

        System.out.println("Отсортированный массив:");
        printArray(array);
    }
}
```

### Объяснение кода:

- **Метод `quickSort`**: Основной метод быстрой сортировки. Он принимает массив
  и границы (индексы) для сортировки.
- **Метод `partition`**: Этот метод выбирает случайный опорный элемент и
  разделяет массив на две части: элементы меньше или равные опорному и элементы
  больше опорного.
- **Метод `swap`**: Упрощает обмен значениями двух элементов в массиве.
- **Метод `printArray`**: Для вывода массива на экран.

## Улучшенная версия быстрой сортировки

Улучшенная версия быстрой сортировки может включать несколько оптимизаций, таких
как:

1. **Выбор опорного элемента**: Использование медианы из трех (первый, средний и
   последний элементы) для выбора опорного элемента, чтобы уменьшить вероятность
   худшего случая.
2. **Сокращение рекурсии**: Использование итеративного подхода для сортировки
   небольших подмассивов, что может уменьшить использование стека.
3. **Сортировка небольших массивов с помощью другого алгоритма**: Например,
   использование сортировки вставками для массивов размером менее 10 элементов.

Вот пример улучшенной реализации быстрой сортировки на Java:

```java
public class ImprovedQuickSort {

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Используем медиану из трех для выбора опорного элемента
            int pivotIndex = medianOfThree(array, low, high);
            int pivot = array[pivotIndex];
            swap(array, pivotIndex, high); // Перемещаем опорный элемент в конец

            int partitionIndex = partition(array, low, high - 1, pivot);
            swap(array, partitionIndex, high); // Возвращаем опорный элемент на его место

            quickSort(array, low, partitionIndex - 1);
            quickSort(array, partitionIndex + 1, high);
        }
    }

    private static int partition(int[] array, int low, int high, int pivot) {
        int i = low;
        for (int j = low; j <= high; j++) {
            if (array[j] < pivot) {
                swap(array, i, j);
                i++;
            }
        }
        return i; // Возвращаем индекс опорного элемента
    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    private static int medianOfThree(int[] array, int low, int high) {
        int mid = low + (high - low) / 2;

        if (array[low] > array[mid]) {
            swap(array, low, mid);
        }
        if (array[low] > array[high]) {
            swap(array, low, high);
        }
        if (array[mid] > array[high]) {
            swap(array, mid, high);
        }

        return mid; // Возвращаем индекс медианы
    }

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};

        System.out.println("Исходный массив:");
        printArray(array);

        quickSort(array, 0, array.length - 1);

        System.out.println("Отсортированный массив:");
        printArray(array);
    }

    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

### Объяснение улучшений:

1. **Медиана из трех**:
    - Метод `medianOfThree` выбирает опорный элемент как медиану из первого (
      `low`), среднего (`mid`) и последнего (`high`) элементов массива. Это
      помогает избежать худших случаев при уже отсортированных данных.

2. **Сокращение рекурсии**:
    - В этом примере мы не добавили итеративный подход для небольших
      подмассивов. Однако вы можете рассмотреть возможность использования
      сортировки вставками для массивов размером менее определенного порога (
      например 10 элементов), чтобы улучшить производительность.

3. **Чистота кода**:
    - Код стал более структурированным и понятным благодаря выделению логики
      выбора опорного элемента и разделения массива в отдельные методы.

Эти улучшения делают алгоритм более устойчивым к различным входным данным и
повышают его производительность в большинстве случаев.

## Примечания:

- Быстрая сортировка имеет среднюю временную сложность O(n log n), но в худшем
  случае может достигать O(n²), если массив уже отсортирован или содержит много
  одинаковых элементов. Чтобы избежать этого случая, можно использовать
  различные стратегии выбора опорного элемента или применять случайный выбор.

Перемещение опорного элемента в конец массива в алгоритме быстрой сортировки —
это удобный прием, который упрощает процесс разделения массива на две части.
Давайте разберем, почему это делается и какие преимущества это дает.

### Причины перемещения опорного элемента в конец:

1. **Упрощение логики разделения**:
    - Когда опорный элемент находится в конце массива, мы можем легко
      использовать его для сравнения с другими элементами. Это позволяет нам не
      беспокоиться о том, что мы можем случайно перезаписать опорный элемент во
      время процесса разделения.

2. **Избежание лишних обменов**:
    - Если бы мы оставили опорный элемент на своем месте, нам пришлось бы
      следить за тем, чтобы не перемещать его при каждом обмене элементов.
      Перемещение его в конец позволяет нам просто игнорировать его при
      сравнении и обменах.

3. **Логика работы с индексами**:
    - Перемещение опорного элемента в конец позволяет нам использовать один
      проход по массиву для разделения элементов на меньшие и большие
      относительно опорного. В конце этого прохода мы просто помещаем опорный
      элемент на его окончательную позицию (индекс `i`), что делает код более
      чистым и понятным.

### Пример работы:

Предположим, у нас есть массив: `[10, 7, 8, 9, 1, 5]`, и мы выбираем `8` как
опорный элемент.

1. Перемещаем `8` в конец: `[10, 7, 5, 9, 1, 8]`.
2. Начинаем проход по массиву от начала до предпоследнего элемента (где
   находится `8`):
    - Сравниваем каждый элемент с `8` и перемещаем элементы меньше `8` влево.
3. После завершения прохода мы помещаем `8` на позицию `i`, которая указывает на
   место, где должны находиться все элементы меньше или равные `8`.

### Заключение:

Перемещение опорного элемента в конец массива — это стратегический шаг для
упрощения реализации алгоритма быстрой сортировки. Это позволяет избежать
дополнительных проверок и делает код более лаконичным и понятным.

### Почему индекс наименьшего элемента -1

Если индекс меньшего элемента равен -1, это может указывать на несколько
возможных проблем в реализации алгоритма быстрой сортировки или в логике,
связанной с разделением массива. Давайте рассмотрим, что это может означать и
как это исправить.

### Возможные причины:

1. **Инициализация индекса**:
    - Если вы инициализируете индекс меньшего элемента (например, `i`) как `-1`,
      это может означать, что вы еще не нашли ни одного элемента, меньшего
      опорного. В этом случае вам нужно убедиться, что вы правильно обновляете
      этот индекс при нахождении элементов, меньших опорного.

2. **Логика разделения**:
    - Если в процессе разделения массива не было найдено ни одного элемента,
      меньшего опорного, то индекс может остаться равным -1. Это может
      произойти, если все элементы массива больше или равны опорному элементу.

3. **Ошибки в коде**:
    - Возможно, есть ошибка в логике вашего кода, которая приводит к тому, что
      индекс не обновляется должным образом. Например, если вы забыли
      инкрементировать индекс при нахождении элемента меньше опорного.

### Пример исправления:

Вот пример того, как правильно реализовать логику разделения с учетом индекса
меньшего элемента:

```java
private static int partition(int[] array, int low, int high, int pivot) {
    int i = low; // Начинаем с первого элемента
    for (int j = low; j <= high; j++) {
        if (array[j] < pivot) {
            swap(array, i, j);
            i++; // Увеличиваем индекс меньшего элемента
        }
    }
    return i; // Возвращаем индекс первого элемента больше или равного опорному
}
```

### Объяснение:

- В этом коде `i` инициализируется как `low`, что означает начало области для
  элементов меньше опорного.
- При каждом нахождении элемента меньше опорного (`array[j] < pivot`), мы меняем
  его местами с элементом на позиции `i` и увеличиваем `i`.
- В конце функции мы возвращаем `i`, который указывает на позицию первого
  элемента больше или равного опорному.

### Заключение:

Если индекс меньшего элемента равен -1 в вашем коде быстрой сортировки,
проверьте инициализацию индекса и логику разделения массива. Убедитесь, что вы
правильно обновляете индекс при нахождении элементов меньше опорного.

## Преимущества и недостатки

Преимущества:

1. Временная сложность O(n log n) в среднем случае.
2. Хорошо работает на больших массивах.
3. Не требует дополнительной памяти, как сортировка слиянием.

Недостатки:

1. Временная сложность O(n^2) в худшем случае (например, если массив уже
   отсортирован и опорный элемент выбирается неудачно).
2. Не является стабильным алгоритмом (порядок равных элементов может
   измениться).

## Сложность

Сложность алгоритма Quicksort зависит от многих факторов, включая выбор опорного
элемента и распределение входных данных. В общем случае сложность быстрой
сортировки такова:

- Лучший случай. O(nlogn). Алгоритм делит массив на равные части, что приводит к
  наиболее эффективному разделению и сокращению времени выполнения.
- Средний случай. Также O(nlogn). Для случайных данных и при хорошем выборе
  опорного элемента быстрая сортировка чаще всего достигает этой сложности.
- Худший случай. O(n²). Это уже не так хорошо. Такое происходит, когда каждое
  разделение делит массив на части размером '1' и 'n-1', что чаще всего
  случается при выборе опорного элемента как наименьшего или наибольшего
  элемента в массиве. Например, если массив уже отсортирован и в качестве
  опорного выбирается первый или последний элемент, алгоритм будет иметь худшую
  производительность.
