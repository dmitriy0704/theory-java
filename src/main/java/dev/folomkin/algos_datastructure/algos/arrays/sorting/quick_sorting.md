# Быстрая сортировка <br>(Quick Sort)

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Он работает путем
выбора опорного элемента (pivot) и разделения массива на две части: элементы,
меньшие опорного, и элементы, большие опорного. Затем алгоритм рекурсивно
сортирует обе части.


### Почему индекс наименьшего элемента равен -1

Индекс меньшего элемента в алгоритме быстрой сортировки инициализируется
значением low - 1 по следующим причинам:

Инициализация: Мы начинаем с предположения, что до начала процесса сортировки
нет элементов, меньших опорного. Установка индекса меньшего элемента на low - 1
позволяет нам легко увеличивать его, когда мы находим элемент, который меньше
или равен опорному.

Упрощение обмена: Когда мы находим элемент, который меньше или равен опорному
элементу, мы увеличиваем индекс меньшего элемента (i) и затем меняем местами
текущий элемент с элементом на позиции i. Это позволяет нам "собирать" все
элементы, которые меньше или равны опорному, в начале массива.

Логика работы: В начале алгоритма индекс i указывает на позицию перед первым
элементом подмассива (то есть перед low). Когда мы находим элемент, который
меньше или равен опорному, мы перемещаем его в "левую" часть массива (в область
меньших элементов), увеличивая индекс i. Таким образом, все элементы до индекса
i будут меньше или равны опорному.

Пример:
Рассмотрим массив [10, 7, 8, 9, 1, 5] и выберем опорный элемент (например,
последний элемент 5).

Изначально low = 0, high = 5, и индекс меньшего элемента (i) будет равен -1.
Мы начинаем проходить массив от индекса low до high - 1.
Если мы встречаем элемент (например, 1), который меньше или равен опорному (5),
мы увеличиваем i до 0, а затем меняем местами элементы на позициях 0 и 1. Теперь
массив выглядит как [1, 7, 8, 9, 10, 5], и индекс меньшего элемента указывает на
первый элемент.
Этот процесс продолжается для всех элементов массива.
Таким образом, использование значения low - 1 для индекса меньшего элемента
позволяет удобно управлять процессом сортировки и упрощает логику обмена
элементов.

## Варианты реализаций

**Выбор опорного элемента для сортировки**

Быстрая сортировка имеет среднюю временную сложность O(n log n), но в худшем
случае может достигать O(n²), если массив уже отсортирован или содержит много
одинаковых элементов. Чтобы избежать этого случая, можно использовать
различные стратегии выбора опорного элемента или применять случайный выбор.

1. Последний элемент: Это простейший способ, который часто используется в
   учебных примерах. Однако он может привести к плохой производительности (O(
   n²)), если массив уже отсортирован или почти отсортирован.

2. Первый элемент: Аналогично последнему элементу, выбор первого элемента также
   может привести к плохой производительности в случае уже отсортированного
   массива.

3. Случайный элемент: Выбор случайного элемента в качестве опорного может помочь
   избежать худших случаев, связанных с уже отсортированными массивами. Это
   делает алгоритм более устойчивым к различным входным данным.

4. Медиана трех: Эта стратегия включает выбор медианы из трех элементов:
   первого, среднего и последнего. Это позволяет выбрать более "средний"
   элемент, что обычно приводит к лучшему разделению массива и, как следствие, к
   лучшей производительности.

5. Медиана: Если возможно, можно использовать медиану всего массива как опорный
   элемент. Однако это требует дополнительной вычислительной работы и не всегда
   целесообразно.

**Рекомендации:**

Для большинства практических случаев рекомендуется использовать стратегию "
медиана трех", так как она обеспечивает хорошее разделение и минимизирует
вероятность худшего случая.
Если вы работаете с большими массивами или данными, которые могут быть уже
отсортированы или почти отсортированы, стоит рассмотреть использование
случайного выбора или медианы трех.

### Реализация "Медиана трех":

Быстрая сортировка (QuickSort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Метод "медиана
трех" (median-of-three) используется для выбора опорного элемента (pivot) в
массиве, что помогает улучшить производительность алгоритма, особенно на уже
отсортированных или почти отсортированных данных.

Принцип работы метода "медиана трех"

1. Выбор опорного элемента: Вместо того чтобы просто выбирать первый, последний
   или случайный элемент массива в качестве опорного, мы выбираем медиану из
   трех элементов: первого, среднего и последнего. Это помогает избежать плохих
   случаев, когда опорный элемент оказывается наименьшим или наибольшим
   элементом.

2. Разделение массива: После выбора опорного элемента массив разделяется на две
   части: элементы меньше опорного и элементы больше опорного.

3. Рекурсивная сортировка: Рекурсивно применяем тот же процесс к подмассивам.

```java
public class QuickSort {

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(array, low, high);
            quickSort(array, low, pivotIndex - 1);  // Сортируем левую часть
            quickSort(array, pivotIndex + 1, high); // Сортируем правую часть
        }
    }

    private static int partition(int[] array, int low, int high) {
        // Выбор медианы трех
        int mid = low + (high - low) / 2;
        int pivot = medianOfThree(array[low], array[mid], array[high]);

        // Перемещение опорного элемента в конец
        if (pivot == array[low]) {
            swap(array, low, high);
        } else if (pivot == array[mid]) {
            swap(array, mid, high);
        }

        pivot = array[high]; // Теперь опорный элемент в конце

        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (array[j] < pivot) {
                i++;
                swap(array, i, j);
            }
        }

        // Перемещаем опорный элемент на его правильное место
        swap(array, i + 1, high);
        return i + 1;
    }

    private static int medianOfThree(int a, int b, int c) {
        if ((a > b) ^ (a > c)) return a; // a является медианой
        else if ((b > a) ^ (b > c)) return b; // b является медианой
        else return c; // c является медианой
    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void main(String[] args) {
        int[] array = {3, 6, 8, 10, 1, 2, 1};

        System.out.println("Исходный массив:");
        for (int num : array) {
            System.out.print(num + " ");
        }

        quickSort(array, 0, array.length - 1);

        System.out.println("\nОтсортированный массив:");
        for (int num : array) {
            System.out.print(num + " ");
        }
    }
}
```

Объяснение кода

1. Метод quickSort — основной метод для сортировки массива.
2. Метод partition отвечает за разделение массива и выбор опорного элемента с
   использованием метода "медиана трех".
3. Метод medianOfThree определяет медиану из трех переданных значений.
4. Метод swap используется для обмена значениями двух элементов массива.
5. В main создается пример массива и вызывается метод быстрой сортировки.
   Этот код демонстрирует базовую реализацию быстрой сортировки с использованием
   метода "медиана трех", что позволяет улучшить производительность алгоритма в
   некоторых случаях.

Перемещение опорного элемента в конец массива в реализации быстрой сортировки с
использованием метода "медиана трех" делается для упрощения процесса разделения
массива на две части. Давайте разберем, почему это делается и как это помогает.

Причины перемещения опорного элемента в конец:
Упрощение логики разделения: Когда опорный элемент находится в конце массива, мы
можем легко использовать его для сравнения с другими элементами. Это позволяет
нам избежать дополнительных условий для обработки опорного элемента во время
итерации по массиву.

Избежание путаницы: Если опорный элемент остается на своем первоначальном
месте (например, в начале или середине массива), нам нужно будет следить за тем,
чтобы не сравнивать его с самим собой во время процесса разделения. Перемещение
его в конец устраняет эту проблему.

Четкое разделение: Перемещение опорного элемента в конец позволяет нам четко
отделить элементы, меньшие и большие опорного элемента. Мы можем пройти по
массиву и перемещать элементы меньше опорного элемента влево, а затем просто
поместить опорный элемент на правильное место после завершения прохода.

Как это работает:
Выбор медианы: Мы выбираем медиану из трех элементов (первый, средний и
последний) и перемещаем ее в конец массива.

Разделение: Затем мы проходим по массиву от low до high - 1 (исключая последний
элемент, который теперь является опорным) и сравниваем каждый элемент с опорным:

Если элемент меньше опорного, мы увеличиваем индекс i и меняем местами текущий
элемент с элементом на позиции i.
Помещение опорного элемента: После завершения прохода по массиву мы помещаем
опорный элемент на позицию i + 1, что гарантирует, что все элементы слева от
него меньше, а все элементы справа — больше.

Пример:
Предположим, у нас есть массив [3, 6, 8, 10, 1, 2, 1], и мы выбрали 6 как
опорный элемент (медиана трех). После перемещения 6 в конец массив будет
выглядеть так: [3, 6, 8, 10, 1, 2, 6].

Теперь при проходе по массиву мы будем сравнивать каждый элемент с 6. В
результате мы можем легко организовать элементы так:

1. Все элементы меньше 6 будут слева.
2. Все элементы больше 6 будут справа.
3. В конце мы просто поместим 6 на правильное место.

Таким образом, перемещение опорного элемента в конец упрощает логику алгоритма и
делает его более понятным и эффективным.

### Базовая реализация быстрой сортировки<br> с средним опорным элементом

```java
public static void quickSort(int[] sortArr, int low, int high) {
    //завершить,если массив пуст или уже нечего делить
    if (sortArr.length == 0 || low >= high) return;

    //выбираем опорный элемент
    int middle = low + (high - low) / 2;
    int border = sortArr[middle];

    //Разделяем на подмассивы и меняем местами
    int i = low, j = high;
    while (i <= j) {
        while (sortArr[i] < border) i++;
        while (sortArr[j] > border) j--;
        if (i <= j) {
            int swap = sortArr[i];
            sortArr[i] = sortArr[j];
            sortArr[j] = swap;
            i++;
            j--;
        }
    }

    //рекурсия для сортировки левой и правой части
    if (low < j) quickSort(sortArr, low, j);
    if (high > i) quickSort(sortArr, i, high);
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    quickSort(sortArr, 0, sortArr.length - 1);
    for (int i = 0; i < sortArr.length; i++) {
        System.out.print(sortArr[i] + "\n");
    }
}
```

### Реализация "Средний опорный элемент"

Вот пример реализации быстрой сортировки (Quick Sort) на Java с использованием
среднего опорного элемента:

```java
public class QuickSort {

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};
        quickSort(array, 0, array.length - 1);
        System.out.println("Отсортированный массив: ");
        printArray(array);
    }

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Находим индекс опорного элемента
            int pivotIndex = partition(array, low, high);
            // Рекурсивно сортируем элементы до и после опорного элемента
            quickSort(array, low, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, high);
        }
    }

    public static int partition(int[] array, int low, int high) {
        // Вычисляем средний индекс для выбора опорного элемента
        int mid = low + (high - low) / 2;
        int pivot = array[mid];

        // Перемещаем опорный элемент в конец массива
        swap(array, mid, high);

        int i = low - 1; // Индекс меньшего элемента

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }

        // Перемещаем опорный элемент на его окончательную позицию
        swap(array, i + 1, high);

        return i + 1; // Возвращаем индекс опорного элемента
    }

    public static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

#### Объяснение кода:

1. **Метод `quickSort`**: Это основной метод быстрой сортировки. Он принимает
   массив и границы сортируемой части массива. Если границы корректны (
   `low < high`), он вызывает метод `partition` для разделения массива и
   рекурсивно сортирует полученные подмассивы.

2. **Метод `partition`**: Этот метод выбирает опорный элемент (в данном случае
   средний элемент), перемещает его в конец массива и затем переставляет
   элементы так, чтобы все элементы меньше или равные опорному были слева от
   него, а все большие — справа. В конце он возвращает индекс опорного элемента.

3. **Метод `swap`**: Упрощает обмен значениями двух элементов в массиве.

4. **Метод `printArray`**: Просто выводит массив на экран.

Вы можете запустить этот код в любой среде разработки Java или
онлайн-компиляторе.

Быстрая сортировка (Quick Sort) — это один из самых эффективных алгоритмов
сортировки, который использует метод "разделяй и властвуй". Основная идея
заключается в том, чтобы выбрать опорный элемент (pivot) и разделить массив на
две части: элементы, меньшие опорного, и элементы, большие опорного. Затем
рекурсивно сортируются обе части.

========================

## Реализация с последним опорным элементом

```java
public class QuickSort {

    // Метод для выполнения быстрой сортировки
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Находим индекс разделителя
            int pivotIndex = partition(arr, low, high);
            // Рекурсивно сортируем элементы до и после разделителя
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    // Метод для разделения массива и нахождения индекса разделителя
    public static int partition(int[] arr, int low, int high) {
        int pivot = array[high]; // Выбираем последний элемент в качестве опорного
        int i = (low - 1); // Индекс меньшего элемента
        for (int j = low; j < high; j++) {
            // Если текущий элемент меньше или равен опорному
            if (arr[j] <= pivot) {
                i++;
                // Меняем местами элементы
                swap(arr, i, j);
            }
        }
        // Меняем местами опорный элемент с элементом на позиции i + 1
        swap(arr, i + 1, high);
        return i + 1; // Возвращаем индекс разделителя
    }

    // Метод для обмена элементов массива
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};
        System.out.println("Исходный массив:");
        printArray(array);

        quickSort(array, 0, array.length - 1);

        System.out.println("Отсортированный массив:");
        printArray(array);
    }

    // Метод для вывода массива на экран
    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```

Объяснение кода:

quickSort(int[] arr, int low, int high):

Это рекурсивная функция, которая выполняет сортировку.
Она принимает массив arr, индекс начала low и индекс конца high сортируемой
части массива.
Если low < high, это означает, что в массиве есть как минимум два элемента для
сортировки.
Функция вызывает partition для разделения массива и получения индекса опорного
элемента.
Затем она рекурсивно вызывает quickSort для сортировки подмассивов до и после
опорного элемента.
partition(int[] arr, int low, int high):

Эта функция выбирает последний элемент arr[high] в качестве опорного.
Она переставляет элементы массива так, чтобы все элементы, меньшие опорного,
оказались перед ним, а все элементы, большие опорного, — после него.
Функция возвращает индекс опорного элемента после разделения.
swap(int[] arr, int i, int j):

Это вспомогательная функция для обмена двух элементов массива.
main(String[] args):

Это основная функция, которая создает массив, вызывает quickSort для его
сортировки и выводит отсортированный массив.
Как работает быстрая сортировка:

Выбор опорного элемента: Из массива выбирается опорный элемент. В этом примере
мы выбираем последний элемент.
Разделение: Массив разделяется на две части: элементы, меньшие опорного, и
элементы, большие опорного.
Рекурсия: Быстрая сортировка рекурсивно применяется к обеим частям массива.
Временная сложность:

Средняя: O(n log n)
Худшая: O(n^2) (возникает, когда опорный элемент всегда является наименьшим или
наибольшим элементом)
Быстрая сортировка обычно является одним из самых быстрых алгоритмов сортировки
для больших массивов.

## Оптимальная реализация с случайным опорным элементом

```java
import java.util.Random;

public class OptimizedQuickSort {

    private static final int INSERTION_SORT_THRESHOLD = 10;

    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    private static void quickSort(int[] arr, int low, int high) {
        while (low < high) {
            if (high - low <= INSERTION_SORT_THRESHOLD) {
                insertionSort(arr, low, high);
                return;
            }

            int pivotIndex = partition(arr, low, high);

            if (pivotIndex - low < high - pivotIndex) {
                quickSort(arr, low, pivotIndex - 1);
                low = pivotIndex + 1;
            } else {
                quickSort(arr, pivotIndex + 1, high);
                high = pivotIndex - 1;
            }
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivotIndex = getRandomPivot(low, high);
        swap(arr, pivotIndex, high);
        int pivot = arr[high];

        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return i + 1;
    }

    private static void insertionSort(int[] arr, int low, int high) {
        for (int i = low + 1; i <= high; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    private static int getRandomPivot(int low, int high) {
        Random random = new Random();
        return random.nextInt(high - low + 1) + low;
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        quickSort(arr);
        System.out.println("Отсортированный массив:");
        for (int value : arr) {
            System.out.print(value + " ");
        }
    }
}
```

Оптимизации:

1. Выбор случайного опорного элемента: Функция getRandomPivot выбирает случайный
   опорный элемент, что помогает избежать худшего случая, когда массив уже
   отсортирован или почти отсортирован.
2. Использование сортировки вставками для небольших подмассивов: Когда размер
   подмассива становится меньше INSERTION_SORT_THRESHOLD, алгоритм переключается
   на сортировку вставками, которая более эффективна для небольших массивов.
3. Итеративная реализация с оптимизацией хвостовой рекурсии: Рекурсия заменена
   на цикл while, а также оптимизирована хвостовая рекурсия, что предотвращает
   переполнение стека для больших массивов.
4. Медиана из трёх: Вместо выбора случайного опорного элемента, можно
   использовать медиану из трёх элементов (первый, средний и последний) для
   выбора опорного элемента, что еще больше уменьшает вероятность худшего
   случая.

Эти оптимизации делают быструю сортировку более эффективной и устойчивой к
различным типам входных данных.

## Преимущества и недостатки

Преимущества:

1. Временная сложность O(n log n) в среднем случае.
2. Хорошо работает на больших массивах.
3. Не требует дополнительной памяти, как сортировка слиянием.

Недостатки:

1. Временная сложность O(n^2) в худшем случае (например, если массив уже
   отсортирован и опорный элемент выбирается неудачно).
2. Не является стабильным алгоритмом (порядок равных элементов может
   измениться).

## Сложность

Сложность алгоритма Quicksort зависит от многих факторов, включая выбор опорного
элемента и распределение входных данных. В общем случае сложность быстрой
сортировки такова:

- Лучший случай. O(nlogn). Алгоритм делит массив на равные части, что приводит к
  наиболее эффективному разделению и сокращению времени выполнения.
- Средний случай. Также O(nlogn). Для случайных данных и при хорошем выборе
  опорного элемента быстрая сортировка чаще всего достигает этой сложности.
- Худший случай. O(n²). Это уже не так хорошо. Такое происходит, когда каждое
  разделение делит массив на части размером '1' и 'n-1', что чаще всего
  случается при выборе опорного элемента как наименьшего или наибольшего
  элемента в массиве. Например, если массив уже отсортирован и в качестве
  опорного выбирается первый или последний элемент, алгоритм будет иметь худшую
  производительность.
