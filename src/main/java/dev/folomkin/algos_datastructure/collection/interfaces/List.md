# Интерфейс List\<E>

**_РЕАЛИЗАЦИИ:_**

- ArrayList;
- LinkedList;
- Vector;
- Stack;

Интерфейс List в Java Collection Framework представляет упорядоченную
коллекцию (также известную как последовательность). Интерфейс List расширяет
Collection.
Предоставляется возможность доступа к элементам
коллекции по индексу и по значению (так как реализации позволяют хранить
дубликаты, результатом поиска по значению будет первое найденное вхождение).

Сохраняет последовательность элементов <br>
Элементы могут быть доступны по индексу <br>
Может содержать повторяющиеся элементы

Помимо Iterator списки также могут вернуть Listerator, который позволяет вставку
и замену элементов, а также двунаправленный доступ.

В Java `List` — это **интерфейс** из коллекционного фреймворка, представляющий
**упорядоченную коллекцию элементов**, в которой допускаются **повторы** и
**доступ по индексу**.

## Основное о `List`

`List` — это интерфейс

Реализуется следующими основными классами:

| Класс          | Основан на          | Особенности                                                         |
|----------------|---------------------|---------------------------------------------------------------------|
| **ArrayList**  | массив              | Быстрый доступ по индексу, медленные вставки и удаления из середины |
| **LinkedList** | двусвязный список   | Быстрые вставки/удаления, медленный доступ по индексу               |
| **Vector**     | массив (устаревший) | Синхронизирован, медленнее `ArrayList`                              |

## Временная сложность (ArrayList vs LinkedList)

| Операция            | ArrayList | LinkedList |
|---------------------|-----------|------------|
| `get(i)`            | O(1)      | O(n)       |
| `add(element)`      | O(1)\*    | O(1)       |
| `add(i, element)`   | O(n)      | O(n)       |
| `remove(i)`         | O(n)      | O(n)       |
| `iterator.remove()` | O(n)      | O(1)       |

\* — при амортизированной стоимости (ArrayList расширяется при заполнении)

### Когда использовать:

- `ArrayList` — когда нужно **часто обращаться по индексу**
- `LinkedList` — когда нужно **часто добавлять/удалять в середине/начале**

---


**_ОСНОВНЫЕ МЕТОДЫ:_**

- **void add(int index, Object obj)** - вставляет элемент obj в позицию index.
  Старые элементы, начиная с позиции index, сдвигаются, их индексы увеличиваются
  на единицу.
- **boolean addAll(int index, Collection coll)** – вставляет все элементы
  коллекции coll
- **E get(int index)** - извлекает без удаления объект по индексу.
- **int indexOf(Object obj)** - возвращает индекс первого вхождения объекта obj
  или -1, если этот список не содержит элемента
- **int lastIndexOf(Object obj)** - возвращает индекс последнего вхождения
  объекта obj в список или -1 если его нет
- **E set(int index, E element)** - Используется для замены элемента в этом
  списке на указанной позиции на указанный элемент
- **List\<E> subList(int start, int end)** - получает набор элементов, которые
  находятся в списке между индексами start и end
- **E remove(int index)** - удаляет последний извлеченный в список. Если
  объект не найден, то возвращается -1
- **static \<E> List\<E> of(элементы)** - создает из набора элементов объект
  List
- **void sort(Comparator\<? super E> comp)** - сортирует список с помощью
  компаратора comp
- **ListIterator\<E> listIterator()** - возвращает объект ListIterator для
  обхода элементов списка

**_Методы наследуемые из Collection:_**

- **int size()**;
- **boolean isEmpty()**;
- **boolean add(E element)**;
- **boolean remove(Object o)**;
- **boolean contains(Object o)**;
- **void clear()**;

## Временная сложность (ArrayList vs LinkedList)

| Операция            | ArrayList | LinkedList |
|---------------------|-----------|------------|
| `get(i)`            | O(1)      | O(n)       |
| `add(element)`      | O(1)\*    | O(1)       |
| `add(i, element)`   | O(n)      | O(n)       |
| `remove(i)`         | O(n)      | O(n)       |
| `iterator.remove()` | O(n)      | O(1)       |

\* — при амортизированной стоимости (ArrayList расширяется при заполнении)

## _ArrayList\<E>_

Класс, реализующий интерфейс List, являющийся динамическим массивом объектных
ссылок. Несинхронизированный.

ArrayList, как и Vector является реализацией динамического массива объектов.
Позволяет хранить любые данные, включая null в качестве элемента. Реализация
основана на обычном массиве. Данную реализацию следует применять, если в
процессе работы с коллекцией предполагается
частое обращение к элементам по индексу. Из-за особенностей реализации
поиндексное обращение к элементам выполняется за константное время O(1). Но
данную коллекцию рекомендуется избегать, если требуется частое
удаление/добавление элементов в середину коллекции.

ArrayList создается с начальной емкостью capacity 10 ячеек.
Переменная size хранит количество добавленных элементов и изначально равна 0.

Если добавить в ArrayList больше элементов, чем его capacity – неявно для
пользователя произойдет вызов метода grow() и пересоздание внутреннего массива.

Алгоритм расширения внутреннего массива:

- Создается новый массив по формуле (capacity * 3) / 2 + 1
- Все элементы старого массива копируются в новый, методом System.arraycopy()
- Новый массив присваивается внутренней переменной elementData.
  Старый массив объявляется мусором – на него больше нет ссылки

Автоматически внутренний массив не уменьшается.
Чтобы обрезать емкость списка до реального количества элементов в нем –
используем метод trimToSize(). Этот метод есть только у ArrayList и отсутствует
у List.

Удаление и добавление элементов для такой коллекции представляет ресурсоемкую
задачу, поэтому объект ArrayList\<E> лучше всего подходит для хранения списков с
малым числом подобных действий. С другой стороны, навигация по списку
осуществляется очень быстро, поэтому операции поиска производятся за более
короткое время.

**_Иерархия наследования:_**
java.util.AbstractCollection<E>
-> java.util.AbstractList<E>
-> java.util.ArrayList<E>

**_Конструкторы:_**

- **ArrayList()** - создает пустой список, размером 10;
- **ArrayList(Collection<? extends E> c)** - создает список из указанной
  коллекции
- **ArrayList(int initialCapacity)** - создает пустой список с изначально
  указанным объемом

**_Методы:_**

- **E get(int index)** – возвращает элемент, находящийся на указанной позиции в
  списке, представляет собой одно из главных достоинств класса из-за скорости
  выполнения;
- **boolean add(E e)** - добавляет указанный элемент в конец списка;
- **void add(int index, E e)** - вставляет указанный элемент на указанную
  позицию;
- **boolean addAll(Collection<? extends E> c)** – добавляет все элементы
  указанной коллекции в конец данного списка в порядке, определенном итератором
  Iterator данной коллекции;
- **boolean addAll(int index, Collection<? extends E> c)** – добавляет все
  элементы указанной коллекции в список, начиная с указанной позиции;
- **int indexOf(Object o)** – возвращает индекс первого вхождения указанного
  элемента данного списка или -1, если данный список не содержит указанный
  элемент;
- **E remove(int index)** – удаляет элемент из указанной позиции в списке;
- **boolean remove(Object o)** – удаляет первый встретившийся указанный элемент
  из списка, если он там имеется;
- **boolean removeAll(Collection<?> c)** – удаляет из списка все элементы,
  которые содержатся в указанной коллекции;
- **protected void removeRange(int fromIndex, int toIndex)** – удаляет из списка
  все элементы, чей индекс находится от fromIndex, включительно, до toIndex, не
  включая его;
- **E set(int index, E element)** – заменяет элемент на указанной позиции в
  списке на указанный элемент;
- **default void sort (Compare<? super E> e)** - сортирует список на основе
  компаратора;
- **List\<E> subList(int fromIndex, int toIndex)** – возвращает представление
  данного списка в виде подсписка, начиная с элемента с индексом fromIndex,
  включительно, до элемента с индексом toIndex, не включая его;
- static <E> copyOf(Collection <? extends E> coll) - создает немодифицированный
  список на основе передаваемой коллекции;
- **boolean isEmpty()** – возвращает true, если данный список не содержит
  элементов;
- **int lastIndexOf(Object o)** – возвращает индекс последнего вхождения
  указанного элемента данного списка или -1, если список не содержит данный
  элемент;
- **Iterator<E> iterator()** – возвращает итератор для правильного прохода по
  списку;
- **ListIterator<E> listIterator()** – возвращает итератор списка (для прохода в
  правильной последовательности);
- **ListIterator\<E> listIterator(int index)** – возвращает итератор списка (для
  прохода в правильной последовательности), начиная с указанной позиции в
  списке;
- **void ensureCapacity(int minCapacity)** - увеличивает объем данного
  экземпляра ArrayList, если это необходимо, чтобы удостовериться, что он может
  содержать, по меньшей мере, число элементов, указанное в аргументе
  minCapacity;
- **Object[] toArray()** – возвращает массив всех элементов данного списка в
  правильной последовательности (т.е. от первого до последнего элемента);
- **\<T> T[] toArray(T[] a)** – возвращает массив, содержащий все элементы
  данного списка в правильной последовательности (от первого до последнего
  элемента); тип возвращенного массива при выполнении – тот же самый, что и у
  указанного массива;
- **Object clone()** – возвращает копию объекта с теми же значениями полей, что
  у данного экземпляра ArrayList;
- **void trimToSize()** – сокращает массив до размера данного экземпляра
  ArrayList, который и будет текущим размером списка (так как при удалении
  элементов размер списка не изменяется).
- **boolean equals(Object o)** – сравнивает указанный объект с данным списком (
  на предмет равенства);
- **int hashCode()** – возвращает хэш-код для данного списка.
- **boolean retainAll(Collection<?> c)** – оставляет в данном списке только те
  элементы, которые содержатся в указанной коллекции;
- **int size()** – возвращает количество элементов данного списка;
- **void clear()** – удаляет все элементы из списка;
- -**boolean contains(Object o)** – возвращает true, если данный список содержит
  указанный элемент;
- **boolean containsAll(Collection<?> c)** – возвращает true, если данный список
  содержит все элементы данной коллекции;
- **toString** – возвращает представление коллекции в виде строки символов.
  Строковое представление состоит из списка элементов коллекции в порядке, в
  котором они возвращаются итератором, список заключается в квадратные
  скобки («[]»), соседние элементы разделяются символами «, » (запятая и
  пробел). Элементы преобразуются в строку таким же образом, как и в
  String.valueOf(Object).
- **protected void finalize()** – генерирует исключение Throwable, этот метод
  вызывается, когда Java – сборщик мусора обнаруживает, что на объект нет
  ссылок; подкласс переопределяет метод finalize, чтобы запросить системные
  ресурсы или выполнить другие операции по очистке памяти;
- **public final Class<?> getClass()** – возвращает класс объекта во время
  выполнения, например,
- **public final void notify()** – «просыпается» один поток, который ожидает на
  «мониторе» данный объект; если несколько потоков ожидают данный объект, то для
  «просыпания» выбирается один из них;
- **public final void notifyAll()** – пробуждает все потоки;
- **public final void wait(long timeout)** – генерирует исключение
  InterruptedException. У метода wait() есть три вариации. Один метод wait()
  бесконечно ждет другой поток, пока не будет вызван метод notify() или
  notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток
  в ожидание на определенное время. По истечении этого времени поток просыпается
  и продолжает работу.
- **boolean equals(Object o)** – сравнивает указанный объект со списком в смысле
  их равенства. Возвращает true тогда и только тогда, когда указанный объект
  является также списком, оба списка имеют одинаковый размер и все
  соответствующие пары элементов в обоих списках равны (Два элемента e1 и e2
  считаются равными, если (e1==null ? e2==null : e1.equals(e2)).)
- **int hashCode()** – возвращает значение хэш-кода для данного списка, хэш-код
  для списка определяется как результат следующих вычислений:

### Внутренние детали реализации

1. **Создаём ArrayList** (изначально пустой):

- `elementData = []`, `size = 0`

2. **Добавляем элементы:**
   ```java
   list.add("a");
   list.add("b");
   list.add("c");
   ```
   После добавления:

- `elementData = ["a", "b", "c", null, null, null, ...]`
- `size = 3`

3. **Добавляем 11-й элемент:**

- При заполнении текущего массива (например, длиной 10), создаётся новый массив
  длиной 15.
- Старые элементы копируются в новый массив:
    - `elementData = ["a", "b", ..., "k", null, null, ...]`

4. **Удаляем элемент:**
   ```java
   list.remove(1);
   ```
   После удаления:

- `elementData = ["a", "c", null, null, ...]`
- `size = 2`

### Основные свойства `ArrayList`

- Хранит элементы в **массиве `Object[]`**.
- Размер массива фиксирован, но при заполнении создаётся новый массив большего
  размера, куда копируются старые элементы.
- Поддерживает **доступ по индексу** через массив (O(1)).
- Доступ к элементам по индексу - O(1)
- Вставка и удаление элементов с конца - O(1)
- Доступ к элементам по значению - O(n)
- Медленная вставка и удаление элементов из середины
- Использует под капотом обычный массив elementData <br>
- Хранит любые значения, в том числе и null<br>
- Не синхронизирован<br>
- Автоматически увеличивается, но не уменьшается<br>

### Примеры

**Преобразование списка в массив - toArray():**

```java
public class ExampleStart {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        Object[] strArray = list.toArray();
        System.out.println(Arrays.toString(strArray));
        String[] strArray2 = list.toArray(new String[list.size()]);
        System.out.println(Arrays.toString(strArray2));
    }
}
```

**Представление массива в виде списка:**

```java
public class ExampleStart {
    public static void main(String[] args) {
        String[] strings = {"a", "b", "c", "d"};
        List<String> list = Arrays.asList(strings);
        List<String> list2 = Arrays.asList("fd", "fgfd", "gfgsd");
        System.out.println(list);
    }
}
```

Удаление и добавление элементов для такой коллекции представляет ресурсоемкую
задачу, поэтому объект ArrayList\<E> лучше всего подходит для хранения списков с
малым числом подобных действий. С другой стороны, навигация по списку
осуществляется очень быстро, поэтому операции поиска производятся за более
короткое время.

```java
    public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(5);
    list.add(null);
    list.add(50);
    System.out.println(list);
    list.add(5, 87);
    System.out.println(list);
    list.remove(2);
    System.out.println(list);
}
```

В данной ситуации не создается новый класс для каждого конкретного типа, и сама
коллекция не меняется, просто компилятор снабжается информацией о типе
элементов, которые могут храниться в list. При этом параметром коллекции может
быть только объектный тип. Попытка добавления\удаления элемента с номером,
выходящим за пределы текущего размера списка, приведет к исключительной
ситуации.<br>
Указывать тип следует при создании ссылки, иначе будет позволено добавлять
объекты всех типов. На этом основан принцип типобезопасности, обеспечиваемый
параметризацией коллекций.

### ПРИНЦИП РАБОТЫ

Каждый экземпляр ArrayList имеет емкость (CAPACITY). Емкость – это размер
массива, который используется для хранения элементов. По мере добавления
элементов в ArrayList его емкость автоматически увеличивается.

Когда массив заполняется, его ёмкость увеличивается. Новая ёмкость вычисляется
по формуле: старая ёмкость * 1.5 + 1. Например, если начальная ёмкость была 10,
то после расширения она станет 16.

При увеличении ёмкости создаётся новый массив, и все элементы из старого
копируются в новый, что является затратной операцией. Поэтому, если заранее
известно, что список будет большим, лучше сразу задать достаточную начальную
ёмкость.

Начальный размер capacity равен 10. Можно передать свое значение capacity
используя конструктор public ArrayList(int initialCapacity).

Удаление элементов из середины списка может быть затратной операцией, так как
все последующие элементы смещаются влево, что требует копирования данных. Также
стоит отметить, что размер внутреннего массива автоматически не уменьшается
после удаления элементов.

Метод trimToSize() позволяет уменьшить ёмкость ArrayList до фактического
количества элементов. Он полезен, если список часто изменяется и его размер
значительно сократился. Этот метод отсутствует в интерфейсе List, он доступен
только в ArrayList.

## АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ

Алгоритмическая сложность операций с `ArrayList` в Java зависит от
конкретной операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

- В конец списка: O(1) в среднем (если массив не переполнен). Если массив
  переполнен, происходит его увеличение, что требует O(n) времени, но это
  происходит редко, поэтому в среднем сложность остается O(1).
- В начало или в произвольную позицию: O(n) (необходимо сдвинуть элементы).

2. **Удаление элемента**:

- Из конца списка: O(1) (если не требуется уменьшение размера массива).
- Из начала или из произвольной позиции: O(n) (необходимо сдвинуть
  элементы).

3. **Поиск элемента**:

- O(n) (в худшем случае необходимо пройти по всему списку).

4. **Доступ к элементу по индексу**:

- O(1) (доступ к элементу по индексу осуществляется за константное время,
  так как `ArrayList` основан на массиве).

Таким образом, `ArrayList` хорошо подходит для операций доступа по индексу и
добавления элементов в конец списка, но менее эффективен для вставки и удаления
элементов в начале или середине списка из-за необходимости сдвига элементов.

Для `ArrayList` в Java сложность вставки и удаления элементов из середины списка
составляет O(n).

Вот подробности:

1. **Вставка элемента в середину**:

- Чтобы вставить элемент в середину списка, необходимо сначала сдвинуть все
  элементы, находящиеся после позиции вставки, на одну позицию вправо. Это
  требует O(n) времени в худшем случае, так как вам нужно пройти по всем
  элементам после вставляемого.
- После сдвига сам процесс вставки (изменение значения по индексу)
  выполняется за O(1).
- В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

- Для удаления элемента из середины списка также необходимо сначала найти
  этот элемент (если у вас нет ссылки на него), что требует O(n) времени.
- После нахождения элемента необходимо сдвинуть все элементы, находящиеся
  после удаляемого, на одну позицию влево. Это также требует O(n) времени.
- Таким образом, общая сложность удаления элемента из середины списка
  составляет O(n).

В общем, операции вставки и удаления в середине `ArrayList` имеют линейную
сложность из-за необходимости сдвига элементов.

### Внутренние детали реализации

1. **Создаём ArrayList** (изначально пустой):

- `elementData = []`, `size = 0`

2. **Добавляем элементы:**
   ```java
   list.add("a");
   list.add("b");
   list.add("c");
   ```
   После добавления:

- `elementData = ["a", "b", "c", null, null, null, ...]`
- `size = 3`

3. **Добавляем 11-й элемент:**

- При заполнении текущего массива (например, длиной 10), создаётся новый массив
  длиной 15.
- Старые элементы копируются в новый массив:
    - `elementData = ["a", "b", ..., "k", null, null, ...]`

4. **Удаляем элемент:**
   ```java
   list.remove(1);
   ```
   После удаления:

- `elementData = ["a", "c", null, null, ...]`
- `size = 2`

### Преимущества `ArrayList`

1. Быстрый доступ по индексу (O(1)).
2. Амортизированная вставка в конец (O(1)).
3. Простая структура, основанная на массиве.

### Недостатки `ArrayList`

1. Медленное удаление/вставка в середине (O(n)), из-за сдвига элементов.
2. При росте массива создаётся новый массив, что требует копирования (временные
   затраты).

## _LinkedList\<E>_

LinkedList\<E> является реализацией двусвязного списка для интерфейса List
который работает эффективно как для вставки элементов, так и для удаления,
используя, как издержки, более сложную структуру. LinkedList\<E> также реализует
интерфейсы Queue\<E> и Deque\<E> и может работать с обоих концов очереди. Он
может работать с очередью как по принципу FIFO, так и по принципу LIFO.  
Связанный список хранит ссылки на объекты отдельно вместе со ссылками
на следующее и предыдущее звенья последовательности, поэтому часто
называется двунаправленным списком.

В этом классе объявлены методы, позволяющие манипулировать им как
очередью, двунаправленной очередью и т.д. Двунаправленный список, кроме
обычного, имеет особый «нисходящий» итератор, позволяющий двигаться от
конца списка к началу, и извлекается методом descendingIterator().

Класс LinkedList содержит три основных поля:

- Node<E> first – Ссылка на первый элемент списка.
- Node<E> last – Ссылка на последний элемент списка.
- int size – Количество элементов в списке

----

### Основная структура `LinkedList`

```java
class Node<E> {
    E item;         // Значение
    Node<E> next;   // Ссылка на следующий узел
    Node<E> prev;   // Ссылка на предыдущий узел
}
```

`LinkedList` хранит:

```java
Node<E> first;  // Голова списка
Node<E> last;   // Хвост списка
int size;       // Количество элементов
```

### Визуально:

```
null ← [A] ⇄ [B] ⇄ [C] → null
```

- Каждый элемент связан с **предыдущим** и **следующим**.
- Это даёт **быстрые вставки и удаления** в начале, в середине и в конце.

### Ключевые операции:

| Операция            | Что происходит                                | Сложность |
|---------------------|-----------------------------------------------|-----------|
| `addFirst(E)`       | Добавление в начало — новая "голова"          | O(1)      |
| `addLast(E)`        | Добавление в конец — новая "хвостовая" нода   | O(1)      |
| `get(int index)`    | Пройти с начала или конца до нужного элемента | O(n)      |
| `remove(int index)` | Найти и удалить — переустановить ссылки       | O(n)      |
| `add(int index, E)` | Найти место и вставить, поменять ссылки       | O(n)      |
| `iterator.remove()` | Быстрое удаление по итератору                 | O(1)      |

-----

### Основные характеристики LinkedList

1. **Структура**: Каждый узел в `LinkedList` состоит из трех частей:

- Ссылка на предыдущий узел.
- Ссылка на следующий узел.
- Данные (значение), хранящиеся в узле.

2. **Двусвязный список**: В отличие от односвязного списка, где каждый узел
   содержит только ссылку на следующий узел, в двусвязном списке каждый узел
   имеет ссылки как на предыдущий, так и на следующий узел. Это позволяет легко
   перемещаться в обоих направлениях.

3. **Гибкость**: `LinkedList` позволяет динамически изменять размер списка,
   добавляя или удаляя элементы без необходимости перераспределения памяти, как
   это происходит в массивах.

### Принцип работы LinkedList

_**Добавление элементов в конец списка**_

- Создаётся новый узел (Node).
- Устанавливается значение (item) для нового узла.
- Ссылки узла добавляются в конец списка.
- Устанавливаются ссылки на предыдущий и следующий узлы (для нового и соседних
  узлов).

_**Добавление элемента в середину списка**_

- Проверяется индекс. Если он отрицательный или превышает размер списка,
  выбрасывается исключение IndexOutOfBoundsException.
- Если индекс равен размеру списка, элемент добавляется в конец.
- Вставка в середину происходит перед элементом с указанным индексом:
    - Метод node(index) находит узел по индексу.
    - Определяется место вставки (поиск узла идёт с начала или конца списка в
      зависимости от индекса).
    - Создаётся новый узел, и его ссылки устанавливаются между соседними узлами.
- Обновляются ссылки на предыдущие и следующие узлы для нового элемента и его
  соседей.
- Увеличивается размер списка.

Удаление элемента из связного списка по значению:

- Последовательно сравниваются элементы списка с заданным значением, начиная с
  первого узла.
- Когда найден узел с соответствующим значением, элемент сохраняется в отдельную
  переменную.
- Ссылки соседних узлов перенаправляются так, чтобы исключить удаляемый элемент.
- Очищаются ссылки и данные узла, который содержал удалённый элемент, и
  уменьшается размер списка.

#### Основные операции

1. **Добавление элемента (add)**:

- При добавлении элемента в конец списка создается новый узел, который
  ссылается на `null` (если это последний элемент).
- Если список не пустой, новый узел связывается с текущим последним узлом, а
  последний узел обновляется для ссылки на новый узел.
- Если элемент добавляется в начало или в середину списка, ссылки
  соответствующих узлов обновляются для поддержания связности.

2. **Удаление элемента (remove)**:

- При удалении элемента необходимо найти соответствующий узел.
- После нахождения узла его предыдущий и следующий узлы обновляют свои
  ссылки так, чтобы пропустить удаляемый узел.
- Если удаляется первый или последний элемент, необходимо обновить указатели
  на голову или хвост списка.

3. **Поиск элемента (get)**:

- Для поиска элемента по индексу необходимо пройти по списку от начала до
  нужного индекса (или от конца, если индекс ближе к концу).
- Сложность поиска составляет O(n) в худшем случае.

4. **Итерация**:

- Итерация по элементам `LinkedList` может быть выполнена с помощью
  итератора или цикла for-each.
- Итератор позволяет проходить по элементам без необходимости знать
  внутреннюю структуру списка.

-------------

## **АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ**

Алгоритмическая сложность операций с `LinkedList` в Java зависит от конкретной
операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

    - В конец списка: O(1) (если у вас есть ссылка на последний элемент).
    - В начало списка: O(1).
    - В произвольную позицию: O(n) (необходимо пройти до нужной позиции).

2. **Удаление элемента**:

    - Из конца списка: O(1) (если у вас есть ссылка на последний элемент).
    - Из начала списка: O(1).
    - Из произвольной позиции: O(n) (необходимо пройти до нужной позиции).

3. **Поиск элемента**:

    - O(n) (необходимо пройти по всему списку в худшем случае).

4. **Доступ к элементу по индексу**:

    - O(n) (необходимо пройти по списку до нужного индекса).

Таким образом, `LinkedList` хорошо подходит для операций добавления и удаления
элементов в начале или конце списка, но неэффективен для доступа по индексу и
поиска элементов.

Для `LinkedList` в Java сложность вставки и удаления элемента из середины списка
составляет O(n).

Вот подробности:

1. **Вставка элемента в середину**:

    - Чтобы вставить элемент в середину списка, необходимо сначала найти
      позицию, куда вы хотите вставить элемент. Это требует O(n) времени, так
      как вам нужно пройти по списку до нужного индекса.
    - После того как вы нашли нужную позицию, сама операция вставки (изменение
      ссылок) выполняется за O(1).
    - В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

    - Аналогично, для удаления элемента из середины списка сначала нужно найти
      этот элемент, что также требует O(n) времени.
    - После нахождения элемента операция удаления (изменение ссылок) выполняется
      за O(1).
    - Таким образом, общая сложность удаления элемента из середины списка также
      составляет O(n).

В общем, операции вставки и удаления в середине `LinkedList` имеют линейную
сложность из-за необходимости поиска нужной позиции.

Самый быстрый метод класса add(E element). Главным же достоинством
класса является скорость работы метода remove() на Iterator, после получения
его из LinkedList. Также очень быстро работает метод add(E element) на
ListIterator. Операция удаления из начала и конца списка выполняется достаточно
быстро, в отличие от операций поиска и извлечения.

Используется когда необходимо часто добавлять или удалять элементы, особенно в
начало списка. Либо когда нужна вставка элемента в конец за гарантированное
время.

Для манипуляций с первым и последним элементами списка в LinkedList\<E>
реализованы методы:

- **void addFirst(E e), void addLast(E e)** - добавление элементов в начало и
  конец списка;
- **E getFirst(), E getLast()** — извлекающие элементы;
- **E removeFirst(), E removeLast()** — удаляющие и извлекающие элементы;
- **E removeLastOccurrence(E elem), E removeFirstOccurrence(E elem)** —
  удаляющие и извлекающие элемент, первый или последний раз встречаемый
  в списке.

----------------

#### Преимущества LinkedList

- **Эффективное добавление и удаление**: Операции добавления и удаления
  элементов выполняются за O(1) при условии, что у вас есть ссылка на нужный
  узел.
- **Динамическое выделение памяти**: Размер списка может изменяться динамически
  без необходимости перераспределения памяти.

#### Недостатки LinkedList

- **Память**: Каждый элемент требует дополнительной памяти для хранения ссылок
  на соседние элементы.
- **Поиск**: Поиск по индексу требует O(n) времени из-за необходимости
  последовательного прохода по списку.

## ARRAYLIST и LINKEDLIST

При добавлении в середину, начало или конец списка LinkedList быстрее, чем
ArrayList.

Вставки и удаления элементов из LinkedList происходят за постоянное время, в том
числе и с использованием итераторов, в то же время вставка\удаление элемента в
ArrayList приводит к сдвигу всех элементов после позиции добавления\удаления, а
в случае, если базовый массив хранения переполняется, то еще и сам массив
увеличивается в полтора раза с копированием старого массива в новый.

ArrayList быстрее LinkedList при вызове метода get(index), т.к. это происходит
за время O(n), а в LinkedList за O(1).

Список LinkedList занимает больший объем памяти за счет необходимости
хранения ссылок на соседние объекты, что следует учитывать при создании
списков больших размеров. Список LinkedList занимает от 3,5 до 5 раз больше
памяти нежели аналогичный список ArrayList.

Если необходимо осуществлять быструю навигацию по списку, то следует применять
ArrayList, так как перебор элементов в LinkedList осуществляется на порядок
медленнее. С другой стороны, если требуется часто добавлять и удалять элементы
из списка, то уже класс LinkedList обеспечивает значительно более высокую
скорость переиндексации. То есть если коллекция формируется в начале процесса и
в дальнейшем используется только для доступа к информации, то применяется
ArrayList, если же коллекция подвергается изменениям на всем протяжении
функционирования приложения, то выгоднее LinkedList.

Выгода использования LinkedList в работе с серединой и началом списка.
Вставка и удаление в LinkedList устроены гораздо проще, чем в ArrayList – просто
переопределятся ссылки на соседние элементы.

### Основные характеристики LinkedList

1. **Структура**: Каждый узел в `LinkedList` состоит из трех частей:

- Ссылка на предыдущий узел.
- Ссылка на следующий узел.
- Данные (значение), хранящиеся в узле.

2. **Двусвязный список**: В отличие от односвязного списка, где каждый узел
   содержит только ссылку на следующий узел, в двусвязном списке каждый узел
   имеет ссылки как на предыдущий, так и на следующий узел. Это позволяет легко
   перемещаться в обоих направлениях.

3. **Гибкость**: `LinkedList` позволяет динамически изменять размер списка,
   добавляя или удаляя элементы без необходимости перераспределения памяти, как
   это происходит в массивах.

### Реализация LinkedList

вручную на Java, с базовыми операциями — добавление, удаление и вывод.

```java
public class MyLinkedList<E> {
    private static class Node<E> {
        E data;
        Node<E> prev;
        Node<E> next;

        Node(E data) {
            this.data = data;
        }
    }

    private Node<E> head;
    private Node<E> tail;
    private int size = 0;

    // Добавление в конец
    public void add(E element) {
        Node<E> newNode = new Node<>(element);
        if (tail == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size++;
    }

    // Удаление по индексу
    public void remove(int index) {
        checkBounds(index);
        Node<E> current = getNode(index);

        if (current.prev != null) current.prev.next = current.next;
        else head = current.next; // удаляем первый элемент

        if (current.next != null) current.next.prev = current.prev;
        else tail = current.prev; // удаляем последний элемент

        size--;
    }

    // Получение узла по индексу
    private Node<E> getNode(int index) {
        checkBounds(index);
        Node<E> current;
        if (index < size / 2) {
            current = head;
            for (int i = 0; i < index; i++) current = current.next;
        } else {
            current = tail;
            for (int i = size - 1; i > index; i--) current = current.prev;
        }
        return current;
    }

    private void checkBounds(int index) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("Index: " + index);
    }

    // Вывод элементов
    public void printList() {
        Node<E> current = head;
        while (current != null) {
            System.out.print(current.data + " ⇄ ");
            current = current.next;
        }
        System.out.println("null");
    }
}
```

### Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        MyLinkedList<String> list = new MyLinkedList<>();

        list.add("A");
        list.add("B");
        list.add("C");
        list.printList(); // A ⇄ B ⇄ C ⇄ null

        list.remove(1);
        list.printList(); // A ⇄ C ⇄ null
    }
}
```

### Что реализовано:

* Двусвязный список.
* Добавление в конец.
* Удаление по индексу.
* Быстрый доступ к элементам с учётом ближнего конца.
* Печать списка.

## _Vector\<E>_

Реализация динамического массива объектов. Позволяет хранить любые данные,
включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но, как
и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется
достижения потокобезопасности. Потому как в Vector, в отличии. от других
реализаций List, все операции с данными являются синхронизированными. В качестве
альтернативы часто применяется аналог — ArrayList.  
Как и массив, он содержит элементы, доступ к которым возможен по индексу. Однако
размер вектора может расти или уменьшаться в зависимости от добавления или
удаления элементов после того, как Vector уже был создан. Класс вектор является
синхронизированной реализацией интерфейса List.
Deprecated. Устаревший класс
На смену Vector пришел класс пакета java.util.concurrent СopyOnWriteArrayList

**_Конструкторы:_**

- *Vector()* – создает пустой вектор таким образом, что внутренний массив имеет
  размер 10, а его стандартный инкремент объема равен нулю;
- *Vector(Collection<? extends E> c)* – создает вектор, содержащий элементы
  указанной коллекции в порядке, возвращенном итератором;
- *Vector(int initialCapacity)* – создает пустой вектор с указанным начальным
  объемом и со стандартным инкрементом объема, равным нулю;
- *Vector(int initialCapacity, int capacityIncrement)* – создает пустой вектор с
  указанными начальным объемом и инкрементом объема.

**_Методы:_**

- **void addElement(E obj)** – добавляет указанный компонент в конец вектора,
  увеличивая его размер на 1;
- **boolean removeElement(Object obj)** – удаляет первый, т.е. имеющий
  минимальный индекс, встретившийся аргумент из вектора;
- **void setElementAt(E obj, int index)** – вставляет элемент, представляющий
  собой указанный объект, на определенное индексом место в векторе;
- **public E elementAt(int index)** – возвращает элемент с указанным индексом;
  этот метод идентичен методу get(int), являющемуся частью интерфейса List;
- **public E firstElement()** – возвращает первый элемент (с индексом 0) данного
  вектора;
- **public E lastElement()** – возвращает последний элемент вектора;
- **public void insertElementAt(E obj,int index)** – вставляет указанный объект
  как элемент данного вектора на место, определенное индексом. Каждый элемент
  данного вектора с индексом, большим или равным указанному индексу, получает
  индекс, больший предыдущего на 1.

```java
public static void main(String[] args) {
    Vector v = new Vector(3, 2);
    System.out.println("Начальный размер " + v.size());
    System.out.println("Начальный объем " + v.capacity());
    v.addElement(1);
    v.addElement(2);
    v.addElement(3);
    v.addElement(4);
    System.out.println("Новый объем " + v.capacity());
    // Enumeration - доступ к серии элементов одновременно;
    Enumeration e = v.elements();
    while (e.hasMoreElements()) {
        System.out.println(e.nextElement());
    }
}
```

**Различия между классами ArrayList и Vector:**

| ArrayList                                                                                            | Vector                                                                                                                                                                |
|------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ArrayList не синхронизирован                                                                         | Vector синхронизирован                                                                                                                                                |
| ArrayList увеличивает на 50% <br/> текущий размер массива, если число элементов превышает его размер | Vector увеличивает на 100% <br/> текущий размер массива, если число элементов превышает его размер                                                                    |
| ArrayList не является классом-наследником                                                            | Vector является классом наследником                                                                                                                                   |
| ArrayList является быстрым, потому что он не синхронизированный                                      | Vector является медленным, так как он синхронизирован, т.е. при многопоточности он будет удерживать другие потоки до тех пор, пока не освободит от блокировки объект. |
| ArrayList использует интерфейс Iterator для прохода по элементам                                     | Vector использует интерфейс Enumeration для перемещения по элементам. Но может также использовать и интерфейс Iterator.                                               |

## _Stack\<E>_

Stack\<E> — данная коллекция является расширением коллекции Vector. Была
добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является
частично синхронизированной коллекцией (кроме метода добавления push()). После
добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно
реализации этого интерфейса, например ArrayDeque.  
Stack\<E> – класс, определенный для структуры данных «стек», организованной
по принципу LIFO (last-in-first-out – последним вошел – первым вышел). Класс
Stack является наследником класса Vector, который является синхронизированным
массивом с изменяющимся размером.

***Методы:***

- **E void push(E element)** – помещает указанный элемент на вершину стека;
- **E pop()** – возвращает и удаляет элемент с вершины стека;
- **E peek()** – возвращает, но не удаляет;
- **boolean empty()** – проверяет, является ли стек пустым;
- **int search(Object obj)** – возвращает расстояние от указанного объекта до
  вершины стека (от 1 для вершины стека) или –1, если элемент не найден.

## ListIterator

Отлично! Давай разберём, как **`ListIterator` работает под капотом** в
`LinkedList`.

---

## 🔹 Цель `ListIterator`:

Он обеспечивает **двунаправленный обход** и даёт возможность **вставлять,
удалять и заменять элементы во время обхода**, всё **без потери позиции и без
сдвига элементов**, в отличие от `ArrayList`.

---

## 🔧 Упрощённая внутренняя модель:

```java
class LinkedListIterator<E> implements ListIterator<E> {
    Node<E> lastReturned = null;  // последний возвращённый узел
    Node<E> next;                 // следующий узел при вызове next()
    int nextIndex;                // индекс next
}
```

---

## 📍 Как работает `next()` и `previous()`

```java
public E next() {
    lastReturned = next;
    next = next.next;
    nextIndex++;
    return lastReturned.item;
}
```

```java
public E previous() {
    next = next.prev;
    lastReturned = next;
    nextIndex--;
    return lastReturned.item;
}
```

`lastReturned` — это тот узел, к которому применяются `remove()`, `set()`.

---

## 🧹 Удаление (`remove()`)

```java
public void remove() {
    if (lastReturned == null)
        throw new IllegalStateException();

    Node<E> prev = lastReturned.prev;
    Node<E> next = lastReturned.next;

    if (prev != null) prev.next = next;
    else head = next;

    if (next != null) next.prev = prev;
    else tail = prev;

    if (next == this.next) nextIndex--; // корректировка позиции
    lastReturned = null;
}
```

🔧 Удаляется **конкретный узел** — `lastReturned` — уже известный, поэтому:

* **Никакого поиска**!
* Только **перестановка ссылок**.
* Итого: **`O(1)`**

---

## ➕ Вставка (`add(E e)`)

```java
public void add(E e) {
    Node<E> newNode = new Node<>(e);
    Node<E> prev = next != null ? next.prev : tail;

    newNode.prev = prev;
    newNode.next = next;

    if (prev != null) prev.next = newNode;
    else head = newNode;

    if (next != null) next.prev = newNode;
    else tail = newNode;

    lastReturned = null;
    nextIndex++;
}
```

Тоже **прямая вставка между двумя узлами** — никаких сдвигов или копирования.
Сложность: **`O(1)`**.

---

## 🧠 Вывод:

* `ListIterator` в `LinkedList` — это умный "курсор", который **знает, где
  находится**, и может:

    * быстро удалять текущий элемент (`remove`)
    * вставлять элемент прямо в позицию (`add`)
    * заменять элемент (`set`)
* Всё это — **без поиска**, поэтому **`O(1)`**.

Хочешь, я покажу минимальную реализацию своего `ListIterator` вручную?
