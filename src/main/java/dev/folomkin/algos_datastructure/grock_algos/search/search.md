# Бинарный поиск

Бинарный поиск — это алгоритм; на входе он получает отсортированный
список элементов. Если элемент, который вы ищете, присутствует в списке,
то бинарный поиск возвращает ту позицию, в которой он был найден. В противном
случае бинарный поиск возвращает null.

Бинарный поиск — тип поискового алгоритма, который последовательно делит пополам
заранее отсортированный массив данных, чтобы обнаружить нужный элемент. Другие
его названия — двоичный поиск, метод половинного деления, дихотомия.

Принцип работы алгоритма бинарного поиска
Основная последовательность действий алгоритма выглядит так:

1. Сортируем массив данных.
2. Делим его пополам и находим середину.
3. Сравниваем срединный элемент с заданным искомым элементом.
4. Если искомое число больше среднего — продолжаем поиск в правой части
   массива (если он отсортирован по возрастанию): делим ее пополам, повторяя
   пункт 3. Если же заданное число меньше — алгоритм продолжит поиск в левой
   части массива, снова возвращаясь к пункту 3.

![binary-search.png](/img/binary-search.png)

При таком поиске список делится пополам и отбрасывается каждый раз ненужная
часть. В списке из n элементов обычный поиск потребует n шагов, а
бинарный - log2(n).

Бинарный поиск работает только в том случае, если список отсортирован.

## Функция binarySearch()

### Итеративная реализация

Функция **`binary_search()`** получает отсортированный массив и значение. Если
значение присутствует в массиве, то функция возвращает его позицию. При
этом мы должны следить за тем, в какой части массива проводится поиск.
Вначале это весь массив:

Поэтапно:

```java
public static void main(String[] args) {
    int[] arrays = {2, 4, 3, 5, 56, 32, 54, 34, 23}; //-> [2, 3, 4, 5, 23, 32, 34, 43, 54, 56, 76]
    int target = 32; //-> Искомое число
    Arrays.sort(arrays);

    int index = binarySearch(arrays, target);

}

int binarySearch(int[] arrays, int target) {
    //-> В переменных low и high хранятся границы
    // той части списка, в которой выполняется поиск
    int low = 0;
    int high = arrays.length - 1;
    //-> Пока эта часть не сократится до одного элемента...
    while (low <= high) {
        //-> ...проверяем среднее значение
        int mid = (low + high) / 2;
        int guess = arrays[mid];
        if (guess == target) { //-> значение найдено
            return mid;
        }
        if (guess < target) { //-> мало, увеличиваем минимальное на [среднее+1]
            low = mid + 1;
        }
        if (guess > target) { //-> много, уменьшаем максимальное на [среднее-1]
            high = mid - 1;
        }
    }
    return -1;
}


```

### С рекурсией

```java
public class Binary {

    public static void main(String[] args) {
        int[] values = {1, 1, 2, 3, 4, 10};
        int valueToFind = 3;
        System.out.printf("Index = %d%n", binarySearch(values, valueToFind, 0, values.length - 1));
    }

    private static int binarySearch(int[] values, int valueToFind, int l, int r) {
        if (l == r) {
            return (values[l] == valueToFind) ? l : -1;
        }

        int m = l + (r - l) / 2;

        if (valueToFind > values[m]) {
            return binarySearch(values, valueToFind, m + 1, r);
        } else if (values[m] > valueToFind) {
            return binarySearch(values, valueToFind, l, m - 1);
        }
        return m;
    }

}
```