# Интерфейс Map

Карта отображений — это объект, который хранит пару «ключ–значение».
Поиск объекта (значения) облегчается по сравнению с множествами за счет
того, что его можно найти по уникальному ключу. Уникальность объектов-ключей
должна обеспечиваться переопределением методов hashCode() и equals()
или реализацией интерфейсов Comparable, Comparator пользовательским классом.

`Map<K,V>` - принимает два дженерика типа K и V. Повторяющиеся элементы
запрещены. Часто используемые реализации включают HashMap, Hashtable и
LinkedHashMap. Их подинтерфейс SortedMap<K,V> моделирует упорядоченную и
отсортированную карту на основании ключа, реализованного в TreeMap.  
Интерфейс Map.Entry предназначен для извлечения ключей и значений карты с
помощью методов K getKey() и V getValue() соответственно. Вызов метода
V setValue(V value) заменяет значение, ассоциированное с текущим ключом.

**_Свойства:_**

- Хранит данные парами: key – value
- Ключ всегда является уникальным.
  Уникальность определяется за счет контракта hashcode() equals()
- Значения могут дублироваться
- Доступ к значениям осуществляется по ключу
  Ключ по значению получить нельзя

По умолчанию под капотом Map массив на 16 buckets (корзин)
Внутри каждого бакета данные хранятся в LinkedList
Массив автоматически расширяется: 16 – 32 – 64

Худший результат работы Map – Коллизия:
Когда все элементы попадают в один bucket и их приходится перебирать итерацией
по внутреннему LinkedList.

В таком случае происходит оптимизация хранения данных в этом бакете:
Если размер внутреннего LinkedList бакета становится равен 8 элементам и размер
внутреннего массива Map равен 64 бакетам – происходит преобразование структуры
данных внутри этого бакета в RB-дерево(red-black tree).

Для объектов-ключей важно переопределить методы equals() и hashCode()
Допускается добавление объектов без переопределения этих методов, но найти их в
Map будет невозможно.

**Почему Map не наследуется от Collection?**

Это связано с различиями в их целях и использовании. Интерфейс Collection
представляет собой общие методы для работы с группой объектов, таких как
добавление, удаление и проверка наличия элемента. Он ориентирован на работу с
коллекциями объектов, где каждый объект является элементом коллекции.
Интерфейс Map, с другой стороны, представляет собой отображение ключей на
значения. Он не рассматривает элементы коллекции как отдельные объекты, а
предоставляет доступ к значению, связанному с определенным ключом. Это более
общий и мощный подход, который не сводится к работе с отдельными элементами
коллекции.  
Интерфейс Map включает в себя методы для управления парами ключ-значение и
обеспечивает эффективный доступ к значениям по ключу. По этим причинам он не
является подтипом Collection. Однако, классы, реализующие интерфейс Map, часто
предоставляют методы, которые позволяют работать с элементами коллекции или
возвращают представление коллекции ключей, значений или записей (ключ-значение).
Таким образом, хотя Map и Collection предоставляют абстракции для работы с
группой объектов, они решают разные задачи, и поэтому не существует
иерархического отношения наследования между ними.
Map - коллекция пар "ключ-значение". Ключ всегда должен быть уникален,
значение нет.

## _Интерфейсы и реализации:_

**Интерфейсы:**

- `Map<K,V>` — отображает уникальные ключи и значения;
- `Map.Entry<K,V>` — описывает пару «ключ–значение»;
- `SortedMap<K,V>` — содержит отсортированные ключи и значения;
- `NavigableMap<K,V>` — добавляет новые возможности навигации и поиска по ключу.

**Классы:**

- `AbstractMap<K,V>` — реализует интерфейс Map<K,V>, является суперклассом
  для всех перечисленных карт отображений;
- `HashTable<K,V>` - реализация такой структуры данных, как хэш-таблица. Она не
  позволяет использовать null в качестве значения или ключа. Эта коллекция была
  реализована раньше, чем Java Collection Framework, но в последствии была
  включена в его состав. Как и другие коллекции из Java 1.0, Hashtable _является
  синхронизированной_ (почти все методы помечены как synchronized). Из-за этой
  особенности у неё имеются существенные проблемы с производительностью и,
  начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие
  реализации интерфейса Map ввиду отсутствия у них синхронизации.
- `HashMap<K,V>` — коллекция является альтернативой Hashtable. Двумя основными
  отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap
  позволяет использовать null как в качестве ключа, так и значения. Так же как и
  Hashtable, данная коллекция не является упорядоченной: порядок хранения
  элементов зависит от хэш-функции. Добавление элемента выполняется за
  константное время O(1), но время удаления, получения зависит от распределения
  хэш-функции. В идеале является константным, но может быть и линейным O(n).
- `LinkedHashMap<K,V>` — образует дважды связанный список ключей. Этот
  механизм эффективен, только если превышен коэффициент загруженности карты при
  работе с кэш-памятью и др.  
  LinkedHashMap — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от
  HashMap, порядок итерирования равен порядку добавления элементов. Данная
  особенность достигается благодаря двунаправленным связям между элементами
  (аналогично LinkedList). Но это преимущество имеет также и недостаток —
  увеличение памяти, которое занимает коллекция.
- `TreeMap<K,V>` — использует дерево, где ключи расположены в виде дерева
  поиска в определенном порядке;
- `WeakHashMap\<K,V>` — позволяет механизму сборки мусора удалять из карты
  значения по ключу, ссылка на который вышла из области видимости приложения;

## Map:

- **_Map_**
    - **HashTable\<K,V>** - реализация синхронизированной хеш-таблицы для
      интерфейса Map\<K,V>, который не допускает null ключей или значения для
      наследуемых методов;
    - **LinkedHashMap\<K,V>** - хэш-таблица со свойствами связанного списка для
      улучшения методов вставки и удаления;
    - **HashMap\<K,V>** - реализация хэш-таблицы, методы не синхронизированы;
    - **EnumMap\<K,V>** - реализация хэш-таблицы в виде перечислений;
- **_SortedMap_**
    - **TreeMap\<K,V>** - реализация SortedMap в виде дерева;

**Представления карты**

- **Set\<K> keySet()** - возвращает представление карты в виде множества ключей;
- **Collection\<V> values()** - возвращает представление карты в виде коллекции
  значений;
- **Set entrySet()** - представление в виде множества пар ключ-значения;

___Методы Map\<K,V>:___

- **boolean containsKey(Object key)** - проверяет наличие ключа;
- **boolean containsValue(Object value)** - проверяет наличие значения;
- **V get(Object key)** - возвращает значение указанного ключа или null;
- **V put(K key, V value)** - помещает в коллекцию новый объект с ключом k и
  значением v. Если в коллекции уже есть объект с подобным ключом, то он
  перезаписывается. После добавления возвращает предыдущее значение для ключа k,
  если он уже был в коллекции. Если же ключа еще не было в коллекции, то
  возвращается значение null.
- **default V putIfAbsent(K key, V value)** — добавляет ключ-значение, только
  если key не существует;
- **default V compute(K key, BiFunction<? super K, ? super V, ? extends V>
  remappingFunction)** — помещает ключ key и вычисляет значение value при
  добавлении в вызывающую карту;
- **default V computeIfAbsent(K key, Function<? super K, ? super V>
  mappingFunction)** — помещает ключ key и значение value в вызывающую карту,
  если пары с таким ключом не существует, если ключ существует, то за- мена не
  производится;
- **default V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends
  V> remappingFunction)** — заменяет значение value в вызывающей карте, если
  ключ с таким значением существует, если же пары с таким ключом не существует,
  то вставка пары не производится;
- **void putAll(Map <? extends K, ? extends V> m)** — помещает карту m в
  вызывающую карту;
- **V remove(Object key)** — удаляет пару «ключ–значение» по ключу key;
- **void clear()** — удаляет все пары из вызываемой карты;
- **boolean containsKey(Object key)** — возвращает true, если вызывающая карта
  содержит key как ключ;
- **boolean containsValue(Object value)** — возвращает true, если вызывающая
  карта содержит value как значение;
- **Set<K> keySet()** — возвращает множество ключей;
- **Set<Map.Entry<K, V>> entrySet()** — возвращает множество, содержащее
  значения карты в виде пар «ключ–значение»;
- **Collection<V> values()** — возвращает коллекцию, содержащую значения
  карты;
- **static <K, V> Map<K, V> copyOf(Map <? extends K,? extends V> map)** —
  копирует исходную карту в немодифицируемую новую карту;
- **static <K, V> Map<K, V> of(parameters)** — перегруженный метод для со-
  здания неизменяемых карт на основе переданных в метод параметров;
- **default void forEach(BiConsumer<? super K, ? super V> action)** — выполняет
  действие над каждым элементом Map.

В коллекциях, возвращаемых тремя последними методами, можно только удалять
элементы, добавлять нельзя. Данное ограничение обуславливается параметризацией
возвращаемого методами значения.

Наличие ключа можно проверить так:

```java
public static void main(String[] args) {
    if (!hashMap.containsKey("Пряник")) {
        // replacement will not happen if the key exists
        hashMap.put("Пряник", 4);
    }
}
```

## Интерфейс Map.Entry

Интерфейс Map.Entry в Java используется для работы с элементами Map. Он
представляет пару ключ-значение и имеет методы, которые позволяют получить и
изменить ключ и значение пары.

Методы Map.Entry<K, V>:

- K getKey() — возвращает ключ текущего входа;
- V getValue() — возвращает значение текущего входа;
- V setValue(V obj) — устанавливает значение объекта obj в текущем входе.

```java
public static void main(String[] args) {
    Map<String, Integer> map = new HashMap<>();
    map.put("Jeans", 40);
    map.put("T-Shirt", 35);
    map.put("Gloves", 42);
    map.compute("Shoes", (k, v) -> 77); // adding a pair
    System.out.println(map);
    // replacing value if key exists
    map.computeIfPresent("Shoes", (k, v) -> v + k.length());
    System.out.println(map);
    map.computeIfAbsent("Shoes", v -> 11);
    // adding a pair if the key is missing
    map.computeIfAbsent("Shoes_2", v -> 11);
    System.out.println(map);
}
```

## HashMap

HashMap использует хэш - таблицу, в которой ключи отсортированы относительно
значений их хэш-кодов.
Bucket – это элемент (ячейка) внутреннего массива HashMap.
В нем хранятся узлы Nodes.

**_Свойства:_**

- Хранит значения в произвольном порядке
- Структура хранения данных: bucket (корзина)
- Ключ и значение могут быть null
- Объекты с null ключами всегда записываются в нулевую ячейку массива.

Чтобы добавить или заменить элемент, используется метод put, либо replace, а
чтобы получить его значение по ключу - метод get. С помощью других методов
интерфейса Map также производятся другие манипуляции над элементами: перебор,
получение ключей, значений, удаление.

```java
public class Program {

    public static void main(String[] args) {
        Map<Integer, String> states = new HashMap<Integer, String>();
        states.put(1, "Germany");
        states.put(2, "Spain");
        states.put(4, "France");
        states.put(3, "Italy");

        // получим объект по ключу 2
        String first = states.get(2);
        System.out.println(first);
        // получим весь набор ключей
        Set<Integer> keys = states.keySet();
        // получить набор всех значений
        Collection<String> values = states.values();
        //заменить элемент
        states.replace(1, "Poland");
        // удаление элемента по ключу 2
        states.remove(2);
        // перебор элементов
        for (Map.Entry<Integer, String> item : states.entrySet()) {
            System.out.printf("Key: %d  Value: %s \n", item.getKey(), item.getValue());
        }
        Map<String, Person> people = new HashMap<String, Person>();
        people.put("1240i54", new Person("Tom"));
        people.put("1564i55", new Person("Bill"));
        people.put("4540i56", new Person("Nick"));

        for (Map.Entry<String, Person> item : people.entrySet()) {

            System.out.printf("Key: %s  Value: %s \n", item.getKey(), item.getValue().getName());
        }
    }
}

class Person {
    private String name;

    public Person(String value) {
        name = value;
    }

    String getName() {
        return name;
    }
}

////////
public class Code {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);

        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}

```

Хеш-таблица – структура данных, реализующая интерфейс ассоциативного массива (
сопоставления ключ–значение или entry), которая обеспечивает быструю вставку и
поиск элементов.

Хеш-функция получает ключ, а на выходе возвращает целое число – хеш-код.
По полученному хэш-коду ключ помещается по определенному индексу хеш-таблицы.
За хеш-функцию отвечает метод hashCode()

По этой причине важно, чтобы хеш-функция вела себя последовательно и выводила
один и тот же хэш-код для одинаковых входных данных. Поэтому в качестве ключей
рекомендуется использовать только неизменяемые immutable типы, например класс
String или Integer.

Хеш-отображение не гарантирует порядок расположения своих элементов.
Порядок, в котором элементы вводятся в хеш-отображение, не обязательно
соответствует тому порядку, в котором они извлекаются итератором.

**_HashMap содержит следующие свойства:**_

- table – внутренний массив типа Entry
- size — размер, количество добавленных элементов
- capacity – емкость, количество бакетов в хэш-таблице
- loadFactor – коэффициент загрузки, по умолчанию равен 0.75
  Показатель насколько хэш-таблица может быть заполнена до того, как ее capacity
  будет автоматически увеличена
- threshold – количество элементов, при достижении которого, размер хэш-таблицы
  увеличится в два раза. Рассчитывается по формуле (capacity * loadFactor)

**_Алгоритм добавления элемента в HashMap:**_

Высчитывается hashCode() ключа

- Определяется бакет (ячейка массива) в которую будет добавлен новый элемент.
  Номер определяется по остатку от деления хэшкода на кол-во ячеек.
  В более новых версиях Java с помощью бинарного сдвига.
- Если бакет пустой - элемент просто добавляется.
- Если бакет не пустой – элемент добавляется в LinkedList внутри бакета:
    - Ключ добавляемого элемента сравнивается с ключами в LinkedList по
      хэшкодам.
    - Если хэшкоды неравны – переход к следующему элементу
    - Если хэшкоды равны – ключи дополнительно сравниваются по equals()
    - Если ключи равны по equals() – перезаписывается value найденного ключа
    - Если ключи не равны по equals() – переход к следующему элементу
- Если ключ не найден в LinkedList – элемент добавляется в конец списка

___


### Устройство

HashMap в Java — это структура данных, которая реализует интерфейс Map и
использует хеш-таблицу для хранения пар "ключ-значение". Она обеспечивает
быстрый доступ к элементам по ключу, что делает её одной из самых популярных
реализаций Map. Давайте рассмотрим, как работает HashMap, его основные
характеристики и внутренние механизмы.

Основные характеристики HashMap

1. Ключи и значения: HashMap хранит данные в виде пар "ключ-значение". Каждый
   ключ должен быть уникальным, но значения могут повторяться.
2. Неупорядоченность: Элементы в HashMap не имеют определенного порядка. Порядок
   вставки не сохраняется.
3. Допускает null: HashMap позволяет использовать один null в качестве ключа и
   любое количество null в качестве значений.
4. Не синхронизирован: HashMap не является потокобезопасным. Если несколько
   потоков одновременно изменяют его, необходимо использовать внешнюю
   синхронизацию.

Как работает HashMap

1. Хеширование
   Когда вы добавляете пару "ключ-значение" в HashMap, ключ проходит через
   хеш-функцию, которая вычисляет хеш-код для этого ключа. Хеш-код — это целое
   число, которое используется для определения индекса в массиве (хеш-таблице),
   где будет храниться значение.

```java
int hash = key.hashCode();
int index = hash % array.length; // Определяем индекс в массиве
```

2. Обработка коллизий<br>
   Коллизия происходит, когда два разных ключа имеют одинаковый хеш-код и,
   следовательно, попадают в один и тот же индекс массива. Для обработки
   коллизий HashMap использует метод цепочек (chaining):
    1. Каждый элемент массива представляет собой связный список (или дерево с
       Java 8 и выше), который хранит все пары "ключ-значение", имеющие
       одинаковый индекс.
    2. Если возникает коллизия, новая пара добавляется в конец связного списка
       или дерева.
3. Резервирование места<br>
   Когда количество элементов в HashMap превышает определенный порог (обычно 75%
   от текущей емкости), происходит увеличение емкости:
    1. Создается новый массив большего размера.
    2. Все существующие элементы перераспределяются по новому массиву на основе
       их хеш-кодов.
4. Время доступа<br>
   В среднем время доступа к элементам по ключу составляет O(1) благодаря
   использованию хеширования. Однако в худшем случае (например, если все
   элементы попадают в одну цепочку) время доступа может составлять O(n). Чтобы
   избежать этого, важно правильно выбирать размер начального массива и
   коэффициент загрузки.

Пример использования HashMap

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();

        // Добавление элементов
        map.put("Alice", 30);
        map.put("Bob", 25);
        map.put("Charlie", 35);

        // Получение элемента
        System.out.println("Age of Alice: " + map.get("Alice"));

        // Проверка наличия ключа
        if (map.containsKey("Bob")) {
            System.out.println("Bob is in the map.");
        }

        // Удаление элемента
        map.remove("Charlie");

        // Итерация по элементам
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
    }
}
```

Заключение
HashMap — это мощная структура данных для хранения пар "ключ-значение" с быстрым
доступом к элементам по ключу. Она использует хеширование для обеспечения
высокой производительности и обрабатывает коллизии с помощью цепочек. Понимание
работы HashMap поможет вам эффективно использовать её в ваших Java-приложениях.

___
**Добавление нескольких значений к одному ключу**

В HashMap в Java ключи должны быть уникальными. Если вы попытаетесь добавить
пару "ключ-значение" с уже существующим ключом, новое значение заменит старое.
Однако, если вам нужно хранить несколько значений для одного ключа, вы можете
использовать несколько подходов.

1. Использование HashMap с List или Set
   Один из самых распространенных способов обработки одинаковых ключей — это
   использование HashMap, где значениями являются коллекции (например, List или
   Set). Это позволяет хранить несколько значений для одного ключа.

Пример с использованием ArrayList

```java
public class Main {
    public static void main(String[] args) {
        HashMap<String, List<Integer>> map = new HashMap<>();

        // Добавление значений
        addValue(map, "Alice", 30);
        addValue(map, "Alice", 31);
        addValue(map, "Bob", 25);
        addValue(map, "Charlie", 35);
        addValue(map, "Alice", 32);

        // Вывод значений
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
    }

    private static void addValue(HashMap<String, List<Integer>> map, String key, Integer value) {
        // Получаем список значений по ключу
        List<Integer> values = map.get(key);

        // Если список не существует, создаем новый
        if (values == null) {
            values = new ArrayList<>();
            map.put(key, values);
        }

        // Добавляем новое значение в список
        values.add(value);
    }
}
```

2. Использование HashMap с Set

Если вам нужно хранить уникальные значения для каждого ключа (без дубликатов),
вы можете использовать HashSet вместо ArrayList.

```java
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Set<Integer>> map = new HashMap<>();

        // Добавление значений
        addValue(map, "Alice", 30);
        addValue(map, "Alice", 31);
        addValue(map, "Bob", 25);
        addValue(map, "Charlie", 35);
        addValue(map, "Alice", 30); // Дубликат не будет добавлен

        // Вывод значений
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
    }

    private static void addValue(HashMap<String, Set<Integer>> map, String key, Integer value) {
        // Получаем множество значений по ключу
        Set<Integer> values = map.get(key);

        // Если множество не существует, создаем новое
        if (values == null) {
            values = new HashSet<>();
            map.put(key, values);
        }

        // Добавляем новое значение в множество
        values.add(value);
    }
}
```

Заключение
Если вам нужно обрабатывать одинаковые пары ключ-значение в Java с
использованием HashMap, вы можете использовать коллекции (например, List или
Set) в качестве значений. Это позволит вам хранить несколько значений для одного
ключа и управлять ими более гибко. Выбор между списком и множеством зависит от
ваших требований к уникальности значений.

___

_**Как работает обработка коллизий в HashMap**_

Когда два ключа имеют одинаковый хеш-код и попадают в один и тот же индекс
массива, HashMap создает связный список (или дерево) для хранения всех пар "
ключ-значение", которые имеют одинаковый индекс. В Java 8 и выше, если
количество элементов в цепочке превышает определенный порог (обычно 8), HashMap
преобразует связный список в сбалансированное дерево (например, Red-Black Tree)
для улучшения производительности.

Пример обработки коллизий<br>
Вот пример, который демонстрирует, как HashMap обрабатывает коллизии:

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<Key, String> map = new HashMap<>();

        // Создаем ключи с одинаковым хеш-кодом
        Key key1 = new Key(1);
        Key key2 = new Key(2);

        // Добавляем пары "ключ-значение"
        map.put(key1, "Value for key 1");
        map.put(key2, "Value for key 2");

        // Вывод значений
        System.out.println("Key 1: " + map.get(key1));
        System.out.println("Key 2: " + map.get(key2));
    }
}

class Key {
    private int id;

    public Key(int id) {
        this.id = id;
    }

    @Override
    public int hashCode() {
        return 1; // Оба ключа будут иметь одинаковый хеш-код
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Key)) return false;
        Key other = (Key) obj;
        return this.id == other.id;
    }
}
```

Объяснение кода<br>

1. Класс Key: Мы создаем класс Key, который имеет метод hashCode(), возвращающий
   одно и то же значение (в данном случае 1). Это означает, что все экземпляры
   этого класса будут иметь одинаковый хеш-код.
2. Добавление пар: Мы добавляем два разных ключа (key1 и key2) в HashMap.
   Несмотря на то что они разные объекты, они имеют одинаковый хеш-код.
3. Обработка коллизий: Когда мы добавляем оба ключа в HashMap, они будут
   храниться в одной цепочке (связанном списке или дереве), так как их хеш-коды
   совпадают.
4. Получение значений: Мы можем получить значения по каждому из ключей без
   проблем, так как метод equals() также переопределен для сравнения объектов по
   их идентификатору.

Заключение<br>
В случае коллизий в HashMap, структура данных автоматически обрабатывает их с
помощью связных списков или деревьев. Вам не нужно беспокоиться о том, как
именно это происходит — просто используйте уникальные ключи для хранения
значений. Если вам нужно хранить несколько значений для одного ключа,
рассмотрите возможность использования коллекций (например, List или Set) как
значений.


___

**Бакеты**

В контексте HashMap в Java "бакеты" (или "ведра") — это структуры данных,
которые используются для хранения пар "ключ-значение". Бакеты помогают
организовать данные в HashMap и обеспечивают эффективный доступ к ним. Давайте
рассмотрим, как это работает.

Основные концепции

1. Хеширование: Когда вы добавляете пару "ключ-значение" в HashMap, сначала
   вычисляется хеш-код ключа с помощью метода hashCode(). Этот хеш-код затем
   используется для определения индекса (или бакета) в массиве, который хранит
   все бакеты.
2. Массив бакетов: HashMap использует массив для хранения бакетов. Каждый
   элемент массива может содержать один или несколько объектов (пары "
   ключ-значение"). Индекс массива определяется на основе хеш-кода ключа.
3. Обработка коллизий: Если два или более ключа имеют одинаковый хеш-код и,
   следовательно, попадают в один и тот же индекс массива (это называется
   коллизией), HashMap использует метод цепочек (chaining) для обработки этих
   коллизий. В этом случае все пары "ключ-значение", которые имеют одинаковый
   индекс, будут храниться в связанном списке или дереве внутри соответствующего
   бакета.

Пример работы с бакетами

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();

        // Добавление пар "ключ-значение"
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");

        // Получение значения по ключу
        System.out.println(map.get("key1")); // Вывод: value1
    }
}
```

Как это выглядит под капотом<br>

1. Добавление элемента:
    1. При добавлении "key1" вычисляется его хеш-код.
    2. На основе этого хеш-кода определяется индекс в массиве.
    3. Если по этому индексу еще нет других элементов, создается новый бакет и
       добавляется пара "key1" : "value1".
2. Обработка коллизий:
    1. Если вы добавите другой ключ, который имеет тот же хеш-код (например, "
       key4"), он попадет в тот же индекс.
    2. В этом случае HashMap создаст связанный список или дерево внутри этого
       бакета и добавит пару "key4" : "value4" туда.
3. Получение элемента:
    1. При получении значения по ключу сначала вычисляется его хеш-код.
    2. Затем определяется индекс массива.
    3. Если по этому индексу есть несколько элементов (из-за коллизий), HashMap
       будет перебирать элементы в связанном списке или дереве до тех пор, пока
       не найдет нужный ключ.

Заключение<br>
Бакеты в HashMap — это важная часть структуры данных, которая позволяет
эффективно хранить и извлекать пары "ключ-значение". Они обеспечивают обработку
коллизий и позволяют поддерживать производительность операций вставки и поиска
на высоком уровне.

___ 

_**Метод цепочек для обработки колизий**_

Метод цепочек (chaining) — это один из способов обработки коллизий в
хеш-таблицах, таких как HashMap в Java. Когда два или более ключа имеют
одинаковый хеш-код и, следовательно, попадают в один и тот же индекс массива (
бакета), метод цепочек позволяет хранить все эти пары "ключ-значение" в одной
структуре данных, связанной с этим индексом.

Как работает метод цепочек

1. Хеширование: Когда вы добавляете пару "ключ-значение" в HashMap, сначала
   вычисляется хеш-код ключа с помощью метода hashCode(). Этот хеш-код
   используется для определения индекса в массиве бакетов.
2. Создание бакета: Если по этому индексу еще нет других элементов, создается
   новый бакет. В Java это обычно реализуется как связный список или дерево.
3. Добавление элементов: Если по этому индексу уже есть элементы (из-за
   коллизий), новая пара "ключ-значение" добавляется в существующий бакет. В
   случае связного списка новый элемент добавляется в конец списка, а если
   используется сбалансированное дерево (например, Red-Black Tree), то элемент
   будет вставлен в соответствующее место дерева.
4. Поиск элементов: При поиске значения по ключу сначала вычисляется его хеш-код
   и индекс массива. Затем HashMap проверяет бакет по этому индексу:
    1. Если бакет представляет собой связный список, он перебирает элементы
       списка до тех пор, пока не найдет нужный ключ.
    2. Если бакет представляет собой дерево, поиск выполняется с использованием
       алгоритма поиска дерева.

Пример работы метода цепочек

```java
import java.util.LinkedList;

class HashMapWithChaining<K, V> {
    private static class Entry<K, V> {
        K key;
        V value;

        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private LinkedList<Entry<K, V>>[] buckets;
    private int capacity;

    @SuppressWarnings("unchecked")
    public HashMapWithChaining(int capacity) {
        this.capacity = capacity;
        buckets = new LinkedList[capacity];
        for (int i = 0; i < capacity; i++) {
            buckets[i] = new LinkedList<>();
        }
    }

    public void put(K key, V value) {
        int index = getIndex(key);
        LinkedList<Entry<K, V>> bucket = buckets[index];

        // Проверяем наличие ключа и обновляем значение
        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
        }

        // Если ключ не найден, добавляем новую пару
        bucket.add(new Entry<>(key, value));
    }

    public V get(K key) {
        int index = getIndex(key);
        LinkedList<Entry<K, V>> bucket = buckets[index];

        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }

        return null; // Ключ не найден
    }

    private int getIndex(K key) {
        return Math.abs(key.hashCode()) % capacity; // Вычисление индекса
    }
}
```

Преимущества метода цепочек<br>

1. Простота реализации: Метод цепочек легко реализовать с использованием
   стандартных структур данных (например, списков или деревьев).
2. Гибкость: Он позволяет хранить несколько значений для одного и того же
   индекса без необходимости перераспределения памяти.
3. Устойчивость к коллизиям: Даже если количество коллизий увеличивается,
   производительность операций вставки и поиска остается приемлемой.

Недостатки метода цепочек<br>

1. Память: Использование дополнительных структур данных для хранения элементов
   может привести к увеличению потребления памяти.
2. Производительность: В худшем случае (например, если все элементы попадают в
   один бакет) производительность операций может ухудшиться до O(n), где n —
   количество элементов в бакете.
3. Необходимость управления размером: При увеличении количества элементов может
   потребоваться перераспределение памяти и увеличение размера массива бакетов
   для поддержания производительности.

Заключение<br>
Метод цепочек — это эффективный способ обработки коллизий в хеш-таблицах. Он
позволяет сохранять производительность операций вставки и поиска на высоком
уровне даже при наличии коллизий за счет использования связанных списков или
деревьев для хранения пар "ключ-значение".

___
**Колизии**

Коллизия в контексте хеш-таблиц возникает, когда два или более ключа имеют
одинаковый хеш-код, что приводит к тому, что они попадают в один и тот же индекс
массива (бакета). Это может произойти по нескольким причинам:<br>

1. Ограниченное количество индексов<br>
   Хеш-таблицы используют фиксированный размер массива для хранения данных. Если
   количество возможных ключей превышает количество доступных индексов, то
   неизбежно будут коллизии. Например, если у вас есть 10 возможных индексов и
   15 различных ключей, то как минимум 5 ключей будут иметь одинаковый индекс.
2. Хеш-функция<br>
   Хеш-функция преобразует ключ в целое число (хеш-код), которое затем
   используется для определения индекса в массиве. Если хеш-функция не
   распределяет ключи равномерно по всем возможным индексам, это может привести
   к большому количеству коллизий. Например, если хеш-функция возвращает одно и
   то же значение для разных ключей или если она слишком проста (например,
   просто возвращает последний символ строки), это может привести к частым
   коллизиям.
3. Ограниченная длина хеша<br>
   Некоторые хеш-функции могут генерировать хеш-коды с ограниченной длиной (
   например, 32 бита), что также увеличивает вероятность коллизий. В этом случае
   множество различных входных данных будет отображаться на ограниченное
   количество выходных значений.
4. Сходство ключей<br>
   Если ключи имеют схожие характеристики (например, строки с одинаковыми
   префиксами или числа с одинаковыми значащими цифрами), это может привести к
   тому, что они будут генерировать одинаковые хеш-коды.

Примеры<br>

1. Простая хеш-функция: Если у вас есть строка "abc" и "cba", и ваша хеш-функция
   просто суммирует ASCII-коды символов, то обе строки могут дать один и тот же
   результат.
2. Ограниченный диапазон: Если вы используете целые числа в качестве ключей и
   ваша хеш-функция просто берет остаток от деления на 10 (например, key % 10),
   то все числа, заканчивающиеся на одну и ту же цифру (например, 12 и 22),
   будут иметь одинаковый индекс.
   Заключение<br>
   Коллизии — это естественная часть работы с хеш-таблицами из-за ограниченного
   количества индексов и особенностей хеш-функций. Эффективные алгоритмы
   обработки
   коллизий (такие как метод цепочек или открытая адресация) помогают
   минимизировать их влияние на производительность операций вставки и поиска в
   хеш-таблицах.

___
**Одинаковый hashcode**

В Java `HashMap` использует хеш-функцию для распределения ключей по "корзинам" (
buckets) в зависимости от их хеш-кода. Однако, разные объекты могут иметь
одинаковый хеш-код из-за особенностей хеширования. Это явление называется
коллизией.

Вот несколько причин, почему два ключа могут иметь одинаковый хеш-код:<br>

1. **Ограниченное пространство значений**: Хеш-функция преобразует объект в
   целое число (хеш-код), и поскольку количество возможных объектов значительно
   больше, чем количество возможных целых чисел, разные объекты могут быть
   преобразованы в одно и то же значение.
2. **Алгоритм хеширования**: Хеш-функции не идеальны и могут создавать коллизии.
   Например, если два объекта имеют одинаковые значения для всех полей, которые
   участвуют в вычислении хеш-кода, они будут иметь одинаковый хеш-код.
3. **Пользовательские классы**: Если вы создаете собственный класс и
   переопределяете метод `hashCode()`, вы можете случайно создать коллизии, если
   не будете учитывать все важные поля объекта.

Когда происходит коллизия (т.е. два ключа имеют одинаковый хеш-код), `HashMap`
использует дополнительную структуру данных (обычно связный список или дерево)
для хранения всех элементов с одинаковым хеш-кодом в одной корзине. При поиске
элемента по ключу `HashMap` сначала вычисляет хеш-код ключа, находит
соответствующую корзину и затем сравнивает ключи внутри этой корзины с помощью
метода `equals()`, чтобы найти нужный элемент.

Таким образом, хотя коллизии возможны, `HashMap` эффективно обрабатывает их,
обеспечивая корректное поведение при добавлении и поиске элементов.

### Сложности методов

В среднем, операция добавления, удаления и поиска элемента в HashMap имеют
временную сложность O(1). Однако, в худшем случае, когда все элементы попадают в
одну корзину, они будут связаны в связный список или дерево, и операция может
занимать время O(n), где n - количество элементов в корзине. Таким образом,
сложность операций в HashMap зависит от количества коллизий и хеш-функции.<br>
В среднем, сложность выборки элемента также составляет O(1), но в худшем случае
может достигать O(n).


## LinkedHashMap

LinkedHashMap расширяет HashMap.
Поддерживает связанный список записей в том порядке, в котором они добавлены.
Это позволяет организовать итерацию по карте в порядке вставки.
Элементы хранятся в порядке добавления.

## HashTable

Класс Hashtable<K, V> реализует интерфейс Map, обладает также несколькими
специфичными, по сравнению с другими коллекциями, методами:

- Enumeration<V> elements() — возвращает итератор для значений карты;
- Enumeration<K> keys() — возвращает итератор для ключей карты

Hashtable – это синхронизированный аналог HashMap.
Синхронизирован.
Deprecated. На смену пришел ConcurrentHashMap.
Не хранит null.

```java
public static void main(String[] args) {
    Hashtable<String, Integer> table = new Hashtable<>();
    table.put("Jeans", 40); // adding a pair
    table.put("T-Shirt", 35);
    table.put("Gloves", 42);
    table.compute("Shoes", (k, v) -> 77); // adding a pair
    System.out.println(table);

    Enumeration<String> keys = table.keys();
    while (keys.hasMoreElements()) {
        System.out.println(keys.nextElement());
    }
    Enumeration<Integer> values = table.elements();
    while (values.hasMoreElements()) {
        System.out.println(values.nextElement());
    }
}
```

## WeakHashMap<K,V>

Реализация интерфейса Map со слабыми ключами.
Запись в WeakHashMap будет автоматически удалена GK по ключу, ссылка на который
вышла из области видимости приложения (ключ со слабой ссылкой).
Записи автоматически удаляются GK.

Класс WeakHashMap<K, V> хорошо работает в ситуациях, когда в процессе работы с
коллекцией некоторые объекты должны из нее гарантированно удаляться, но моменты
необходимости удаления и само удаление пары из коллекции могут отставать друг от
друга по времени.

Пусть существует некоторый набор заказов. Заказ может находиться в
состоянии «обработан/необработан». Исходно коллекция содержит необработанные
заказы. Как только заказ изменяет статус на «обработан», его следует удалить
из коллекции. Разрешать всем пользователям коллекции удалять заказы, то
есть модифицировать коллекцию не очень разумно по причинам безопасности.
Коллекция WeakHashMap сама будет заботиться об удалении неактуальных
объектов, утративших ссылку на внешний ключ.

```java
class Order {
}

class Key {
    //  где класс Key содержит информацию об уникальном номере заказа и текущем статусе заказа.
    private int keyUnique;
    private boolean isProcessed;

    public Key(int keyUnique) {
        this.keyUnique = keyUnique;
    }

    public boolean isProcessed() {
        return isProcessed;
    }

    public void setProcessed(boolean processed) {
        isProcessed = processed;
    }
}

class CurrentOrders {
    private WeakHashMap<Key, Order> orders = new WeakHashMap<>();

    public Order put(Key key, Order value) {
        return orders.put(key, value);
    }

    public Order get(Object key) {
        return orders.get(key);
    }

    public int size() {
        return orders.size();
    }
}

public class Code {
    public static void main(String[] args) throws InterruptedException {
        CurrentOrders orders = new CurrentOrders();
        List<Key> keys = new ArrayList<>();
        keys.add(new Key(100));
        keys.add(new Key(220));
        keys.add(new Key(770));
        orders.put(keys.get(0), new Order());
        orders.put(keys.get(1), new Order());
        orders.put(keys.get(2), new Order());
        keys.get(1).setProcessed(true);
        final int size = keys.size();
        Iterator<Key> iterator = keys.iterator();
        while (iterator.hasNext()) {
            Key ordersKey = iterator.next();
            if (ordersKey.isProcessed()) {
                iterator.remove();
            }
        }
        System.out.println(orders.size());
        System.gc();
        Thread.sleep(1_000);
        System.out.println(orders.size());
    }
}
```

Чтобы сохранять ссылки на ключи, для них будет создан список. После этого
значение isProcessed у ключа будет изменено, он будет удален из списка ключей и,
как следствие, ключ из WeakHashMap утратит ссылку и станет целью для удаления
«сборщиком мусора». Удаление происходит не мгновенно, а только когда сработает
«сборщик мусора». И после этого число заказов уменьшится с 3 до 2.

## EnumMap

Класс EnumMap<K extends Enum<K>, V> в качестве ключа может принимать только
объекты, принадлежащие одному типу enum, который должен быть определен при
создании коллекции. Специально организован для обеспечения максимальной скорости
доступа к элементам коллекции.

```java
enum Country {
    RUSSIA, BELARUS, INDIA, CHINA, POLAND
}

public class Code {
    public static void main(String[] args) {
        EnumMap<Country, Integer> map = new EnumMap<Country, Integer>(Country.class);
        map.put(Country.POLAND, 3);
        map.put(Country.BELARUS, 4);
        map.forEach((k, v) -> System.out.println(k + ": " + v));

        // -> 
        // BELARUS: 4
        // POLAND: 3

    }
}
```

## SortedMap

Интерфейс SortedMap расширяет Map и создает отображение, в котором все элементы
отсортированы в порядке возрастания их ключей.

**МЕТОДЫ:**

- K firstKey(): возвращает ключ первого элемента отображения
- K lastKey(): возвращает ключ последнего элемента отображения
- SortedMap<K, V> headMap(K end): возвращает отображение SortedMap, которые
  содержит все элементы оригинального SortedMap вплоть до элемента с ключом end
- SortedMap<K, V> tailMap(K start): возвращает отображение SortedMap, которые
  содержит все элементы оригинального SortedMap, начиная с элемента с ключом
  start
- SortedMap<K, V> subMap(K start, K end): возвращает отображение SortedMap,
  которые содержит все элементы оригинального SortedMap вплоть от элемента с
  ключом start до элемента с ключом end

## NavigableMap

Интерфейс NavigableMap расширяет интерфейс SortedMap и обеспечивает возможность
получения элементов отображения относительно других элементов.

SortedMap расширена методами навигации, возвращающими ближайшие совпадения для
заданных целей поиска:

- lowerEntry(K), floorEntry(K), ceilingEntry(K) и higherEntry(K) возвращают
  объекты Map.Entry, связанные с ключами соответственно меньше, меньше или
  равны, больше или равно и больше, чем данный ключ, возвращая null, если такого
  ключа нет.
- lowerKey(K), floorKey(K), ceilingKey(K) и higherKey(K) возвращают ключ
  соответственно меньше, меньше или равно, больше или равно и больше, чем данный
  ключ, возвращая null, если такого ключа нет.
- descendingMap() возвращает NavigableMap в обратном порядке
- subMap(K, boolean, K, boolean), headMap(K, boolean) и tailMap(K, boolean)
  отличаются от аналогичных методов SortedMap принятием дополнительных
  аргументов, описывающих, являются ли нижняя и верхняя границы инклюзивными по
  сравнению с эксклюзивными
- firstEntry(), pollFirstEntry(), lastEntry() и pollLastEntry() возвращают и/или
  удаляют наименьшие и наибольшие отображения, если таковые имеются, в противном
  случае возвращая null
- subMap(K, K), headMap(K) и tailMap(K) предназначены для возврата части
  NavigableMap

**МЕТОДЫ:**

- Map.Entry<K, V> ceilingEntry(K key): возвращает элемент с наименьшим ключом k,
  который больше или равен ключу key (k >=key). Если такого ключа нет, то
  возвращается null.
- Map.Entry<K, V> floorEntry(K key): возвращает элемент с наибольшим ключом k,
  который меньше или равен ключу key (k <=key). Если такого ключа нет, то
  возвращается null.
- Map.Entry<K, V> higherEntry(K key): возвращает элемент с наименьшим ключом k,
  который больше ключа key (k >key). Если такого ключа нет, то возвращается
  null.
- Map.Entry<K, V> lowerEntry(K key): возвращает элемент с наибольшим ключом k,
  который меньше ключа key (k <key). Если такого ключа нет, то возвращается
  null.
- Map.Entry<K, V> firstEntry(): возвращает первый элемент отображения
- Map.Entry<K, V> lastEntry(): возвращает последний элемент отображения
- Map.Entry<K, V> pollFirstEntry(): возвращает и одновременно удаляет первый
  элемент из отображения
- Map.Entry<K, V> pollLastEntry(): возвращает и одновременно удаляет последний
  элемент из отображения
- K ceilingKey(K key): возвращает наименьший ключ k, который больше или равен
  ключу key (k >=key). Если такого ключа нет, то возвращается null.
- K floorKey(K key): возвращает наибольший ключ k, который меньше или равен
  ключу key (k <=key). Если такого ключа нет, то возвращается null.
- K lowerKey(K key): возвращает наибольший ключ k, который меньше ключа key (k <
  key). Если такого ключа нет, то возвращается null.
- K higherKey(K key): возвращает наименьший ключ k, который больше ключа key (
  k >key). Если такого ключа нет, то возвращается null.
- NavigableSet<K> descendingKeySet(): возвращает объект NavigableSet, который
  содержит все ключи отображения в обратном порядке
- NavigableMap<K, V> descendingMap(): возвращает отображение NavigableMap,
  которое содержит все элементы в обратном порядке
- NavigableSet<K> navigableKeySet(): возвращает объект NavigableSet, который
  содержит все ключи отображения
- NavigableMap<K, V> headMap(K upperBound, boolean incl): возвращает отображение
  NavigableMap, которое содержит все элементы оригинального NavigableMap вплоть
  от элемента с ключом upperBound. Параметр incl при значении true указывает,
  что элемент с ключом upperBound также включается в выходной набор.
- NavigableMap<K, V> tailMap(K lowerBound, boolean incl): возвращает отображение
  NavigableMap, которое содержит все элементы оригинального NavigableMap,
  начиная с элемента с ключом lowerBound. Параметр incl при значении true
  указывает, что элемент с ключом lowerBound также включается в выходной набор.
- NavigableMap<K, V> subMap(K lowerBound, boolean lowIncl, K upperBound, boolean
  highIncl): возвращает отображение NavigableMap, которое содержит все элементы
  оригинального NavigableMap от элемента с ключом lowerBound до элемента с
  ключом upperBound. Параметры lowIncl и highIncl при значении true включают в
  выходной набор элементы с ключами lowerBound и upperBound соответственно.

## TreeMap

Структура хранения данных красно-черное сбалансированное дерево.
По-умолчанию TreeMap сортируется по ключам с использованием принципа натуральной
сортировки, но это поведение может быть настроено под конкретную задачу при
помощи объекта класса Comparator.
Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а
следовательно, также и интерфейс SortedMap. Поэтому в отличие от коллекции
HashMap в TreeMap все объекты автоматически сортируются по возрастанию их
ключей.

**_Свойства:_**

- Красно-черное сбалансированное дерево
- Все элементы отсортированы в порядке возрастания ключа
- Порядок сортировки может быть задан Comparator и Comparable

**Конструкторы:**

- TreeMap() - создает пустое отображение в виде дерева
- TreeMap(Map<? extends K, ? extends V> map) - создает дерево, в которое
  добавляет все элементы из отображения map
- TreeMap(SortedMap<K, ? extends V> smap) - создает дерево, в которое добавляет
  все элементы из отображения smap
- TreeMap(Comparator<? super K> comparator) - создает пустое дерево, где все
  добавляемые элементы впоследствии будут отсортированы компаратором.

```java
public class Program {
    public static void main(String[] args) {
        TreeMap<Integer, String> states = new TreeMap<Integer, String>();
        states.put(10, "Germany");
        states.put(2, "Spain");
        states.put(14, "France");
        states.put(3, "Italy");
        // получим объект по ключу 2
        String first = states.get(2);
        // перебор элементов
        for (Map.Entry<Integer, String> item : states.entrySet()) {
            System.out.printf("Key: %d  Value: %s \n", item.getKey(), item.getValue());
        }
        // получим весь набор ключей
        Set<Integer> keys = states.keySet();
        // получить набор всех значений
        Collection<String> values = states.values();
        // получаем все объекты, которые стоят после объекта с ключом 4
        Map<Integer, String> afterMap = states.tailMap(4);
        // получаем все объекты, которые стоят до объекта с ключом 10
        Map<Integer, String> beforeMap = states.headMap(10);
        // получим последний элемент дерева
        Map.Entry<Integer, String> lastItem = states.lastEntry();
        System.out.printf("Last item has key %d value %s \n", lastItem.getKey(), lastItem.getValue());
        Map<String, Person> people = new TreeMap<String, Person>();
        people.put("1240i54", new Person("Tom"));
        people.put("1564i55", new Person("Bill"));
        people.put("4540i56", new Person("Nick"));
        for (Map.Entry<String, Person> item : people.entrySet()) {
            System.out.printf("Key: %s  Value: %s \n", item.getKey(), item.getValue().getName());
        }
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }
}
```

Кроме собственно методов интерфейса Map класс TreeMap реализует методы
интерфейса NavigableMap. Например, мы можем получить все объекты до или после
определенного ключа с помощью методов headMap и tailMap. Также мы можем получить
первый и последний элементы и провести ряд дополнительных манипуляций с
объектами.




