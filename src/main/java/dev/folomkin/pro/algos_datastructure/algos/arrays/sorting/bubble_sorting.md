# Пузырьковая сортировка<br> (Bubble sort)

Данный алгоритм сортировки прост, но имеет одну из наиболее низких скоростей
выполнения. Представим себе цепочку случайно расставленных чисел в возрастающем
порядке, для которых будут выполняться следующие шаги, начиная с начала цепочки:

- сравнить два числа;
- если число слева больше, то поменять их местами;
- перейти на одну позицию вправо.

Сортировка пузырьком — это самый простой алгоритм сортировки. Он проходит по
массиву несколько раз, на каждом этапе перемещая самое большое значение из
неотсортированных в конец массива.

Задан массив целых чисел:

    [3] [7] [4] [4] [6] [5] [8]

При первом проходе по массиву мы сравниваем значения 3 и 7. Поскольку 7 больше
3, мы оставляем их как есть. После чего сравниваем 7 и 4. 4 меньше 7, поэтому мы
меняем их местами, перемещая семерку на одну позицию ближе к концу массива.
Теперь он выглядит так:

    [3] [4] [7] [4] [6] [5] [8]

Этот процесс повторяется до тех пор, пока семерка не дойдет почти до конца
массива. В конце она сравнивается с элементом 8, которое больше, а значит,
обмена не происходит. После того, как мы обошли массив один раз, он выглядит
так:

    [3] [4] [4] [6] [5] [7] [8]

Поскольку был совершен по крайней мере один обмен значений, нам нужно пройти по
массиву еще раз. В результате этого прохода мы перемещаем на место число 6.

    // [3] [4] [4] [5] [6] [7] [8]

И снова был произведен как минимум один обмен, а значит, проходим по массиву еще
раз.

При следующем проходе обмена не производится, что означает, что наш массив
отсортирован, и алгоритм закончил свою работу.

```java
package dev.folomkin.algos_datastructure.algos.arrays.sorting;

public class Code {
    public static void bubbleSort(int[] array) {
        int n = array.length;
        boolean swapped;

        // -> Проходит по всем элементам массива
        for (int i = 0; i < n - 1; i++) {

            // -> Если в ходе прохода по массиву не было произведено
            // ни одной замены (переменная swapped остается false),
            // это означает, что массив уже отсортирован, и можно
            // завершить выполнение.
            swapped = false;

            // -> Сравнивает соседние элементы и меняет их местами,
            // если они находятся в неправильном порядке
            for (int j = 0; j < n - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    // Меняем местами array[j] и array[j + 1]
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    swapped = true;
                }
            }

            // -> Если не было обменов, массив уже отсортирован
            if (!swapped) {
                break;
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Исходный массив:");
        printArray(array);
        bubbleSort(array);
        System.out.println("Отсортированный массив:");
        printArray(array);
    }

    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}

```

## Объяснение кода

1. Метод bubbleSort: Этот метод принимает массив целых чисел и сортирует его с
   помощью пузырьковой сортировки. Он использует два вложенных цикла: внешний
   цикл проходит по всем элементам массива, а внутренний цикл сравнивает
   соседние элементы и меняет их местами, если они находятся в неправильном
   порядке.
2. Оптимизация: Если в ходе прохода по массиву не было произведено ни одной
   замены (переменная swapped остается false), это означает, что массив уже
   отсортирован, и можно завершить выполнение.

Для сортировки массива из пяти элементов необходимо максимум четыре прохода и
десять сравнений. Если после прохода не было ни одной перестановки, то
сортировку можно прервать. В этом случае для сортировки ранее уже
отсортированного массива нужен всего один проход.

Алгоритм пузырьковой сортировки является одним из самых медленных. Если массив
состоит из N элементов, то на первом проходе будет выполнено N-1 сравнений, на
втором N-2, далее N-3 и т.д. То есть всего будет произведено проходов:

(N-1) + (N-2) + (N-3) + … + 1 = N x (N-1)/2

Таким образом, при сортировке алгоритм выполняет около 0.5х(N^2) сравнений. Для
N = 5, количество сравнений будет примерно 10, для N = 10 количество сравнений
вырастит до 45. Таким образом, с увеличением количества элементов сложность
сортировки значительно увеличивается.

На скорость алгоритма влияет не только количество проходов, но и количество
перестановок, которые потребуется совершить. Для случайных данных количество
перестановок в среднем составляет (N^2)/4, то есть примерно в половину меньше,
чем количество проходов. Однако, в худшем случае количество перестановок также
может составить N^2/2 – это в том случае, если данные изначально отсортированы
в обратном порядке.

Алгоритм хорошо себя показывает с большими наборами данных, где элементы почти
отсортированы и требуется всего одна итерация, чтобы определить, отсортирован ли
список до конца.
В случае с совершенно неотсортированным списком, для пузырьковой сортировки он
должен быть хотя бы небольшим.

## Сложность

Временная сложность O(N²), так как имеются вложенные циклы. Внешний проход по
элементам выполняется за N раз, внутренний — тоже N раз, и в итоге мы получаем
N*N, N² итераций.

| СЛОЖНОСТЬ | Наилучший случай | В среднем | Наихудший случай |
|-----------|------------------|-----------|------------------|
| Время     | O(n)             | O(n^2)    | O(n^2)           |
| Память    | O(1)             | O(1)      | O(1)             |
