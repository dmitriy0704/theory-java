# Сортировка слиянием<br> (Merge Sorting)

Сортировка слиянием (Merge Sort) — это эффективный алгоритм сортировки, который
использует метод "разделяй и властвуй". Он делит массив на две половины,
рекурсивно сортирует каждую половину, а затем объединяет (сливает)
отсортированные половины в один отсортированный массив.

## Принцип работы алгоритма

При сортировке слиянием мы разделяем массив пополам до тех пор, пока каждый
участок не станет длиной в один элемент. Затем эти участки возвращаются на
место (сливаются) в правильном порядке.

Давайте посмотрим на такой массив:

    [3][8][2][1][5][4][6][7]

Разделим его пополам:

    [3][8][2][1] [5][4][6][7]

И будем делить каждую часть пополам, пока не останутся части с одним элементом:

    [3][8] [2][1] [5][4] [6][7]
    [3] [8] [2] [1] [5] [4] [6] [7]

Теперь, когда мы разделили массив на максимально короткие участки, мы сливаем их
в правильном порядке.

    [3] [8] [2] [1] [5] [4] [6] [7]
    [3][8] [1][2] [4][5] [6][7]

Сначала мы получаем группы по два отсортированных элемента, потом «собираем» их
в группы по четыре элемента и в конце собираем все вместе в отсортированный
массив.

        [1][2][3][8]  [4][5][6][7]
        [1][2][3][4][5][6][7][8]

Для работы алгоритма мы должны реализовать следующие операции:

1. Операцию для рекурсивного разделения массива на группы
2. Слияние в правильном порядке

Стоит отметить, что в отличие от линейных алгоритмов сортировки, сортировка
слиянием будет делить и склеивать массив вне зависимости от того, был он
отсортирован изначально или нет. Поэтому, несмотря на то, что в худшем случае он
отработает быстрее, чем линейный, в лучшем случае его производительность будет
ниже, чем у линейного. Поэтому сортировка слиянием — не самое лучшее решение,
когда надо отсортировать частично упорядоченный массив.

## Пример реализации

Вот пример кода, который демонстрирует сортировку слиянием:

```java 
public class MergeSort {
    // Метод для сортировки массива с использованием сортировки слиянием
    public static void mergeSort(int[] array) {
        if (array.length < 2) {
            return; // Если массив состоит из одного элемента, он уже отсортирован
        }

        int mid = array.length / 2; // Находим середину массива
        int[] left = new int[mid]; // Создаем левую половину
        int[] right = new int[array.length - mid]; // Создаем правую половину

        // Заполняем левую и правую половины
        for (int i = 0; i < mid; i++) {
            left[i] = array[i];
        }
        for (int i = mid; i < array.length; i++) {
            right[i - mid] = array[i];
        }

        // Рекурсивно сортируем обе половины
        mergeSort(left);
        mergeSort(right);

        // Сливаем отсортированные половины
        merge(array, left, right);
    }

    // Метод для слияния двух отсортированных массивов
    private static void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;

        // Сравниваем элементы левой и правой половин и заполняем основной массив
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                array[k++] = left[i++];
            } else {
                array[k++] = right[j++];
            }
        }

        // Копируем оставшиеся элементы левой половины, если есть
        while (i < left.length) {
            array[k++] = left[i++];
        }

        // Копируем оставшиеся элементы правой половины, если есть
        while (j < right.length) {
            array[k++] = right[j++];
        }
    }

    // Метод для вывода массива на экран
    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }

    // Главный метод для тестирования сортировки слиянием
    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10}; // Исходный массив
        System.out.println("Исходный массив:");
        printArray(array);

        mergeSort(array); // Сортируем массив

        System.out.println("Отсортированный массив:");
        printArray(array); // Выводим отсортированный массив
    }
}
```

## Объяснение кода

1. Метод mergeSort:

    1. Принимает массив целых чисел в качестве аргумента.
    2. Если длина массива меньше 2, он возвращается, так как массив уже
       отсортирован.
    3. Находит середину массива и создает два новых массива: left и right.
    4. Заполняет эти массивы значениями из исходного массива.
    5. Рекурсивно вызывает mergeSort для обеих половин.
    6. После сортировки обеих половин вызывает метод merge для их слияния.

2. Метод merge:

    1. Принимает основной массив и два отсортированных массива (left и right).
    2. Сравнивает элементы из обоих массивов и заполняет основной массив
       отсортированными значениями.
3. Если остались элементы в одной из половин, они копируются в основной массив.

3. Метод printArray:
    1. Выводит элементы массива на экран.

4. Метод main:

    1. Создает массив, выводит его на экран, сортирует с помощью mergeSort, а
       затем снова выводит отсортированный массив.

## Преимущества и недостатки

Преимущества:

1. Временная сложность O(n log n) в худшем, среднем и лучшем случаях.
2. Стабильный алгоритм (сохраняет порядок равных элементов).
3. Хорошо работает с большими массивами.

Недостатки:

1. Требует дополнительной памяти для временных массивов, что может быть
   проблемой для больших массивов.

Сортировка слиянием — это мощный и эффективный алгоритм, который часто
используется в практических приложениях, особенно когда требуется стабильная
сортировка.

| СЛОЖНОСТЬ | Наилучший случай | В среднем     | Наихудший случай |
|-----------|------------------|---------------|------------------|
| Время     | O(n * log n )    | O(n * log n ) | O(n * log n)     |
| Память    | O(n)             | O(n)          | O(n)             |