# Структуры данных

В Java существует множество структур данных, которые можно использовать для
хранения и управления данными. Вот основные из них:

1. Массивы (Arrays)
   Одномерные массивы: Хранят фиксированное количество элементов одного типа.
   Многомерные массивы: Массивы массивов, например, двумерные массивы.
2. Списки (Lists)
   ArrayList: Динамический массив, который может изменять свой размер. Позволяет
   быстро получать доступ к элементам по индексу.
   LinkedList: Связанный список, который позволяет быстро добавлять и удалять
   элементы, но доступ к элементам по индексу медленнее, чем в ArrayList.
3. Наборы (Sets)
   HashSet: Набор, который не допускает дубликатов и не гарантирует порядок
   элементов. Использует хеширование для быстрого поиска.
   LinkedHashSet: Подобен HashSet, но сохраняет порядок добавления элементов.
   TreeSet: Набор, который хранит элементы в отсортированном порядке.
4. Словари (Maps)
   HashMap: Хранит пары "ключ-значение" и не гарантирует порядок. Использует
   хеширование для быстрого доступа.
   LinkedHashMap: Подобен HashMap, но сохраняет порядок добавления пар "
   ключ-значение".
   TreeMap: Хранит пары "ключ-значение" в отсортированном порядке по ключу.
5. Стек (Stack)
   Реализован через класс Stack, который следует принципу LIFO (последний
   пришел — первый вышел). Также можно использовать Deque для реализации стека.
6. Очередь (Queue)
   Реализована через интерфейс Queue. Существует несколько реализаций:
   LinkedList: Может использоваться как очередь.
   PriorityQueue: Очередь с приоритетами, где элементы обрабатываются в порядке
   их приоритета.
7. Дек (Deque)
   Двунаправленная очередь, которая позволяет добавлять и удалять элементы с
   обоих концов. Реализуется через класс ArrayDeque или LinkedList.
8. Куча (Heap)
   Структура данных, которая может быть реализована с помощью массива или
   специального класса для управления приоритетами (например, PriorityQueue).
9. Графы (Graphs)
   Графы могут быть реализованы с помощью списков смежности или матриц
   смежности. В Java нет встроенной структуры данных для графов, но их можно
   реализовать с использованием других коллекций.
10. Деревья (Trees)
    Бинарные деревья и другие виды деревьев могут быть реализованы вручную или с
    использованием сторонних библиотек.
    Java предоставляет мощный набор коллекций через пакет java.util, который
    включает в себя все вышеперечисленные структуры данных и их реализации.
    Выбор структуры данных зависит от конкретных требований задачи, таких как
    необходимость в быстром доступе к элементам, частота вставок и удалений и
    т.д.

## Массив

Массив - это нумерованный набор переменных одного типа.
Упорядоченная коллекция элементов одного типа, расположенных в непрерывной
области памяти. Доступ к элементам осуществляется по индексу (номеру элемента в
массиве). В Java массивы имеют фиксированный размер, который задается при
создании.

Объявляется следующем образом:

```java
int[] arr = new int[10];
```

Все массивы в Java одномерные. В случае с многомерными массивами каждый элемент
содержит только ссылку на вложенный массив.  
Можно создать нулевого размера, может быть полезно если нужно вернуть пустой
массив из какого-либо метода.
Оператор new используется для создания ссылочного типа данных. Ссылка хранится
на стеке, а объект в куче. Если на объект нет ссылок, то он будет удалён
автоматически. Удаление объекта может быть осуществлено с задержкой

#### Операции:

- Доступ к элементу по индексу: array[index] - O(1).
- Изменение элемента по индексу: array[index] = value - O(1).
- Итерация (обход) по всем элементам: for-each, итератор - O(n).
- Копирование массива: System.arraycopy(), Arrays.copyOf() - O(n).

#### Методы и алгоритмы:

- поиск (contains, линейный поиск O(n), бинарный поиск в отсортированном массиве
  O(log n)),
- сортировка (Arrays.sort() использует quicksort для примитивных
  типов - сложность O(n log n), для объектов - mergesort или Timsort (для
  Comparable либо Comparator - если заданы).

## Список (Динамический массив)

Идея списка или же динамического массива заключается в автоматическом расширении
емкости.

Объявляется следующем образом:

```java
ArrayList<Integer> arr = new ArrayList<Integer>();
```

Передается класс обертка. Если не указать в конструктор начальную емкость, то
будет создан пустой список с емкостью в 10 элементов

В случае, когда зарезервированной емкости не хватает, при достижении
максимального количества элементов будет создан новый массив с емкостью:
новая_емкость = (старая_емкость * 3) / 2 + 1. Существующие элементы списка будут
скопированы в новый массив

Чтобы не тратить память напрасно, при удалении элементов следует вызывать метод
trimToSize()

Плюсы:

- доступ к элементам по индексу за O(1), к элементам по значению за O(n);
- можно хранить любые значения и даже null.

минусы:

- вставка или удаление элемента в середину списка вызывает перезапись всех
  элементов, работает за O(n);
- поиск за O(n);
- не синхронизирован.

## Стек

Очередь работает по принципу LIFO.Добавление и удаление элементов производится
только с одного конца, называемого вершиной стека. В Java наследуется от
Vector<E>, реализует следующие интерфейсы: Iterable<E>, Collection<E>, List<E>,
RandomAccess, Serializable, Cloneable.

Объявляется следующем образом:

```java
Stack<Integer> arr = new Stack<Integer>();
```

#### Операции:

- push(element): Добавляет элемент на вершину стека - O(1).
- pop(): Удаляет и возвращает элемент с вершины стека - O(1).
- peek(): Возвращает элемент с вершины стека без удаления - O(1).
- isEmpty(): Проверяет, пуст ли стек - O(1).
- size(): Возвращает количество элементов в стеке - O(1).

#### Важные принципы:

- LIFO: Строгое соблюдение порядка добавления и удаления элементов.
- Ограниченный доступ: Доступ возможен только к вершине стека.

#### Реализация:

Стек в Java можно реализовать несколькими способами: на базе класса Deque (
ArrayDeque), Stack, либо LinkedList. Если требуется работа в многопоточном
режиме, то лучше воспользоваться ConcurrentLinkedDeque. Для специализированных
высокопроизводительных приложений, может потребоваться создание собственного
класса, заточенного на особые методы оптимизации (упрощение интерфейса, ручная
работа с выделением памяти, ограниченный набор операций).

#### Методы и алгоритмы:

реализация обратной польской нотации, алгоритм проверки правильности
последовательности скобок.

## Очередь

Структура данных, работающая по принципу "первым пришел - первым вышел"
(First-In, First-Out - FIFO). Добавление элементов производится в конец очереди,
а удаление - из начала.

Интерфейс Queue<E> описывает одностороннюю очередь, а Deque<E> - двухстороннюю.
Иерархия следующая:   
`Iterable<T> => Collection<E> => Queue<E> => Deque<E>`

Интерфейсы Queue<E> и Deque<E> реализуют следующие классы:
ArrayDeque<E> - двухсторонняя очередь  
LinkedList<E> - связный список  
PriorityQueue<E> - очередь с приоритетами

Объявляется следующем образом:

```java
Queue<Integer> arr = new ArrayDeque<Integer>();
Deque<Integer> arr1 = new ArrayDeque<Integer>();
PriorityQueue<Integer> arr2 = new PriorityQueue<Integer>();
// Очередь на LinkedList'е
Queue<Integer> arr = new LinkedList<Integer>();
Deque<Integer> arr = new LinkedList<Integer>();

```

Разница между реализацией на листе и деку
ArrayDeque реализует дек на массиве, поэтому он эффективнее по памяти и работает
быстрее, чем LinkedList.

PriorityQueue.
Этот класс реализует следующие интерфейсы: Iterable\<E>, Collection\<E>,
Queue\<E>, Serializable. У этого класса есть свои особенности:
Из очереди первым возвращается элемент с наибольшим приоритетом
Значение null добавить нельзя

#### Операции:

- offer(element): Добавляет элемент в конец очереди - O(1).
- poll(): Удаляет и возвращает элемент из начала очереди - O(1).
- peek(): Возвращает элемент из начала очереди без удаления - O(1).
- isEmpty(): Проверяет, пуста ли очередь - O(1).
- size(): Возвращает количество элементов в очереди - O(1).

#### Важные принципы:

- FIFO: Строгое соблюдение порядка добавления и удаления элементов.
- Ограниченный доступ: Добавление только в конец, удаление только из начала.

#### Реализация:

Для реализации очереди в Java на неблокирующих алгоритмах подойдет
ConcurrentLinkedQueue (для работы из нескольких потоков), либо ArrayDeque и
LinkedList. ConcurrentLinkedQueue обеспечивает атомарность операций и видимость
для всех потоков. ArrayDeque - при реализации будет быстрее работать при
операциях добавления/удаления. LinkedList позволяет быстро вставлять и удалять
из середины, в то время как ArrayDeque эффективнее при доступе по индексу.

#### Методы и алгоритмы:

fпоиск в ширину (BFS), моделирование систем обслуживания, реализация пула
ресурсов.

## Связный список

LinkedList<E> реализует связный список, элементы которого хранят ссылки на
предыдущий и следующий элементы.

Класс реализует следующие интерфейсы:
Iterable<E>, Collection<E>, List<E>, Queue<E>, Deque<E>, Serializable,
Cloneable.

Объявляется следующем образом:

```java
LinkedList<Integer> arr = new LinkedList<Integer>();
```

### Сравнение скорости ArrayList и LinkedList

| Операция                                     | ArrayList                                                      | LinkedList                                         |
|----------------------------------------------|----------------------------------------------------------------|----------------------------------------------------|
| Добавить новый элемент add (E element)       | O(1), <br/>O(n) - при копировании                              | O(1)                                               |
| Добавить элемент  add (int index, E element) | O(n/2) - с середины,<br/> O(n) - с начала,<br/> O(1) - с конца | O(n/4),<br/> O(n) - в конец или начало             |
| Удалить элемент  remove (int index)          | O(n/2) - с середины,<br/> O(n) - с начала, <br/>O(1) - с конца | O(n/4),<br/> O(n) - в конец или начало             |
| Взятие по индексу get (int index)            | O(1)                                                           | O(n/4)                                             |
| Добавить элемент                             | O(1)                                                           | В середине — O(n/4)<br>В конце или в начале — O(n) |

LinkedList занимает гораздо больше памяти, чем ArrayList. Использовать нужно в
определенных случаях, чаще всего когда речь идет о двусвязном списке. Также
стоит отметить, что элементы у ArrayList в памяти хранятся линейно, поэтому
доступ по индексу происходит за O(1)

### HashTable и HashMap

HashMap используется для хранения пары «ключ-значение».

Если конструктору не передать никаких значений, то будет создан пустой словарь с
емкостью в 16 элементов и коэффициентом заполнения 0.75

Если коэффициент заполнения достигает максимума, то число bucket'ов
увеличивается в два раза

Класс HashMap<K, V> реализует следующие интерфейсы:
Map<K, V>, Serializable, Cloneable.

Объявляется следующем образом:

```java
HashMap<String, Integer> map = new HashMap<String, Integer>();
```

**Разница между HashTable и HashMap**

Хэш-Таблица не может хранить null, в отличии от Хэш-Мапы

В Хэш-Таблице все методы синхронизированы, что сказывается на скорости работы

Хэш-Таблица не рекомендуется к использования, так как считается устаревшей,
Хэш-Мапа предпочтительнее

P.S. Если требуется выбрать структуру, которая справится с параллельными
вычислениями, то есть ConcurrentHashMap

## Дерево

В Java есть TreeMap\<K, V> и TreeSet\<E>, которые описывают словари, где
ключи хранятся в отсортированном порядке. TreeSet инкапсулирует в себе TreeMap,
который в свою очередь использует сбалансированное бинарное красно-черное дерево
для хранения элементов.

Класс TreeSet<E> реализует следующие интерфейсы:
Iterable\<E>, Collection\<E>, Set\<E>, SortedSet\<E>, NavigableSet\<E>,
Serializable, Cloneable.

Класс TreeMap\<K, V> реализует следующие интерфейсы:
Map\<K,V>, SortedMap\<K, V>, NavigableMap\<K, V>, Serializable, Cloneable.

Объявляется следующем образом:

```java
TreeSet<Integer> set = new TreeSet<Integer>();
TreeMap<String, Integer> map = new TreeMap<String, Integer>();
```

В чем разница между HashSet и TreeSet
Под капотом у TreeSet лежит красно-чеÒ§Lрное дерево и упорядочивание элементов
происходит именно по принципу красно-черных деревьев. HashSet не поддерживает
упорядочивание

Сложность TreeSet - O(log(n)), HashSet - O(1) (речь идет о методах add(),
contains(), remove())

### Red-Black Tree

Красно-черное дерево – самобалансирующаяся версия двоичного поиска.
Обеспечивает логарифмическую сложность О(log(n)) операций добавления, удаления и
поиска.

Верхний элемент – это корень дерева (чёрный цвет).
Все остальные элементы распределяются налево или направо в зависимости от
значения хешей:

- Все левые потомки должны быть меньше корневого узла (или равны ему
- Все правые потомки должны быть больше
- Оба потомка каждого красного узла — черные
- Все листья дерева (нижние элементы не содержащие данных) – черные
- Любой простой путь от узла-предка до листового узла-потомка содержит
  одинаковое число чёрных узлов.
  Простой путь – это тот в котором каждый узел входит ровно по одному разу.

____

## Граф

[Источник](https://javarush.com/groups/posts/3022-chto-sprashivajut-na-sobesedovanii-obzor-algoritmov-chastjh-2)

Граф — одна из самых гибких и универсальных структур в программировании.

Граф G обычно задается при помощи пары множеств G = (V, R), где:

- V — множество вершин;
- R — множество линий, соединяющих пары вершин.

Обычные соединяющие линии называют ребрами:

![graph0.png](/img/algos/graph/graph0.png)

Линии со стрелками — дугами:

![graph0.png](/img/algos/graph/graph1.png)

Как правило, граф представляют с помощью схемы, на которой некоторые вершины
соединены ребрами (дугами).
Графы, связанные между собой дугами, непосредственно указывающими направление,
называют направленными. Если же графы соединены ребрами, то есть без указания
направления возможного движения, они становятся ненаправленными. Это значит, что
перемещения по ним возможны в обоих направлениях: как от вершины А к В, так и от
В к А.

Связный граф — граф, в котором от каждой вершины к любой другой вершине ведёт
хотя бы один путь:

![graph1.png](/img/algos/graph/graph1.png)

Если это не так, граф становится несвязным:

![graph2.png](/img/algos/graph/graph2.png)

Также ребрам (дугам) могут присваиваться веса — числа, представляющие физическое
расстояние между двумя вершинами (или относительное время перехода между двумя
вершинами). Такие графы и называют взвешенными:

![graph3.png](/img/algos/graph/graph3.png)

### Алгоритмы поиска пути (глубина, ширина)

Одна из основных операций, которые выполняются с графами, — это определение всех
вершин, достижимых от заданной вершины. Представьте, что вы пытаетесь
определить, как можно добраться от одного города в другой с возможными
пересадками. К одним городам можно добраться напрямую, к другим нужно ехать в
обход через другие города. Существует много других ситуаций, в которых может
понадобиться нахождение всех вершин, к которым можно найти путь от заданной
вершины.
Так вот, существует два основных способа обхода графов: обход в глубину и обход
в ширину, которые мы и рассмотрим. Оба способа обеспечат перебор всех связных
вершин.  
Для дальнейшего рассмотрения алгоритмов в глубину и ширину возьмем следующий
граф:

![graph4.png](/img/algos/graph/graph4.png)

### Обход в глубину

Это один из наиболее распространенных методов обхода графа. Данная стратегия
поиска в глубину состоит в том, чтобы идти «вглубь» графа насколько это
возможно, а достигнув тупика, возвращаться к ближайшей вершине, у которой есть
смежные ранее не посещенные вершины.
Этот алгоритм хранит в стеке информацию о том, куда следует вернуться при
достижении “тупика”.

Правила обхода в глубину:

1. Посетить смежную, ранее не посещенную вершину, пометить её и занести в стек.
2. Перейти на данную вершину.
3. Повторить этап 1.
4. Если выполнение пункта 1 невозможно, вернуться к предыдущей вершины и
   попытаться повторить правило 1. Если это невозможно — вернуться к вершине до
   нее, и так далее, пока не найдем вершину, с которой можно продолжить обход.
5. Продолжать до тех пор, пока все вершины не окажутся в стеке.

