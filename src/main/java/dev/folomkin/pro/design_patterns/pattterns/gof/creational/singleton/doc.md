# Одиночка(Singleton)

- это порождающий паттерн, который гарантирует существование только одного
  объекта определённого класса, а также позволяет достучаться до этого объекта
  из любого места программы.

Одиночка имеет такие же преимущества и недостатки, что и глобальные переменные.
Его невероятно удобно использовать, но он нарушает модульность вашего кода.

Вы не сможете просто взять и использовать класс, зависящий от одиночки в другой
программе. Для этого придётся эмулировать присутствие одиночки и там. Чаще всего
эта проблема проявляется при написании юнит-тестов.

**Применимость**: Многие программисты считают Одиночку антипаттерном, поэтому
его всё реже и реже можно встретить в Java-коде.

Тем не менее одиночке нашлось применение в стандартных библиотеках Java:

java.lang.Runtime#getRuntime()

java.awt.Desktop#getDesktop()

java.lang.System#getSecurityManager()

**Признаки применения паттерна:** Одиночку можно определить по статическому
создающему методу, который возвращает один и тот же объект.

## Структура

![singleton_structure.png](/img/design_pattern/design_patterns/singleton_structure.png)

1. Одиночка определяет статический метод getInstance,
который возвращает единственный экземпляр своего
класса.<br>
Конструктор одиночки должен быть скрыт от клиентов.
Вызов метода getInstance должен стать единственным
способом получить объект этого класса.

## Пример кода

Паттерн "Синглтон" (Singleton) гарантирует, что класс имеет только один
экземпляр и предоставляет глобальную точку доступа к этому экземпляру.
Существует несколько способов реализации синглтона в Java. Один из самых
распространенных и безопасных способов — это использование ленивой инициализации
с синхронизацией.

Вот пример реализации паттерна "Синглтон" с использованием ленивой инициализации
и синхронизации:

### Пример 1

```java
public class Singleton {
    // Приватная статическая переменная для хранения единственного экземпляра
    private static Singleton instance;

    // Приватный конструктор, чтобы предотвратить создание экземпляров извне
    private Singleton() {
        // Инициализация
    }

    // Публичный статический метод для получения единственного экземпляра
    public static synchronized Singleton getInstance() {
        // Проверяем, существует ли уже экземпляр
        if (instance == null) {
            instance = new Singleton(); // Создаем новый экземпляр, если он не существует
        }
        return instance; // Возвращаем единственный экземпляр
    }

    // Пример метода, который можно вызвать на синглтоне
    public void someMethod() {
        System.out.println("Метод синглтона вызван.");
    }
}

// Пример использования синглтона
public class SingletonExample {
    public static void main(String[] args) {
        // Получаем единственный экземпляр синглтона
        Singleton singleton = Singleton.getInstance();
        singleton.someMethod(); // Вывод: Метод синглтона вызван.
    }
}
```

Объяснение кода:

1. Приватная статическая переменная: private static Singleton instance; — это
   переменная, которая будет хранить единственный экземпляр класса Singleton.
2. Приватный конструктор: private Singleton() — конструктор объявлен как
   приватный, чтобы предотвратить создание экземпляров класса извне.
3. Публичный статический метод: public static synchronized Singleton
   getInstance() — этот метод предоставляет глобальную точку доступа к
   экземпляру. Он синхронизирован, чтобы предотвратить создание нескольких
   экземпляров в многопоточной среде.
4. Ленивая инициализация: Экземпляр создается только при первом вызове метода
   getInstance(), что позволяет экономить ресурсы, если экземпляр не нужен.
5. Пример использования: В классе SingletonExample мы получаем экземпляр
   синглтона и вызываем метод someMethod().

Альтернативные подходы:

1. Инициализация при загрузке класса: Можно использовать статический блок
   инициализации, чтобы создать экземпляр при загрузке класса. Это гарантирует,
   что
   экземпляр будет создан только один раз, но не позволяет отложить создание
   экземпляра.

2. Использование enum: В Java можно использовать перечисления для реализации
   синглтона, что автоматически обеспечивает потокобезопасность и защиту от
   сериализации.

Вот пример с использованием enum:

```java
public enum Singleton {
    INSTANCE;

    public void someMethod() {
        System.out.println("Метод синглтона вызван.");
    }
}

// Пример использования
public class SingletonExample {
    public static void main(String[] args) {
        Singleton singleton = Singleton.INSTANCE;
        singleton.someMethod(); // Вывод: Метод синглтона вызван.
    }
}
```

Этот подход является самым простым и безопасным способом реализации синглтона в
Java.

### Пример 2

```java
// -> Одиночка (один поток)

// ->  Singleton.java: Одиночка


/**
 *  Класс одиночки определяет статический метод `getInstance`, 
 *  который позволяет клиентам повторно использовать одно и то же подключение
 *  к базе данных по всей программ
 */

public final class Singleton {
    /**
     *  Поле для хранения объекта-одиночки должно быть объявлено статичным.
     */
    private static Singleton instance;
    public String value;

    /**
     * Конструктор одиночки всегда должен оставаться приватным, 
     * чтобы клиенты не могли самостоятельно создавать экземпляры этого класса 
     * через оператор `new`.
     */
    private Singleton(String value) {
        // Этот код эмулирует медленную инициализацию.
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        this.value = value;
    }

    /**
     * Основной статический метод одиночки служит альтернативой
     * конструктору и является точкой доступа к экземпляру этого класса.
     */
    public static Singleton getInstance(String value) {

        /**
         * На всякий случай ещё раз проверим, не был ли объект создан другим потоком, 
         * пока текущий ждал освобождения блокировки.
         */

        if (instance == null) {
            instance = new Singleton(value);
        }
        return instance;
    }
}

// -> DemoSingleThread.java: Клиентский код

package refactoring_guru.singleton.example.non_thread_safe;

public class DemoSingleThread {
    public static void main(String[] args) {
        System.out.println("Если вы видите то же самое значение, то синглтон был использован повторно. (yay!)" + "\n" +
                "Если вы видите разные значения, значит было создано 2 синглтона. (booo!!)" + "\n\n" +
                "RESULT:" + "\n");
        Singleton singleton = Singleton.getInstance("FOO");
        Singleton anotherSingleton = Singleton.getInstance("BAR");
        System.out.println(singleton.value);
        System.out.println(anotherSingleton.value);
    }
}

```


## Шаги реализации

1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
2. Объявите статический создающий метод, который будет использоваться для получения одиночки.
3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
4. Сделайте конструктор класса приватным.
5. В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.