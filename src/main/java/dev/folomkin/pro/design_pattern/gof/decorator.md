# Decorator (Декоратор)

Декоратор — это структурный паттерн проектирования, который позволяет
динамически добавлять объектам новую функциональность, оборачивая их в полезные
«обёртки».

**Паттерн Decorator (Декоратор)** — это структурный паттерн проектирования,
который позволяет динамически добавлять новые обязанности или поведение объекту,
оборачивая его в другой объект. Он предоставляет гибкую альтернативу
наследованию для расширения функциональности, сохраняя интерфейс исходного
объекта.

### **Описание паттерна**

**Цель**:

- Динамически добавлять новые обязанности объекту без изменения его кода.
- Обеспечить гибкое расширение функциональности через композицию вместо
  наследования.

**Когда использовать**:

- Когда нужно добавлять функциональность объектам на лету (например, добавление
  логирования, кэширования, шифрования).
- Когда наследование нецелесообразно из-за большого числа комбинаций поведения.
- Когда требуется сохранить интерфейс исходного объекта, но расширить его
  поведение.
- Для реализации принципа единственной ответственности (SRP), разделяя основную
  логику и дополнительные функции.

**Примеры использования**:

- Потоки ввода-вывода в Java (`BufferedInputStream`, `DataInputStream`).
- Добавление функциональности в UI-компоненты (например, прокрутка или рамка в
  Swing).
- Декорирование сервисов (логирование, проверка прав доступа).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/decorator_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Компонент задаёт общий интерфейс обёрток и оборачиваемых объектов.
2. Конкретный компонент определяет класс оборачиваемых объектов. Он содержит
   какое-то базовое поведение, которое потом изменяют декораторы.
3. Базовый декоратор хранит ссылку на вложенный объект-компонент. Им может быть
   как конкретный компонент, так и один из конкретных декораторов. Базовый
   декоратор делегирует все свои операции вложенному объекту. Дополнительное
   поведение будет жить в конкретных декораторах.
4. Конкретные декораторы — это различные вариации декораторов, которые содержат
   добавочное поведение. Оно выполняется до или после вызова аналогичного
   поведения обёрнутого объекта.
5. Клиент может оборачивать простые компоненты и декораторы в другие декораторы,
   работая со всеми объектами через общий интерфейс компонентов.

### **Реализация в Java**

Пример: декорирование напитков в кофейне, где к базовому напитку (например,
кофе) можно добавлять ингредиенты (молоко, сироп).

```java
// Компонент
interface Beverage {
    String getDescription();

    double getCost();
}

// Конкретный компонент
class Espresso implements Beverage {
    @Override
    public String getDescription() {
        return "Espresso";
    }

    @Override
    public double getCost() {
        return 2.0;
    }
}

// Абстрактный декоратор
abstract class BeverageDecorator implements Beverage {
    protected Beverage beverage;

    public BeverageDecorator(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription();
    }

    @Override
    public double getCost() {
        return beverage.getCost();
    }
}

// Конкретные декораторы
class Milk extends BeverageDecorator {
    public Milk(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Milk";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.5;
    }
}

class Syrup extends BeverageDecorator {
    public Syrup(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Syrup";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.7;
    }
}

// Клиентский код
public class DecoratorExample {
    public static void main(String[] args) {
        Beverage espresso = new Espresso();
        System.out.println(espresso.getDescription() + " $" + espresso.getCost());
        // Вывод: Espresso $2.0

        Beverage latte = new Milk(espresso);
        System.out.println(latte.getDescription() + " $" + latte.getCost());
        // Вывод: Espresso, Milk $2.5

        Beverage fancyLatte = new Syrup(new Milk(espresso));
        System.out.println(fancyLatte.getDescription() + " $" + fancyLatte.getCost());
        // Вывод: Espresso, Milk, Syrup $3.2
    }
}
```

### **Как это работает**

1. Клиент создаёт базовый объект (`Espresso`) и передаёт его в декоратор
   (`Milk`, `Syrup`).
2. Каждый декоратор реализует интерфейс `Beverage`, вызывая методы исходного
   объекта и добавляя своё поведение (например, увеличивая стоимость или изменяя
   описание).
3. Декораторы можно комбинировать в цепочку, добавляя несколько уровней
   функциональности (`Syrup` оборачивает `Milk`, который оборачивает
   `Espresso`).
4. Клиент работает с декорированным объектом через тот же интерфейс `Beverage`.

### **Реальное использование в Java**

1. **Java I/O**:
   Потоки ввода-вывода в Java — классический пример паттерна Decorator:
   ```java
   import java.io.*;

   public class IOExample {
       public static void main(String[] args) throws IOException {
           FileInputStream fis = new FileInputStream("test.txt");
           BufferedInputStream bis = new BufferedInputStream(fis); // Декоратор
           int data = bis.read();
           bis.close();
       }
   }
   ```
    - `BufferedInputStream` декорирует `FileInputStream`, добавляя буферизацию.
    - `DataInputStream` может добавить методы для чтения примитивных типов.

2. **Swing UI**:
   В Swing декораторы используются для добавления функциональности компонентам,
   например, рамок или полос прокрутки:
   ```java
   import javax.swing.*;

   JScrollPane scrollPane = new JScrollPane(new JTextArea()); // Декоратор
   ```

3. **Spring Framework**:
   В Spring декораторы часто используются для добавления функциональности,
   например, кэширования или логирования:
   ```java
   @Cacheable("results")
   public Result computeExpensiveResult() { /* Логика */ }
   ```
   Здесь `@Cacheable` действует как декоратор, добавляя кэширование к методу.

### **Преимущества**

- **Гибкость**: Можно комбинировать декораторы в любом порядке и количестве.
- **Соответствие принципу Open/Closed**: Функциональность расширяется без
  изменения исходного класса.
- **Альтернатива наследованию**: Избегает создания множества подклассов для
  комбинаций поведения.
- **Переиспользуемость**: Декораторы можно применять к разным объектам одного
  интерфейса.

### **Недостатки**

- **Увеличение числа классов**: Каждый декоратор — это отдельный класс.
- **Сложность отладки**: Цепочка декораторов может затруднить отслеживание
  выполнения.
- **Не всегда интуитивно**: Многослойное декорирование может быть трудно понять
  новичкам.
- **Ограничение интерфейса**: Декораторы должны строго следовать интерфейсу
  компонента, что ограничивает добавление новых методов.

### **Отличие от других паттернов**

- **Decorator vs Adapter**:
    - **Decorator** добавляет поведение, сохраняя тот же интерфейс.
    - **Adapter** преобразует интерфейс одного класса в другой.
- **Decorator vs Proxy**:
    - **Decorator** фокусируется на добавлении функциональности.
    - **Proxy** управляет доступом или жизненным циклом объекта (например,
      ленивая инициализация).
- **Decorator vs Composite**:
    - **Decorator** оборачивает один объект, добавляя поведение.
    - **Composite** управляет группой объектов как единым целым (древовидная
      структура).

### **Проблемы и антипаттерны**

1. **Слишком длинные цепочки декораторов**: Многослойное декорирование может
   снизить читаемость и производительность.
    - **Решение**: Ограничивайте количество декораторов или используйте другие
      паттерны (например, Strategy) для сложных случаев.
2. **Нарушение инкапсуляции**: Если декоратор изменяет внутреннее состояние
   объекта, это может привести к ошибкам.
    - **Решение**: Декораторы должны быть прозрачными и работать только с
      публичным интерфейсом.
3. **Сложность тестирования**: Тестирование цепочек декораторов может быть
   затруднительным.
    - **Решение**: Используйте мок-объекты (например, с Mockito) для изоляции
      компонентов.

### **Современные альтернативы в Java**

- **Лямбда-выражения**:
  В Java 8+ декораторы иногда заменяются функциональными композициями:
  ```java
  Function<Beverage, Beverage> addMilk = bev -> new Beverage() {
      public String getDescription() { return bev.getDescription() + ", Milk"; }
      public double getCost() { return bev.getCost() + 0.5; }
  };

  Beverage espresso = new Espresso();
  Beverage latte = addMilk.apply(espresso);
  ```
- **Spring AOP**:
  В Spring аспекты могут действовать как декораторы, добавляя сквозную
  функциональность (логирование, транзакции):
  ```java
  @Transactional
  public void saveOrder(Order order) { /* Логика */ }
  ```
- **Аннотации**:
  Аннотации, такие как `@Log` в SLF4J или `@Cacheable` в Spring, часто заменяют
  явные декораторы для простых случаев.

### **Итог**

Паттерн Decorator — это мощный инструмент для динамического расширения
функциональности объектов, особенно в системах, где требуется множество
комбинаций поведения. В Java он широко используется в стандартной библиотеке (
I/O, Swing) и фреймворках (Spring). Его гибкость делает его идеальным для
случаев, где наследование неудобно, но он может усложнить код при чрезмерном
использовании. В современных Java-приложениях декораторы часто упрощаются с
помощью лямбда-выражений, AOP или аннотаций.


