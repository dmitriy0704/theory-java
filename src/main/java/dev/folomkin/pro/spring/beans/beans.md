# SPRING

## IoC и DI

**Inversion of Control (IoC)** и **Dependency Injection (DI)** — это
фундаментальные концепции фреймворка Spring в Java, которые связаны между собой
и лежат в основе его архитектуры. Они помогают создавать гибкие, модульные и
легко тестируемые приложения. Давайте разберём их кратко и понятно.

### **Inversion of Control (IoC)**

- **Определение**: IoC (Инверсия управления) — это принцип проектирования, при
  котором управление жизненным циклом объектов и их зависимостями передаётся от
  самого объекта к внешнему контейнеру (в Spring — это **ApplicationContext**).
- **Как работает**:
    - Вместо того чтобы объект сам создавал свои зависимости или управлял своим
      жизненным циклом, контейнер Spring (IoC-контейнер) берёт на себя
      ответственность за:
        - Создание объектов (бинов).
        - Управление их конфигурацией и жизненным циклом.
        - Внедрение зависимостей.
    - Объект "пассивно" получает всё необходимое от контейнера, а не "активно"
      создаёт зависимости.
- **Пример аналогии**:
    - Без IoC: Вы сами идёте в магазин, покупаете ингредиенты и готовите еду.
    - С IoC: Вы заказываете еду, а ресторан (контейнер) готовит и доставляет её
      вам.
- **В Spring**:
    - IoC реализуется через **ApplicationContext** или **BeanFactory**, которые
      управляют созданием, конфигурацией и связыванием бинов.
    - Вы описываете бины и их зависимости (через XML, Java-конфигурации или
      аннотации), а контейнер решает, когда и как их создавать.

### **Dependency Injection (DI)**

- **Определение**: DI (Внедрение зависимостей) — это конкретная реализация IoC,
  при которой зависимости объекта (другие объекты или ресурсы) предоставляются
  ему извне, а не создаются внутри самого объекта.
- **Как работает**:
    - Вместо того чтобы объект создавал свои зависимости (например, через
      `new`), контейнер Spring "внедряет" их в объект.
    - Это делает код более модульным, тестируемым и независимым от конкретных
      реализаций.
- **Типы DI в Spring**:
    1. **Конструкторное внедрение**:
        - Зависимости передаются через конструктор.
       ```java
       @Component
       public class UserService {
           private final DatabaseRepository repository;
  
           @Autowired
           public UserService(DatabaseRepository repository) {
               this.repository = repository;
           }
       }
       ```
    2. **Сеттерное внедрение**:
        - Зависимости устанавливаются через сеттеры.
       ```java
       @Component
       public class UserService {
           private DatabaseRepository repository;
  
           @Autowired
           public void setRepository(DatabaseRepository repository) {
               this.repository = repository;
           }
       }
       ```
    3. **Полевое внедрение** (реже используется):
        - Зависимости внедряются напрямую в поля через аннотацию `@Autowired`.
       ```java
       @Component
       public class UserService {
           @Autowired
           private DatabaseRepository repository;
       }
       ```
- **Преимущества DI**:
    - Упрощает тестирование (можно подменять зависимости моками).
    - Снижает связанность (loose coupling) между классами.
    - Позволяет легко заменять реализации зависимостей.

### **Связь IoC и DI**:

- **IoC** — это общий принцип: управление объектами передаётся контейнеру.
- **DI** — это способ реализации IoC, когда контейнер "внедряет" зависимости в
  объекты.
- В Spring IoC-контейнер (ApplicationContext) использует DI для предоставления
  бинам их зависимостей, что позволяет избежать жёсткой привязки классов друг к
  другу.

### **Пример в Spring**:

```java
// Конфигурация через Java
@Configuration
public class AppConfig {
    @Bean
    public DatabaseRepository databaseRepository() {
        return new DatabaseRepository();
    }

    @Bean
    public UserService userService(DatabaseRepository repository) {
        return new UserService(repository);
    }
}

// Классы
public class DatabaseRepository {
    public void save() {
        System.out.println("Сохранение в базе данных");
    }
}

public class UserService {
    private final DatabaseRepository repository;

    public UserService(DatabaseRepository repository) {
        this.repository = repository;
    }

    public void performAction() {
        repository.save();
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService service = context.getBean(UserService.class);
        service.performAction(); // Выведет: Сохранение в базе данных
    }
}
```

### **Ключевые моменты**:

- **IoC**:
    - Передаёт управление созданием и жизненным циклом объектов контейнеру.
    - Делает приложение более декларативным (вы описываете, "что нужно", а не "
      как это сделать").
- **DI**:
    - Реализует IoC, предоставляя зависимости объектам.
    - В Spring поддерживается через аннотации (`@Autowired`, `@Inject`), XML или
      Java-конфигурации.
- **Преимущества**:
    - Модульность: классы не зависят от конкретных реализаций.
    - Тестируемость: легко подменять зависимости.
    - Гибкость: можно менять конфигурацию без изменения кода.

### **Связь с жизненным циклом бинов**:

- IoC-контейнер управляет полным жизненным циклом бинов (создание,
  инициализация, использование, уничтожение).
- DI обеспечивает внедрение зависимостей на этапе создания или конфигурирования
  бина.


================================================================================
--------------------------------------------------------------------------------

## Жизненный цикл бинов

1. **Создание экземпляра (Instantiation)**: Spring контейнер создаёт объект бина
   с помощью конструктора или фабричного метода.

2. **Заполнение свойств (Populate Properties)**: Контейнер внедряет зависимости,
   указанные в конфигурации (через XML, аннотации или Java-конфигурацию).

3. **Инициализация (Initialization)**:
    - Вызываются методы, помеченные аннотацией `@PostConstruct`, или методы,
      указанные в `init-method`.
    - Реализуются интерфейсы, такие как `InitializingBean` (метод
      `afterPropertiesSet`).

4. **Использование (Usage)**: Бин готов к использованию в приложении.

5. **Уничтожение (Destruction)**:
    - При завершении работы контейнера вызываются методы, помеченные
      `@PreDestroy`, или методы, указанные в `destroy-method`.
    - Реализуются интерфейсы, такие как `DisposableBean` (метод `destroy`).

### Дополнительные аспекты:

- **Bean Post Processors**: На этапах до и после инициализации могут быть
  вызваны методы `BeanPostProcessor` для дополнительной обработки.
- **Скоупы (Scopes)**: Жизненный цикл зависит от области видимости бина (
  `singleton`, `prototype`, `request`, и т.д.). Например, `prototype` бины не
  проходят этап уничтожения.
- **Aware-интерфейсы**: Если бин реализует интерфейсы, такие как
  `ApplicationContextAware` или `BeanNameAware`, Spring вызывает соответствующие
  методы для передачи контекста или имени бина.

### Пример:

```java

@Component
public class ExampleBean {
    @PostConstruct
    public void init() {
        System.out.println("Бин инициализирован!");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Бин уничтожен!");
    }
}
```


================================================================================
--------------------------------------------------------------------------------


## Scope бинов

В Java Spring **scope** (область видимости) бина определяет, как и когда Spring
контейнер создаёт, управляет и уничтожает экземпляры бина. Область видимости
влияет на жизненный цикл и поведение бина в приложении. Spring поддерживает
несколько стандартных scope, а также позволяет определять собственные. Ниже
описаны основные scope с их особенностями.

### Основные scope бинов в Spring:

1. **Singleton** (Одиночка, по умолчанию):
    - **Описание**: Создаётся **один экземпляр** бина на весь контейнер. Все
      запросы к бину возвращают один и тот же объект.
    - **Особенности**:
        - Подходит для stateless-объектов (например, сервисы, репозитории).
        - Жизненный цикл полностью управляется контейнером, включая уничтожение
          при закрытии контекста.
    - **Пример использования**:
      ```java
      @Component
      @Scope("singleton") // Необязательно, так как это значение по умолчанию
      public class SingletonBean {
          // Логика
      }
      ```

2. **Prototype**:
    - **Описание**: Создаётся **новый экземпляр** бина при каждом запросе к
      нему.
    - **Особенности**:
        - Подходит для stateful-объектов, где каждый клиент должен работать с
          уникальным экземпляром.
        - Spring не управляет полным жизненным циклом: методы уничтожения (
          `@PreDestroy`, `destroy-method`) **не вызываются**.
    - **Пример использования**:
      ```java
      @Component
      @Scope("prototype")
      public class PrototypeBean {
          // Логика
      }
      ```

3. **Request**:
    - **Описание**: Создаётся **новый экземпляр** бина для каждого
      HTTP-запроса (доступно только в веб-приложениях с `ApplicationContext`).
    - **Особенности**:
        - Бин живёт в течение обработки одного HTTP-запроса.
        - Используется для хранения данных, специфичных для запроса (например,
          данные формы).
        - Требуется зависимость `spring-web`.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestBean {
          // Логика
      }
      ```

4. **Session**:
    - **Описание**: Создаётся **один экземпляр** бина на всю HTTP-сессию
      пользователя.
    - **Особенности**:
        - Бин живёт, пока активна сессия пользователя (например, для хранения
          пользовательских данных, таких как корзина покупок).
        - Требуется `spring-web`.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class SessionBean {
          // Логика
      }
      ```

5. **Application**:
    - **Описание**: Создаётся **один экземпляр** бина на весь жизненный цикл
      `ServletContext` (веб-приложения).
    - **Особенности**:
        - Бин общий для всех пользователей приложения.
        - Используется редко, для глобальных ресурсов приложения.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class ApplicationBean {
          // Логика
      }
      ```

6. **WebSocket**:
    - **Описание**: Создаётся **один экземпляр** бина на всю сессию
      WebSocket-соединения.
    - **Особенности**:
        - Используется для работы с WebSocket в Spring.
        - Доступно в приложениях, использующих WebSocket (требуется
          `spring-websocket`).
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class WebSocketBean {
          // Логика
      }
      ```

### Кастомные scope:

- Spring позволяет создавать **пользовательские scope** путём реализации
  интерфейса `org.springframework.beans.factory.config.Scope`.
- Пример: scope для пула потоков или специфичных бизнес-логики.


================================================================================
--------------------------------------------------------------------------------

## Проксирование (proxyMode):

- Для scope, таких как `request`, `session`, или `websocket`, часто используется
  `proxyMode` (например, `ScopedProxyMode.TARGET_CLASS` или
  `ScopedProxyMode.INTERFACES`), чтобы бин мог быть внедрён в singleton-бины.
  Это создаёт прокси, который делегирует вызовы к нужному экземпляру в
  зависимости от контекста (например, текущего HTTP-запроса).

### Как задать scope:

1. **Через аннотации**:
   ```java
   @Component
   @Scope("prototype")
   public class MyBean {
       // Логика
   }
   ```
2. **Через Java-конфигурацию**:
   ```java
   @Configuration
   public class AppConfig {
       @Bean
       @Scope("prototype")
       public MyBean myBean() {
           return new MyBean();
       }
   }
   ```
3. **Через XML**:
   ```xml
   <bean id="myBean" class="com.example.MyBean" scope="prototype"/>
   ```

### Важные замечания:

- **Singleton** — наиболее распространённый scope, так как минимизирует overhead
  на создание объектов.
- **Prototype** может привести к утечкам памяти, если экземпляры не очищаются
  вручную.
- Для веб-ориентированных scope (`request`, `session`, `application`) требуется
  включение поддержки через `spring-web` и настройка `ApplicationContext`.


================================================================================
--------------------------------------------------------------------------------

## StateLess и StateFull объекты

В контексте программирования, в том числе Java и Spring, термины **stateless** (
без состояния) и **stateful** (состояние) описывают, как объекты хранят и
управляют данными между вызовами. Эти понятия важны для понимания поведения
бинов в Spring, особенно в контексте их scope (области видимости). Вот краткое и
ясное объяснение:

### **Stateless-объекты** (без состояния):

- **Определение**: Объект, который **не сохраняет данные** (состояние) между
  вызовами методов. Каждый вызов метода работает с входными параметрами, не
  завися от предыдущих операций.
- **Характеристики**:
    - Не хранит информацию о предыдущих вызовах (нет изменяемых полей, связанных
      с состоянием).
    - Потокобезопасен (thread-safe), так как не имеет общего изменяемого
      состояния.
    - Подходит для многократного использования одним экземпляром (например, в
      scope `singleton` в Spring).
- **Примеры**:
    - Сервисы в Spring, выполняющие операции без хранения данных (например,
      сервис для вычисления суммы двух чисел).
    - Утилитные классы с чистыми функциями.
  ```java
  @Component
  public class StatelessService {
      public int calculateSum(int a, int b) {
          return a + b; // Не сохраняет состояние
      }
  }
  ```
- **Когда использовать**: Для операций, которые не зависят от истории вызовов. В
  Spring такие объекты обычно делают `singleton`, чтобы минимизировать создание
  новых экземпляров.

### **Stateful-объекты** (с состоянием):

- **Определение**: Объект, который **сохраняет данные** (состояние) между
  вызовами методов. Состояние обычно хранится в полях объекта.
- **Характеристики**:
    - Хранит информацию, которая влияет на поведение при последующих вызовах (
      например, счётчик, пользовательские данные).
    - Не является потокобезопасным по умолчанию, так как несколько потоков могут
      изменять общее состояние.
    - В Spring часто используется с scope `prototype`, `request` или `session`,
      чтобы каждый клиент работал с уникальным экземпляром.
- **Примеры**:
    - Объект, представляющий корзину покупок пользователя, где добавленные
      товары сохраняются.
    - Объект, хранящий временные данные сессии.
  ```java
  @Component
  @Scope("prototype")
  public class StatefulBean {
      private int counter = 0; // Состояние

      public void increment() {
          counter++;
      }

      public int getCounter() {
          return counter;
      }
  }
  ```
- **Когда использовать**: Когда нужно сохранять данные между вызовами, например,
  для отслеживания состояния конкретного пользователя или процесса.

### **Ключевые различия**:

| Характеристика     | Stateless             | Stateful                                 |
|--------------------|-----------------------|------------------------------------------|
| Хранение состояния | Не хранит             | Хранит                                   |
| Потокобезопасность | Потокобезопасен       | Обычно не потокобезопасен                |
| Spring Scope       | Обычно `singleton`    | Обычно `prototype`, `request`, `session` |
| Пример             | Сервис для вычислений | Корзина покупок, сессия                  |

### **Связь с Spring**:

- **Singleton scope**: Подходит для **stateless**-объектов, так как один
  экземпляр используется всеми клиентами, и нет риска конфликтов из-за изменения
  состояния.
- **Prototype, request, session scope**: Используются для **stateful**-объектов,
  чтобы каждый клиент или запрос имел свой экземпляр, избегая проблем с общим
  состоянием.

### **Практические советы**:

- Предпочитайте **stateless**-объекты для повышения производительности и
  упрощения масштабирования.
- Используйте **stateful**-объекты только там, где состояние необходимо (
  например, для пользовательских данных).
- В Spring для stateful-бинов в веб-приложениях часто применяют scope `request`
  или `session` с `proxyMode` для корректного внедрения в singleton-бины.


================================================================================
--------------------------------------------------------------------------------


## Отличие области видимости Singleton от Application

В Java Spring **Singleton** и **Application** — это два разных scope (области
видимости) бинов, которые определяют, как и когда создаются и управляются
экземпляры бинов в контейнере Spring. Хотя на первый взгляд они могут казаться
похожими, между ними есть ключевые различия. Давайте разберём их подробно.

### **1. Singleton Scope**

- **Описание**: Это область видимости **по умолчанию** в Spring. В рамках одного
  **ApplicationContext** создаётся **один экземпляр** бина, который используется
  для всех запросов к этому бину.
- **Характеристики**:
    - Один экземпляр на **контейнер** (ApplicationContext).
    - Создаётся при инициализации контейнера (если не используется ленивая
      инициализация — `@Lazy`).
    - Живёт весь жизненный цикл контейнера и уничтожается при его закрытии.
    - Подходит для **stateless**-объектов (без состояния), таких как сервисы,
      репозитории, утилитные классы.
- **Контекст**: Привязан к **ApplicationContext**. Если в приложении несколько
  контекстов (например, родительский и дочерний), каждый контекст будет иметь
  свой собственный экземпляр singleton-бинов.
- **Пример использования**:
  ```java
  @Component
  @Scope("singleton") // Необязательно, так как это значение по умолчанию
  public class SingletonBean {
      public void doSomething() {
          System.out.println("Я singleton-бин!");
      }
  }
  ```

### **2. Application Scope**

- **Описание**: Создаётся **один экземпляр** бина на весь **ServletContext** (
  жизненный цикл веб-приложения). Этот scope доступен только в веб-приложениях
  Spring (требуется зависимость `spring-web`).
- **Характеристики**:
    - Один экземпляр на **веб-приложение** (ServletContext), а не на
      ApplicationContext.
    - Живёт весь жизненный цикл веб-приложения, независимо от того, сколько
      ApplicationContext создано в этом приложении.
    - Используется для глобальных ресурсов, которые должны быть общими для всех
      пользователей и всех контекстов в веб-приложении (например, глобальные
      конфигурации или кэши).
    - Обычно требует проксирования (`proxyMode = ScopedProxyMode.TARGET_CLASS`)
      для внедрения в бины с другими scope (например, singleton).
- **Контекст**: Привязан к **ServletContext**, который охватывает всё
  веб-приложение. Даже если в приложении несколько ApplicationContext (например,
  в DispatcherServlet и ContextLoaderListener), бин в application scope будет
  общим для всех.
- **Пример использования**:
  ```java
  @Component
  @Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
  public class ApplicationBean {
      public void doSomething() {
          System.out.println("Я application-бин!");
      }
  }
  ```

### **Ключевые отличия**:

| Характеристика             | Singleton Scope                           | Application Scope                           |
|----------------------------|-------------------------------------------|---------------------------------------------|
| **Привязка**               | К ApplicationContext                      | К ServletContext                            |
| **Количество экземпляров** | Один на каждый ApplicationContext         | Один на всё веб-приложение                  |
| **Контекст использования** | Любой Spring-приложение (веб или не веб)  | Только веб-приложения                       |
| **Жизненный цикл**         | Живёт, пока существует ApplicationContext | Живёт, пока существует ServletContext       |
| **Типичное применение**    | Stateless-бины (сервисы, репозитории)     | Глобальные ресурсы веб-приложения           |
| **Проксирование**          | Не требуется                              | Часто требуется для внедрения в другие бины |

### **Пример сценария**:

- **Singleton**: Если у вас есть сервис `UserService`, который выполняет
  операции с пользователями (без хранения состояния), он обычно будет в scope
  `singleton`. Если приложение использует несколько ApplicationContext (
  например, в сложной конфигурации с родительским и дочерним контекстами),
  каждый контекст создаст свой экземпляр `UserService`.
- **Application**: Если у вас есть бин `GlobalConfig`, который хранит глобальные
  настройки приложения (например, параметры подключения к внешнему сервису), он
  будет в scope `application`. Этот бин будет общим для всех контекстов в рамках
  одного веб-приложения, и все пользователи будут работать с одним экземпляром.

### **Когда использовать**:

- **Singleton**: Используйте для большинства бинов, особенно stateless, если вам
  не нужно разделять их между разными ApplicationContext или если вы работаете в
  невеб-приложении.
- **Application**: Используйте в веб-приложениях для глобальных ресурсов,
  которые должны быть общими для всех пользователей и всех контекстов в рамках
  одного ServletContext.

### **Практическая заметка**:

- В большинстве случаев `singleton` достаточно, так как он проще и покрывает
  большинство сценариев.
- `Application` scope редко используется, так как необходимость в глобальном
  бине, привязанном к ServletContext, возникает только в специфичных случаях (
  например, кэширование данных, общих для всего приложения).

--------------------------------------------------------------------------------


## ApplicationContext

**ApplicationContext** в Java Spring — это центральный интерфейс фреймворка,
представляющий **IoC-контейнер** (Inversion of Control), который управляет
жизненным циклом бинов, их конфигурацией и зависимостями в приложении. Это более
продвинутая и функциональная версия контейнера по сравнению с `BeanFactory`.
Давайте разберём, что это такое, кратко и понятно.

### **Что такое ApplicationContext?**

- **ApplicationContext** — это объект, который:
    - Создаёт, конфигурирует и управляет **бинами** (объектами, управляемыми
      Spring).
    - Обеспечивает **внедрение зависимостей** (Dependency Injection).
    - Предоставляет дополнительные возможности, такие как поддержка
      интернационализации, событий, доступа к ресурсам и работа в
      веб-приложениях.
- Он загружает конфигурацию приложения (из XML, Java-конфигураций или аннотаций)
  и создаёт контекст, в котором бины взаимодействуют.

### **Основные функции ApplicationContext**:

1. **Управление бинами**:
    - Создание, инициализация и уничтожение бинов.
    - Поддержка scope бинов (например, `singleton`, `prototype`).
2. **Внедрение зависимостей**:
    - Автоматическое связывание бинов через конструкторы, сеттеры или поля (с
      помощью `@Autowired`, `@Inject` и т.д.).
3. **Поддержка дополнительных возможностей**:
    - **Интернационализация** (i18n): работа с сообщениями на разных языках.
    - **События**: публикация и обработка событий в приложении.
    - **Доступ к ресурсам**: загрузка файлов, свойств и других ресурсов.
    - **Управление профайлами**: активация бинов в зависимости от окружения (
      `dev`, `prod`).
    - **Поддержка AOP**: интеграция с аспектно-ориентированным
      программированием.
4. **Контекст для веб-приложений**:
    - В веб-приложениях `ApplicationContext` может быть привязан к
      `ServletContext` (например, через `ContextLoaderListener` или
      `DispatcherServlet`).

### **Типы ApplicationContext**:

В зависимости от типа приложения и конфигурации используются разные реализации:

- **AnnotationConfigApplicationContext**: Для Java-конфигураций с аннотациями.
  ```java
  ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
  ```
- **ClassPathXmlApplicationContext**: Для XML-конфигураций из classpath.
  ```java
  ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
  ```
- **FileSystemXmlApplicationContext**: Для XML-конфигураций из файловой системы.
- **WebApplicationContext**: Для веб-приложений, интегрируется с
  `ServletContext`.

### **ApplicationContext в жизненном цикле приложения**:

1. **Загрузка конфигурации**: Читает конфигурацию (XML, Java, аннотации).
2. **Создание бинов**: Инициализирует бины согласно их scope (например,
   singleton создаётся сразу, если не ленивый).
3. **Внедрение зависимостей**: Связывает бины между собой.
4. **Инициализация**: Вызывает методы инициализации (`@PostConstruct`,
   `init-method`).
5. **Использование**: Приложение работает, бины доступны через
   `context.getBean()`.
6. **Уничтожение**: При закрытии контекста вызываются методы уничтожения (
   `@PreDestroy`, `destroy-method`).

### **Отличие от BeanFactory**:

- `BeanFactory` — более простой контейнер, предоставляющий базовые функции (
  создание и управление бинами).
- `ApplicationContext` расширяет `BeanFactory`, добавляя поддержку событий,
  интернационализации, веб-функционала и автоматической обработки аннотаций (
  например, `@Autowired`).

### **Пример использования**:

```java

@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}

@Component
public class MyBean {
    public void doSomething() {
        System.out.println("Работаю!");
    }
}

public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        MyBean bean = context.getBean(MyBean.class);
        bean.doSomething(); // Выведет: Работаю!
    }
}
```

### **Связь с Singleton и Application Scope**:

- **Singleton Scope**: Один экземпляр бина на один `ApplicationContext`. Если
  создано несколько контекстов, каждый будет иметь свой singleton-бин.
- **Application Scope**: Один экземпляр бина на весь `ServletContext` (в
  веб-приложении), общий для всех `ApplicationContext` в рамках одного
  веб-приложения.

### **Когда использовать**:

- **ApplicationContext** — стандартный выбор для большинства приложений Spring,
  так как он предоставляет полный набор функций.
- Используйте `BeanFactory` только в очень ограниченных сценариях (например, в
  средах с минимальными ресурсами).

--------------------------------------------------------------------------------


## Несколько контекстов ApplicationContext

В Spring Framework несколько **ApplicationContext** (контекстов) могут
существовать в одном приложении в определённых сценариях, когда требуется
разделение конфигураций, бинов или логики приложения. Это чаще всего встречается
в **веб-приложениях**, но может быть и в невеб-приложениях при сложной
архитектуре. Давайте разберём основные случаи, когда в приложении может быть
несколько `ApplicationContext`, кратко и понятно.

### **Случаи, когда возникает несколько ApplicationContext**

1. **Веб-приложения с ContextLoaderListener и DispatcherServlet**:
    - **Описание**: В Spring MVC стандартная конфигурация включает:
        - **Корневой ApplicationContext**, создаваемый `ContextLoaderListener`,
          который содержит глобальные бины (сервисы, репозитории, конфигурации
          базы данных).
        - **Дочерний WebApplicationContext**, создаваемый каждым
          `DispatcherServlet`, для веб-специфичных бинов (контроллеры,
          ViewResolver, HandlerMapping).
    - **Почему несколько контекстов?**
        - Разделение ответственности: корневой контекст хранит общие бины,
          доступные всему приложению, а контексты `DispatcherServlet` — бины,
          связанные с обработкой HTTP-запросов.
        - Если в приложении несколько `DispatcherServlet` (например, для разных
          URL-паттернов, таких как `/api/*` и `/web/*`), каждый из них создаёт
          свой собственный `WebApplicationContext`.
    - **Пример**:
      ```xml
      <!-- web.xml -->
      <listener>
          <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
      </listener>
      <context-param>
          <param-name>contextConfigLocation</param-name>
          <param-value>/WEB-INF/applicationContext.xml</param-value>
      </context-param>
 
      <servlet>
          <servlet-name>apiDispatcher</servlet-name>
          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
          <init-param>
              <param-name>contextConfigLocation</param-name>
              <param-value>/WEB-INF/api-servlet.xml</param-value>
          </init-param>
      </servlet>
      <servlet-mapping>
          <servlet-name>apiDispatcher</servlet-name>
          <url-pattern>/api/*</url-pattern>
      </servlet-mapping>
 
      <servlet>
          <servlet-name>webDispatcher</servlet-name>
          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
          <init-param>
              <param-name>contextConfigLocation</param-name>
              <param-value>/WEB-INF/web-servlet.xml</param-value>
          </init-param>
      </servlet>
      <servlet-mapping>
          <servlet-name>webDispatcher</servlet-name>
          <url-pattern>/web/*</url-pattern>
      </servlet-mapping>
      ```
        - Здесь создаётся:
            - Один корневой `ApplicationContext` (`ContextLoaderListener`).
            - Два дочерних `WebApplicationContext` (по одному для каждого
              `DispatcherServlet`).

2. **Модульные приложения с иерархией контекстов**:
    - **Описание**: В крупных приложениях может быть несколько
      `ApplicationContext`, организованных в иерархию (родительский и дочерние
      контексты), чтобы разделить конфигурации по модулям или слоям.
    - **Почему несколько контекстов?**
        - Для изоляции бинов: например, один контекст для инфраструктуры (база
          данных, кэши), другой для бизнес-логики.
        - Дочерние контексты наследуют бины из родительского, но могут добавлять
          свои собственные.
    - **Пример**:
      ```java
      public class Main {
          public static void main(String[] args) {
              // Родительский контекст
              AnnotationConfigApplicationContext parentContext = new AnnotationConfigApplicationContext(InfrastructureConfig.class);
              // Дочерний контекст
              AnnotationConfigApplicationContext childContext = new AnnotationConfigApplicationContext();
              childContext.setParent(parentContext);
              childContext.register(BusinessConfig.class);
              childContext.refresh();
          }
      }
      ```
        - Здесь родительский контекст содержит инфраструктурные бины, а
          дочерний — бизнес-логику.

3. **Микросервисная архитектура или модульные WAR-файлы**:
    - **Описание**: Если приложение состоит из нескольких WAR-файлов,
      развёрнутых в одном сервере (например, Tomcat), каждый WAR имеет свой
      собственный `ServletContext` и, соответственно, свой `ApplicationContext`.
    - **Почему несколько контекстов?**
        - Каждый WAR — это отдельное веб-приложение со своим `ServletContext` и
          Spring-контекстами.
        - Даже если используется общий корневой контекст, каждый WAR может иметь
          свои `DispatcherServlet` с отдельными `WebApplicationContext`.
    - **Пример**: Разные модули приложения (например, админ-панель и публичный
      API) развёрнуты как отдельные WAR-файлы, каждый со своим
      `ApplicationContext`.

4. **Тестирование**:
    - **Описание**: В тестах часто создаются отдельные `ApplicationContext` для
      каждого тестового класса или набора тестов, чтобы изолировать конфигурации
      и бины.
    - **Почему несколько контекстов?**
        - Тестовые контексты создаются с разными конфигурациями (например, с
          моками или тестовой базой данных).
        - Spring кэширует контексты, но разные тесты могут использовать разные
          конфигурации, что приводит к созданию нескольких `ApplicationContext`.
    - **Пример**:
      ```java
      @SpringBootTest
      @ContextConfiguration(classes = TestConfig1.class)
      public class Test1 {
          @Autowired
          private SomeService service;
      }
 
      @SpringBootTest
      @ContextConfiguration(classes = TestConfig2.class)
      public class Test2 {
          @Autowired
          private SomeService service;
      }
      ```
        - Здесь создаются два отдельных `ApplicationContext` для `TestConfig1` и
          `TestConfig2`.

5. **Плагины или модульные приложения**:
    - **Описание**: В приложениях с модульной структурой (например, плагины или
      подключаемые модули) каждый модуль может создавать свой собственный
      `ApplicationContext`.
    - **Почему несколько контекстов?**
        - Каждый модуль имеет свою конфигурацию и бины, которые изолированы от
          других модулей.
        - Модули могут загружаться динамически, создавая свои контексты во время
          выполнения.
    - **Пример**: В приложении с плагинами каждый плагин регистрирует свой
      `ApplicationContext` для обработки своей логики.

6. **Разные профили или окружения**:
    - **Описание**: Spring позволяет использовать профили (`@Profile`) для
      разделения конфигураций (например, `dev`, `prod`). Хотя профили обычно
      работают в рамках одного контекста, в некоторых случаях разные профили
      могут приводить к созданию отдельных контекстов.
    - **Пример**:
      ```java
      AnnotationConfigApplicationContext context1 = new AnnotationConfigApplicationContext();
      context1.getEnvironment().setActiveProfiles("dev");
      context1.register(DevConfig.class);
      context1.refresh();
 
      AnnotationConfigApplicationContext context2 = new AnnotationConfigApplicationContext();
      context2.getEnvironment().setActiveProfiles("prod");
      context2.register(ProdConfig.class);
      context2.refresh();
      ```
        - Здесь создаются два `ApplicationContext` для разных профилей.

### **Как управляются множественные контексты?**

- **Иерархия контекстов**:
    - В веб-приложениях часто используется иерархия: корневой
      `ApplicationContext` (от `ContextLoaderListener`) и дочерние
      `WebApplicationContext` (от `DispatcherServlet`).
    - Дочерние контексты наследуют бины из родительского, но могут
      переопределять их или добавлять свои.
- **Изоляция**:
    - Каждый `ApplicationContext` изолирован и управляет своими бинами.
    - Бины в scope `singleton` уникальны для каждого контекста (например, два
      `ApplicationContext` будут иметь разные экземпляры singleton-бинов).
- **Связь с ServletContext**:
    - В веб-приложении все контексты привязаны к одному `ServletContext`,
      который обеспечивает глобальный доступ к ресурсам и атрибутам приложения.
    - Бины в scope `application` общие для всех контекстов в рамках одного
      `ServletContext`.

### **Практические замечания**

- **Когда несколько контекстов полезны?**
    - Для разделения конфигураций (например, инфраструктура, бизнес-логика,
      веб-слой).
    - Для поддержки нескольких точек входа (например, REST API и MVC в одном
      приложении).
    - Для модульности и изоляции в больших приложениях.
- **Недостатки**:
    - Увеличивают сложность приложения.
    - Могут потребовать больше памяти, так как каждый контекст хранит свои бины.
    - Требуют осторожности при управлении зависимостями между контекстами.
- **Scope и множественные контексты**:
    - Бины в scope `singleton` уникальны для каждого `ApplicationContext`.
    - Бины в scope `application` общие для всех контекстов в рамках одного
      `ServletContext`.
    - Для внедрения бинов с короткоживущими scopes (например, `request`,
      `session`) в singleton-бины используется `proxyMode` (как обсуждалось
      ранее).

### **Пример сценария**

Предположим, у вас есть веб-приложение с REST API и веб-интерфейсом:

- **Корневой контекст** (`ContextLoaderListener`): Хранит сервисы, репозитории,
  настройки базы данных.
- **Дочерний контекст 1** (`DispatcherServlet` для `/api/*`): Контроллеры для
  REST API.
- **Дочерний контекст 2** (`DispatcherServlet` для `/web/*`): Контроллеры для
  MVC и рендеринга HTML.
- Все контексты используют общий `ServletContext`, а бины в scope
  `application` (например, глобальный кэш) общие для всех.

### **Связь с предыдущими темами**

- **ServletContext**: Все `ApplicationContext` в веб-приложении привязаны к
  одному `ServletContext`, который обеспечивает доступ к глобальным ресурсам.
- **DispatcherServlet**: Создаёт дочерний `WebApplicationContext` для обработки
  HTTP-запросов.
- **ContextLoaderListener**: Создаёт корневой `ApplicationContext`, общий для
  всех `DispatcherServlet`.
- **proxyMode**: Используется для корректного внедрения бинов с scopes
  `request`, `session`, `application` в бины из разных контекстов.



--------------------------------------------------------------------------------


## ServletContext

**ServletContext** в Java — это объект, предоставляемый веб-контейнером (
например, Tomcat, Jetty) в веб-приложениях, работающих на основе **Java Servlet
API**. Он представляет **контекст веб-приложения** и используется для хранения и
управления глобальными данными, ресурсами и конфигурацией, общими для всех
сервлетов и компонентов приложения. В контексте Spring **ServletContext** играет
важную роль, особенно для scope `application` и интеграции с веб-приложениями.
Давайте разберём кратко и понятно.

### **Что такое ServletContext?**

- **ServletContext** — это интерфейс, определённый в пакете `javax.servlet`,
  который создаётся веб-контейнером при запуске веб-приложения.
- Он действует как **глобальный контейнер данных** для всего приложения,
  позволяя:
    - Хранить общие данные (атрибуты) для всех сервлетов и пользователей.
    - Получать доступ к ресурсам приложения (например, файлам в папке
      `WEB-INF`).
    - Управлять конфигурацией приложения (например, параметрами из `web.xml`).
- Каждый веб-приложение имеет **один ServletContext**, который существует на
  протяжении всего жизненного цикла приложения (от старта до остановки сервера
  или приложения).

### **Основные функции ServletContext**:

1. **Хранение атрибутов**:
    - Позволяет сохранять и извлекать данные, доступные всем компонентам
      приложения (аналогично глобальной "карте" ключ-значение).
    - Пример:
      ```java
      ServletContext context = getServletContext();
      context.setAttribute("appName", "MyApp");
      String appName = (String) context.getAttribute("appName");
      ```
2. **Доступ к ресурсам**:
    - Предоставляет доступ к файлам и ресурсам веб-приложения (например, файлы в
      `/WEB-INF`).
    - Пример:
      ```java
      InputStream resource = context.getResourceAsStream("/WEB-INF/config.properties");
      ```
3. **Конфигурационные параметры**:
    - Читает параметры, заданные в `web.xml` (или аннотациях в современных
      приложениях).
    - Пример в `web.xml`:
      ```xml
      <context-param>
          <param-name>appVersion</param-name>
          <param-value>1.0</param-value>
      </context-param>
      ```
      ```java
      String version = context.getInitParameter("appVersion");
      ```
4. **Логирование**:
    - Позволяет записывать сообщения в лог приложения.
    - Пример:
      ```java
      context.log("Application started");
      ```
5. **Управление сервлетами**:
    - Предоставляет информацию о сервлетах и их конфигурации, а также о самом
      приложении (например, путь к корню приложения).
    - Пример:
      ```java
      String contextPath = context.getContextPath(); // Например, "/myapp"
      ```

### **ServletContext в Spring**:

- В Spring **ServletContext** связан с веб-приложениями и используется для:
    - Инициализации **WebApplicationContext** (специальной версии
      `ApplicationContext` для веб-приложений).
    - Хранения бинов в scope `application`, которые создаются один раз на весь
      `ServletContext` (см. ваш предыдущий вопрос о scope `application`).
    - Интеграции через компоненты, такие как `ContextLoaderListener` (загружает
      корневой `ApplicationContext`) или `DispatcherServlet` (создаёт свой
      собственный `WebApplicationContext`).
- Spring использует `ServletContext` для:
    - Доступа к глобальным ресурсам и параметрам.
    - Привязки бинов с scope `application` к жизненному циклу `ServletContext`.
    - Обеспечения взаимодействия между Spring и веб-контейнером.

### **Пример использования в Spring**:

```java

@Component
@Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class AppConfigBean {
    public String getAppName() {
        return "MyApp";
    }
}

// Получение ServletContext в Spring
@Component
public class MyServlet {
    @Autowired
    private ServletContext servletContext;

    public void doSomething() {
        String appName = (String) servletContext.getAttribute("appName");
        System.out.println("App Name: " + appName);
    }
}
```

### **Ключевые моменты**:

- **Один на приложение**: В каждом веб-приложении существует только один
  `ServletContext`, создаваемый веб-контейнером при старте приложения.
- **Жизненный цикл**: `ServletContext` живёт от старта приложения (
  разворачивания WAR-файла) до его остановки.
- **Связь с ApplicationContext**:
    - `ApplicationContext` в Spring управляет бинами в рамках одного контекста,
      а `ServletContext` — это более низкоуровневый объект, общий для всего
      веб-приложения.
    - Бины в scope `application` привязаны к `ServletContext`, а бины в scope
      `singleton` — к конкретному `ApplicationContext`.
- **Использование**: Часто применяется для хранения глобальных данных (например,
  кэшей, настроек) или интеграции с веб-контейнером.

### **Отличие от ApplicationContext**:

| Характеристика       | ServletContext                      | ApplicationContext                    |
|----------------------|-------------------------------------|---------------------------------------|
| **Тип**              | Часть Java Servlet API              | Часть Spring Framework                |
| **Назначение**       | Управление ресурсами веб-приложения | Управление бинами и DI в Spring       |
| **Область действия** | Всё веб-приложение                  | Конкретный контекст приложения        |
| **Создаётся**        | Веб-контейнером (Tomcat, Jetty)     | Spring (ApplicationContext)           |
| **Привязка scope**   | Scope `application`                 | Scope `singleton`, `prototype`, и др. |

### **Когда использовать**:

- Используйте `ServletContext` для:
    - Доступа к глобальным ресурсам или параметрам веб-приложения.
    - Хранения данных, общих для всех пользователей и сервлетов.
    - Интеграции Spring с веб-контейнером.
- В Spring чаще работайте с `ApplicationContext` для управления бинами, а
  `ServletContext` используйте, если требуется взаимодействие с веб-контейнером
  или scope `application`.

--------------------------------------------------------------------------------


## Что такое DispatcherServlet и ContextLoaderListener?

**DispatcherServlet** и **ContextLoaderListener** — это ключевые компоненты в
веб-приложениях Spring, которые используются для интеграции Spring с
веб-контейнером (например, Tomcat, Jetty) и управления **ApplicationContext** в
контексте веб-приложения. Они выполняют разные роли, но оба связаны с
инициализацией и управлением Spring в веб-приложениях. Давайте разберём их
кратко и понятно.

### **DispatcherServlet**

- **Что это?**
    - **DispatcherServlet** — это центральный сервлет в Spring MVC, который
      обрабатывает все HTTP-запросы в веб-приложении и направляет их к
      соответствующим контроллерам.
    - Это реализация паттерна **Front Controller**, который служит единой точкой
      входа для всех запросов.
- **Функции**:
    - Создаёт собственный **WebApplicationContext** (дочерний контекст Spring),
      который содержит бины, связанные с веб-логикой (контроллеры, обработчики
      запросов, view resolvers и т.д.).
    - Обрабатывает HTTP-запросы: принимает запрос, вызывает соответствующий
      контроллер, обрабатывает результат и возвращает ответ (например,
      HTML-страницу, JSON).
    - Управляет маршрутизацией запросов, обработкой исключений, рендерингом
      представлений (views).
- **Как работает**:
    - Определяется в `web.xml` или через Java-конфигурацию.
    - При старте создаёт свой `WebApplicationContext`, который загружает бины из
      указанных конфигураций (XML, Java, аннотации).
    - Обрабатывает запросы, делегируя их компонентам Spring MVC (HandlerMapping,
      HandlerAdapter, ViewResolver).
- **Пример конфигурации**:
    - В `web.xml`:
      ```xml
      <servlet>
          <servlet-name>dispatcher</servlet-name>
          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
          <init-param>
              <param-name>contextConfigLocation</param-name>
              <param-value>/WEB-INF/spring-mvc-config.xml</param-value>
          </init-param>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>dispatcher</servlet-name>
          <url-pattern>/</url-pattern>
      </servlet-mapping>
      ```
    - В Java-конфигурации:
      ```java
      @Configuration
      @EnableWebMvc
      public class WebConfig implements WebMvcConfigurer {
          // Конфигурация MVC
      }
      ```
- **Когда использовать**:
    - Для обработки HTTP-запросов в Spring MVC.
    - Для настройки контроллеров, представлений и REST API.

### **ContextLoaderListener**

- **Что это?**
    - **ContextLoaderListener** — это слушатель (listener), который
      инициализирует **корневой WebApplicationContext** для всего
      веб-приложения.
    - Он загружает бины, которые являются глобальными для приложения и не
      связаны напрямую с обработкой HTTP-запросов (например, сервисы,
      репозитории, конфигурации базы данных).
- **Функции**:
    - Создаёт **корневой ApplicationContext**, который является родительским для
      контекстов, созданных `DispatcherServlet`.
    - Загружает бины, определённые в глобальной конфигурации (например, сервисы,
      DAO, источники данных).
    - Привязывает корневой контекст к **ServletContext**, делая его доступным
      для всех компонентов приложения.
- **Как работает**:
    - Регистрируется в `web.xml` как слушатель.
    - При старте веб-приложения (разворачивание WAR) создаёт корневой
      `WebApplicationContext` на основе указанной конфигурации (XML или Java).
    - Этот контекст используется всеми `DispatcherServlet` в приложении как
      родительский, чтобы избежать дублирования бинов.
- **Пример конфигурации**:
    - В `web.xml`:
      ```xml
      <listener>
          <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
      </listener>
      <context-param>
          <param-name>contextConfigLocation</param-name>
          <param-value>/WEB-INF/applicationContext.xml</param-value>
      </context-param>
      ```
    - В Java-конфигурации:
      ```java
      public class AppInitializer implements WebApplicationInitializer {
          @Override
          public void onStartup(ServletContext servletContext) {
              AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext();
              rootContext.register(AppConfig.class);
              servletContext.addListener(new ContextLoaderListener(rootContext));
          }
      }
      ```
- **Когда использовать**:
    - Для инициализации глобальных бинов, которые используются в разных частях
      приложения (например, сервисы, доступ к базе данных).
    - Когда нужно создать общий корневой контекст для нескольких
      `DispatcherServlet`.

### **Ключевые отличия**:

| Характеристика           | DispatcherServlet                         | ContextLoaderListener                  |
|--------------------------|-------------------------------------------|----------------------------------------|
| **Тип**                  | Сервлет (обрабатывает HTTP-запросы)       | Слушатель (инициализирует контекст)    |
| **Роль**                 | Обработка запросов, Spring MVC            | Создание корневого ApplicationContext  |
| **Контекст**             | Создаёт дочерний WebApplicationContext    | Создаёт корневой WebApplicationContext |
| **Содержимое контекста** | Контроллеры, ViewResolver, HandlerMapping | Сервисы, репозитории, конфигурации БД  |
| **Привязка**             | Обрабатывает запросы по URL-паттерну      | Привязан к ServletContext              |
| **Использование**        | Для MVC и REST API                        | Для глобальных бинов приложения        |

### **Как они взаимодействуют**:

- **Иерархия контекстов**:
    - `ContextLoaderListener` создаёт **корневой WebApplicationContext**,
      содержащий глобальные бины (например, сервисы, репозитории).
    - `DispatcherServlet` создаёт **дочерний WebApplicationContext**, который
      наследует бины из корневого контекста и добавляет свои (контроллеры,
      обработчики).
    - Это позволяет разделить конфигурацию: глобальные бины (сервисы) в корневом
      контексте, веб-специфичные бины (контроллеры) — в контексте
      `DispatcherServlet`.
- **Пример структуры**:
    - Корневой контекст (`ContextLoaderListener`): бины сервисов, доступ к базе
      данных.
    - Дочерний контекст (`DispatcherServlet`): бины контроллеров, обработка
      HTTP-запросов.
- Если в приложении несколько `DispatcherServlet` (например, для разных
  URL-паттернов), они все используют один корневой контекст, созданный
  `ContextLoaderListener`.

### **Практические замечания**:

- **Когда нужен ContextLoaderListener?**
    - Если приложение сложное, и вы хотите разделить конфигурацию на
      глобальную (сервисы, репозитории) и веб-специфичную (контроллеры).
    - Если у вас несколько `DispatcherServlet` (например, для REST API и MVC).
- **Когда достаточно только DispatcherServlet?**
    - В простых приложениях, где все бины (сервисы, контроллеры) можно
      разместить в одном контексте.
- **Scope и ServletContext**:
    - Бины в scope `application` привязаны к `ServletContext`, который создаётся
      веб-контейнером и используется обоими компонентами.
    - `ContextLoaderListener` делает корневой контекст доступным через
      `ServletContext`, а `DispatcherServlet` использует его для доступа к
      глобальным бинам.

### **Пример полного веб-приложения**:

```xml
<!-- web.xml -->
<web-app>
    <!-- ContextLoaderListener для корневого контекста -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/applicationContext.xml</param-value>
    </context-param>

    <!-- DispatcherServlet для MVC -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-mvc-config.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

### **Связь с предыдущими темами**:

- **ServletContext**: `ContextLoaderListener` привязывает корневой
  `WebApplicationContext` к `ServletContext`, а `DispatcherServlet` использует
  его для доступа к глобальным ресурсам.
- **ApplicationContext**: `ContextLoaderListener` создаёт корневой контекст, а
  `DispatcherServlet` — дочерний.
- **Scope**: Бины в scope `application` привязаны к `ServletContext`, а бины в
  scope `singleton` — к конкретному `ApplicationContext` (корневому или
  дочернему).

--------------------------------------------------------------------------------


## ProxyMode

В контексте Spring Framework **proxyMode** — это атрибут, используемый в
аннотации `@Scope` для указания, как Spring должен создавать прокси-объекты для
бинов с определёнными областями видимости (scopes), такими как `request`,
`session`, или `application`. Это необходимо, чтобы корректно внедрять бины с
короткоживущими scopes в бины с более долгоживущими scopes (например,
`singleton`). Давайте разберём кратко и понятно.

### **Что такое proxyMode?**

- **proxyMode** определяет, каким образом Spring создаёт **прокси** для бина,
  чтобы обеспечить правильное поведение при внедрении зависимости в контексте,
  где области видимости бинов различаются.
- Прокси — это промежуточный объект, который "оборачивает" реальный бин и
  управляет доступом к нему, позволяя контейнеру Spring подставлять нужный
  экземпляр бина в зависимости от текущего контекста (например, HTTP-запроса или
  сессии).
- Используется в основном для веб-ориентированных scopes (`request`, `session`,
  `application`) или пользовательских scopes.

### **Зачем нужен proxyMode?**

Когда бин с короткоживущим scope (например, `request`) внедряется в бин с
долгоживущим scope (например, `singleton`), возникает проблема:

- Singleton-бин создаётся один раз и живёт весь жизненный цикл
  `ApplicationContext`.
- Request-бин создаётся для каждого HTTP-запроса и уничтожается после его
  завершения.
- Без прокси singleton-бин получил бы фиксированную ссылку на request-бин,
  созданный в момент инициализации, что привело бы к некорректной работе (
  например, использованию устаревшего или недоступного бина).

**proxyMode** решает эту проблему, создавая прокси-объект, который динамически
подставляет актуальный экземпляр бина в зависимости от текущего контекста (
например, текущего HTTP-запроса).

### **Значения proxyMode**

Атрибут `proxyMode` в аннотации `@Scope` принимает значения из перечисления
`ScopedProxyMode`. Основные варианты:

1. **ScopedProxyMode.NO** (по умолчанию):
    - Прокси не создаётся.
    - Подходит, если бин не внедряется в бины с другими scopes или если scope
      совпадает (например, оба бина в `singleton`).
    - Используется, когда проксирование не требуется.
    - Пример:
      ```java
      @Component
      @Scope("request")
      public class RequestBean {
          // Без прокси
      }
      ```

2. **ScopedProxyMode.TARGET_CLASS**:
    - Создаёт **прокси на основе CGLIB**, который работает на уровне класса.
    - Прокси заменяет сам класс бина, позволяя подставлять актуальный экземпляр
      при каждом вызове.
    - Используется, когда бин не реализует интерфейсы или когда требуется
      проксирование всего класса.
    - Пример:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestBean {
          public String getData() {
              return "Данные для текущего запроса";
          }
      }
      ```

3. **ScopedProxyMode.INTERFACES**:
    - Создаёт **прокси на основе JDK Dynamic Proxy**, который работает на уровне
      интерфейсов.
    - Требует, чтобы бин реализовал хотя бы один интерфейс.
    - Прокси реализует интерфейсы бина и подставляет актуальный экземпляр при
      вызове методов.
    - Используется, когда бин реализует интерфейсы, и вы хотите ограничить
      проксирование только ими.
    - Пример:
      ```java
      public interface MyService {
          String getData();
      }
 
      @Component
      @Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)
      public class SessionBean implements MyService {
          public String getData() {
              return "Данные для текущей сессии";
          }
      }
      ```

### **Как работает проксирование?**

- Когда вы указываете `proxyMode`, Spring создаёт прокси-объект вместо реального
  бина.
- Этот прокси перехватывает вызовы методов и делегирует их актуальному
  экземпляру бина, который соответствует текущему контексту (например, текущему
  HTTP-запросу или сессии).
- Прокси "знает", как получить правильный экземпляр бина из текущего контекста (
  `ServletContext` для `application`, HTTP-сессии для `session`, HTTP-запроса
  для `request`).

### **Пример использования**

Предположим, у вас есть singleton-бин, который зависит от request-бин:

```java

@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    public String getRequestId() {
        return "ID запроса: " + UUID.randomUUID().toString();
    }
}

@Component
public class SingletonService {
    private final RequestBean requestBean;

    @Autowired
    public SingletonService(RequestBean requestBean) {
        this.requestBean = requestBean;
    }

    public void printRequestId() {
        System.out.println(requestBean.getRequestId());
    }
}
```

- Без `proxyMode` Spring внедрил бы фиксированный экземпляр `RequestBean`,
  который был бы создан один раз и стал бы недействительным после завершения
  запроса.
- С `proxyMode = ScopedProxyMode.TARGET_CLASS` Spring создаёт прокси, который
  при каждом вызове `printRequestId()` подставляет актуальный экземпляр
  `RequestBean` для текущего HTTP-запроса.

### **Ключевые моменты**

- **Когда использовать proxyMode?**
    - Когда бин с короткоживущим scope (`request`, `session`, `application`)
      внедряется в бин с долгоживущим scope (обычно `singleton`).
    - Без проксирования Spring выбросит исключение или внедрит некорректный
      экземпляр.
- **CGLIB vs JDK Proxy**:
    - `TARGET_CLASS` (CGLIB): Работает с любыми классами, но требует зависимости
      `cglib` и может быть чуть медленнее.
    - `INTERFACES` (JDK Proxy): Работает только с интерфейсами, но быстрее и
      легче в использовании, если бин реализует интерфейсы.
- **Связь с ServletContext**:
    - Для scope `application`, `request`, `session` прокси взаимодействует с
      `ServletContext` или текущим HTTP-контекстом, чтобы подставить правильный
      экземпляр бина.
- **Ограничения**:
    - Проксирование добавляет небольшой оверхед.
    - `INTERFACES` не работает, если класс не реализует интерфейсы.
    - Прокси не требуется, если бины имеют одинаковый scope или если бин не
      внедряется в другие бины.

### **Связь с предыдущими темами**

- **ServletContext**: `proxyMode` позволяет бинам в scope `request`, `session`,
  или `application` корректно работать с `ServletContext`, подставляя
  экземпляры, привязанные к текущему HTTP-запросу или сессии.
- **ApplicationContext**: Прокси создаются в рамках `ApplicationContext` (или
  `WebApplicationContext`), чтобы управлять доступом к бинам с разными scopes.
- **DispatcherServlet и ContextLoaderListener**: Прокси часто используются в
  контексте, созданном `DispatcherServlet`, для внедрения request- или
  session-бинов в singleton-бины, определённые в корневом контексте (
  `ContextLoaderListener`).

### **Пример полной конфигурации**

```java

@Configuration
public class AppConfig {
    @Bean
    @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public RequestBean requestBean() {
        return new RequestBean();
    }

    @Bean
    public SingletonService singletonService(RequestBean requestBean) {
        return new SingletonService(requestBean);
    }
}
```

--------------------------------------------------------------------------------


## Сроки жизни бинов с Scope request, session и application.

В Spring Framework сроки жизни бинов зависят от их **области видимости (scope)
**. Области `request`, `session` и `application` используются в веб-приложениях
и привязаны к специфическим аспектам веб-контекста, определённого в *
*ServletContext**. Давайте разберём сроки жизни каждого из этих scopes кратко и
понятно.

### **1. Request Scope**

- **Срок жизни**:
    - Бин живёт в течение **одного HTTP-запроса**.
    - Создаётся при поступлении запроса и уничтожается после завершения
      обработки этого запроса.
- **Подробности**:
    - Каждый HTTP-запрос (например, GET, POST) создаёт новый экземпляр бина.
    - После завершения запроса (например, когда ответ отправлен клиенту) бин
      становится недоступным, и методы уничтожения (`@PreDestroy`,
      `destroy-method`) вызываются.
    - Используется для хранения данных, специфичных для конкретного запроса,
      например, параметры формы или временные данные обработки.
- **Пример**:
  ```java
  @Component
  @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
  public class RequestBean {
      @PostConstruct
      public void init() {
          System.out.println("RequestBean создан для запроса");
      }

      @PreDestroy
      public void destroy() {
          System.out.println("RequestBean уничтожен после запроса");
      }
  }
  ```
- **Контекст**:
    - Привязан к текущему HTTP-запросу, который обрабатывается через
      `DispatcherServlet`.
    - Требует `spring-web` и работает в рамках `WebApplicationContext`.

### **2. Session Scope**

- **Срок жизни**:
    - Бин живёт в течение **одной HTTP-сессии пользователя**.
    - Создаётся при старте новой сессии (например, когда пользователь впервые
      обращается к приложению) и уничтожается при завершении сессии (например,
      при истечении времени сессии или вызове `session.invalidate()`).
- **Подробности**:
    - Один экземпляр бина существует для каждой пользовательской сессии.
    - Сессия обычно сохраняется на сервере (или в кластере) и идентифицируется
      через `HttpSession`.
    - Подходит для хранения данных, связанных с пользователем, например, корзины
      покупок или настроек пользователя.
    - Методы уничтожения (`@PreDestroy`, `destroy-method`) вызываются при
      завершении сессии.
- **Пример**:
  ```java
  @Component
  @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
  public class SessionBean {
      private int counter = 0;

      public void increment() {
          counter++;
      }

      public int getCounter() {
          return counter;
      }

      @PreDestroy
      public void destroy() {
          System.out.println("SessionBean уничтожен после завершения сессии");
      }
  }
  ```
- **Контекст**:
    - Привязан к `HttpSession`, которая хранится в `ServletContext`.
    - Требует `spring-web` и работает в рамках `WebApplicationContext`.

### **3. Application Scope**

- **Срок жизни**:
    - Бин живёт в течение **всего жизненного цикла веб-приложения**.
    - Создаётся при старте приложения (разворачивании WAR-файла) и уничтожается
      при остановке приложения или сервера.
- **Подробности**:
    - Один экземпляр бина существует для всего `ServletContext`.
    - Подходит для хранения глобальных данных или ресурсов, общих для всех
      пользователей и всех контекстов в приложении (например, глобальный кэш или
      конфигурация).
    - Методы уничтожения (`@PreDestroy`, `destroy-method`) вызываются при
      остановке приложения.
- **Пример**:
  ```java
  @Component
  @Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
  public class ApplicationBean {
      @PostConstruct
      public void init() {
          System.out.println("ApplicationBean создан при старте приложения");
      }

      @PreDestroy
      public void destroy() {
          System.out.println("ApplicationBean уничтожен при остановке приложения");
      }
  }
  ```
- **Контекст**:
    - Привязан к `ServletContext`, который существует на протяжении всего
      жизненного цикла веб-приложения.
    - Общий для всех `ApplicationContext` (корневого и дочерних) в рамках одного
      приложения.

### **Сравнение сроков жизни**

| Scope           | Срок жизни                         | Создаётся               | Уничтожается                                | Типичное использование               |
|-----------------|------------------------------------|-------------------------|---------------------------------------------|--------------------------------------|
| **Request**     | Один HTTP-запрос                   | При поступлении запроса | После завершения запроса                    | Данные запроса, временные результаты |
| **Session**     | Одна HTTP-сессия пользователя      | При создании сессии     | При завершении сессии (timeout, invalidate) | Корзина, настройки пользователя      |
| **Application** | Весь жизненный цикл веб-приложения | При старте приложения   | При остановке приложения                    | Глобальные конфигурации, кэши        |

### **Связь с ServletContext**

- Все три scope (`request`, `session`, `application`) работают в контексте
  веб-приложения и привязаны к **ServletContext**:
    - **Request**: Связан с текущим `HttpServletRequest`, который хранится в
      рамках запроса.
    - **Session**: Связан с `HttpSession`, которая хранится в `ServletContext`.
    - **Application**: Непосредственно привязан к `ServletContext`, который
      является глобальным для всего приложения.

### **Особенности и proxyMode**

- Для внедрения бинов с `request`, `session`, или `application` scope в бины с
  более долгоживущими scopes (например, `singleton`) используется `proxyMode` (
  как обсуждалось ранее). Это позволяет подставлять актуальный экземпляр бина в
  зависимости от текущего контекста (запроса, сессии или приложения).
- Без `proxyMode` (например, `ScopedProxyMode.TARGET_CLASS`) внедрение request-
  или session-бинов в singleton-бин вызовет проблемы, так как singleton-бин не
  сможет работать с динамически меняющимися экземплярами.

### **Связь с жизненным циклом бинов**

- **Создание**:
    - Бины в `request` scope создаются для каждого запроса.
    - Бины в `session` scope создаются при старте сессии.
    - Бины в `application` scope создаются один раз при старте приложения.
- **Инициализация**: Вызываются методы `@PostConstruct` или `init-method` при
  создании бина.
- **Уничтожение**:
    - Для `request`: После завершения запроса.
    - Для `session`: После завершения сессии.
    - Для `application`: При остановке приложения.
    - Методы `@PreDestroy` или `destroy-method` вызываются при уничтожении.

### **Практические замечания**

- **Request**: Используйте для данных, которые нужны только на время обработки
  одного запроса (например, данные формы).
- **Session**: Используйте для данных, связанных с конкретным пользователем (
  например, авторизация, корзина).
- **Application**: Используйте для глобальных ресурсов, общих для всех
  пользователей (например, кэш или конфигурация).
- Все эти scopes требуют зависимости `spring-web` и работают только в
  веб-приложениях с `WebApplicationContext`.

### **Пример полного кода**

```java

@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    public String getRequestId() {
        return "Request ID: " + UUID.randomUUID().toString();
    }
}

@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionBean {
    private int counter = 0;

    public void increment() {
        counter++;
    }

    public int getCounter() {
        return counter;
    }
}

@Component
@Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ApplicationBean {
    public String getAppName() {
        return "MyApp";
    }
}

@Component
public class MyService {
    @Autowired
    private RequestBean requestBean;
    @Autowired
    private SessionBean sessionBean;
    @Autowired
    private ApplicationBean applicationBean;

    public void printInfo() {
        System.out.println(requestBean.getRequestId()); // Новый ID для каждого запроса
        System.out.println("Session counter: " + sessionBean.getCounter()); // Сохраняется в сессии
        System.out.println("App name: " + applicationBean.getAppName()); // Общее для приложения
    }
}
```

--------------------------------------------------------------------------------


## Сроки жизни Singleton и Application бинов

Простите за возможное недопонимание! Я не указывал, что срок жизни **singleton**
-бинов **дольше**, чем у **application**-бинов. Давайте разберёмся и уточним
разницу в сроках жизни этих бинов, чтобы устранить путаницу.

### **Срок жизни singleton-бинов**

- **Singleton-бин** живёт в течение **жизненного цикла ApplicationContext**, в
  котором он определён.
- **Создание**: Создаётся при инициализации `ApplicationContext` (если не
  используется ленивая инициализация с `@Lazy`).
- **Уничтожение**: Уничтожается при закрытии `ApplicationContext` (например, при
  вызове `context.close()` или остановке приложения).
- **Особенности**:
    - Один экземпляр на каждый `ApplicationContext`.
    - Если в приложении несколько `ApplicationContext` (например, корневой от
      `ContextLoaderListener` и дочерний от `DispatcherServlet`), каждый создаёт
      свой собственный singleton-бин.
    - В веб-приложении срок жизни singleton-бина зависит от того, к какому
      `ApplicationContext` он привязан (корневому или дочернему).

### **Срок жизни application-бинов**

- **Application-бин** живёт в течение **жизненного цикла ServletContext**,
  который охватывает весь цикл существования веб-приложения.
- **Создание**: Создаётся при старте веб-приложения (разворачивание WAR-файла).
- **Уничтожение**: Уничтожается при остановке веб-приложения (например, при
  остановке сервера или удалении приложения).
- **Особенности**:
    - Один экземпляр на весь `ServletContext`, то есть общий для всех
      `ApplicationContext` в рамках одного веб-приложения.
    - Доступен всем компонентам приложения, независимо от того, в каком
      `ApplicationContext` они находятся.

### **Почему может показаться, что singleton живёт дольше?**

Если в моём предыдущем ответе возникла путаница, это могло быть связано с
описанием контекста или недостаточной ясностью. На самом деле:

- **Application-бин** обычно живёт **дольше** или **столько же**, сколько
  singleton-бин, потому что:
    - `ServletContext` (к которому привязан application-бин) существует весь
      жизненный цикл веб-приложения.
    - `ApplicationContext` (к которому привязан singleton-бин) может быть создан
      и закрыт в рамках этого же приложения. Например, корневой
      `ApplicationContext` (от `ContextLoaderListener`) обычно живёт столько же,
      сколько `ServletContext`, но дочерние контексты (от `DispatcherServlet`)
      могут создаваться и закрываться в процессе работы приложения.
- Если приложение использует только один `ApplicationContext` (например,
  корневой), то singleton-бины в этом контексте живут столько же, сколько
  application-бины, так как оба привязаны к жизненному циклу веб-приложения.
- Однако, если есть несколько `ApplicationContext` (например, дочерние контексты
  от нескольких `DispatcherServlet`), singleton-бины в этих контекстах могут
  быть уничтожены раньше, если соответствующий контекст закрывается (например,
  при перезагрузке `DispatcherServlet`).

### **Ключевые различия в сроках жизни**

| Scope           | Срок жизни                               | Привязка                               |
|-----------------|------------------------------------------|----------------------------------------|
| **Singleton**   | Весь жизненный цикл `ApplicationContext` | Один экземпляр на `ApplicationContext` |
| **Application** | Весь жизненный цикл `ServletContext`     | Один экземпляр на `ServletContext`     |

- **Application-бин** живёт дольше в случаях, когда приложение имеет несколько
  `ApplicationContext`, так как он привязан к `ServletContext`, который общий
  для всех контекстов и существует, пока приложение работает.
- **Singleton-бин** живёт столько же, сколько его `ApplicationContext`. Если это
  корневой контекст, то срок жизни совпадает с `ServletContext` (и,
  соответственно, с application-бинами). Если это дочерний контекст, он может
  быть короче.

### **Пример для ясности**

Предположим, у вас есть веб-приложение:

- **Корневой ApplicationContext** (создан `ContextLoaderListener`):
    - Содержит singleton-бин `ServiceBean`.
    - Живёт от старта до остановки веб-приложения (как `ServletContext`).
- **Дочерний WebApplicationContext** (создан `DispatcherServlet`):
    - Содержит singleton-бин `ControllerBean`.
    - Живёт, пока существует `DispatcherServlet` (обычно совпадает с жизненным
      циклом приложения, но может быть перезагружен).
- **Application-бин**:
    - Содержится в `ServletContext` и доступен всем контекстам.
    - Живёт от старта до остановки веб-приложения.

Если приложение останавливается, **application-бин** и singleton-бины из
корневого контекста уничтожаются одновременно. Singleton-бины из дочернего
контекста могут быть уничтожены раньше, если `DispatcherServlet`
перезагружается.

### **Уточнение**

Если в моём предыдущем ответе было сказано что-то, что подразумевало, что
singleton-бины живут дольше, это была ошибка или недопонимание. В типичном
веб-приложении с одним корневым `ApplicationContext` singleton-бины и
application-бины живут одинаково долго, так как оба привязаны к жизненному циклу
приложения. Однако application-бины могут считаться более "долгоживущими" в
сценариях с множественными `ApplicationContext`, так как они общие для всех
контекстов.

### **Пример кода**

```java

@Component
@Scope("singleton")
public class SingletonBean {
    @PostConstruct
    public void init() {
        System.out.println("SingletonBean создан");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("SingletonBean уничтожен");
    }
}

@Component
@Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ApplicationBean {
    @PostConstruct
    public void init() {
        System.out.println("ApplicationBean создан");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("ApplicationBean уничтожен");
    }
}
```

- **SingletonBean**: Уничтожается при закрытии его `ApplicationContext`.
- **ApplicationBean**: Уничтожается при остановке `ServletContext` (
  веб-приложения).

### **Ответ на ваш вопрос**

Я не утверждал, что singleton-бины живут дольше application-бинов. Если это
впечатление возникло, возможно, из-за описания, что singleton-бины привязаны к
`ApplicationContext`, а application-бины — к `ServletContext`. В большинстве
случаев их сроки жизни совпадают, но в приложениях с множественными
`ApplicationContext` application-бины могут существовать дольше, если дочерние
контексты перезагружаются или закрываются раньше.

Если у вас есть конкретный пример из моих ответов, который вызвал путаницу, или
вы хотите углубиться в какой-то сценарий, пожалуйста, уточните, и я разъясню!

--------------------------------------------------------------------------------


# Прокси бинов

## Что такое прокси бинов?

**Прокси бинов** в Spring Framework — это специальные объекты, которые создаются
Spring для оборачивания реальных бинов (объектов, управляемых контейнером
Spring) с целью добавления дополнительной функциональности или управления их
поведением. Прокси выступают как посредники между вызывающим кодом и целевым
бином, перехватывая вызовы методов и позволяя Spring внедрять дополнительную
логику, такую как транзакции, аспекты или работа с различными областями
видимости (scopes). Давайте разберём это кратко и понятно.

### **Что такое прокси бинов?**

- Прокси — это объект, который заменяет реальный бин в контейнере Spring. Он
  перехватывает вызовы методов бина и может выполнять дополнительную логику до,
  после или вместо вызова целевого метода.
- Прокси создаются автоматически Spring, когда это необходимо (например, для
  аннотаций `@Transactional`, аспектов AOP или бинов с определёнными scopes,
  таких как `request` или `session`).
- Реальный бин (целевой объект) остаётся неизменным, а прокси добавляет
  функциональность поверх него.

### **Зачем нужны прокси бинов?**

Spring использует прокси для следующих целей:

1. **Управление транзакциями (@Transactional)**:
    - Прокси перехватывает вызовы методов, помеченных `@Transactional`, чтобы
      открыть, зафиксировать или откатить транзакцию.
    - Пример:
      ```java
      @Service
      public class UserService {
          @Transactional
          public void saveUser(User user) {
              // Логика сохранения
          }
      }
      ```
        - Прокси оборачивает метод `saveUser`, добавляя логику управления
          транзакцией.

2. **Поддержка различных scopes (request, session, application)**:
    - Когда бин с короткоживущим scope (например, `request`) внедряется в бин с
      долгоживущим scope (например, `singleton`), Spring создаёт прокси, чтобы
      подставлять актуальный экземпляр бина в зависимости от текущего
      контекста (например, HTTP-запроса).
    - Используется `proxyMode` в аннотации `@Scope` (например,
      `ScopedProxyMode.TARGET_CLASS`).
    - Пример:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestBean {
          public String getRequestId() {
              return "ID: " + UUID.randomUUID().toString();
          }
      }
      ```
        - Прокси обеспечивает, что каждый вызов метода возвращает данные
          текущего запроса.

3. **Аспектно-ориентированное программирование (AOP)**:
    - Прокси позволяют применять аспекты (например, логирование, проверку
      безопасности) к методам бинов.
    - Например, аннотации `@Around`, `@Before`, или пользовательские аспекты
      используют прокси для перехвата вызовов.
    - Пример:
      ```java
      @Aspect
      @Component
      public class LoggingAspect {
          @Before("execution(* com.example.UserService.*(..))")
          public void logBefore() {
              System.out.println("Метод вызван");
          }
      }
      ```
        - Прокси для `UserService` добавляет логирование перед вызовом методов.

4. **Ленивая инициализация (@Lazy)**:
    - Для бинов, помеченных `@Lazy`, Spring создаёт прокси, чтобы отложить
      создание реального бина до первого вызова.
    - Прокси перехватывает вызовы и инициализирует бин только при необходимости.

5. **Кэширование (@Cacheable)**:
    - Прокси перехватывает вызовы методов, помеченных `@Cacheable`, чтобы
      проверять кэш и возвращать закэшированный результат вместо выполнения
      метода.
    - Пример:
      ```java
      @Service
      public class UserService {
          @Cacheable("users")
          public User getUserById(Long id) {
              return new User(id, "User" + id);
          }
      }
      ```

6. **Асинхронное выполнение (@Async)**:
    - Прокси для методов, помеченных `@Async`, позволяет выполнять их в
      отдельном потоке.

### **Как создаются прокси?**

Spring использует два механизма для создания прокси:

1. **JDK Dynamic Proxy**:
    - Работает с бинами, реализующими интерфейсы.
    - Создаёт прокси, реализующий те же интерфейсы, что и целевой бин.
    - Используется, если указано `proxyMode = ScopedProxyMode.INTERFACES` или
      для AOP с интерфейсами.
2. **CGLIB**:
    - Работает на уровне классов, создавая подкласс целевого бина.
    - Используется, если бин не реализует интерфейсы или если указано
      `proxyMode = ScopedProxyMode.TARGET_CLASS`.
    - Требует зависимости `cglib` (включена по умолчанию в Spring).

### **Как работает прокси?**

- Прокси заменяет реальный бин в `ApplicationContext`.
- Когда код вызывает метод бина, вызов сначала попадает в прокси.
- Прокси выполняет дополнительную логику (например, открывает транзакцию,
  проверяет кэш, подставляет актуальный экземпляр для scope) и, при
  необходимости, делегирует вызов реальному бину.
- После выполнения метода прокси может завершить транзакцию, записать лог или
  выполнить другие действия.

### **Пример работы**

```java

@Service
public class UserService {
    @Autowired
    private UserRepository repository;

    @Transactional
    public void saveUser(User user) {
        repository.save(user);
    }
}

@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    public String getRequestId() {
        return "ID: " + UUID.randomUUID().toString();
    }
}

@Component
public class MyService {
    @Autowired
    private UserService userService;
    @Autowired
    private RequestBean requestBean;

    public void process() {
        userService.saveUser(new User()); // Прокси для @Transactional управляет транзакцией
        System.out.println(requestBean.getRequestId()); // Прокси для scope подставляет актуальный экземпляр
    }
}
```

- Прокси для `UserService` добавляет транзакционную логику.
- Прокси для `RequestBean` подставляет новый экземпляр для каждого HTTP-запроса.

### **Ключевые особенности**

- **Самопроизвольные вызовы**:
    - Прокси перехватывает только внешние вызовы методов. Если метод, помеченный
      `@Transactional` или другим аспектом, вызывается внутри того же класса,
      прокси не срабатывает, и дополнительная логика (например, транзакция) не
      применяется.
    - Решение: Вынести метод в отдельный бин или использовать `AspectJ` вместо
      прокси.
- **Производительность**:
    - Прокси добавляют небольшой оверхед, но он минимален в большинстве случаев.
- **Ограничения**:
    - CGLIB не работает с финальными классами или методами.
    - JDK Proxy требует, чтобы бин реализовал интерфейсы.

### **Связь с @Transactional**

- Аннотация `@Transactional` — один из основных случаев, когда Spring создаёт
  прокси. Прокси перехватывает вызовы методов, чтобы:
    - Открыть транзакцию перед выполнением метода.
    - Зафиксировать или откатить транзакцию после выполнения.
- Это реализуется через AOP, где прокси выступает как посредник,
  взаимодействующий с `PlatformTransactionManager`.

### **Связь с другими темами**

- **Scopes (request, session, application)**: Прокси используются для внедрения
  бинов с короткоживущими scopes в singleton-бины с помощью `proxyMode`.
- **ApplicationContext**: Прокси создаются в рамках `ApplicationContext`,
  который управляет бинами и их аспектами.
- **ServletContext**: В веб-приложениях прокси для scope `request`, `session`,
  `application` взаимодействуют с `ServletContext` для доступа к текущему
  HTTP-запросу или сессии.
- **DispatcherServlet**: Прокси часто используются в контексте, созданном
  `DispatcherServlet`, для работы с веб-специфичными бинами.

### **Практические замечания**

- Прокси — это мощный инструмент, который делает Spring гибким и модульным.
- Используйте `proxyMode = ScopedProxyMode.TARGET_CLASS` для классов без
  интерфейсов, а `ScopedProxyMode.INTERFACES` — для бинов с интерфейсами.
- Если требуется работа с внутренними вызовами или сложные аспекты, рассмотрите
  использование `AspectJ` вместо прокси.

Если вам нужен более детальный пример, разбор конкретного сценария или помощь с
конфигурацией, уточните, пожалуйста!

--------------------------------------------------------------------------------


## Зачем Spring создает прокси бинов?

Spring создаёт **прокси** для бинов по нескольким причинам, связанным с
управлением зависимостями, жизненным циклом бинов и предоставлением
дополнительных возможностей, таких как аспектно-ориентированное
программирование (AOP), транзакции, или работа с различными областями
видимости (scopes). Прокси позволяют Spring перехватывать вызовы методов бина и
добавлять дополнительную логику, не изменяя исходный код бина. Давайте разберём
основные причины кратко и понятно.

### **Основные причины создания прокси в Spring**

1. **Поддержка различных scopes (например, request, session, application)**:
    - **Проблема**: Когда бин с короткоживущим scope (например, `request` или
      `session`) внедряется в бин с долгоживущим scope (например, `singleton`),
      Spring должен подставлять актуальный экземпляр бина, соответствующий
      текущему контексту (например, текущему HTTP-запросу или сессии). Без
      прокси singleton-бин получил бы фиксированную ссылку на бин, созданный в
      момент инициализации, что привело бы к некорректной работе.
    - **Решение**: Spring использует `proxyMode` (например,
      `ScopedProxyMode.TARGET_CLASS` или `ScopedProxyMode.INTERFACES`) в
      аннотации `@Scope` для создания прокси. Прокси перехватывает вызовы
      методов и подставляет правильный экземпляр бина, соответствующий текущему
      контексту (например, текущему HTTP-запросу).
    - **Пример**:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestBean {
          public String getRequestId() {
              return "ID запроса: " + UUID.randomUUID().toString();
          }
      }
 
      @Component
      public class SingletonService {
          @Autowired
          private RequestBean requestBean;
 
          public void printRequestId() {
              System.out.println(requestBean.getRequestId()); // Прокси подставляет актуальный экземпляр
          }
      }
      ```
        - Здесь прокси для `RequestBean` обеспечивает, что `SingletonService`
          получает актуальный экземпляр `RequestBean` для каждого HTTP-запроса.

2. **Реализация аспектно-ориентированного программирования (AOP)**:
    - **Проблема**: Spring AOP позволяет добавлять сквозную функциональность (
      например, логирование, управление транзакциями, проверку безопасности) к
      методам бинов без изменения их кода.
    - **Решение**: Spring создаёт прокси для бинов, к которым применяются
      аспекты (например, аннотации `@Transactional`, `@Around`, или
      пользовательские аспекты). Прокси перехватывает вызовы методов и выполняет
      дополнительную логику, определённую в аспектах, до или после вызова
      целевого метода.
    - **Пример**:
      ```java
      @Service
      @Transactional
      public class UserService {
          public void saveUser() {
              System.out.println("Сохранение пользователя");
          }
      }
      ```
        - Spring создаёт прокси для `UserService`, чтобы обернуть вызов
          `saveUser()` в транзакцию (открытие, коммит или откат транзакции).

3. **Управление транзакциями**:
    - **Проблема**: Аннотация `@Transactional` требует, чтобы вызовы методов
      бина оборачивались в транзакции базы данных.
    - **Решение**: Spring использует прокси для перехвата вызовов методов,
      помеченных `@Transactional`, чтобы управлять транзакциями (например,
      начинать транзакцию перед вызовом метода и фиксировать её после).
    - **Механизм**: Прокси вызывает код управления транзакциями (например, из
      `PlatformTransactionManager`) перед и после выполнения метода.

4. **Ленивая инициализация (Lazy Initialization)**:
    - **Проблема**: Если бин помечен как `@Lazy`, он не должен создаваться при
      старте `ApplicationContext`, а только при первом обращении к нему.
    - **Решение**: Spring создаёт прокси, который заменяет реальный бин. При
      первом вызове метода прокси инициализирует настоящий бин и делегирует ему
      вызов.
    - **Пример**:
      ```java
      @Component
      @Lazy
      public class LazyBean {
          @PostConstruct
          public void init() {
              System.out.println("LazyBean создан");
          }
      }
      ```
        - Прокси для `LazyBean` создаётся при старте, но сам бин
          инициализируется только при первом обращении.

5. **Обработка аннотаций и дополнительных функций**:
    - Spring использует прокси для реализации аннотаций, таких как `@Async` (
      асинхронное выполнение методов) или `@Cacheable` (кэширование
      результатов).
    - **Пример**:
      ```java
      @Service
      public class CacheableService {
          @Cacheable("users")
          public User getUserById(Long id) {
              return new User(id, "User" + id);
          }
      }
      ```
        - Прокси перехватывает вызов `getUserById`, проверяет кэш и вызывает
          метод только если результат не закэширован.

### **Как Spring создаёт прокси?**

Spring использует два механизма для создания прокси:

1. **JDK Dynamic Proxy**:
    - Работает на уровне интерфейсов.
    - Используется, если бин реализует хотя бы один интерфейс и указано
      `proxyMode = ScopedProxyMode.INTERFACES`.
    - Создаёт прокси, реализующий интерфейсы бина, что позволяет перехватывать
      вызовы методов.
2. **CGLIB**:
    - Работает на уровне классов.
    - Используется, если указано `proxyMode = ScopedProxyMode.TARGET_CLASS` или
      если бин не реализует интерфейсы.
    - Создаёт подкласс целевого класса, перехватывающий вызовы методов.

### **Когда Spring создаёт прокси?**

Прокси создаются в следующих случаях:

- Бин имеет scope, требующий динамического доступа (например, `request`,
  `session`, `application`) с `proxyMode`.
- Бин помечен аннотациями, связанными с AOP (например, `@Transactional`,
  `@Async`, `@Cacheable`).
- Применяются пользовательские аспекты через `@Aspect` или конфигурацию AOP.
- Бин помечен как `@Lazy`.
- Используются аннотации, требующие перехвата вызовов (например, `@Scope` с
  прокси, `@Configuration` для перехвата вызовов `@Bean`).

### **Почему прокси важен?**

- **Гибкость**: Прокси позволяют добавлять функциональность (например,
  транзакции, логирование) без изменения кода бина.
- **Совместимость scopes**: Обеспечивают корректное внедрение бинов с разными
  областями видимости.
- **Модульность**: Упрощают тестирование и замену компонентов, так как прокси
  изолирует логику от реализации.
- **Динамическое поведение**: Позволяют Spring управлять поведением бинов (
  например, ленивая загрузка, кэширование) без прямого вмешательства в их код.

### **Связь с предыдущими темами**

- **Scopes (request, session, application)**: Прокси (с `proxyMode`) необходимы
  для внедрения бинов с короткоживущими scopes в singleton-бины, чтобы
  подставлять актуальный экземпляр в зависимости от текущего HTTP-запроса или
  сессии.
- **ApplicationContext**: Прокси создаются в рамках `ApplicationContext` или
  `WebApplicationContext` для управления доступом к бинам.
- **ServletContext**: Бины в scope `application` используют прокси для доступа к
  данным, привязанным к `ServletContext`.
- **DispatcherServlet**: Дочерний `WebApplicationContext`, созданный
  `DispatcherServlet`, использует прокси для работы с request- и session-бинами
  в веб-приложении.

### **Пример полного сценария**

```java

@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    public String getRequestId() {
        return "ID запроса: " + UUID.randomUUID().toString();
    }
}

@Service
@Transactional
public class UserService {
    @Autowired
    private RequestBean requestBean;

    public void processUser() {
        System.out.println("Обработка пользователя в транзакции");
        System.out.println(requestBean.getRequestId()); // Прокси подставляет актуальный RequestBean
    }
}
```

- Здесь прокси создаётся:
    - Для `RequestBean` (из-за `proxyMode = ScopedProxyMode.TARGET_CLASS`),
      чтобы подставлять новый экземпляр для каждого HTTP-запроса.
    - Для `UserService` (из-за `@Transactional`), чтобы обернуть вызовы методов
      в транзакции.

### **Практические замечания**

- **CGLIB vs JDK Proxy**: Используйте `TARGET_CLASS` для классов без интерфейсов
  или если требуется проксирование всего класса. Используйте `INTERFACES` для
  большей производительности, если бин реализует интерфейсы.
- **Оверхед**: Прокси добавляют небольшой накладной расход, но это оправдано их
  гибкостью.
- **Ограничения**: Прокси не перехватывают вызовы внутренних методов (например,
  если метод A вызывает метод B в том же классе, AOP-логика не сработает, так
  как вызов не проходит через прокси).


--------------------------------------------------------------------------------


## @Transactional и Proxy в Spring

Аннотация **`@Transactional`** в Spring Framework тесно связана с механизмом *
*прокси бинов**, так как Spring использует прокси для реализации управления
транзакциями. Прокси позволяют перехватывать вызовы методов бина, чтобы добавить
логику управления транзакциями (например, начало, коммит или откат транзакции)
без изменения исходного кода бина. Давайте разберём эту связь кратко и понятно.

### **Как @Transactional использует прокси?**

1. **Роль @Transactional**:
    - Аннотация `@Transactional` указывает, что метод или класс должен
      выполняться в рамках транзакции базы данных.
    - Она применяется к бинам (например, сервисам), чтобы обеспечить
      атомарность, согласованность, изоляцию и долговечность (ACID) при
      выполнении операций с базой данных.
    - Пример:
      ```java
      @Service
      public class UserService {
          @Transactional
          public void saveUser(User user) {
              // Логика сохранения пользователя в базе данных
          }
      }
      ```

2. **Почему нужен прокси?**:
    - Spring не изменяет код бина напрямую. Вместо этого он создаёт *
      *прокси-объект**, который оборачивает целевой бин (например,
      `UserService`).
    - Прокси перехватывает вызовы методов, помеченных `@Transactional`, и
      добавляет логику управления транзакциями:
        - **До вызова метода**: Открывает транзакцию (например, через
          `PlatformTransactionManager`).
        - **После успешного выполнения**: Фиксирует (commit) транзакцию.
        - **При исключении**: Откатывает (rollback) транзакцию.
    - Это реализуется с помощью **AOP (аспектно-ориентированного
      программирования)**, где прокси действует как посредник между вызывающим
      кодом и целевым бином.

3. **Механизм создания прокси**:
    - Spring создаёт прокси для бинов, помеченных `@Transactional`, используя
      один из двух подходов:
        - **JDK Dynamic Proxy**:
            - Используется, если бин реализует хотя бы один интерфейс.
            - Прокси реализует интерфейсы бина и перехватывает вызовы методов.
            - Подходит, если вы используете интерфейсы (например, `UserService`
              реализует `IUserService`).
        - **CGLIB**:
            - Используется, если бин не реализует интерфейсы или если явно
              указано проксирование на уровне класса.
            - Создаёт подкласс целевого бина для перехвата вызовов.
            - Требует зависимости `cglib` (включена по умолчанию в Spring).
    - Выбор между JDK Proxy и CGLIB зависит от конфигурации и структуры бина.
      Например, аннотация
      `@EnableTransactionManagement(proxyTargetClass = true)` заставляет Spring
      использовать CGLIB даже для бинов с интерфейсами.

4. **Как это работает на практике**:
    - Когда вы вызываете метод, помеченный `@Transactional`, вызов сначала
      попадает в прокси.
    - Прокси проверяет наличие аннотации `@Transactional` и её параметры (
      например, `propagation`, `isolation`, `rollbackOn`).
    - Прокси взаимодействует с `PlatformTransactionManager` для:
        - Открытия транзакции (например, получение соединения с базой данных).
        - Выполнения целевого метода.
        - Фиксации или отката транзакции в зависимости от результата.
    - После этого прокси возвращает управление вызывающему коду.

### **Пример работы**

```java

@Service
public class UserService {
    @Autowired
    private UserRepository repository;

    @Transactional
    public void saveUser(User user) {
        repository.save(user); // Сохранение в базе
        // Если здесь произойдёт исключение, транзакция откатится
    }
}
```

- Spring создаёт прокси для `UserService`.
- При вызове `saveUser`:
    - Прокси открывает транзакцию (например, через
      `DataSourceTransactionManager`).
    - Вызывает `repository.save(user)`.
    - Если метод завершился успешно, прокси фиксирует транзакцию.
    - Если выброшено исключение (по умолчанию `RuntimeException` или его
      подклассы), прокси откатывает транзакцию.

### **Ключевые особенности**

- **Перехват вызовов**:
    - Прокси работает только для **внешних вызовов** методов. Если метод,
      помеченный `@Transactional`, вызывается внутри того же класса (внутренний
      вызов), прокси не срабатывает, и транзакция не создаётся. Это называется *
      *проблема самопроизвольного вызова** (self-invocation).
    - Пример:
      ```java
      @Service
      public class UserService {
          @Transactional
          public void saveUser(User user) {
              updateUser(user); // Транзакция НЕ применяется, так как вызов внутренний
          }
  
          @Transactional
          public void updateUser(User user) {
              // Логика
          }
      }
      ```
        - Чтобы избежать этого, можно:
            - Вынести метод в другой бин.
            - Использовать `@Transactional` на уровне класса.
            - Применить `AspectJ` вместо прокси (требует дополнительной
              настройки).

- **Конфигурация**:
    - Для включения поддержки `@Transactional` используется аннотация
      `@EnableTransactionManagement` в конфигурации:
      ```java
      @Configuration
      @EnableTransactionManagement
      public class AppConfig {
          @Bean
          public PlatformTransactionManager transactionManager() {
              return new DataSourceTransactionManager(dataSource());
          }
      }
      ```
    - Прокси создаются автоматически для всех бинов, помеченных
      `@Transactional`.

- **Параметры @Transactional**:
    - Прокси учитывает настройки аннотации, такие как:
        - `propagation`: Правила создания/использования транзакций (например,
          `REQUIRED`, `NESTED`).
        - `isolation`: Уровень изоляции транзакции.
        - `rollbackOn`: Какие исключения вызывают откат транзакции.
    - Прокси применяет эти настройки при управлении транзакцией.

### **Связь с другими аспектами Spring**

- **AOP**: `@Transactional` — это аспект, реализованный через AOP. Прокси — это
  механизм, который позволяет Spring применять аспекты к методам бинов.
- **Scopes**: Прокси также используются для поддержки scope `request`,
  `session`, и `application` (как обсуждалось ранее), чтобы подставлять
  актуальные экземпляры бинов. Хотя это другой случай использования прокси, он
  показывает, как Spring использует прокси для разных целей.
- **ApplicationContext**: Прокси создаются в рамках `ApplicationContext`,
  который управляет бинами и их зависимостями.
- **DispatcherServlet**: В веб-приложениях `@Transactional` часто используется в
  сервисах, вызываемых контроллерами из `DispatcherServlet`, а прокси
  обеспечивает корректное управление транзакциями.

### **Почему прокси важен для @Transactional?**

- **Изоляция логики**: Прокси позволяет отделить логику транзакций от
  бизнес-логики бина.
- **Гибкость**: Можно настроить параметры транзакций (например, `propagation`,
  `isolation`) без изменения кода.
- **Автоматизация**: Spring автоматически управляет транзакциями, избавляя
  разработчика от ручного вызова `commit` или `rollback`.

### **Ограничения**

- **Самопроизвольные вызовы**: Как упомянуто, внутренние вызовы методов в одном
  бине не проходят через прокси, и `@Transactional` не срабатывает.
- **Производительность**: Прокси добавляют небольшой оверхед, но это обычно
  незначительно.
- **Финальные классы/методы**: CGLIB-прокси не работают с финальными классами
  или методами, так как они не могут быть переопределены. В таких случаях нужно
  использовать JDK-прокси или убрать `final`.

### **Пример полного сценария**

```java

@Configuration
@EnableTransactionManagement
public class AppConfig {
    @Bean
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(dataSource());
    }

    @Bean
    public DataSource dataSource() {
        // Конфигурация источника данных
        return new DriverManagerDataSource();
    }
}

@Service
public class UserService {
    @Autowired
    private UserRepository repository;

    @Transactional
    public void saveUser(User user) {
        repository.save(user);
        // Если здесь выбросится исключение, транзакция откатится
    }
}
```

- Spring создаёт прокси для `UserService`, чтобы обернуть вызов `saveUser` в
  транзакцию.
- Прокси взаимодействует с `PlatformTransactionManager` для управления
  транзакцией.

### **Связь с предыдущими темами**

- **Прокси для scopes**: Прокси, используемые для `@Transactional`, похожи на
  прокси для scope `request`, `session`, `application` (с `proxyMode`), так как
  оба механизма основаны на AOP и перехвате вызовов.
- **ApplicationContext**: Прокси для `@Transactional` создаются в рамках
  `ApplicationContext`, который управляет бинами и их аспектами.
- **ServletContext**: В веб-приложениях `@Transactional` часто используется в
  сервисах, вызываемых из контроллеров в `DispatcherServlet`, а прокси
  обеспечивает корректное выполнение транзакций в контексте HTTP-запросов.

