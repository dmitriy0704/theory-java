# SPRING

## Scope бинов

В Java Spring **scope** (область видимости) бина определяет, как и когда Spring
контейнер создаёт, управляет и уничтожает экземпляры бина. Область видимости
влияет на жизненный цикл и поведение бина в приложении. Spring поддерживает
несколько стандартных scope, а также позволяет определять собственные. Ниже
описаны основные scope с их особенностями.

### Основные scope бинов в Spring:

1. **Singleton** (Одиночка, по умолчанию):
    - **Описание**: Создаётся **один экземпляр** бина на весь контейнер. Все
      запросы к бину возвращают один и тот же объект.
    - **Особенности**:
        - Подходит для stateless-объектов (например, сервисы, репозитории).
        - Жизненный цикл полностью управляется контейнером, включая уничтожение
          при закрытии контекста.
    - **Пример использования**:
      ```java
      @Component
      @Scope("singleton") // Необязательно, так как это значение по умолчанию
      public class SingletonBean {
          // Логика
      }
      ```

2. **Prototype**:
    - **Описание**: Создаётся **новый экземпляр** бина при каждом запросе к
      нему.
    - **Особенности**:
        - Подходит для stateful-объектов, где каждый клиент должен работать с
          уникальным экземпляром.
        - Spring не управляет полным жизненным циклом: методы уничтожения (
          `@PreDestroy`, `destroy-method`) **не вызываются**.
    - **Пример использования**:
      ```java
      @Component
      @Scope("prototype")
      public class PrototypeBean {
          // Логика
      }
      ```

3. **Request**:
    - **Описание**: Создаётся **новый экземпляр** бина для каждого
      HTTP-запроса (доступно только в веб-приложениях с `ApplicationContext`).
    - **Особенности**:
        - Бин живёт в течение обработки одного HTTP-запроса.
        - Используется для хранения данных, специфичных для запроса (например,
          данные формы).
        - Требуется зависимость `spring-web`.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestBean {
          // Логика
      }
      ```

4. **Session**:
    - **Описание**: Создаётся **один экземпляр** бина на всю HTTP-сессию
      пользователя.
    - **Особенности**:
        - Бин живёт, пока активна сессия пользователя (например, для хранения
          пользовательских данных, таких как корзина покупок).
        - Требуется `spring-web`.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class SessionBean {
          // Логика
      }
      ```

5. **Application**:
    - **Описание**: Создаётся **один экземпляр** бина на весь жизненный цикл
      `ServletContext` (веб-приложения).
    - **Особенности**:
        - Бин общий для всех пользователей приложения.
        - Используется редко, для глобальных ресурсов приложения.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class ApplicationBean {
          // Логика
      }
      ```

6. **WebSocket**:
    - **Описание**: Создаётся **один экземпляр** бина на всю сессию
      WebSocket-соединения.
    - **Особенности**:
        - Используется для работы с WebSocket в Spring.
        - Доступно в приложениях, использующих WebSocket (требуется
          `spring-websocket`).
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class WebSocketBean {
          // Логика
      }
      ```

### Кастомные scope:

- Spring позволяет создавать **пользовательские scope** путём реализации
  интерфейса `org.springframework.beans.factory.config.Scope`.
- Пример: scope для пула потоков или специфичных бизнес-логики.

### Проксирование (proxyMode):

- Для scope, таких как `request`, `session`, или `websocket`, часто используется
  `proxyMode` (например, `ScopedProxyMode.TARGET_CLASS` или
  `ScopedProxyMode.INTERFACES`), чтобы бин мог быть внедрён в singleton-бины.
  Это создаёт прокси, который делегирует вызовы к нужному экземпляру в
  зависимости от контекста (например, текущего HTTP-запроса).

### Как задать scope:

1. **Через аннотации**:
   ```java
   @Component
   @Scope("prototype")
   public class MyBean {
       // Логика
   }
   ```
2. **Через Java-конфигурацию**:
   ```java
   @Configuration
   public class AppConfig {
       @Bean
       @Scope("prototype")
       public MyBean myBean() {
           return new MyBean();
       }
   }
   ```
3. **Через XML**:
   ```xml
   <bean id="myBean" class="com.example.MyBean" scope="prototype"/>
   ```

### Важные замечания:

- **Singleton** — наиболее распространённый scope, так как минимизирует overhead
  на создание объектов.
- **Prototype** может привести к утечкам памяти, если экземпляры не очищаются
  вручную.
- Для веб-ориентированных scope (`request`, `session`, `application`) требуется
  включение поддержки через `spring-web` и настройка `ApplicationContext`.

---

## StateLess и StateFull объекты

В контексте программирования, в том числе Java и Spring, термины **stateless** (
без состояния) и **stateful** (состояние) описывают, как объекты хранят и
управляют данными между вызовами. Эти понятия важны для понимания поведения
бинов в Spring, особенно в контексте их scope (области видимости). Вот краткое и
ясное объяснение:

### **Stateless-объекты** (без состояния):

- **Определение**: Объект, который **не сохраняет данные** (состояние) между
  вызовами методов. Каждый вызов метода работает с входными параметрами, не
  завися от предыдущих операций.
- **Характеристики**:
    - Не хранит информацию о предыдущих вызовах (нет изменяемых полей, связанных
      с состоянием).
    - Потокобезопасен (thread-safe), так как не имеет общего изменяемого
      состояния.
    - Подходит для многократного использования одним экземпляром (например, в
      scope `singleton` в Spring).
- **Примеры**:
    - Сервисы в Spring, выполняющие операции без хранения данных (например,
      сервис для вычисления суммы двух чисел).
    - Утилитные классы с чистыми функциями.
  ```java
  @Component
  public class StatelessService {
      public int calculateSum(int a, int b) {
          return a + b; // Не сохраняет состояние
      }
  }
  ```
- **Когда использовать**: Для операций, которые не зависят от истории вызовов. В
  Spring такие объекты обычно делают `singleton`, чтобы минимизировать создание
  новых экземпляров.

### **Stateful-объекты** (с состоянием):

- **Определение**: Объект, который **сохраняет данные** (состояние) между
  вызовами методов. Состояние обычно хранится в полях объекта.
- **Характеристики**:
    - Хранит информацию, которая влияет на поведение при последующих вызовах (
      например, счётчик, пользовательские данные).
    - Не является потокобезопасным по умолчанию, так как несколько потоков могут
      изменять общее состояние.
    - В Spring часто используется с scope `prototype`, `request` или `session`,
      чтобы каждый клиент работал с уникальным экземпляром.
- **Примеры**:
    - Объект, представляющий корзину покупок пользователя, где добавленные
      товары сохраняются.
    - Объект, хранящий временные данные сессии.
  ```java
  @Component
  @Scope("prototype")
  public class StatefulBean {
      private int counter = 0; // Состояние

      public void increment() {
          counter++;
      }

      public int getCounter() {
          return counter;
      }
  }
  ```
- **Когда использовать**: Когда нужно сохранять данные между вызовами, например,
  для отслеживания состояния конкретного пользователя или процесса.

### **Ключевые различия**:

| Характеристика     | Stateless             | Stateful                                 |
|--------------------|-----------------------|------------------------------------------|
| Хранение состояния | Не хранит             | Хранит                                   |
| Потокобезопасность | Потокобезопасен       | Обычно не потокобезопасен                |
| Spring Scope       | Обычно `singleton`    | Обычно `prototype`, `request`, `session` |
| Пример             | Сервис для вычислений | Корзина покупок, сессия                  |

### **Связь с Spring**:

- **Singleton scope**: Подходит для **stateless**-объектов, так как один
  экземпляр используется всеми клиентами, и нет риска конфликтов из-за изменения
  состояния.
- **Prototype, request, session scope**: Используются для **stateful**-объектов,
  чтобы каждый клиент или запрос имел свой экземпляр, избегая проблем с общим
  состоянием.

### **Практические советы**:

- Предпочитайте **stateless**-объекты для повышения производительности и
  упрощения масштабирования.
- Используйте **stateful**-объекты только там, где состояние необходимо (
  например, для пользовательских данных).
- В Spring для stateful-бинов в веб-приложениях часто применяют scope `request`
  или `session` с `proxyMode` для корректного внедрения в singleton-бины.

Если нужен пример кода или разбор конкретного случая, дайте знать!


---

## Жизненный цикл бинов

Жизненный цикл бинов в контексте фреймворка Spring (если вы имеете в виду Java
Spring, так как запрос на русском языке и термин "бины" чаще всего ассоциируется
с этим фреймворком) состоит из нескольких этапов. Я опишу его кратко и понятно,
а если вам нужны детали или другой контекст, уточните, пожалуйста.

### Жизненный цикл бина в Spring:

1. **Создание экземпляра (Instantiation)**: Spring контейнер создаёт объект бина
   с помощью конструктора или фабричного метода.

2. **Заполнение свойств (Populate Properties)**: Контейнер внедряет зависимости,
   указанные в конфигурации (через XML, аннотации или Java-конфигурацию).

3. **Инициализация (Initialization)**:
    - Вызываются методы, помеченные аннотацией `@PostConstruct`, или методы,
      указанные в `init-method`.
    - Реализуются интерфейсы, такие как `InitializingBean` (метод
      `afterPropertiesSet`).

4. **Использование (Usage)**: Бин готов к использованию в приложении.

5. **Уничтожение (Destruction)**:
    - При завершении работы контейнера вызываются методы, помеченные
      `@PreDestroy`, или методы, указанные в `destroy-method`.
    - Реализуются интерфейсы, такие как `DisposableBean` (метод `destroy`).

### Дополнительные аспекты:

- **Bean Post Processors**: На этапах до и после инициализации могут быть
  вызваны методы `BeanPostProcessor` для дополнительной обработки.
- **Скоупы (Scopes)**: Жизненный цикл зависит от области видимости бина (
  `singleton`, `prototype`, `request`, и т.д.). Например, `prototype` бины не
  проходят этап уничтожения.
- **Aware-интерфейсы**: Если бин реализует интерфейсы, такие как
  `ApplicationContextAware` или `BeanNameAware`, Spring вызывает соответствующие
  методы для передачи контекста или имени бина.

### Пример:

```java

@Component
public class ExampleBean {
    @PostConstruct
    public void init() {
        System.out.println("Бин инициализирован!");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Бин уничтожен!");
    }
}
```

================ Удалить ====================
================ Удалить ====================
================ Удалить ====================
================ Удалить ====================
================ Удалить ====================
================ Удалить ====================






----------

## Как работать с аннотациями в Spring

### 1. Что такое аннотации?

Аннотация — это специальный мета-элемент в Java, который можно применять к
классам, методам, полям и другим элементам кода для передачи дополнительной
информации.

Spring использует собственные аннотации для:

- Определения компонентов (бинов)
- Управления зависимостями (внедрение зависимостей)
- Конфигурации транзакций
- Обработки аспектов и многое другое

### 2. Основные аннотации Spring

| Аннотация        | Назначение                                     |
|------------------|------------------------------------------------|
| `@Component`     | Определяет класс как компонент Spring (бин)    |
| `@Service`       | Специализация `@Component` для сервисного слоя |
| `@Repository`    | Специализация `@Component` для DAO слоя        |
| `@Controller`    | Для контроллеров MVC                           |
| `@Autowired`     | Внедрение зависимости по типу                  |
| `@Qualifier`     | Уточнение бина при внедрении                   |
| `@Value`         | Внедрение значений из свойств                  |
| `@Configuration` | Класс конфигурации Spring                      |
| `@Bean`          | Метод, создающий бин                           |
| `@Transactional` | Управление транзакциями                        |

### 3. Пример использования основных аннотаций

```java

@Service
public class UserService {

    private final UserRepository userRepository;

    // Внедрение зависимости через конструктор
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
    }
}
```

### 4. Как Spring обрабатывает аннотации?

- При запуске приложения Spring сканирует классы (если включён component
  scanning).
- Находит классы с аннотациями типа `@Component`, `@Service`, и регистрирует их
  как бины.
- Внедряет зависимости, помеченные `@Autowired`.
- Применяет дополнительные механизмы (например, проксирование для транзакций с
  помощью `@Transactional`).

### 5. Создание собственных аннотаций

Можно создавать свои аннотации, комбинируя существующие.

```java

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface MyCustomService {
}
```

Использование:

```java

@MyCustomService
public class MyService {
}
```

### 6. Включение поддержки аннотаций

В XML-конфигурации:

```xml

<context:component-scan base-package="com.example"/>
```

В Java-конфигурации:

```java

@Configuration
@ComponentScan("com.example")
public class AppConfig {
}
```

#### Итог

Работа с аннотациями в Spring — это декларативный способ настройки приложения:

- Помечаете классы и методы нужными аннотациями.
- Spring автоматически создаёт и управляет бинами.
- Упрощается внедрение зависимостей и управление поведением (например,
  транзакциями).

-------


---

### 🛠️ **Как работать с аннотациями в Spring Framework**

1. **Объявление компонентов**: Используйте аннотации, такие как `@Component`,
   `@Service`, `@Repository`, `@Controller` и т. д., чтобы указать Spring, что
   данный класс является компонентом и должен быть управляем контейнером Spring.

2. **Автоматическая инъекция зависимостей**: Используйте `@Autowired` для
   внедрения зависимостей в поля, конструкторы или методы. Это позволяет Spring
   автоматически подставить необходимые бины.

3. **Конфигурация с `@Configuration`**: Используйте аннотацию `@Configuration`
   для создания конфигурационных классов и `@Bean` для явного создания бинов.

4. **Работа с REST с `@RestController` и `@RequestMapping`**: Для создания
   RESTful API в Spring используйте аннотации `@RestController`, `@GetMapping`,
   `@PostMapping`, `@PutMapping` и т. д.

5. **Транзакции с `@Transactional`**: Используйте аннотацию `@Transactional` для
   указания, что метод или класс должен быть выполнен в рамках транзакции.

6. **Аспектно-ориентированное программирование (AOP)**: Для реализации
   аспектов (например, логирования или мониторинга) используйте `@Aspect` и
   аннотации AOP, такие как `@Before`, `@After`, `@Around`.

7. **Управление свойствами с `@Value`**: Для внедрения значений из
   конфигурационных файлов используйте аннотацию `@Value`.

---

### 🌍 **Заключение**

Работа с аннотациями в Spring значительно упрощает разработку, позволяя
автоматизировать множество процессов и конфигураций. Это сокращает количество
кода, который необходимо писать вручную, и делает систему более гибкой и
поддерживаемой. С помощью аннотаций Spring можно легко управлять компонентами,
конфигурациями, зависимостями и многими другими аспектами приложения.

## Как работают аннотации в Spring Framework

Аннотации в **Spring Framework** играют ключевую роль в **упрощении конфигурации
** и **управлении компонентами** в приложении. Они позволяют разработчику
избегать громоздкой XML-конфигурации и сделать код более читаемым и
поддерживаемым. Spring использует аннотации для **управления зависимостями**, *
*обработки аспектов** и **обработки транзакций**, а также для реализации *
*интерфейсов** и **конфигурации компонентов**.

Вот как работают аннотации в Spring Framework:

---

### 🔍 **Основные принципы работы с аннотациями в Spring**

1. **Управление зависимостями с помощью аннотаций**

   Spring использует аннотации для **инъекции зависимостей** и управления
   бинами. С помощью аннотаций контейнер Spring создает и управляет объектами,
   называемыми **бинами**.

- **`@Autowired`**: Для автоматической инъекции зависимостей в поля,
  конструкторы или методы.
  ```java
  @Component
  public class UserService {
      @Autowired
      private UserRepository userRepository;  // Инъекция зависимостей
  }
  ```

- **`@Component`**, **`@Service`**, **`@Repository`**, **`@Controller`**:
  Аннотации для пометки классов как компонентов Spring, которые могут быть
  автоматически зарегистрированы как бины.
    - **`@Component`**: Для любых компонентов.
    - **`@Service`**: Для классов с бизнес-логикой.
    - **`@Repository`**: Для классов, работающих с базой данных.
    - **`@Controller`**: Для контроллеров в Spring MVC.
    - **`@RestController`**: Для контроллеров в REST API.

  Пример с использованием **`@Service`**:
  ```java
  @Service
  public class UserService {
      public void registerUser(User user) {
          // Логика регистрации пользователя
      }
  }
  ```

2. **Конфигурация Spring с аннотациями**

   В Spring можно создавать бины и управлять конфигурацией с помощью аннотаций.

- **`@Configuration`**: Указывает, что класс содержит конфигурацию для
  Spring.
- **`@Bean`**: Указывает, что метод создает бин, который Spring должен
  зарегистрировать в контейнере.

  Пример:
  ```java
  @Configuration
  public class AppConfig {
      @Bean
      public UserService userService() {
          return new UserServiceImpl();
      }
  }
  ```

Этот класс `AppConfig` конфигурирует бины для контейнера Spring, создавая
объект `UserServiceImpl` с помощью метода `userService()`.

3. **Работа с транзакциями с помощью аннотаций**

   Аннотация **`@Transactional`** в Spring позволяет управлять транзакциями, что
   особенно полезно при работе с базой данных. Она автоматически обрабатывает
   начало и завершение транзакции для метода или класса, в зависимости от
   конфигурации.

   Пример:
   ```java
   @Service
   @Transactional  // Указывает, что все методы этого класса должны быть выполнены в рамках транзакции
   public class UserService {
       public void registerUser(User user) {
           // Логика регистрации с поддержкой транзакций
       }
   }
   ```

4. **AOP (Aspect-Oriented Programming) с аннотациями**

   **Aspect-Oriented Programming (AOP)** позволяет добавлять дополнительные
   функции (например, логирование, мониторинг) к существующему коду, не изменяя
   сам код.

   В Spring можно использовать аннотации для создания аспектов:

- **`@Aspect`**: Определяет аспект.
- **`@Before`, `@After`, `@Around`**: Аннотации для определения точек среза
  в коде.

Пример:

   ```java

@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Метод " + joinPoint.getSignature().getName() + " будет вызван.");
    }
}
   ```

В этом примере создается аспект, который будет выводить сообщение перед
вызовом любого метода в классе из пакета `com.example.service`.

5. **Обработка HTTP-запросов с помощью аннотаций**

   В **Spring MVC** и **Spring Boot** используются аннотации для обработки
   HTTP-запросов.

- **`@Controller`**: Помечает класс как контроллер Spring MVC.
- **`@RequestMapping`**, **`@GetMapping`**, **`@PostMapping`** и другие:
  Определяют маршруты для обработки HTTP-запросов.

Пример:

   ```java

@RestController
public class UserController {
    @Autowired
    private UserService userService;

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
}
   ```

В этом примере **`@RestController`** определяет, что класс будет обрабатывать
HTTP-запросы, а **`@GetMapping`** — это маршрут для обработки запросов типа
GET по URL `/users/{id}`.

6. **Работа с параметрами с помощью аннотаций**

   Для внедрения параметров из конфигурации (например, из
   `application.properties` или `application.yml`) используется аннотация *
   *`@Value`**.

   Пример:
   ```java
   @Component
   public class MyService {
       @Value("${app.name}")
       private String appName;

       public void printAppName() {
           System.out.println(appName);
       }
   }
   ```

   В этом примере Spring внедрит значение параметра `app.name` из конфигурации в
   поле `appName`.

---

### ⚙️ **Как Spring управляет аннотациями**

1. **Контейнер Spring** сканирует классы с аннотациями и автоматически
   регистрирует их как **бины** в контексте приложения.

- Это называется **`component scanning`**.
- Когда класс помечен аннотацией, Spring знает, что он должен создать
  экземпляр этого класса и управлять им.

2. **Инжекция зависимостей**:

- Spring использует аннотацию **`@Autowired`** для внедрения зависимостей.
  Это означает, что контейнер Spring автоматически находит и внедряет
  зависимости в поля, конструкторы или методы, помеченные этой аннотацией.

3. **Конфигурация с помощью аннотаций**:

- Аннотация **`@Configuration`** указывает, что класс содержит конфигурацию,
  а **`@Bean`** используется для явного создания бинов, которые Spring будет
  управлять.

4. **Транзакции**:

- Аннотация **`@Transactional`** помечает методы или классы, которые должны
  выполняться в рамках транзакции.

5. **AOP**:

- Аннотация **`@Aspect`** используется для создания аспектов, а аннотации *
  *`@Before`**, **`@After`** и **`@Around`** позволяют добавлять
  функциональность до, после или вокруг методов.

6. **Обработка HTTP-запросов**:

- Аннотации **`@Controller`**, **`@RequestMapping`** и их производные (
  например, **`@GetMapping`**) используются для обработки HTTP-запросов в
  приложении Spring MVC или Spring Boot.

---

### 💡 **Преимущества работы с аннотациями в Spring**

- **Упрощение конфигурации**: Аннотации позволяют избавиться от громоздкой
  XML-конфигурации.
- **Гибкость**: Легко настроить работу с бинами, зависимостями, аспектами и
  транзакциями.
- **Читаемость**: Код становится более компактным и понятным.
- **Автоматизация**: Spring автоматически управляет зависимостями и
  конфигурациями, что упрощает тестирование и поддержку.

---

### 🔑 **Заключение**

Аннотации в Spring Framework позволяют значительно упростить конфигурацию и
управление объектами в приложении. Они сокращают количество boilerplate-кода и
делают систему более гибкой и масштабируемой. С помощью аннотаций Spring
упрощает такие задачи, как внедрение зависимостей, управление транзакциями,
обработка HTTP-запросов и работа с аспектами.

# Transaction

Аннотация `@Transactional` в **Spring Framework** используется для обозначения
методов или классов, которые должны работать в рамках **транзакции**. Она
упрощает управление транзакциями, автоматически обрабатывая создание, коммиты и
откаты транзакций, что значительно упрощает работу с базой данных и другими
ресурсами.

### 📌 Основные моменты:

- **Транзакции** — это механизмы, которые обеспечивают **атомарность** операций,
  чтобы данные оставались согласованными, даже если система сталкивается с
  ошибками.
- **`@Transactional`** позволяет Spring автоматически управлять транзакциями,
  начиная их в момент вызова метода и заканчивая при его завершении (с коммитом
  или откатом, в зависимости от результата).

---

## 🚀 Как работает `@Transactional`?

Транзакция шаг за шагом

Отлично! Давай разберёмся, **как работает транзакция в Spring под капотом**,
когда ты используешь аннотацию `@Transactional`.

---

## 🔍 Что происходит, когда ты пишешь `@Transactional`

```java

@Service
public class OrderService {

    @Transactional
    public void createOrder() {
        // 1. Начинаем транзакцию
        // 2. Выполняем SQL/ORM операции
        // 3. Коммит или откат
    }
}
```

Ты вроде написал всего одну аннотацию, а на самом деле запускается целый
механизм:

---

## 🧩 Шаг за шагом — как это работает

### **1. Spring создает прокси**

Когда Spring видит аннотацию `@Transactional`, он не просто использует твой
класс напрямую, а **создает обёртку** (прокси), которая перехватывает вызовы
методов и добавляет транзакционную логику.

- Если ты используешь интерфейсы — применяется **JDK proxy**.
- Если нет интерфейсов — используется **CGLIB proxy** (динамическое
  наследование).

> Это важно: внутренние вызовы методов не проходят через прокси — именно поэтому
`@Transactional` может "не сработать", если вызвать метод изнутри того же
> класса.

---

### **2. Прокси перехватывает вызов метода**

Когда ты вызываешь `createOrder()`, на самом деле вызывается:

```
proxy.createOrder();
```

И тут Spring делает следующее:

#### ✅ Проверка контекста транзакции:

- Есть ли уже активная транзакция?
    - Если **да**, и `Propagation` = `REQUIRED` — используем её.
    - Если `REQUIRES_NEW` — **приостанавливаем текущую**, начинаем новую.
    - Если `NOT_SUPPORTED` — **приостанавливаем текущую** и выполняем без
      транзакции.
    - И т.д.

#### ✅ Вызов `TransactionManager`:

- Выбирается нужный `PlatformTransactionManager`.
- Вызывается метод `getTransaction()` → начинается транзакция.

---

### **3. Выполняется твой метод**

Теперь вызывается **реальный** метод `createOrder()`.

---

### **4. Коммит или откат**

После завершения метода:

- Если всё прошло без исключений → `commit`.
- Если было `RuntimeException` или `Error` → `rollback`.

> По умолчанию Spring откатывает **только unchecked exceptions** (например,
`RuntimeException`). Для checked-исключений (`IOException`, `SQLException`) —
> нужно указать явно:

```java
@Transactional(rollbackFor = IOException.class)
```

---

### **5. Завершение**

Текущая транзакция закрывается, и Spring "возвращает" выполнение дальше.

---

## ⚙ Пример жизненного цикла

```java

@Transactional
public void process() {
    dao.save();
    dao.update();
    if (someConditionFails()) {
        throw new RuntimeException("Oops");
    }
}
```

🧠 Под капотом:

1. `TransactionManager.begin()` — старт
2. `save()` и `update()` вызываются внутри транзакции
3. Если исключение — `rollback`
4. Если всё ок — `commit`

---

## 🚧 Подводные камни

- **Внутренний вызов метода** — не работает, транзакция не включится.
- **Не те исключения** — если не RuntimeException, то откат не произойдёт.
- **Неправильный уровень распространения (`Propagation`)** — можно нечаянно
  вложить транзакции или потерять их.

---

## 💬 Хочешь посмотреть пример, где используется `Propagation.REQUIRES_NEW` или

`rollbackFor`, чтобы лучше понять?

Когда вы аннотируете метод или класс аннотацией `@Transactional`, Spring
применяет специальное поведение, связанное с транзакциями, к этому методу или
всем методам в классе.

### 1. **Базовый пример**

```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class MyService {

    @Transactional
    public void someMethod() {
        // Логика работы с базой данных
    }
}
```

- В этом примере метод `someMethod()` будет выполняться в рамках транзакции.
- Если метод выполняется успешно, транзакция будет **коммичена** (подтверждена).
- Если в методе произойдёт исключение (например, ошибка в базе данных),
  транзакция будет **откатана**.

---

## 📚 Важные аспекты `@Transactional`

1. **Управление транзакциями**:

- **Начало транзакции** происходит сразу перед выполнением метода.
- **Коммит**: если метод завершился успешно, транзакция будет зафиксирована.
- **Откат**: если в методе произошло исключение, Spring автоматически
  откатит транзакцию, восстанавливая состояние данных до начала метода.

2. **По умолчанию откат на RuntimeException**:

   Spring откатывает транзакцию **по умолчанию только для unchecked exceptions
   ** (например, `RuntimeException`), но не для **checked exceptions** (
   например, `IOException` или `SQLException`).

3. **Сквозной аспект (Aspect-Oriented Programming, AOP)**:

   `@Transactional` работает на основе **аспектно-ориентированного
   программирования (AOP)**, что означает, что Spring создаёт прокси для класса,
   а сама транзакция управляется этим прокси. Это позволяет Spring автоматически
   перехватывать вызовы методов и оборачивать их в транзакции.

---

## 🔧 Настройки аннотации `@Transactional`

Аннотация `@Transactional` имеет несколько полезных атрибутов, которые позволяют
настроить поведение транзакции.

### 1. **`propagation`** — уровень распространения транзакции

**Уровень распространения** определяет, как Spring будет вести себя, если
существует уже активная транзакция:

- **`REQUIRED`** (по умолчанию): Если существует активная транзакция, то текущий
  метод будет выполнен в рамках этой транзакции. Если транзакции нет — она будет
  создана.
- **`REQUIRES_NEW`**: Всегда создаёт новую транзакцию. Если транзакция уже
  существует, она будет приостановлена.
- **`NESTED`**: Создаёт новую транзакцию, но внутри существующей. Это как
  вложенная транзакция, которая может быть откатана отдельно, не влияя на
  внешнюю.
- **`SUPPORTS`**: Если существует активная транзакция, метод будет выполнен в её
  рамках, если нет — транзакция не будет создана.
- **`NOT_SUPPORTED`**: Метод не будет выполнять транзакцию, если она есть.
- **`MANDATORY`**: Требует, чтобы существовала активная транзакция. Если
  транзакции нет, будет выброшено исключение.
- **`NEVER`**: Метод не может быть выполнен в транзакции. Если она существует,
  будет выброшено исключение.

Пример:

```java

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void someMethod() {
    // Логика, которая должна быть в новой транзакции
}
```

### 2. **`isolation`** — уровень изоляции транзакции

**Уровень изоляции** определяет, как транзакция будет взаимодействовать с
другими параллельными транзакциями:

- **`DEFAULT`**: Используется уровень изоляции по умолчанию, настроенный в базе
  данных.
- **`READ_COMMITTED`**: Гарантирует, что данные, которые транзакция читает, были
  зафиксированы.
- **`READ_UNCOMMITTED`**: Разрешает чтение "грязных" данных (неподтвержденных
  другими транзакциями).
- **`REPEATABLE_READ`**: Гарантирует, что данные, которые были прочитаны, не
  изменятся в течение транзакции.
- **`SERIALIZABLE`**: Самый высокий уровень изоляции, при котором транзакции
  выполняются последовательно, исключая всякую параллельность.

Пример:

```java

@Transactional(isolation = Isolation.SERIALIZABLE)
public void someMethod() {
    // Логика с самым высоким уровнем изоляции
}
```

### 3. **`timeout`** — время ожидания транзакции

**`timeout`** позволяет задать максимальное время, в течение которого транзакция
должна быть завершена. Если транзакция не завершится за это время, она будет
откатана.

Пример:

```java

@Transactional(timeout = 5)
public void someMethod() {
    // Этот метод будет завершён или откатан через 5 секунд
}
```

### 4. **`readOnly`** — режим только для чтения

Если транзакция не должна изменять данные (только читать), то можно пометить её
как **`readOnly`** для оптимизации. В некоторых случаях это позволяет базе
данных или другим компонентам системы оптимизировать выполнение транзакции.

Пример:

```java

@Transactional(readOnly = true)
public List<User> getAllUsers() {
    return userRepository.findAll();
}
```

### 5. **`rollbackFor` и `noRollbackFor`** — управление откатом

Эти атрибуты позволяют задать исключения, при которых транзакция будет откатана.

- **`rollbackFor`**: Указывает исключения, при которых транзакция должна быть
  откатана.
- **`noRollbackFor`**: Указывает исключения, при которых транзакция **не будет
  откатана**.

Пример:

```java

@Transactional(rollbackFor = SQLException.class)
public void someMethod() throws SQLException {
    // Транзакция откатится, если будет выброшено SQLException
}
```

---

## 💡 Пример использования `@Transactional`

```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public void createUserWithAddress(User user, Address address) {
        userRepository.save(user);
        addressRepository.save(address); // Это будет частью той же транзакции
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createUserWithNewTransaction(User user) {
        userRepository.save(user); // Создаст новую транзакцию
    }
}
```

---

## 🧩 Резюме:

1. **`@Transactional`** помогает управлять транзакциями, автоматически начиная
   их, коммитя или откатывая в случае ошибок.
2. Можно настроить **уровень изоляции**, **время ожидания**, и **поведение при
   ошибках**.
3. **`@Transactional`** работает через **AOP**, оборачивая методы или классы в
   транзакционный контекст.
4. **Использование различных атрибутов** позволяет гибко настраивать транзакции
   под разные бизнес-требования.

Если хочешь разобрать конкретный пример использования транзакций или других
атрибутов, скажи!

==========

### Проксирование для транзакций

Проксирование — ключевой механизм, который Spring использует для реализации
таких возможностей, как управление транзакциями через аннотацию
`@Transactional`.

### Что такое проксирование в контексте Spring и транзакций?

**Прокси (proxy)** — это объект-заместитель, который "оборачивает" оригинальный
объект (например, сервис), перехватывает вызовы его методов и добавляет
дополнительное поведение.

В случае транзакций прокси:

- При вызове метода с `@Transactional` прокси **открывает транзакцию** перед
  выполнением метода.
- Затем вызывает сам метод.
- После успешного завершения — **коммитит транзакцию**.
- Если метод выбрасывает исключение — **откатывает транзакцию**.

Таким образом, бизнес-логика остаётся чистой и не содержит кода управления
транзакциями — этим занимается прокси.

### Как это работает технически?

1. Spring создаёт прокси-объект для бина с `@Transactional`.
2. Вызов метода идёт через прокси.
3. Прокси запускает соответствующий код из Transaction Manager (
   начало/коммит/откат).
4. Затем прокси вызывает реальный метод целевого объекта.

### Виды проксирования в Spring

#### 1. JDK Dynamic Proxy

- Используется, если класс реализует интерфейс.
- Прокси создаётся на основе интерфейса.
- Ограничение: можно проксировать только методы интерфейса.

#### 2. CGLIB Proxy

- Используется, если класс не реализует интерфейс или явно указано.
- Создаётся подкласс целевого класса с переопределёнными методами.
- Позволяет проксировать любые методы класса.

## Пример

```java

@Service
public class UserService {

    @Transactional
    public void createUser(User user) {
        // здесь бизнес-логика
    }
}
```

При вызове `createUser()` фактически вызывается метод через прокси:

```text
Прокси:
  -> открыть транзакцию
  -> вызвать UserService.createUser()
  -> если успешно — коммит
  -> если ошибка — откат
```

### Почему важно понимать проксирование?

- Вызовы методов внутри того же класса **не проходят через прокси**, поэтому
  аннотация `@Transactional` не сработает при вызове метода из другого метода
  того же класса.

  ```java
  @Service
  public class MyService {
  
      @Transactional
      public void methodA() { ... }
  
      public void methodB() {
          methodA(); // @Transactional не сработает!
      }
  }
  ```

- Чтобы транзакции работали корректно, вызовы должны идти через
  Spring-контейнер (через прокси).

### Работа с аннотациями на примере @Transaction

Аннотация **`@Transactional`** в **Spring Framework** используется для
управления транзакциями в приложении, что позволяет обеспечить консистентность
данных при работе с базой данных. С помощью этой аннотации можно обозначить, что
определённый метод или класс должен работать в рамках одной транзакции, и Spring
автоматически будет управлять процессом начала, коммита и отката транзакции.

### 🛠️ **Основные моменты, которые стоит учитывать при работе

с `@Transactional`:**

1. **`@Transactional` на уровне класса и метода:**

- **На уровне метода:** Когда аннотация применяется на методе, транзакция будет
  начинаться и завершаться (коммититься или откатываться) для этого конкретного
  метода.
- **На уровне класса:** Если `@Transactional` применяется на уровне класса, то
  транзакция будет работать для всех методов этого класса (если только для
  метода не задано своё поведение).

2. **Типы транзакций:**

- **Программные транзакции** — Spring создает транзакции на основе операций с
  базой данных с помощью менеджера транзакций.
- **Менеджер транзакций:** Spring использует `PlatformTransactionManager` для
  управления транзакциями, например, `DataSourceTransactionManager` для работы с
  базой данных через JDBC.

3. **Поведение транзакций:**

- **Коммит и откат:** Если метод выполняется без ошибок, то транзакция будет
  зафиксирована (commit). Если произойдёт исключение, то транзакция будет
  откатана (rollback).
- **Типы исключений:** По умолчанию транзакция откатывается только в случае *
  *непроверяемых исключений** (наследников `RuntimeException`). Для *
  *проверяемых исключений** (наследников `Exception`) транзакция не будет
  откатана, если это явно не указано в аннотации.

---

### 🚀 **Пример работы с аннотацией `@Transactional`**

Допустим, у нас есть приложение с двумя сервисами: один для регистрации
пользователей, а другой для обработки заказов.

1. **Создание сервиса с транзакционными методами:**

   В нашем примере создадим два сервиса, которые используют аннотацию
   `@Transactional` для работы с базой данных.

   ```java
   @Service
   public class UserService {

       @Autowired
       private UserRepository userRepository;

       @Transactional  // Эта транзакция будет применяться ко всем методам класса
       public void registerUser(User user) {
           // Регистрация пользователя
           userRepository.save(user);
           // Логика бизнес-операции, например, отправка email и т.д.
       }
   }
   ```

   В этом примере метод `registerUser` будет работать в рамках транзакции. Если
   произойдёт ошибка в процессе сохранения пользователя, транзакция будет
   откатана.

2. **Пример транзакции с откатом для проверяемых исключений:**

   Если мы хотим, чтобы транзакция откатывалась и в случае проверяемых
   исключений (например, `SQLException`), нужно явно указать это в аннотации.

   ```java
   @Transactional(rollbackFor = SQLException.class)
   public void registerUser(User user) throws SQLException {
       userRepository.save(user);
       // Дополнительная логика, например, обработка заказов
       if (user.getOrder() == null) {
           throw new SQLException("Ошибка при обработке заказа");
       }
   }
   ```

   В данном примере, если произойдёт ошибка типа `SQLException`, транзакция
   будет откатана.

---

### 📦 **Пример работы с несколькими транзакциями:**

В некоторых случаях может понадобиться, чтобы несколько методов работали в
рамках одной транзакции. В таком случае можно просто применять `@Transactional`
на уровне класса, и все методы в классе будут работать в одной транзакции.

```java

@Service
@Transactional  // Все методы класса будут работать в рамках одной транзакции
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private UserService userService;

    public void processOrder(Order order, User user) {
        orderRepository.save(order);  // Это всё происходит в одной транзакции
        userService.registerUser(user);  // Это тоже часть той же транзакции
    }
}
```

В этом примере, если метод `registerUser` из `UserService` выбросит исключение,
транзакция, включая операцию сохранения заказа, будет откатана.

---

### 🧑‍💻 **Конфигурация `PlatformTransactionManager`**

Spring автоматически настроит `PlatformTransactionManager` в зависимости от
того, какой источник данных вы используете. Например:

- Для **JDBC** будет использован `DataSourceTransactionManager`.
- Для **JPA** будет использован `JpaTransactionManager`.

Если вы используете **Spring Boot**, настройка будет выполнена автоматически, и
вам не нужно будет вручную настраивать менеджер транзакций.

```java

@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }
}
```

Этот пример настраивает `JpaTransactionManager`, который будет управлять
транзакциями для работы с базой данных через JPA.

---

### 🔧 **Ключевые параметры аннотации `@Transactional`**

1. **`propagation`** — Определяет, как должна вести себя транзакция при вызове
   из другой транзакции:

- **`REQUIRED`** (по умолчанию): Если транзакция существует, она будет
  использована. Если её нет, то будет создана новая.
- **`REQUIRES_NEW`**: Каждое выполнение метода будет происходить в новой
  транзакции, независимо от того, существует ли уже текущая транзакция.
- **`NESTED`**: Создаётся вложенная транзакция внутри текущей.

2. **`isolation`** — Определяет уровень изоляции транзакции, например, *
   *`READ_COMMITTED`** или **`SERIALIZABLE`**.

3. **`timeout`** — Время в секундах, после которого транзакция будет откатана,
   если она не завершилась.

4. **`rollbackFor`** — Исключения, при которых должна быть выполнена откат
   транзакции (по умолчанию откат только для непроверяемых исключений).

5. **`noRollbackFor`** — Исключения, при которых откат транзакции не будет
   выполнен (по умолчанию транзакция не откатывается для проверяемых
   исключений).

---

### 🔄 **Транзакции и асинхронность**

Аннотация `@Transactional` не работает в асинхронных методах, например, в
`@Async`. В асинхронных методах нужно использовать другие подходы для управления
транзакциями.

Пример:

```java

@Async
@Transactional  // Не будет работать в асинхронном методе
public void asyncMethod() {
    // Операции с базой данных
}
```

Чтобы использовать транзакции в асинхронных методах, вам нужно вручную управлять
транзакциями, например, с использованием `TransactionTemplate`.

---

### 🚨 **Важные моменты**

1. **Работа с несколькими источниками данных**: Если в приложении используется
   несколько баз данных, можно настроить разные менеджеры транзакций для разных
   источников.
2. **Не забывайте об откате транзакций**: `@Transactional` по умолчанию
   откатывает транзакцию только для **непроверяемых исключений**. Для
   проверяемых нужно явно указать это через `rollbackFor`.
3. **Уровни изоляции и блокировки**: Уровень изоляции влияет на то, как
   транзакции будут взаимодействовать между собой в многозадачных приложениях.
   Выбор уровня изоляции может существенно повлиять на производительность.

---

### 📌 **Заключение**

Аннотация **`@Transactional`** в **Spring** помогает упростить управление
транзакциями и обеспечивать **атомарность операций** при работе с базой данных.
Она автоматически управляет процессом коммита и отката транзакций, а также
позволяет настроить поведение в различных сценариях (например, для проверки
исключений или задания уровня изоляции).

====
Да, можно вызывать метод с аннотацией `@Transactional` внутри другого метода,
также помеченного аннотацией `@Transactional`. Однако нужно учитывать несколько
важных моментов, чтобы это работало корректно.

### 1. **Влияние уровня распространения транзакции (`Propagation`)**

- Если оба метода помечены аннотацией `@Transactional` и используют уровень
  распространения по умолчанию (`Propagation.REQUIRED`), то оба метода будут
  работать в одной и той же транзакции. Это означает, что если один из методов
  завершится с ошибкой, то транзакция будет откатена для обоих методов.
- Если же уровни распространения транзакции в этих методах отличаются, например,
  один использует `Propagation.REQUIRES_NEW` (создание новой транзакции), то для
  каждого метода будет своя отдельная транзакция, и ошибки в одном методе не
  повлияют на другую.

### 2. **Важный момент: прокси и внутренняя вызовность**

- Важно понимать, что аннотация `@Transactional` работает через **прокси** (
  используется аспектно-ориентированное программирование, или AOP). Это
  означает, что транзакционная логика будет применяться только для **внешних
  вызовов методов**, то есть только когда метод вызывается из другого класса или
  из другого компонента.

Если метод с аннотацией `@Transactional` вызывается внутри того же класса (
например, из другого метода этого же класса), то транзакция **не будет**
корректно управляться. Это связано с тем, что прокси применяется только к
внешним вызовам, а внутри класса Java вызов метода будет обычным вызовом,
который не проходит через механизм транзакционного проксирования.

Чтобы это работало, необходимо, чтобы один метод был вызван **из другого
компонента** (например, с использованием Dependency Injection).

### 3. **Пример: внутренний вызов**

В следующем примере метод `methodB` вызывает метод `methodA` внутри того же
класса, и это не приведет к созданию новой транзакции, так как транзакции будут
управляться только при внешнем вызове:

   ```java

@Service
public class MyService {

    @Transactional
    public void methodA() {
        // Транзакция начнется здесь
        methodB();  // Внутренний вызов, транзакция не будет проксирована
    }

    @Transactional
    public void methodB() {
        // Транзакция начнется здесь, но на самом деле она не будет работать
        // корректно, так как вызов был внутри того же класса.
    }
}
   ```

В данном случае `methodB` не будет транзакционным, потому что он вызван из того
же класса, и Spring не применит прокси-транзакцию.

### 4. **Решение: использование инъекции зависимостей**

Чтобы транзакционная аннотация работала корректно при вызове метода из другого
метода в том же классе, вы должны инжектировать экземпляр текущего класса в тот
же класс (или использовать другой механизм). Пример:

   ```java

@Service
public class MyService {

    @Autowired
    private MyService self;  // инжекция самого себя

    @Transactional
    public void methodA() {
        // Транзакция начнется здесь
        self.methodB();  // Вызов через инжекцию приводит к правильному проксированию
    }

    @Transactional
    public void methodB() {
        // Транзакция будет правильно управляться
    }
}
   ```

Здесь `self.methodB()` вызовет метод через прокси, и транзакционная логика будет
корректно применена.

### 5. **Пример с разными уровнями распространения транзакции**

Если вы хотите, чтобы один метод создал новую транзакцию, а другой использовал
уже существующую, вы можете использовать разные уровни распространения
транзакций.

   ```java

@Service
public class MyService {

    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // Транзакция начнется здесь
        methodB();  // Внутренний вызов, метод будет использовать ту же транзакцию
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // В методе будет создана новая транзакция, независимо от текущей
    }
}
   ```

В данном примере, метод `methodA` будет использовать транзакцию, если она
существует, а метод `methodB` будет создавать свою собственную транзакцию (в
случае использования `REQUIRES_NEW`).

### **Заключение**

1. **Внешний вызов метода**: Если метод с аннотацией `@Transactional` вызывается
   из другого компонента, Spring правильно применяет транзакцию.
2. **Внутренний вызов метода**: Если метод с аннотацией `@Transactional`
   вызывается внутри того же класса, то транзакция не будет работать, так как
   транзакции управляются через прокси, а вызов метода внутри того же класса не
   приводит к проксированию.
3. **Использование разных уровней распространения** позволяет гибко управлять
   поведением транзакций при вызове методов.

Таким образом, если вы хотите использовать транзакции при вызове методов внутри
одного класса, нужно инжектировать сам класс (самого себя) и вызывать методы
через инжекцию, чтобы проксирование сработало.

====
Да, можно вызывать метод с аннотацией `@Transactional` из метода без этой
аннотации, и это будет работать, как ожидается, **при условии, что вызов
происходит из другого компонента** или другого слоя в приложении (например,
через Spring's Dependency Injection).

### Как работает `@Transactional`:

Аннотация `@Transactional` работает на основе **прокси**, и транзакционное
поведение применяется только тогда, когда метод вызывается **вне зависимости**
от самого объекта, то есть через проксирование.

Если метод с аннотацией `@Transactional` вызывается из другого метода, который
находится в другом классе или через Spring инъекцию, то **Spring создаст прокси
** для этого метода и обеспечит правильное управление транзакциями.

### Важные моменты:

1. **Внешний вызов метода**: Когда вы вызываете метод, помеченный аннотацией
   `@Transactional`, из метода без аннотации `@Transactional`, и этот вызов
   происходит через Spring (например, через инъекцию зависимостей), то
   транзакция будет создана и управляться для вызова этого метода. Метод,
   который не аннотирован `@Transactional`, не будет автоматически участвовать в
   транзакции. Однако сам вызов метода с `@Transactional` будет обработан
   Spring, и транзакция будет работать корректно.

2. **Внутренний вызов метода**: Важно заметить, что если метод с
   `@Transactional` вызывается внутри того же класса, это не приведет к
   корректному применению транзакции, так как прокси работает только для *
   *внешних вызовов**. Если же метод с аннотацией вызывается из другого класса,
   например, через инъекцию зависимостей, то транзакция будет работать, как
   ожидалось.

### Пример: Вызов метода с `@Transactional` из метода без этой аннотации

```java

@Service
public class MyService {

    @Autowired
    private AnotherService anotherService;  // Другой сервис с транзакционным методом

    public void methodWithoutTransaction() {
        // Этот метод не будет транзакционным, но вызовет метод с @Transactional
        anotherService.methodWithTransaction();
    }
}

@Service
public class AnotherService {

    @Transactional
    public void methodWithTransaction() {
        // Этот метод будет выполняться в рамках транзакции
        System.out.println("This method is transactional.");
    }
}
```

В данном примере:

- `methodWithoutTransaction()` не имеет аннотации `@Transactional`, но вызывает
  метод `methodWithTransaction()`, который помечен как транзакционный.
- Поскольку вызов `methodWithTransaction()` происходит через инъекцию
  зависимостей (то есть это внешний вызов), транзакция будет корректно
  управляться Spring для метода `methodWithTransaction()`.

### Важное ограничение:

- **Внутренний вызов**: Если вы вызовете метод с аннотацией `@Transactional` из
  другого метода **в том же классе**, транзакция не будет корректно применена.
  Прокси транзакций в Spring работает только для **внешних** вызовов, то есть
  вызов должен происходить через Spring (например, через инъекцию зависимостей).

Пример, где транзакция **не будет работать**:

```java

@Service
public class MyService {

    @Transactional
    public void methodWithTransaction() {
        // Транзакция начнется здесь
        methodWithoutTransaction();  // Вызов из того же класса, транзакция не будет применена
    }

    public void methodWithoutTransaction() {
        // Этот метод не будет транзакционным
    }
}
```

В этом случае, вызов `methodWithoutTransaction()` из `methodWithTransaction()`
не приведет к транзакционному поведению, так как вызов происходит внутри того же
класса, и прокси не срабатывает.

### Заключение:

- **Да**, можно вызывать метод с аннотацией `@Transactional` из метода, не
  помеченного этой аннотацией, если вызов происходит через Spring (например,
  через инъекцию зависимостей).
- Однако **если метод с аннотацией `@Transactional` вызывается внутри того же
  класса**, транзакция не будет применяться, так как прокси применяется только к
  внешним вызовам.

Поэтому всегда учитывайте, что Spring применяет проксирование только к **внешним
вызовам**.

====================

## ACID

**ACID** — это набор четырёх принципов, которые гарантируют, что транзакции в *
*системах управления базами данных (СУБД)** выполняются корректно и с
сохранением **целостности** данных, даже в случае сбоев или ошибок.

ACID — это аббревиатура, расшифровывается как:

1. **A** — **Atomicity** (Атомарность)
2. **C** — **Consistency** (Согласованность)
3. **I** — **Isolation** (Изоляция)
4. **D** — **Durability** (Долговечность)

Каждый из этих принципов играет важную роль в обеспечении корректной работы
транзакций в базе данных.

---

### 1. **Atomicity** (Атомарность)

**Атомарность** означает, что транзакция рассматривается как **единое целое**,
которое либо выполняется полностью, либо не выполняется вообще. Если в процессе
выполнения транзакции произошла ошибка, все изменения, сделанные в рамках
транзакции, будут откатаны, и база данных вернется в состояние, которое было до
её начала.

- **Пример**: Если транзакция включает в себя два действия, например, перевод
  денег с одного счёта на другой, и при этом происходит сбой при снятии денег,
  то операция будет отменена, и деньги не будут сняты.

---

### 2. **Consistency** (Согласованность)

**Согласованность** гарантирует, что транзакция переводит базу данных из одного
**консистентного состояния** в другое, соблюдая все бизнес-правила, ограничения
и инварианты, заданные для данных. Если транзакция завершена успешно, база
данных должна оставаться в консистентном состоянии. В случае сбоя транзакция не
должна приводить к нарушению целостности данных.

- **Пример**: Если в базе данных есть ограничения, например, на уникальность
  идентификаторов или на значения валюты, то транзакция должна быть такой, чтобы
  после её выполнения эти ограничения не нарушались.

---

### 3. **Isolation** (Изоляция)

**Изоляция** гарантирует, что транзакции выполняются независимо друг от друга, и
их результаты не могут быть видны другим транзакциям до завершения. Это
означает, что одна транзакция не может "увидеть" изменения, сделанные другой
транзакцией, если эта другая транзакция ещё не завершена (в зависимости от
уровня изоляции транзакций).

- **Пример**: Если две транзакции одновременно пытаются изменить один и тот же
  объект, одна из них должна быть заблокирована до завершения другой, чтобы
  избежать конфликтов и несогласованности данных.

---

### 4. **Durability** (Долговечность)

**Долговечность** гарантирует, что как только транзакция завершена (коммичена),
все её изменения будут сохранены в базе данных и не будут потеряны, даже если
произойдёт сбой системы, например, сбой питания или отключение компьютера.

- **Пример**: После того как вы перевели деньги на счёт другого человека,
  изменения должны остаться в базе данных даже если сервер упадет сразу после
  завершения транзакции.

==========

> ## Свойства транзакций ACID

- **Атомарность (Atomicity)** гарантирует, что никакая транзакция не будет
  зафиксирована в системе частично. Будут либо выполнены все операции, либо ни
  одной.

- **Согласованность (Consistency)**. Выполненая транзакция, сохраняет
  согласованность базы данных. Согласованность является более широким понятием,
  чем может показаться.<br>
  Например, в банковской системе может существовать требование равенства суммы,
  списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и
  оно не может быть гарантировано только проверками целостности базы данных. Это
  поведение должны учитывать программисты при написании кода транзакций. Если
  какая-либо транзакция произведёт списание, но не произведёт зачисления, то
  система останется в некорректном состоянии и свойство согласованности будет
  нарушено.

- **Изолированность (Isolation)**. Во время выполнения транзакции параллельные
  транзакции не должны оказывать влияние на её результат.
  Изолированность обходится дорого, поэтому в реальных базах данных существуют
  режимы, не полностью изолирующие транзакцию. Об уровнях изоляции мы поговорим
  в отдельной статье.

- **Устойчивость (Durability)**. Независимо от проблем с оборудованием,
  изменения, сделанные успешно завершённой транзакцией, должны остаться
  сохранёнными после возвращения системы в работу.

Конечно! Свойства **ACID** — это набор ключевых принципов, которые обеспечивают
надежность и корректность транзакций в системах управления базами данных (СУБД)
и других системах, работающих с данными.

### Что такое ACID?

ACID — это аббревиатура из четырёх свойств транзакций:

| Буква | Свойство                      | Описание                                                                                                   |
|-------|-------------------------------|------------------------------------------------------------------------------------------------------------|
| A     | Atomicity (Атомарность)       | Транзакция выполняется полностью или не выполняется вовсе. Нет частичных изменений.                        |
| C     | Consistency (Согласованность) | Транзакция переводит систему из одного корректного состояния в другое, сохраняя все правила и ограничения. |
| I     | Isolation (Изолированность)   | Параллельные транзакции не влияют друг на друга, как если бы они выполнялись последовательно.              |
| D     | Durability (Долговечность)    | После успешного завершения транзакции её изменения сохраняются навсегда, даже при сбоях.                   |

#### Подробнее о каждом свойстве

#### 1. Atomicity (Атомарность)

- Транзакция — это единое целое.
- Все операции внутри транзакции либо выполняются полностью, либо не выполняются
  вовсе.
- Если что-то пошло не так — все изменения откатываются.

**Пример:** перевод денег между счетами: списание с одного и зачисление на
другой — обе операции должны пройти вместе.

#### 2. Consistency (Согласованность)

- После выполнения транзакции база данных остаётся в корректном состоянии.
- Все бизнес-правила, ограничения целостности данных соблюдены.
- Транзакция не нарушает целостность данных.

**Пример:** сумма денег на счетах до и после перевода должна оставаться
неизменной.

#### 3. Isolation (Изолированность)

- Одновременное выполнение нескольких транзакций не должно приводить к
  некорректным результатам.
- Каждая транзакция "изолирована" от других до её завершения.
- В разных СУБД есть разные уровни изоляции (Read Uncommitted, Read Committed,
  Repeatable Read, Serializable).

**Пример:** если одна транзакция читает данные, другая не должна изменять их до
завершения первой.

#### 4. Durability (Долговечность)

- После успешного завершения транзакции её результаты сохраняются навсегда.
- Даже при сбое системы или отключении питания данные не теряются.
- Обычно достигается с помощью журналирования и записи на диск.

#### Итог

ACID гарантирует, что работа с данными будет:

- Надёжной,
- Предсказуемой,
- Безопасной от ошибок и сбоев.

Это фундамент для построения устойчивых систем с базами данных и другими
критичными приложениями.

====



---

## 🧩 Пример работы ACID принципов:

Предположим, у нас есть система, в которой два пользователя пытаются перевести
деньги с одного счёта на другой одновременно:

1. **Atomicity**:

- Если транзакция перевода денег с одного счёта на другой не может быть
  завершена полностью, например, из-за сбоя при списании средств, то все
  изменения, сделанные в процессе, откатываются.
- В случае ошибки данные остаются в том же состоянии, как до начала
  транзакции.

2. **Consistency**:

- Если у нас есть правило, что на счёте не может быть отрицательного
  баланса, то транзакция, которая приводит к нарушению этого правила (
  например, попытка снять больше денег, чем есть на счёте), будет отклонена.
- Это обеспечит сохранение целостности данных.

3. **Isolation**:

- Если два пользователя одновременно пытаются перевести деньги с одного
  счёта на другой, транзакции должны быть выполнены таким образом, чтобы
  изменения одного пользователя не мешали изменениям другого, либо одна из
  транзакций будет ожидать завершения другой.
- В результате, обе транзакции будут выполнены последовательно, или одна из
  них будет откатана, чтобы избежать конфликтов.

4. **Durability**:

- После того как транзакция завершена, переведённые деньги остаются на новом
  счёте, и изменения сохраняются, даже если система внезапно выйдет из
  строя.
- В случае сбоя при выполнении транзакции база данных будет в том состоянии,
  в котором она была до начала транзакции.

---

### 🌍 Применение ACID в реальных системах

1. **Базы данных**: В реляционных базах данных (например, MySQL, PostgreSQL,
   Oracle) принципы ACID обеспечиваются через механизмы управления транзакциями.

2. **Системы, работающие с деньгами**: Например, в банковских системах или
   приложениях для электронной коммерции важно, чтобы транзакции по переводу
   средств между пользователями всегда соблюдали принципы ACID.

3. **Системы с критичной целостностью данных**: Приложения, где важна точность и
   целостность информации, например, в медицинских, юридических и финансовых
   приложениях.

---

### 🔧 Проблемы с ACID

Хотя принципы ACID обеспечивают надежность и целостность данных, они могут *
*снижать производительность** системы. Строгая изоляция между транзакциями и
необходимость блокировать ресурсы могут привести к **потерям производительности
** при высокой нагрузке.

Для таких случаев появились **гибридные подходы** и новые типы баз данных,
например, **NoSQL базы данных**, которые используют более гибкие модели
изоляции (например, **BASE**), подходящие для масштабируемых и распределённых
систем.

---

### 💡 Резюме:

- **ACID** — это четыре принципа (Атомарность, Согласованность, Изоляция и
  Долговечность), которые гарантируют правильное выполнение транзакций в базах
  данных.
- Эти принципы обеспечивают **целостность данных**, **предсказуемость поведения
  ** и **стабильность работы системы**, несмотря на ошибки или сбои.
- Однако из-за требований к блокировкам и изоляции, принципы ACID могут *
  *снижать производительность**, особенно в системах с высокой нагрузкой.

Если интересуют подробности об одном из принципов или примеры их применения,
могу углубиться в конкретную тему!

### Реализация ACID в Spring

Конечно! В Spring Framework поддержка транзакций и обеспечение свойств ACID
реализуются через модуль **Spring Transaction Management**. Рассмотрим, как
Spring помогает реализовать каждое из свойств ACID на практике.

#### 1. Atomicity (Атомарность)

- В Spring атомарность достигается с помощью аннотации `@Transactional`.
- Все операции внутри метода, помеченного `@Transactional`, выполняются как
  единое целое.
- Если в процессе выполнения возникает исключение (например,
  `RuntimeException`), транзакция откатывается — все изменения отменяются.

**Пример:**

```java

@Service
public class BankService {

    @Transactional
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        debit(fromAccountId, amount);
        credit(toAccountId, amount);
        // Если здесь выбросится исключение — изменения откатятся
    }

    private void debit(Long accountId, BigDecimal amount) {
        // списание денег
    }

    private void credit(Long accountId, BigDecimal amount) {
        // зачисление денег
    }
}
```

#### 2. Consistency (Согласованность)

- Spring не проверяет бизнес-правила напрямую, но обеспечивает согласованность
  через интеграцию с СУБД.
- Все ограничения базы данных (например, внешние ключи, уникальные индексы)
  применяются при коммите транзакции.
- Если транзакция нарушает ограничения — она откатывается.

**Пример:**

Если в базе есть ограничение уникальности по email пользователя, попытка
сохранить дубликат вызовет ошибку и откатит транзакцию.

#### 3. Isolation (Изолированность)

- В Spring можно задать уровень изоляции транзакции через параметр `isolation` в
  `@Transactional`.

```java

@Transactional(isolation = Isolation.REPEATABLE_READ)
public void someMethod() {
    // ...
}
```

- Это позволяет контролировать видимость изменений между параллельными
  транзакциями и предотвращать аномалии чтения.

#### 4. Durability (Долговечность)

- Обеспечивается на уровне СУБД и системы хранения.
- Spring гарантирует вызов коммита транзакции после успешного выполнения метода.
- После коммита данные сохраняются в базе и не теряются при сбоях.

## Дополнительно: пример конфигурации

```java

@Configuration
@EnableTransactionManagement
public class AppConfig {

    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

#### Итог

| Свойство ACID | Как реализуется в Spring                       |
|---------------|------------------------------------------------|
| Atomicity     | Аннотация `@Transactional` + откат при ошибках |
| Consistency   | Интеграция с СУБД + ограничения базы данных    |
| Isolation     | Параметр `isolation` в `@Transactional`        |
| Durability    | Коммит транзакции + надёжное хранение данных   |

Если хочешь — могу помочь с примерами настройки уровней изоляции или обработкой
ошибок для управления откатом!

## Уровни изоляции транзакций

**Уровни изоляции транзакций** — это ключевая концепция в работе с базами
данных, которая определяет, как транзакции взаимодействуют друг с другом и как
их операции влияют на данные в условиях параллельного выполнения. Эти уровни
обеспечивают баланс между **производительностью** и **согласованностью** данных.

В **SQL** и **Spring** есть несколько стандартных уровней изоляции, которые
контролируют, насколько одна транзакция может «видеть» изменения, сделанные
другими транзакциями. Чем выше уровень изоляции, тем больше ограничений
накладывается на параллельные транзакции, чтобы избежать **нежелательных
эффектов**, но это может снижать производительность.

### 🔐 Уровни изоляции транзакций

1. **READ UNCOMMITTED** (Чтение неподтвержденных данных)
2. **READ COMMITTED** (Чтение только подтвержденных данных)
3. **REPEATABLE READ** (Повторяемое чтение)
4. **SERIALIZABLE** (Сериализуемый)

---

### 1. **READ UNCOMMITTED** (Чтение неподтвержденных данных)

- **Что это?**
  Этот уровень изоляции позволяет транзакциям читать данные, которые еще не были
  зафиксированы другими транзакциями. Это может привести к **грязным чтениям** (
  dirty reads), когда транзакция читает данные, которые могут быть отменены,
  если транзакция, которая их изменила, будет откатана.


- READ UNCOMMITTED (чтение незафиксированных или «грязных» данных)<br>
  наименее защищенный уровень изоляции, при котором транзакции способны читать
  незафиксированные изменения, сделанные другими транзакциями. При этом возможно
  считывание не только логически несогласованных данных, но и данных, изменения
  которых ещё не зафиксированы;

- **Проблемы:**
    - **Грязные чтения**: Транзакция может читать данные, которые могут быть
      откатаны, что приведет к недостоверной информации.
    - **Невозможность гарантировать консистентность**.

- **Когда использовать?**
  Этот уровень обычно используется, если необходимо получить **высокую
  производительность**, но если допустимы **неполные или неточные данные** (
  например, для отчетности, где точность не так критична).

---

### 2. **READ COMMITTED** (Чтение только подтвержденных данных)

- **Что это?**
  Транзакции могут читать только те данные, которые были **подтверждены**
  другими транзакциями (т.е. изменения, сделанные транзакциями, которые уже
  завершились, будут видны). Однако, если другая транзакция меняет данные во
  время чтения, текущая транзакция может получить разные данные при последующих
  чтениях одних и тех же строк (так называемое **неповторяемое чтение**).

- READ COMMITTED (чтение фиксированных данных)<br>
  исключается «грязное» чтение, транзакция увидит только изменения,
  зафиксированные другими транзакциями. Тем не менее, в процессе работы одной
  транзакции другая может быть успешно завершена и сделанные ею изменения
  зафиксированы. В итоге первая транзакция будет работать с другим набором
  данных. Большинство промышленных СУБД, в частности, Microsoft SQL Server,
  PostgreSQL и Oracle по умолчанию используют именно этот уровень изоляции;


- **Проблемы:**
    - **Неповторяемое чтение**: Транзакция может получить разные результаты при
      нескольких чтениях одних и тех же данных, если другая транзакция изменила
      их между чтениями.

- **Когда использовать?**
  Этот уровень изоляции — хороший компромисс между производительностью и
  консистентностью для большинства приложений, где требуется, чтобы транзакции
  не видели неподтвержденные изменения.

---

### 3. **REPEATABLE READ** (Повторяемое чтение)

- **Что это?**
  Этот уровень изоляции гарантирует, что данные, считанные транзакцией, не могут
  быть изменены другими транзакциями до завершения текущей транзакции.
  Транзакция не столкнется с **неповторяемыми чтениями**: если она прочитала
  данные, эти данные не изменятся, пока транзакция не завершится.

- REPEATABLE READ (повторяющееся чтение)<br>
  накладывает блокировки на обрабатываемые транзакцией строки и не допускает их
  изменения другими транзакциями. В результате транзакция видит только те
  строки, которые были зафиксированы на момент ее запуска. Однако другие
  транзакции могут вставлять новые строки, соответствующие условиям поиска
  инструкций, содержащихся в текущей транзакции. При повторном запуске
  инструкции текущей транзакцией будут извлечены новые строки, что приведёт к
  фантомному чтению. Это уровень изоляции по умолчанию в MySQL;


- **Проблемы:**
    - **Фантомные чтения**: Транзакция может столкнуться с ситуацией, когда
      новые строки данных появляются в результате других транзакций, несмотря на
      то, что сама транзакция видит стабильные данные.

- **Когда использовать?**
  Этот уровень подходит для приложений, где важно, чтобы данные, прочитанные в
  транзакции, оставались неизменными на протяжении всей транзакции. Например, в
  системах бронирования или финансовых приложениях, где важно, чтобы транзакция
  не "потеряла" информацию о том, что она уже прочитала.

---

### 4. **SERIALIZABLE** (Сериализуемый)

- **Что это?**
  Самый высокий уровень изоляции. Транзакции выполняются **по очереди**: каждая
  транзакция выполняется так, как если бы она была единственной в системе, и ее
  действия не могут пересекаться с действиями других транзакций. Это
  предотвращает **грязные чтения**, **неповторяемые чтения** и **фантомные
  чтения**.

- SERIALIZABLE (сериализуемость)<br>
  самый надежный уровень изоляции, полностью исключающий взаимное влияние
  транзакций. Только на этом уровне параллельные транзакции не подвержены
  эффекту «фантомного чтения».


- **Проблемы:**
    - **Производительность**: Это может значительно замедлить систему, потому
      что транзакции будут работать поочередно, а не параллельно.
    - **Блокировки**: Весь ряд данных, с которым работает транзакция, будет
      заблокирован для других, что может сильно снизить производительность
      системы при высокой нагрузке.

- **Когда использовать?**
  Используется, когда **требуется абсолютная консистентность** данных и при этом
  возможны **высокие задержки**. Например, в банковских системах или системах,
  где критически важна корректность финансовых данных.

---

## 🧩 Таблица уровней изоляции

| Уровень изоляции     | Грязные чтения | Неповторяемое чтение | Фантомные чтения | Пример применения                |
|----------------------|----------------|----------------------|------------------|----------------------------------|
| **READ UNCOMMITTED** | Разрешены      | Разрешены            | Разрешены        | Внешняя отчетность               |
| **READ COMMITTED**   | Запрещены      | Разрешены            | Разрешены        | Большинство веб-приложений       |
| **REPEATABLE READ**  | Запрещены      | Запрещены            | Разрешены        | Финансовые приложения            |
| **SERIALIZABLE**     | Запрещены      | Запрещены            | Запрещены        | Критические системы (банковские) |

---

## 🔧 Как установить уровень изоляции транзакции в Spring?

В Spring можно настроить уровень изоляции через аннотацию `@Transactional`,
используя атрибут `isolation`.

Пример:

```java
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

@Transactional(isolation = Isolation.SERIALIZABLE)
public void someMethod() {
    // Код, который будет выполнен с самым высоким уровнем изоляции
}
```

В Spring доступны следующие значения для **`Isolation`**:

- `Isolation.DEFAULT` — используется уровень изоляции по умолчанию (обычно это
  `READ_COMMITTED`).
- `Isolation.READ_UNCOMMITTED` — позволяет читать неподтвержденные данные.
- `Isolation.READ_COMMITTED` — запрещает грязные чтения.
- `Isolation.REPEATABLE_READ` — гарантирует отсутствие неповторяемых чтений.
- `Isolation.SERIALIZABLE` — самый строгий уровень изоляции.

---

## 💡 Резюме:

1. **`READ UNCOMMITTED`** — самый слабый уровень, позволяет грязные чтения.
2. **`READ COMMITTED`** — запрещает грязные чтения, но не исключает
   неповторяемые чтения.
3. **`REPEATABLE READ`** — гарантирует отсутствие неповторяемых чтений, но не
   защищает от фантомных чтений.
4. **`SERIALIZABLE`** — самый строгий уровень изоляции, исключает все виды
   конфликтов, но может сильно снижать производительность.

Выбор уровня изоляции зависит от потребностей вашего приложения: если вам нужно
**повышение производительности**, можно использовать **READ COMMITTED** или *
*READ UNCOMMITTED**; если важна **абсолютная консистентность** данных, лучше
выбрать **SERIALIZABLE**.

Если у тебя есть ещё вопросы или хочешь рассмотреть конкретный пример, не
стесняйся спрашивать!

## Проблемы связанные с уровнями изоляции

Каждый уровень изоляции транзакций в **базах данных** имеет свои **преимущества
** и **недостатки**. При настройке уровней изоляции важно учитывать баланс между
**производительностью** и **целостностью данных**. Хотя более строгие уровни
изоляции обеспечивают большую консистентность данных, они могут привести к *
*потере производительности** и другим проблемам, таким как блокировки и мёртвые
блокировки.

Основные проблемы, связанные с уровнями изоляции:

---

### 1. **Грязные чтения (Dirty Reads)** — **`READ UNCOMMITTED`**

- **Что это?**
    - **Грязные чтения** происходят, когда одна транзакция читает данные,
      которые были изменены другой транзакцией, но ещё не зафиксированы. Если
      транзакция, которая изменила данные, откатывается, то данные, прочитанные
      первой транзакцией, оказываются **невалидными**.

- **Проблема**:
    - Это может привести к ошибочным или некорректным данным, так как данные,
      прочитанные одной транзакцией, могут быть отменены другой.

- **Пример**:
    - Транзакция A считывает данные, которые были изменены транзакцией B, но
      транзакция B откатывает изменения. Транзакция A использует некорректные
      данные.

- **Решение**: Использовать более строгие уровни изоляции, такие как *
  *`READ COMMITTED`** или выше, чтобы исключить грязные чтения.

---

### 2. **Неповторяемое чтение (Non-repeatable Read)** — **`READ COMMITTED`**

- **Что это?**
    - **Неповторяемое чтение** происходит, когда транзакция читает данные, и в
      ходе своей работы другие транзакции изменяют эти данные. При следующем
      чтении тех же данных транзакция получит уже изменённые значения.

- **Проблема**:
    - Невозможность получить **консистентный результат** при нескольких чтениях
      одних и тех же данных в рамках одной транзакции. Это может привести к
      неправильным расчетам или решению, основанному на изменённых данных.

- **Пример**:
    - Транзакция A читает строку данных (например, баланс счета), а в это время
      транзакция B изменяет эти данные. Транзакция A, выполнив ещё одно чтение,
      может получить другие данные, чем при первом чтении.

- **Решение**: Использование уровня изоляции **`REPEATABLE READ`** или *
  *`SERIALIZABLE`** для блокировки данных и предотвращения их изменения другими
  транзакциями.

---

### 3. **Фантомные чтения (Phantom Reads)** — **`REPEATABLE READ`**

- **Что это?**
    - **Фантомные чтения** происходят, когда одна транзакция выполняет выборку
      набора строк (например, всех заказов, сумма которых больше 100 долларов),
      но в процессе выполнения другой процесс добавляет или удаляет строки.
      Когда транзакция повторно выполняет тот же запрос, она может увидеть новые
      строки, которые раньше не были частью результата выборки.

- **Проблема**:
    - Из-за изменения данных другим пользователем (добавление или удаление
      строк) результат выборки может измениться, что приводит к *
      *непредсказуемости** или **несогласованности данных**.

- **Пример**:
    - Транзакция A выполняет запрос для выборки всех заказов на сумму более 100
      долларов и получает 3 строки. В то время как транзакция A работает,
      транзакция B добавляет новый заказ на сумму 150 долларов. После завершения
      транзакции A тот же запрос даёт 4 строки, включая новый заказ.

- **Решение**: Использование уровня изоляции **`SERIALIZABLE`**, который
  блокирует изменения в наборе строк данных во время работы транзакции.

---

### 4. **Мёртвая блокировка (Deadlock)** — **`SERIALIZABLE`** и *

*`REPEATABLE READ`**

- **Что это?**
    - **Мёртвая блокировка** возникает, когда две или более транзакции блокируют
      друг друга, ожидая ресурсы, занятые другими транзакциями, образуя **цикл
      зависимостей**. Это приводит к тому, что транзакции не могут завершиться,
      и система остаётся в состоянии блокировки.

- **Проблема**:
    - Когда транзакции не могут быть выполнены, это может привести к **потере
      производительности** и **висению** системы, так как транзакции никогда не
      завершатся.

- **Пример**:
    - Транзакция A блокирует строку 1, а транзакция B блокирует строку 2.
      Транзакция A пытается получить блокировку на строку 2, а транзакция B
      пытается заблокировать строку 1. Обе транзакции ожидают друг друга, что
      приводит к **мёртвой блокировке**.

- **Решение**: Использование **таймаутов**, а также грамотная организация *
  *порядка блокировок** и использование **уровней изоляции**, минимизирующих
  необходимость в блокировках (например, **`READ COMMITTED`**).

---

### 5. **Проблемы с производительностью** — **`SERIALIZABLE`**

- **Что это?**
    - Уровень изоляции **`SERIALIZABLE`** представляет собой самый строгий
      уровень изоляции и блокирует все данные, с которыми работает транзакция.
      Это может привести к значительным **потерям производительности**, так как
      транзакции становятся последовательными, и система не может эффективно
      использовать многозадачность.

- **Проблема**:
    - **Медленная работа** системы, поскольку транзакции ожидают друг друга, что
      значительно снижает **пропускную способность** и **конкурентность**.

- **Решение**: Использование более слабых уровней изоляции, таких как *
  *`READ COMMITTED`** или **`REPEATABLE READ`**, в зависимости от потребностей
  приложения.

---

### 6. **Иллюзия согласованности (Phantom Read + Dirty Read)** — *

*`READ UNCOMMITTED`**

- **Что это?**
    - Когда транзакции выполняются с уровнем изоляции **`READ UNCOMMITTED`**,
      могут возникать не только грязные чтения, но и иллюзия согласованности
      данных. Например, транзакция может видеть изменения данных, которые будут
      отменены или изменены другой транзакцией.

- **Проблема**:
    - Это может привести к **некорректным решениям** или действиям, основанным
      на данных, которые не являются истинными (например, неправильные расчеты
      или отчеты).

- **Решение**: Повышение уровня изоляции транзакций до **`READ COMMITTED`** или
  выше для предотвращения грязных чтений и повышения надёжности работы с
  данными.

---

### 🔧 **Резюме: Проблемы и решения**

| Проблема                           | Уровень изоляции   | Описание проблемы                                               | Рекомендация                                       |
|------------------------------------|--------------------|-----------------------------------------------------------------|----------------------------------------------------|
| **Грязные чтения**                 | `READ UNCOMMITTED` | Чтение неподтвержденных данных.                                 | Использовать `READ COMMITTED` или выше.            |
| **Неповторяемое чтение**           | `READ COMMITTED`   | Изменение данных между чтениями одной транзакции.               | Использовать `REPEATABLE READ` или выше.           |
| **Фантомные чтения**               | `REPEATABLE READ`  | Изменение набора данных (добавление/удаление строк).            | Использовать `SERIALIZABLE`.                       |
| **Мёртвая блокировка**             | Все уровни         | Транзакции блокируют друг друга, ожидая освобождения ресурсов.  | Использовать таймауты и упорядочивание блокировок. |
| **Проблемы с производительностью** | `SERIALIZABLE`     | Очень строгие блокировки могут замедлить систему.               | Использовать более слабые уровни изоляции.         |
| **Иллюзия согласованности**        | `READ UNCOMMITTED` | Невозможность корректно работать с промежуточными результатами. | Использовать `READ COMMITTED` или выше.            |

---

Выбор уровня изоляции зависит от **конкретных требований** к приложению. Для
большинства приложений достаточно **`READ COMMITTED`** или **`REPEATABLE READ`
**, но для критичных данных (например, в банковских системах) лучше использовать
**`SERIALIZABLE`** с учётом того, что это может снизить производительность.



------


> ## Проблемы которые решают уровни изоляции

При параллельном выполнении транзакций возможны следую-
щие проблемы:

- **потерянное обновление** (lost update) -
  при одновременном
  изменении одного блока данных разными транзакциями теряются
  все изменения, кроме последнего. Т.е. в этом случае
  одна транзакция переписывает изменения, осуществленные
  другой транзакцией, в результате одно из изменений будет
  утеряно;

- **«грязное» чтение** (dirty read)- чтение данных, добавленных
  или изменённых транзакцией, которая впоследствии не подтвердится
  (откатится). В этом случае незафиксированные
  изменения, осуществленные одной транзакцией, читаются
  (или обновляются) другой. В случае перезаписи этих промежуточных
  значений или отката первой транзакции незафиксированные
  изменения могут быть отменены, а прочитавшая
  их транзакция с этого момента станет работать с неверными
  данными;

- **неповторяющееся чтение** (non-repeataЫe read) -
  при повторном
  чтении в рамках одной транзакции ранее прочитанные
  данные оказываются изменёнными. Возникает тогда,
  когда транзакция считывает из базы значение, после чего
  вторая транзакция обновляет это значение. Если в этот момент
  времени первая транзакция продолжает выполняться,
  то имеющиеся в ее распоряжении данные становятся неактуальными;

- **фантомное чтение (phantom reads)** - одна транзакция в ходе
  своего выполнения несколько раз выбирает множество
  строк по одним и тем же критериям. Другая транзакция в
  интервалах между этими выборками добавляет строки или
  изменяет столбцы некоторых строк, используемых в критериях
  выборки первой транзакции, и успешно заканчивается.
  В результате получится, что одни и те же выборки в первой
  транзакции дают разные множества строк.

### 1. Dirty Read (грязное чтение)

- **Что это?** Транзакция читает данные, которые были изменены другой
  транзакцией, но ещё не зафиксированы (не закоммичены).
- **Проблема:** Если другая транзакция откатится, то прочитанные данные окажутся
  недействительными.
- **Пример:** Транзакция A изменила значение, но не закоммитила. Транзакция B
  прочитала это значение. Если A откатится — B работала с неверными данными.

### 2. Non-repeatable Read (неповторяемое чтение)

- **Что это?** В рамках одной транзакции повторный запрос одних и тех же данных
  возвращает разные результаты из-за изменений другой транзакцией.
- **Проблема:** Нарушается согласованность данных при повторных чтениях.
- **Пример:** Транзакция A читает строку. Транзакция B изменяет эту строку и
  коммитит. При повторном чтении в A данные уже другие.

### 3. Phantom Read (фантомное чтение)

- **Что это?** При повторном выполнении запроса в рамках одной транзакции
  появляются новые строки, добавленные другой транзакцией.
- **Проблема:** Нарушается целостность выборки данных.
- **Пример:** Транзакция A выполняет запрос с условием (например, все заказы за
  сегодня). Транзакция B добавляет новый заказ и коммитит. При повторном запросе
  в A появляется "фантом" — новая строка.

#### Как уровни изоляции решают эти проблемы

| Уровень изоляции | Dirty Read   | Non-repeatable Read | Phantom Read |
|------------------|--------------|---------------------|--------------|
| Read Uncommitted | возможен     | возможен            | возможен     |
| Read Committed   | предотвращён | возможен            | возможен     |
| Repeatable Read  | предотвращён | предотвращён        | возможен     |
| Serializable     | предотвращён | предотвращён        | предотвращён |

#### Кратко о каждом уровне

- **Read Uncommitted:** Позволяет читать незакоммиченные данные — грязные чтения
  возможны.
- **Read Committed:** Запрещает грязные чтения, но неповторяемые и фантомные
  чтения остаются.
- **Repeatable Read:** Гарантирует стабильность прочитанных строк — нет грязных
  и неповторяемых чтений, но фантомы могут появляться.
- **Serializable:** Полная изоляция — все три проблемы исключены за счёт
  последовательного выполнения транзакций.

-----------

###

> ## Тип распространения транзакции

**Тип распространения транзакции (Transaction Propagation)** — это поведение,
определяющее, как транзакция ведёт себя при вызове одного транзакционного метода
из другого транзакционного метода. Другими словами, это правила, по которым
новая или существующая транзакция используется или создаётся при вложенных
вызовах.

#### Зачем это нужно?

В приложениях с бизнес-логикой часто один метод вызывает другой, и оба могут
быть помечены как транзакционные. Важно понять, будет ли использоваться одна
общая транзакция или для каждого метода создаётся своя.

#### Основные типы распространения транзакции (на примере Spring Framework):

| Тип распространения         | Описание                                                                                 |
|-----------------------------|------------------------------------------------------------------------------------------|
| **REQUIRED** (по умолчанию) | Если есть текущая транзакция — использовать её, иначе создать новую.                     |
| **REQUIRES_NEW**            | Всегда создавать новую транзакцию, при этом существующая (если есть) приостанавливается. |
| **SUPPORTS**                | Если есть текущая транзакция — использовать её, иначе работать без транзакции.           |
| **NOT_SUPPORTED**           | Всегда работать без транзакции, при этом существующая приостанавливается.                |
| **MANDATORY**               | Обязательно должна быть существующая транзакция, иначе выбрасывается исключение.         |
| **NEVER**                   | Никогда не работать в рамках транзакции, если она есть — выбрасывается исключение.       |
| **NESTED**                  | Если есть текущая транзакция — создать вложенную (savepoint), иначе создать новую.       |

#### Пример

```java

@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // ...
    methodB(); // вызов другого метода
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // ...
}
```

В этом примере:

- `methodA` запускает или использует текущую транзакцию.
- `methodB` всегда запускает новую отдельную транзакцию, приостанавливая ту, что
  была в `methodA`.

#### Почему это важно?

- Позволяет контролировать атомарность операций.
- Помогает избежать проблем с блокировками и откатами.
- Позволяет гибко управлять поведением вложенных операций.

## Подробнее рассказать про каждый тип с примерами!

В контексте Spring и транзакций под **распространением транзакции** (
transaction propagation) понимается поведение, которое определяет, как метод с
аннотацией `@Transactional` взаимодействует с уже существующей транзакцией при
вызове. Это очень важно для управления тем, когда транзакция создаётся заново,
когда используется существующая, а когда откатывается или коммитится.

### Основные типы распространения транзакций (Propagation) в Spring

Spring определяет несколько стратегий распространения транзакций через enum
`Propagation`. Рассмотрим самые распространённые и важные из них с примерами.

#### 1. `REQUIRED` (по умолчанию)

- **Что значит?**  
  Если текущая транзакция есть — использовать её. Если нет — создать новую.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // выполняется в текущей или новой транзакции
        serviceB.methodB();
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodB() {
        // будет выполнен в той же транзакции, что и methodA()
    }
}
```

- **Итог:**  
  `methodA()` и `methodB()` работают в одной транзакции.

#### 2. `REQUIRES_NEW`

- **Что значит?**  
  Всегда создаёт новую транзакцию. Если есть текущая — она приостанавливается до
  завершения новой.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        serviceB.methodB(); // новая транзакция
        // продолжение старой транзакции
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // выполняется в отдельной новой транзакции
    }
}
```

- **Итог:**  
  `methodB()` работает в своей собственной транзакции, независимо от
  `methodA()`. Если `methodB()` откатится — это не повлияет на основную
  транзакцию `methodA()`.

#### 3. `SUPPORTS`

- **Что значит?**  
  Если есть текущая транзакция — использовать её, если нет — выполнять без
  транзакции.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.SUPPORTS)
    public void methodA() {
        // если вызван из метода с транзакцией — будет в ней,
        // иначе без неё.
    }
}
```

- **Итог:**  
  Гибкое поведение: метод может работать как внутри, так и вне транзакции.

---

#### 4. `NOT_SUPPORTED`

- **Что значит?**  
  Метод всегда выполняется вне транзакции. Если есть текущая — она
  приостанавливается.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void methodA() {
        // выполняется без транзакции,
        // даже если вызывается из метода с ней.
    }
}
```

- **Итог:**  
  Используется для операций, которые не должны быть частью транзакции (например,
  чтение без блокировок).

---

#### 5. `MANDATORY`

- **Что значит?**  
  Метод должен вызываться только внутри существующей транзакции. Если нет —
  выбрасывается исключение.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.MANDATORY)
    public void methodA() {
        // если вызывается вне транзакции — ошибка!
    }
}
```

---

#### 6. `NEVER`

- **Что значит?**  
  Метод должен вызываться только вне транзакции. Если есть активная —
  выбрасывается исключение.

---

#### 7. `NESTED` (работает только с DataSourceTransactionManager)

- **Что значит?**  
  Создаёт вложенную (savepoint) транзакцию внутри текущей. При ошибке можно
  откатить только вложенную часть без отката всей внешней.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        serviceB.methodB(); // nested transaction внутри основной
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.NESTED)
    public void methodB() {
        // вложенная точка сохранения (savepoint)
        // можно откатить отдельно от основной.
    }
}
```

---

#### Краткое резюме

| Тип распространения | Поведение                                       | Когда использовать                      |
|---------------------|-------------------------------------------------|-----------------------------------------|
| REQUIRED            | Использует текущую или создаёт новую            | Большинство случаев                     |
| REQUIRES_NEW        | Всегда новая, приостанавливает текущую          | Независимые операции                    |
| SUPPORTS            | Использует текущую или без транзации            | Опциональная работа в/вне трансакций    |
| NOT_SUPPORTED       | Всегда без трансакций, приостанавливает текущую | Операции без блокировок                 |
| MANDATORY           | Только внутри существующей                      | Гарантия наличия трансакции             |
| NEVER               | Только вне трансакций                           | Гарантия отсутствия трансакции          |
| NESTED              | Вложенная (savepoint) внутри текущей            | Частичный откат внутри большой операции |
