# SPRING

## Scope бинов

В Java Spring **scope** (область видимости) бина определяет, как и когда Spring
контейнер создаёт, управляет и уничтожает экземпляры бина. Область видимости
влияет на жизненный цикл и поведение бина в приложении. Spring поддерживает
несколько стандартных scope, а также позволяет определять собственные. Ниже
описаны основные scope с их особенностями.

### Основные scope бинов в Spring:

1. **Singleton** (Одиночка, по умолчанию):
    - **Описание**: Создаётся **один экземпляр** бина на весь контейнер. Все
      запросы к бину возвращают один и тот же объект.
    - **Особенности**:
        - Подходит для stateless-объектов (например, сервисы, репозитории).
        - Жизненный цикл полностью управляется контейнером, включая уничтожение
          при закрытии контекста.
    - **Пример использования**:
      ```java
      @Component
      @Scope("singleton") // Необязательно, так как это значение по умолчанию
      public class SingletonBean {
          // Логика
      }
      ```

2. **Prototype**:
    - **Описание**: Создаётся **новый экземпляр** бина при каждом запросе к
      нему.
    - **Особенности**:
        - Подходит для stateful-объектов, где каждый клиент должен работать с
          уникальным экземпляром.
        - Spring не управляет полным жизненным циклом: методы уничтожения (
          `@PreDestroy`, `destroy-method`) **не вызываются**.
    - **Пример использования**:
      ```java
      @Component
      @Scope("prototype")
      public class PrototypeBean {
          // Логика
      }
      ```

3. **Request**:
    - **Описание**: Создаётся **новый экземпляр** бина для каждого
      HTTP-запроса (доступно только в веб-приложениях с `ApplicationContext`).
    - **Особенности**:
        - Бин живёт в течение обработки одного HTTP-запроса.
        - Используется для хранения данных, специфичных для запроса (например,
          данные формы).
        - Требуется зависимость `spring-web`.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestBean {
          // Логика
      }
      ```

4. **Session**:
    - **Описание**: Создаётся **один экземпляр** бина на всю HTTP-сессию
      пользователя.
    - **Особенности**:
        - Бин живёт, пока активна сессия пользователя (например, для хранения
          пользовательских данных, таких как корзина покупок).
        - Требуется `spring-web`.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class SessionBean {
          // Логика
      }
      ```

5. **Application**:
    - **Описание**: Создаётся **один экземпляр** бина на весь жизненный цикл
      `ServletContext` (веб-приложения).
    - **Особенности**:
        - Бин общий для всех пользователей приложения.
        - Используется редко, для глобальных ресурсов приложения.
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class ApplicationBean {
          // Логика
      }
      ```

6. **WebSocket**:
    - **Описание**: Создаётся **один экземпляр** бина на всю сессию
      WebSocket-соединения.
    - **Особенности**:
        - Используется для работы с WebSocket в Spring.
        - Доступно в приложениях, использующих WebSocket (требуется
          `spring-websocket`).
    - **Пример использования**:
      ```java
      @Component
      @Scope(value = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class WebSocketBean {
          // Логика
      }
      ```

### Кастомные scope:

- Spring позволяет создавать **пользовательские scope** путём реализации
  интерфейса `org.springframework.beans.factory.config.Scope`.
- Пример: scope для пула потоков или специфичных бизнес-логики.

### Проксирование (proxyMode):

- Для scope, таких как `request`, `session`, или `websocket`, часто используется
  `proxyMode` (например, `ScopedProxyMode.TARGET_CLASS` или
  `ScopedProxyMode.INTERFACES`), чтобы бин мог быть внедрён в singleton-бины.
  Это создаёт прокси, который делегирует вызовы к нужному экземпляру в
  зависимости от контекста (например, текущего HTTP-запроса).

### Как задать scope:

1. **Через аннотации**:
   ```java
   @Component
   @Scope("prototype")
   public class MyBean {
       // Логика
   }
   ```
2. **Через Java-конфигурацию**:
   ```java
   @Configuration
   public class AppConfig {
       @Bean
       @Scope("prototype")
       public MyBean myBean() {
           return new MyBean();
       }
   }
   ```
3. **Через XML**:
   ```xml
   <bean id="myBean" class="com.example.MyBean" scope="prototype"/>
   ```

### Важные замечания:

- **Singleton** — наиболее распространённый scope, так как минимизирует overhead
  на создание объектов.
- **Prototype** может привести к утечкам памяти, если экземпляры не очищаются
  вручную.
- Для веб-ориентированных scope (`request`, `session`, `application`) требуется
  включение поддержки через `spring-web` и настройка `ApplicationContext`.

---

## StateLess и StateFull объекты

В контексте программирования, в том числе Java и Spring, термины **stateless** (
без состояния) и **stateful** (состояние) описывают, как объекты хранят и
управляют данными между вызовами. Эти понятия важны для понимания поведения
бинов в Spring, особенно в контексте их scope (области видимости). Вот краткое и
ясное объяснение:

### **Stateless-объекты** (без состояния):

- **Определение**: Объект, который **не сохраняет данные** (состояние) между
  вызовами методов. Каждый вызов метода работает с входными параметрами, не
  завися от предыдущих операций.
- **Характеристики**:
    - Не хранит информацию о предыдущих вызовах (нет изменяемых полей, связанных
      с состоянием).
    - Потокобезопасен (thread-safe), так как не имеет общего изменяемого
      состояния.
    - Подходит для многократного использования одним экземпляром (например, в
      scope `singleton` в Spring).
- **Примеры**:
    - Сервисы в Spring, выполняющие операции без хранения данных (например,
      сервис для вычисления суммы двух чисел).
    - Утилитные классы с чистыми функциями.
  ```java
  @Component
  public class StatelessService {
      public int calculateSum(int a, int b) {
          return a + b; // Не сохраняет состояние
      }
  }
  ```
- **Когда использовать**: Для операций, которые не зависят от истории вызовов. В
  Spring такие объекты обычно делают `singleton`, чтобы минимизировать создание
  новых экземпляров.

### **Stateful-объекты** (с состоянием):

- **Определение**: Объект, который **сохраняет данные** (состояние) между
  вызовами методов. Состояние обычно хранится в полях объекта.
- **Характеристики**:
    - Хранит информацию, которая влияет на поведение при последующих вызовах (
      например, счётчик, пользовательские данные).
    - Не является потокобезопасным по умолчанию, так как несколько потоков могут
      изменять общее состояние.
    - В Spring часто используется с scope `prototype`, `request` или `session`,
      чтобы каждый клиент работал с уникальным экземпляром.
- **Примеры**:
    - Объект, представляющий корзину покупок пользователя, где добавленные
      товары сохраняются.
    - Объект, хранящий временные данные сессии.
  ```java
  @Component
  @Scope("prototype")
  public class StatefulBean {
      private int counter = 0; // Состояние

      public void increment() {
          counter++;
      }

      public int getCounter() {
          return counter;
      }
  }
  ```
- **Когда использовать**: Когда нужно сохранять данные между вызовами, например,
  для отслеживания состояния конкретного пользователя или процесса.

### **Ключевые различия**:

| Характеристика     | Stateless             | Stateful                                 |
|--------------------|-----------------------|------------------------------------------|
| Хранение состояния | Не хранит             | Хранит                                   |
| Потокобезопасность | Потокобезопасен       | Обычно не потокобезопасен                |
| Spring Scope       | Обычно `singleton`    | Обычно `prototype`, `request`, `session` |
| Пример             | Сервис для вычислений | Корзина покупок, сессия                  |

### **Связь с Spring**:

- **Singleton scope**: Подходит для **stateless**-объектов, так как один
  экземпляр используется всеми клиентами, и нет риска конфликтов из-за изменения
  состояния.
- **Prototype, request, session scope**: Используются для **stateful**-объектов,
  чтобы каждый клиент или запрос имел свой экземпляр, избегая проблем с общим
  состоянием.

### **Практические советы**:

- Предпочитайте **stateless**-объекты для повышения производительности и
  упрощения масштабирования.
- Используйте **stateful**-объекты только там, где состояние необходимо (
  например, для пользовательских данных).
- В Spring для stateful-бинов в веб-приложениях часто применяют scope `request`
  или `session` с `proxyMode` для корректного внедрения в singleton-бины.

Если нужен пример кода или разбор конкретного случая, дайте знать!


---

## Отличие области видимости Singleton от Application

    В Java Spring **Singleton** и **Application** — это два разных scope (области видимости) бинов, которые определяют, как и когда создаются и управляются экземпляры бинов в контейнере Spring. Хотя на первый взгляд они могут казаться похожими, между ними есть ключевые различия. Давайте разберём их подробно.

### **1. Singleton Scope**

- **Описание**: Это область видимости **по умолчанию** в Spring. В рамках одного
  **ApplicationContext** создаётся **один экземпляр** бина, который используется
  для всех запросов к этому бину.
- **Характеристики**:
    - Один экземпляр на **контейнер** (ApplicationContext).
    - Создаётся при инициализации контейнера (если не используется ленивая
      инициализация — `@Lazy`).
    - Живёт весь жизненный цикл контейнера и уничтожается при его закрытии.
    - Подходит для **stateless**-объектов (без состояния), таких как сервисы,
      репозитории, утилитные классы.
- **Контекст**: Привязан к **ApplicationContext**. Если в приложении несколько
  контекстов (например, родительский и дочерний), каждый контекст будет иметь
  свой собственный экземпляр singleton-бинов.
- **Пример использования**:
  ```java
  @Component
  @Scope("singleton") // Необязательно, так как это значение по умолчанию
  public class SingletonBean {
      public void doSomething() {
          System.out.println("Я singleton-бин!");
      }
  }
  ```

### **2. Application Scope**

- **Описание**: Создаётся **один экземпляр** бина на весь **ServletContext** (
  жизненный цикл веб-приложения). Этот scope доступен только в веб-приложениях
  Spring (требуется зависимость `spring-web`).
- **Характеристики**:
    - Один экземпляр на **веб-приложение** (ServletContext), а не на
      ApplicationContext.
    - Живёт весь жизненный цикл веб-приложения, независимо от того, сколько
      ApplicationContext создано в этом приложении.
    - Используется для глобальных ресурсов, которые должны быть общими для всех
      пользователей и всех контекстов в веб-приложении (например, глобальные
      конфигурации или кэши).
    - Обычно требует проксирования (`proxyMode = ScopedProxyMode.TARGET_CLASS`)
      для внедрения в бины с другими scope (например, singleton).
- **Контекст**: Привязан к **ServletContext**, который охватывает всё
  веб-приложение. Даже если в приложении несколько ApplicationContext (например,
  в DispatcherServlet и ContextLoaderListener), бин в application scope будет
  общим для всех.
- **Пример использования**:
  ```java
  @Component
  @Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
  public class ApplicationBean {
      public void doSomething() {
          System.out.println("Я application-бин!");
      }
  }
  ```

### **Ключевые отличия**:

| Характеристика             | Singleton Scope                           | Application Scope                           |
|----------------------------|-------------------------------------------|---------------------------------------------|
| **Привязка**               | К ApplicationContext                      | К ServletContext                            |
| **Количество экземпляров** | Один на каждый ApplicationContext         | Один на всё веб-приложение                  |
| **Контекст использования** | Любой Spring-приложение (веб или не веб)  | Только веб-приложения                       |
| **Жизненный цикл**         | Живёт, пока существует ApplicationContext | Живёт, пока существует ServletContext       |
| **Типичное применение**    | Stateless-бины (сервисы, репозитории)     | Глобальные ресурсы веб-приложения           |
| **Проксирование**          | Не требуется                              | Часто требуется для внедрения в другие бины |

### **Пример сценария**:

- **Singleton**: Если у вас есть сервис `UserService`, который выполняет
  операции с пользователями (без хранения состояния), он обычно будет в scope
  `singleton`. Если приложение использует несколько ApplicationContext (
  например, в сложной конфигурации с родительским и дочерним контекстами),
  каждый контекст создаст свой экземпляр `UserService`.
- **Application**: Если у вас есть бин `GlobalConfig`, который хранит глобальные
  настройки приложения (например, параметры подключения к внешнему сервису), он
  будет в scope `application`. Этот бин будет общим для всех контекстов в рамках
  одного веб-приложения, и все пользователи будут работать с одним экземпляром.

### **Когда использовать**:

- **Singleton**: Используйте для большинства бинов, особенно stateless, если вам
  не нужно разделять их между разными ApplicationContext или если вы работаете в
  невеб-приложении.
- **Application**: Используйте в веб-приложениях для глобальных ресурсов,
  которые должны быть общими для всех пользователей и всех контекстов в рамках
  одного ServletContext.

### **Практическая заметка**:

- В большинстве случаев `singleton` достаточно, так как он проще и покрывает
  большинство сценариев.
- `Application` scope редко используется, так как необходимость в глобальном
  бине, привязанном к ServletContext, возникает только в специфичных случаях (
  например, кэширование данных, общих для всего приложения).

Если вам нужен пример кода, демонстрация работы этих scope в приложении или
разъяснение какого-то аспекта, уточните, пожалуйста!




---

## Жизненный цикл бинов

Жизненный цикл бинов в контексте фреймворка Spring (если вы имеете в виду Java
Spring, так как запрос на русском языке и термин "бины" чаще всего ассоциируется
с этим фреймворком) состоит из нескольких этапов. Я опишу его кратко и понятно,
а если вам нужны детали или другой контекст, уточните, пожалуйста.

### Жизненный цикл бина в Spring:

1. **Создание экземпляра (Instantiation)**: Spring контейнер создаёт объект бина
   с помощью конструктора или фабричного метода.

2. **Заполнение свойств (Populate Properties)**: Контейнер внедряет зависимости,
   указанные в конфигурации (через XML, аннотации или Java-конфигурацию).

3. **Инициализация (Initialization)**:
    - Вызываются методы, помеченные аннотацией `@PostConstruct`, или методы,
      указанные в `init-method`.
    - Реализуются интерфейсы, такие как `InitializingBean` (метод
      `afterPropertiesSet`).

4. **Использование (Usage)**: Бин готов к использованию в приложении.

5. **Уничтожение (Destruction)**:
    - При завершении работы контейнера вызываются методы, помеченные
      `@PreDestroy`, или методы, указанные в `destroy-method`.
    - Реализуются интерфейсы, такие как `DisposableBean` (метод `destroy`).

### Дополнительные аспекты:

- **Bean Post Processors**: На этапах до и после инициализации могут быть
  вызваны методы `BeanPostProcessor` для дополнительной обработки.
- **Скоупы (Scopes)**: Жизненный цикл зависит от области видимости бина (
  `singleton`, `prototype`, `request`, и т.д.). Например, `prototype` бины не
  проходят этап уничтожения.
- **Aware-интерфейсы**: Если бин реализует интерфейсы, такие как
  `ApplicationContextAware` или `BeanNameAware`, Spring вызывает соответствующие
  методы для передачи контекста или имени бина.

### Пример:

```java

@Component
public class ExampleBean {
    @PostConstruct
    public void init() {
        System.out.println("Бин инициализирован!");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Бин уничтожен!");
    }
}
```

---

## ApplicationContext

**ApplicationContext** в Java Spring — это центральный интерфейс фреймворка,
представляющий **IoC-контейнер** (Inversion of Control), который управляет
жизненным циклом бинов, их конфигурацией и зависимостями в приложении. Это более
продвинутая и функциональная версия контейнера по сравнению с `BeanFactory`.
Давайте разберём, что это такое, кратко и понятно.

### **Что такое ApplicationContext?**

- **ApplicationContext** — это объект, который:
    - Создаёт, конфигурирует и управляет **бинами** (объектами, управляемыми
      Spring).
    - Обеспечивает **внедрение зависимостей** (Dependency Injection).
    - Предоставляет дополнительные возможности, такие как поддержка
      интернационализации, событий, доступа к ресурсам и работа в
      веб-приложениях.
- Он загружает конфигурацию приложения (из XML, Java-конфигураций или аннотаций)
  и создаёт контекст, в котором бины взаимодействуют.

### **Основные функции ApplicationContext**:

1. **Управление бинами**:
    - Создание, инициализация и уничтожение бинов.
    - Поддержка scope бинов (например, `singleton`, `prototype`).
2. **Внедрение зависимостей**:
    - Автоматическое связывание бинов через конструкторы, сеттеры или поля (с
      помощью `@Autowired`, `@Inject` и т.д.).
3. **Поддержка дополнительных возможностей**:
    - **Интернационализация** (i18n): работа с сообщениями на разных языках.
    - **События**: публикация и обработка событий в приложении.
    - **Доступ к ресурсам**: загрузка файлов, свойств и других ресурсов.
    - **Управление профайлами**: активация бинов в зависимости от окружения (
      `dev`, `prod`).
    - **Поддержка AOP**: интеграция с аспектно-ориентированным
      программированием.
4. **Контекст для веб-приложений**:
    - В веб-приложениях `ApplicationContext` может быть привязан к
      `ServletContext` (например, через `ContextLoaderListener` или
      `DispatcherServlet`).

### **Типы ApplicationContext**:

В зависимости от типа приложения и конфигурации используются разные реализации:

- **AnnotationConfigApplicationContext**: Для Java-конфигураций с аннотациями.
  ```java
  ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
  ```
- **ClassPathXmlApplicationContext**: Для XML-конфигураций из classpath.
  ```java
  ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
  ```
- **FileSystemXmlApplicationContext**: Для XML-конфигураций из файловой системы.
- **WebApplicationContext**: Для веб-приложений, интегрируется с
  `ServletContext`.

### **ApplicationContext в жизненном цикле приложения**:

1. **Загрузка конфигурации**: Читает конфигурацию (XML, Java, аннотации).
2. **Создание бинов**: Инициализирует бины согласно их scope (например,
   singleton создаётся сразу, если не ленивый).
3. **Внедрение зависимостей**: Связывает бины между собой.
4. **Инициализация**: Вызывает методы инициализации (`@PostConstruct`,
   `init-method`).
5. **Использование**: Приложение работает, бины доступны через
   `context.getBean()`.
6. **Уничтожение**: При закрытии контекста вызываются методы уничтожения (
   `@PreDestroy`, `destroy-method`).

### **Отличие от BeanFactory**:

- `BeanFactory` — более простой контейнер, предоставляющий базовые функции (
  создание и управление бинами).
- `ApplicationContext` расширяет `BeanFactory`, добавляя поддержку событий,
  интернационализации, веб-функционала и автоматической обработки аннотаций (
  например, `@Autowired`).

### **Пример использования**:

```java

@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}

@Component
public class MyBean {
    public void doSomething() {
        System.out.println("Работаю!");
    }
}

public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        MyBean bean = context.getBean(MyBean.class);
        bean.doSomething(); // Выведет: Работаю!
    }
}
```

### **Связь с Singleton и Application Scope**:

- **Singleton Scope**: Один экземпляр бина на один `ApplicationContext`. Если
  создано несколько контекстов, каждый будет иметь свой singleton-бин.
- **Application Scope**: Один экземпляр бина на весь `ServletContext` (в
  веб-приложении), общий для всех `ApplicationContext` в рамках одного
  веб-приложения.

### **Когда использовать**:

- **ApplicationContext** — стандартный выбор для большинства приложений Spring,
  так как он предоставляет полный набор функций.
- Используйте `BeanFactory` только в очень ограниченных сценариях (например, в
  средах с минимальными ресурсами).

---

## ServletContext

**ServletContext** в Java — это объект, предоставляемый веб-контейнером (
например, Tomcat, Jetty) в веб-приложениях, работающих на основе **Java Servlet
API**. Он представляет **контекст веб-приложения** и используется для хранения и
управления глобальными данными, ресурсами и конфигурацией, общими для всех
сервлетов и компонентов приложения. В контексте Spring **ServletContext** играет
важную роль, особенно для scope `application` и интеграции с веб-приложениями.
Давайте разберём кратко и понятно.

### **Что такое ServletContext?**

- **ServletContext** — это интерфейс, определённый в пакете `javax.servlet`,
  который создаётся веб-контейнером при запуске веб-приложения.
- Он действует как **глобальный контейнер данных** для всего приложения,
  позволяя:
    - Хранить общие данные (атрибуты) для всех сервлетов и пользователей.
    - Получать доступ к ресурсам приложения (например, файлам в папке
      `WEB-INF`).
    - Управлять конфигурацией приложения (например, параметрами из `web.xml`).
- Каждый веб-приложение имеет **один ServletContext**, который существует на
  протяжении всего жизненного цикла приложения (от старта до остановки сервера
  или приложения).

### **Основные функции ServletContext**:

1. **Хранение атрибутов**:
    - Позволяет сохранять и извлекать данные, доступные всем компонентам
      приложения (аналогично глобальной "карте" ключ-значение).
    - Пример:
      ```java
      ServletContext context = getServletContext();
      context.setAttribute("appName", "MyApp");
      String appName = (String) context.getAttribute("appName");
      ```
2. **Доступ к ресурсам**:
    - Предоставляет доступ к файлам и ресурсам веб-приложения (например, файлы в
      `/WEB-INF`).
    - Пример:
      ```java
      InputStream resource = context.getResourceAsStream("/WEB-INF/config.properties");
      ```
3. **Конфигурационные параметры**:
    - Читает параметры, заданные в `web.xml` (или аннотациях в современных
      приложениях).
    - Пример в `web.xml`:
      ```xml
      <context-param>
          <param-name>appVersion</param-name>
          <param-value>1.0</param-value>
      </context-param>
      ```
      ```java
      String version = context.getInitParameter("appVersion");
      ```
4. **Логирование**:
    - Позволяет записывать сообщения в лог приложения.
    - Пример:
      ```java
      context.log("Application started");
      ```
5. **Управление сервлетами**:
    - Предоставляет информацию о сервлетах и их конфигурации, а также о самом
      приложении (например, путь к корню приложения).
    - Пример:
      ```java
      String contextPath = context.getContextPath(); // Например, "/myapp"
      ```

### **ServletContext в Spring**:

- В Spring **ServletContext** связан с веб-приложениями и используется для:
    - Инициализации **WebApplicationContext** (специальной версии
      `ApplicationContext` для веб-приложений).
    - Хранения бинов в scope `application`, которые создаются один раз на весь
      `ServletContext` (см. ваш предыдущий вопрос о scope `application`).
    - Интеграции через компоненты, такие как `ContextLoaderListener` (загружает
      корневой `ApplicationContext`) или `DispatcherServlet` (создаёт свой
      собственный `WebApplicationContext`).
- Spring использует `ServletContext` для:
    - Доступа к глобальным ресурсам и параметрам.
    - Привязки бинов с scope `application` к жизненному циклу `ServletContext`.
    - Обеспечения взаимодействия между Spring и веб-контейнером.

### **Пример использования в Spring**:

```java

@Component
@Scope(value = "application", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class AppConfigBean {
    public String getAppName() {
        return "MyApp";
    }
}

// Получение ServletContext в Spring
@Component
public class MyServlet {
    @Autowired
    private ServletContext servletContext;

    public void doSomething() {
        String appName = (String) servletContext.getAttribute("appName");
        System.out.println("App Name: " + appName);
    }
}
```

### **Ключевые моменты**:

- **Один на приложение**: В каждом веб-приложении существует только один
  `ServletContext`, создаваемый веб-контейнером при старте приложения.
- **Жизненный цикл**: `ServletContext` живёт от старта приложения (
  разворачивания WAR-файла) до его остановки.
- **Связь с ApplicationContext**:
    - `ApplicationContext` в Spring управляет бинами в рамках одного контекста,
      а `ServletContext` — это более низкоуровневый объект, общий для всего
      веб-приложения.
    - Бины в scope `application` привязаны к `ServletContext`, а бины в scope
      `singleton` — к конкретному `ApplicationContext`.
- **Использование**: Часто применяется для хранения глобальных данных (например,
  кэшей, настроек) или интеграции с веб-контейнером.

### **Отличие от ApplicationContext**:

| Характеристика       | ServletContext                      | ApplicationContext                    |
|----------------------|-------------------------------------|---------------------------------------|
| **Тип**              | Часть Java Servlet API              | Часть Spring Framework                |
| **Назначение**       | Управление ресурсами веб-приложения | Управление бинами и DI в Spring       |
| **Область действия** | Всё веб-приложение                  | Конкретный контекст приложения        |
| **Создаётся**        | Веб-контейнером (Tomcat, Jetty)     | Spring (ApplicationContext)           |
| **Привязка scope**   | Scope `application`                 | Scope `singleton`, `prototype`, и др. |

### **Когда использовать**:

- Используйте `ServletContext` для:
    - Доступа к глобальным ресурсам или параметрам веб-приложения.
    - Хранения данных, общих для всех пользователей и сервлетов.
    - Интеграции Spring с веб-контейнером.
- В Spring чаще работайте с `ApplicationContext` для управления бинами, а
  `ServletContext` используйте, если требуется взаимодействие с веб-контейнером
  или scope `application`.

Если нужен пример кода, разбор интеграции с Spring или уточнение какого-то
аспекта, дайте знать!

---

## IoC и DI

**Inversion of Control (IoC)** и **Dependency Injection (DI)** — это
фундаментальные концепции фреймворка Spring в Java, которые связаны между собой
и лежат в основе его архитектуры. Они помогают создавать гибкие, модульные и
легко тестируемые приложения. Давайте разберём их кратко и понятно.

### **Inversion of Control (IoC)**

- **Определение**: IoC (Инверсия управления) — это принцип проектирования, при
  котором управление жизненным циклом объектов и их зависимостями передаётся от
  самого объекта к внешнему контейнеру (в Spring — это **ApplicationContext**).
- **Как работает**:
    - Вместо того чтобы объект сам создавал свои зависимости или управлял своим
      жизненным циклом, контейнер Spring (IoC-контейнер) берёт на себя
      ответственность за:
        - Создание объектов (бинов).
        - Управление их конфигурацией и жизненным циклом.
        - Внедрение зависимостей.
    - Объект "пассивно" получает всё необходимое от контейнера, а не "активно"
      создаёт зависимости.
- **Пример аналогии**:
    - Без IoC: Вы сами идёте в магазин, покупаете ингредиенты и готовите еду.
    - С IoC: Вы заказываете еду, а ресторан (контейнер) готовит и доставляет её
      вам.
- **В Spring**:
    - IoC реализуется через **ApplicationContext** или **BeanFactory**, которые
      управляют созданием, конфигурацией и связыванием бинов.
    - Вы описываете бины и их зависимости (через XML, Java-конфигурации или
      аннотации), а контейнер решает, когда и как их создавать.

### **Dependency Injection (DI)**

- **Определение**: DI (Внедрение зависимостей) — это конкретная реализация IoC,
  при которой зависимости объекта (другие объекты или ресурсы) предоставляются
  ему извне, а не создаются внутри самого объекта.
- **Как работает**:
    - Вместо того чтобы объект создавал свои зависимости (например, через
      `new`), контейнер Spring "внедряет" их в объект.
    - Это делает код более модульным, тестируемым и независимым от конкретных
      реализаций.
- **Типы DI в Spring**:
    1. **Конструкторное внедрение**:
        - Зависимости передаются через конструктор.
       ```java
       @Component
       public class UserService {
           private final DatabaseRepository repository;
  
           @Autowired
           public UserService(DatabaseRepository repository) {
               this.repository = repository;
           }
       }
       ```
    2. **Сеттерное внедрение**:
        - Зависимости устанавливаются через сеттеры.
       ```java
       @Component
       public class UserService {
           private DatabaseRepository repository;
  
           @Autowired
           public void setRepository(DatabaseRepository repository) {
               this.repository = repository;
           }
       }
       ```
    3. **Полевое внедрение** (реже используется):
        - Зависимости внедряются напрямую в поля через аннотацию `@Autowired`.
       ```java
       @Component
       public class UserService {
           @Autowired
           private DatabaseRepository repository;
       }
       ```
- **Преимущества DI**:
    - Упрощает тестирование (можно подменять зависимости моками).
    - Снижает связанность (loose coupling) между классами.
    - Позволяет легко заменять реализации зависимостей.

### **Связь IoC и DI**:

- **IoC** — это общий принцип: управление объектами передаётся контейнеру.
- **DI** — это способ реализации IoC, когда контейнер "внедряет" зависимости в
  объекты.
- В Spring IoC-контейнер (ApplicationContext) использует DI для предоставления
  бинам их зависимостей, что позволяет избежать жёсткой привязки классов друг к
  другу.

### **Пример в Spring**:

```java
// Конфигурация через Java
@Configuration
public class AppConfig {
    @Bean
    public DatabaseRepository databaseRepository() {
        return new DatabaseRepository();
    }

    @Bean
    public UserService userService(DatabaseRepository repository) {
        return new UserService(repository);
    }
}

// Классы
public class DatabaseRepository {
    public void save() {
        System.out.println("Сохранение в базе данных");
    }
}

public class UserService {
    private final DatabaseRepository repository;

    public UserService(DatabaseRepository repository) {
        this.repository = repository;
    }

    public void performAction() {
        repository.save();
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService service = context.getBean(UserService.class);
        service.performAction(); // Выведет: Сохранение в базе данных
    }
}
```

### **Ключевые моменты**:

- **IoC**:
    - Передаёт управление созданием и жизненным циклом объектов контейнеру.
    - Делает приложение более декларативным (вы описываете, "что нужно", а не "
      как это сделать").
- **DI**:
    - Реализует IoC, предоставляя зависимости объектам.
    - В Spring поддерживается через аннотации (`@Autowired`, `@Inject`), XML или
      Java-конфигурации.
- **Преимущества**:
    - Модульность: классы не зависят от конкретных реализаций.
    - Тестируемость: легко подменять зависимости.
    - Гибкость: можно менять конфигурацию без изменения кода.

### **Связь с жизненным циклом бинов**:

- IoC-контейнер управляет полным жизненным циклом бинов (создание,
  инициализация, использование, уничтожение).
- DI обеспечивает внедрение зависимостей на этапе создания или конфигурирования
  бина.

------

## Что такое DispatcherServlet и ContextLoaderListener?

**DispatcherServlet** и **ContextLoaderListener** — это ключевые компоненты в
веб-приложениях Spring, которые используются для интеграции Spring с
веб-контейнером (например, Tomcat, Jetty) и управления **ApplicationContext** в
контексте веб-приложения. Они выполняют разные роли, но оба связаны с
инициализацией и управлением Spring в веб-приложениях. Давайте разберём их
кратко и понятно.

### **DispatcherServlet**

- **Что это?**
    - **DispatcherServlet** — это центральный сервлет в Spring MVC, который
      обрабатывает все HTTP-запросы в веб-приложении и направляет их к
      соответствующим контроллерам.
    - Это реализация паттерна **Front Controller**, который служит единой точкой
      входа для всех запросов.
- **Функции**:
    - Создаёт собственный **WebApplicationContext** (дочерний контекст Spring),
      который содержит бины, связанные с веб-логикой (контроллеры, обработчики
      запросов, view resolvers и т.д.).
    - Обрабатывает HTTP-запросы: принимает запрос, вызывает соответствующий
      контроллер, обрабатывает результат и возвращает ответ (например,
      HTML-страницу, JSON).
    - Управляет маршрутизацией запросов, обработкой исключений, рендерингом
      представлений (views).
- **Как работает**:
    - Определяется в `web.xml` или через Java-конфигурацию.
    - При старте создаёт свой `WebApplicationContext`, который загружает бины из
      указанных конфигураций (XML, Java, аннотации).
    - Обрабатывает запросы, делегируя их компонентам Spring MVC (HandlerMapping,
      HandlerAdapter, ViewResolver).
- **Пример конфигурации**:
    - В `web.xml`:
      ```xml
      <servlet>
          <servlet-name>dispatcher</servlet-name>
          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
          <init-param>
              <param-name>contextConfigLocation</param-name>
              <param-value>/WEB-INF/spring-mvc-config.xml</param-value>
          </init-param>
          <load-on-startup>1</load-on-startup>
      </servlet>
      <servlet-mapping>
          <servlet-name>dispatcher</servlet-name>
          <url-pattern>/</url-pattern>
      </servlet-mapping>
      ```
    - В Java-конфигурации:
      ```java
      @Configuration
      @EnableWebMvc
      public class WebConfig implements WebMvcConfigurer {
          // Конфигурация MVC
      }
      ```
- **Когда использовать**:
    - Для обработки HTTP-запросов в Spring MVC.
    - Для настройки контроллеров, представлений и REST API.

### **ContextLoaderListener**

- **Что это?**
    - **ContextLoaderListener** — это слушатель (listener), который
      инициализирует **корневой WebApplicationContext** для всего
      веб-приложения.
    - Он загружает бины, которые являются глобальными для приложения и не
      связаны напрямую с обработкой HTTP-запросов (например, сервисы,
      репозитории, конфигурации базы данных).
- **Функции**:
    - Создаёт **корневой ApplicationContext**, который является родительским для
      контекстов, созданных `DispatcherServlet`.
    - Загружает бины, определённые в глобальной конфигурации (например, сервисы,
      DAO, источники данных).
    - Привязывает корневой контекст к **ServletContext**, делая его доступным
      для всех компонентов приложения.
- **Как работает**:
    - Регистрируется в `web.xml` как слушатель.
    - При старте веб-приложения (разворачивание WAR) создаёт корневой
      `WebApplicationContext` на основе указанной конфигурации (XML или Java).
    - Этот контекст используется всеми `DispatcherServlet` в приложении как
      родительский, чтобы избежать дублирования бинов.
- **Пример конфигурации**:
    - В `web.xml`:
      ```xml
      <listener>
          <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
      </listener>
      <context-param>
          <param-name>contextConfigLocation</param-name>
          <param-value>/WEB-INF/applicationContext.xml</param-value>
      </context-param>
      ```
    - В Java-конфигурации:
      ```java
      public class AppInitializer implements WebApplicationInitializer {
          @Override
          public void onStartup(ServletContext servletContext) {
              AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext();
              rootContext.register(AppConfig.class);
              servletContext.addListener(new ContextLoaderListener(rootContext));
          }
      }
      ```
- **Когда использовать**:
    - Для инициализации глобальных бинов, которые используются в разных частях
      приложения (например, сервисы, доступ к базе данных).
    - Когда нужно создать общий корневой контекст для нескольких
      `DispatcherServlet`.

### **Ключевые отличия**:

| Характеристика           | DispatcherServlet                         | ContextLoaderListener                  |
|--------------------------|-------------------------------------------|----------------------------------------|
| **Тип**                  | Сервлет (обрабатывает HTTP-запросы)       | Слушатель (инициализирует контекст)    |
| **Роль**                 | Обработка запросов, Spring MVC            | Создание корневого ApplicationContext  |
| **Контекст**             | Создаёт дочерний WebApplicationContext    | Создаёт корневой WebApplicationContext |
| **Содержимое контекста** | Контроллеры, ViewResolver, HandlerMapping | Сервисы, репозитории, конфигурации БД  |
| **Привязка**             | Обрабатывает запросы по URL-паттерну      | Привязан к ServletContext              |
| **Использование**        | Для MVC и REST API                        | Для глобальных бинов приложения        |

### **Как они взаимодействуют**:

- **Иерархия контекстов**:
    - `ContextLoaderListener` создаёт **корневой WebApplicationContext**,
      содержащий глобальные бины (например, сервисы, репозитории).
    - `DispatcherServlet` создаёт **дочерний WebApplicationContext**, который
      наследует бины из корневого контекста и добавляет свои (контроллеры,
      обработчики).
    - Это позволяет разделить конфигурацию: глобальные бины (сервисы) в корневом
      контексте, веб-специфичные бины (контроллеры) — в контексте
      `DispatcherServlet`.
- **Пример структуры**:
    - Корневой контекст (`ContextLoaderListener`): бины сервисов, доступ к базе
      данных.
    - Дочерний контекст (`DispatcherServlet`): бины контроллеров, обработка
      HTTP-запросов.
- Если в приложении несколько `DispatcherServlet` (например, для разных
  URL-паттернов), они все используют один корневой контекст, созданный
  `ContextLoaderListener`.

### **Практические замечания**:

- **Когда нужен ContextLoaderListener?**
    - Если приложение сложное, и вы хотите разделить конфигурацию на
      глобальную (сервисы, репозитории) и веб-специфичную (контроллеры).
    - Если у вас несколько `DispatcherServlet` (например, для REST API и MVC).
- **Когда достаточно только DispatcherServlet?**
    - В простых приложениях, где все бины (сервисы, контроллеры) можно
      разместить в одном контексте.
- **Scope и ServletContext**:
    - Бины в scope `application` привязаны к `ServletContext`, который создаётся
      веб-контейнером и используется обоими компонентами.
    - `ContextLoaderListener` делает корневой контекст доступным через
      `ServletContext`, а `DispatcherServlet` использует его для доступа к
      глобальным бинам.

### **Пример полного веб-приложения**:

```xml
<!-- web.xml -->
<web-app>
    <!-- ContextLoaderListener для корневого контекста -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/applicationContext.xml</param-value>
    </context-param>

    <!-- DispatcherServlet для MVC -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-mvc-config.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

### **Связь с предыдущими темами**:

- **ServletContext**: `ContextLoaderListener` привязывает корневой
  `WebApplicationContext` к `ServletContext`, а `DispatcherServlet` использует
  его для доступа к глобальным ресурсам.
- **ApplicationContext**: `ContextLoaderListener` создаёт корневой контекст, а
  `DispatcherServlet` — дочерний.
- **Scope**: Бины в scope `application` привязаны к `ServletContext`, а бины в
  scope `singleton` — к конкретному `ApplicationContext` (корневому или
  дочернему).

---

## ProxyMode

В контексте Spring Framework **proxyMode** — это атрибут, используемый в
аннотации `@Scope` для указания, как Spring должен создавать прокси-объекты для
бинов с определёнными областями видимости (scopes), такими как `request`,
`session`, или `application`. Это необходимо, чтобы корректно внедрять бины с
короткоживущими scopes в бины с более долгоживущими scopes (например,
`singleton`). Давайте разберём кратко и понятно.

### **Что такое proxyMode?**

- **proxyMode** определяет, каким образом Spring создаёт **прокси** для бина,
  чтобы обеспечить правильное поведение при внедрении зависимости в контексте,
  где области видимости бинов различаются.
- Прокси — это промежуточный объект, который "оборачивает" реальный бин и
  управляет доступом к нему, позволяя контейнеру Spring подставлять нужный
  экземпляр бина в зависимости от текущего контекста (например, HTTP-запроса или
  сессии).
- Используется в основном для веб-ориентированных scopes (`request`, `session`,
  `application`) или пользовательских scopes.

### **Зачем нужен proxyMode?**

Когда бин с короткоживущим scope (например, `request`) внедряется в бин с
долгоживущим scope (например, `singleton`), возникает проблема:

- Singleton-бин создаётся один раз и живёт весь жизненный цикл
  `ApplicationContext`.
- Request-бин создаётся для каждого HTTP-запроса и уничтожается после его
  завершения.
- Без прокси singleton-бин получил бы фиксированную ссылку на request-бин,
  созданный в момент инициализации, что привело бы к некорректной работе (
  например, использованию устаревшего или недоступного бина).

**proxyMode** решает эту проблему, создавая прокси-объект, который динамически
подставляет актуальный экземпляр бина в зависимости от текущего контекста (
например, текущего HTTP-запроса).

### **Значения proxyMode**

Атрибут `proxyMode` в аннотации `@Scope` принимает значения из перечисления
`ScopedProxyMode`. Основные варианты:

1. **ScopedProxyMode.NO** (по умолчанию):
    - Прокси не создаётся.
    - Подходит, если бин не внедряется в бины с другими scopes или если scope
      совпадает (например, оба бина в `singleton`).
    - Используется, когда проксирование не требуется.
    - Пример:
      ```java
      @Component
      @Scope("request")
      public class RequestBean {
          // Без прокси
      }
      ```

2. **ScopedProxyMode.TARGET_CLASS**:
    - Создаёт **прокси на основе CGLIB**, который работает на уровне класса.
    - Прокси заменяет сам класс бина, позволяя подставлять актуальный экземпляр
      при каждом вызове.
    - Используется, когда бин не реализует интерфейсы или когда требуется
      проксирование всего класса.
    - Пример:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestBean {
          public String getData() {
              return "Данные для текущего запроса";
          }
      }
      ```

3. **ScopedProxyMode.INTERFACES**:
    - Создаёт **прокси на основе JDK Dynamic Proxy**, который работает на уровне
      интерфейсов.
    - Требует, чтобы бин реализовал хотя бы один интерфейс.
    - Прокси реализует интерфейсы бина и подставляет актуальный экземпляр при
      вызове методов.
    - Используется, когда бин реализует интерфейсы, и вы хотите ограничить
      проксирование только ими.
    - Пример:
      ```java
      public interface MyService {
          String getData();
      }
 
      @Component
      @Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)
      public class SessionBean implements MyService {
          public String getData() {
              return "Данные для текущей сессии";
          }
      }
      ```

### **Как работает проксирование?**

- Когда вы указываете `proxyMode`, Spring создаёт прокси-объект вместо реального
  бина.
- Этот прокси перехватывает вызовы методов и делегирует их актуальному
  экземпляру бина, который соответствует текущему контексту (например, текущему
  HTTP-запросу или сессии).
- Прокси "знает", как получить правильный экземпляр бина из текущего контекста (
  `ServletContext` для `application`, HTTP-сессии для `session`, HTTP-запроса
  для `request`).

### **Пример использования**

Предположим, у вас есть singleton-бин, который зависит от request-бин:

```java

@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    public String getRequestId() {
        return "ID запроса: " + UUID.randomUUID().toString();
    }
}

@Component
public class SingletonService {
    private final RequestBean requestBean;

    @Autowired
    public SingletonService(RequestBean requestBean) {
        this.requestBean = requestBean;
    }

    public void printRequestId() {
        System.out.println(requestBean.getRequestId());
    }
}
```

- Без `proxyMode` Spring внедрил бы фиксированный экземпляр `RequestBean`,
  который был бы создан один раз и стал бы недействительным после завершения
  запроса.
- С `proxyMode = ScopedProxyMode.TARGET_CLASS` Spring создаёт прокси, который
  при каждом вызове `printRequestId()` подставляет актуальный экземпляр
  `RequestBean` для текущего HTTP-запроса.

### **Ключевые моменты**

- **Когда использовать proxyMode?**
    - Когда бин с короткоживущим scope (`request`, `session`, `application`)
      внедряется в бин с долгоживущим scope (обычно `singleton`).
    - Без проксирования Spring выбросит исключение или внедрит некорректный
      экземпляр.
- **CGLIB vs JDK Proxy**:
    - `TARGET_CLASS` (CGLIB): Работает с любыми классами, но требует зависимости
      `cglib` и может быть чуть медленнее.
    - `INTERFACES` (JDK Proxy): Работает только с интерфейсами, но быстрее и
      легче в использовании, если бин реализует интерфейсы.
- **Связь с ServletContext**:
    - Для scope `application`, `request`, `session` прокси взаимодействует с
      `ServletContext` или текущим HTTP-контекстом, чтобы подставить правильный
      экземпляр бина.
- **Ограничения**:
    - Проксирование добавляет небольшой оверхед.
    - `INTERFACES` не работает, если класс не реализует интерфейсы.
    - Прокси не требуется, если бины имеют одинаковый scope или если бин не
      внедряется в другие бины.

### **Связь с предыдущими темами**

- **ServletContext**: `proxyMode` позволяет бинам в scope `request`, `session`,
  или `application` корректно работать с `ServletContext`, подставляя
  экземпляры, привязанные к текущему HTTP-запросу или сессии.
- **ApplicationContext**: Прокси создаются в рамках `ApplicationContext` (или
  `WebApplicationContext`), чтобы управлять доступом к бинам с разными scopes.
- **DispatcherServlet и ContextLoaderListener**: Прокси часто используются в
  контексте, созданном `DispatcherServlet`, для внедрения request- или
  session-бинов в singleton-бины, определённые в корневом контексте (
  `ContextLoaderListener`).

### **Пример полной конфигурации**

```java

@Configuration
public class AppConfig {
    @Bean
    @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public RequestBean requestBean() {
        return new RequestBean();
    }

    @Bean
    public SingletonService singletonService(RequestBean requestBean) {
        return new SingletonService(requestBean);
    }
}
```
