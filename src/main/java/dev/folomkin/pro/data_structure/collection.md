# JAVA Collection

## HASHMAP

(чуть лучше про то как устроен, и сложности методов)

### **Устройство**

HashMap в Java — это структура данных, которая реализует интерфейс Map и
использует хеш-таблицу для хранения пар "ключ-значение". Она обеспечивает
быстрый доступ к элементам по ключу, что делает её одной из самых популярных
реализаций Map. Давайте рассмотрим, как работает HashMap, его основные
характеристики и внутренние механизмы.

Основные характеристики HashMap

1. Ключи и значения: HashMap хранит данные в виде пар "ключ-значение". Каждый
   ключ должен быть уникальным, но значения могут повторяться.
2. Неупорядоченность: Элементы в HashMap не имеют определенного порядка. Порядок
   вставки не сохраняется.
3. Допускает null: HashMap позволяет использовать один null в качестве ключа и
   любое количество null в качестве значений.
4. Не синхронизирован: HashMap не является потокобезопасным. Если несколько
   потоков одновременно изменяют его, необходимо использовать внешнюю
   синхронизацию.

Как работает HashMap

1. Хеширование
   Когда вы добавляете пару "ключ-значение" в HashMap, ключ проходит через
   хеш-функцию, которая вычисляет хеш-код для этого ключа. Хеш-код — это целое
   число, которое используется для определения индекса в массиве (хеш-таблице),
   где будет храниться значение.
   ```java
   int hash = key.hashCode();
   int index = hash % array.length; // Определяем индекс в массиве
   ```
2. Обработка коллизий<br>
   Коллизия происходит, когда два разных ключа имеют одинаковый хеш-код и,
   следовательно, попадают в один и тот же индекс массива. Для обработки
   коллизий HashMap использует метод цепочек (chaining):
    1. Каждый элемент массива представляет собой связный список (или дерево с
       Java 8 и выше), который хранит все пары "ключ-значение", имеющие
       одинаковый индекс.
    2. Если возникает коллизия, новая пара добавляется в конец связного списка
       или дерева.
3. Резервирование места
   Когда количество элементов в HashMap превышает определенный порог (обычно 75%
   от текущей емкости), происходит увеличение емкости:
    1. Создается новый массив большего размера.
    2. Все существующие элементы перераспределяются по новому массиву на основе
       их хеш-кодов.
4. Время доступа
   В среднем время доступа к элементам по ключу составляет O(1) благодаря
   использованию хеширования. Однако в худшем случае (например, если все
   элементы попадают в одну цепочку) время доступа может составлять O(n). Чтобы
   избежать этого, важно правильно выбирать размер начального массива и
   коэффициент загрузки.

Пример использования HashMap

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();

        // Добавление элементов
        map.put("Alice", 30);
        map.put("Bob", 25);
        map.put("Charlie", 35);

        // Получение элемента
        System.out.println("Age of Alice: " + map.get("Alice"));

        // Проверка наличия ключа
        if (map.containsKey("Bob")) {
            System.out.println("Bob is in the map.");
        }

        // Удаление элемента
        map.remove("Charlie");

        // Итерация по элементам
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
    }
}
```

Заключение
HashMap — это мощная структура данных для хранения пар "ключ-значение" с быстрым
доступом к элементам по ключу. Она использует хеширование для обеспечения
высокой производительности и обрабатывает коллизии с помощью цепочек. Понимание
работы HashMap поможет вам эффективно использовать её в ваших Java-приложениях.

________________________________________________________________________________

## Добавление нескольких значений к одному ключу

В HashMap в Java ключи должны быть уникальными. Если вы попытаетесь добавить
пару "ключ-значение" с уже существующим ключом, новое значение заменит старое.
Однако, если вам нужно хранить несколько значений для одного ключа, вы можете
использовать несколько подходов.

1. Использование HashMap с List или Set
   Один из самых распространенных способов обработки одинаковых ключей — это
   использование HashMap, где значениями являются коллекции (например, List или
   Set). Это позволяет хранить несколько значений для одного ключа.

Пример с использованием ArrayList

```java
public class Main {
    public static void main(String[] args) {
        HashMap<String, List<Integer>> map = new HashMap<>();

        // Добавление значений
        addValue(map, "Alice", 30);
        addValue(map, "Alice", 31);
        addValue(map, "Bob", 25);
        addValue(map, "Charlie", 35);
        addValue(map, "Alice", 32);

        // Вывод значений
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
    }

    private static void addValue(HashMap<String, List<Integer>> map, String key, Integer value) {
        // Получаем список значений по ключу
        List<Integer> values = map.get(key);

        // Если список не существует, создаем новый
        if (values == null) {
            values = new ArrayList<>();
            map.put(key, values);
        }

        // Добавляем новое значение в список
        values.add(value);
    }
}
```

2. Использование HashMap с Set

Если вам нужно хранить уникальные значения для каждого ключа (без дубликатов),
вы можете использовать HashSet вместо ArrayList.

```java
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Set<Integer>> map = new HashMap<>();

        // Добавление значений
        addValue(map, "Alice", 30);
        addValue(map, "Alice", 31);
        addValue(map, "Bob", 25);
        addValue(map, "Charlie", 35);
        addValue(map, "Alice", 30); // Дубликат не будет добавлен

        // Вывод значений
        for (String key : map.keySet()) {
            System.out.println(key + ": " + map.get(key));
        }
    }

    private static void addValue(HashMap<String, Set<Integer>> map, String key, Integer value) {
        // Получаем множество значений по ключу
        Set<Integer> values = map.get(key);

        // Если множество не существует, создаем новое
        if (values == null) {
            values = new HashSet<>();
            map.put(key, values);
        }

        // Добавляем новое значение в множество
        values.add(value);
    }
}
```

Заключение
Если вам нужно обрабатывать одинаковые пары ключ-значение в Java с
использованием HashMap, вы можете использовать коллекции (например, List или
Set) в качестве значений. Это позволит вам хранить несколько значений для одного
ключа и управлять ими более гибко. Выбор между списком и множеством зависит от
ваших требований к уникальности значений.

________________________________________________________________________________

## Как работает обработка коллизий в HashMap

Когда два ключа имеют одинаковый хеш-код и попадают в один и тот же индекс
массива, HashMap создает связный список (или дерево) для хранения всех пар "
ключ-значение", которые имеют одинаковый индекс. В Java 8 и выше, если
количество элементов в цепочке превышает определенный порог (обычно 8), HashMap
преобразует связный список в сбалансированное дерево (например, Red-Black Tree)
для улучшения производительности.

Пример обработки коллизий<br>
Вот пример, который демонстрирует, как HashMap обрабатывает коллизии:

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<Key, String> map = new HashMap<>();

        // Создаем ключи с одинаковым хеш-кодом
        Key key1 = new Key(1);
        Key key2 = new Key(2);

        // Добавляем пары "ключ-значение"
        map.put(key1, "Value for key 1");
        map.put(key2, "Value for key 2");

        // Вывод значений
        System.out.println("Key 1: " + map.get(key1));
        System.out.println("Key 2: " + map.get(key2));
    }
}

class Key {
    private int id;

    public Key(int id) {
        this.id = id;
    }

    @Override
    public int hashCode() {
        return 1; // Оба ключа будут иметь одинаковый хеш-код
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Key)) return false;
        Key other = (Key) obj;
        return this.id == other.id;
    }
}
```

Объяснение кода<br>

1. Класс Key: Мы создаем класс Key, который имеет метод hashCode(), возвращающий
   одно и то же значение (в данном случае 1). Это означает, что все экземпляры
   этого класса будут иметь одинаковый хеш-код.
2. Добавление пар: Мы добавляем два разных ключа (key1 и key2) в HashMap.
   Несмотря на то что они разные объекты, они имеют одинаковый хеш-код.
3. Обработка коллизий: Когда мы добавляем оба ключа в HashMap, они будут
   храниться в одной цепочке (связанном списке или дереве), так как их хеш-коды
   совпадают.
4. Получение значений: Мы можем получить значения по каждому из ключей без
   проблем, так как метод equals() также переопределен для сравнения объектов по
   их идентификатору.

Заключение<br>
В случае коллизий в HashMap, структура данных автоматически обрабатывает их с
помощью связных списков или деревьев. Вам не нужно беспокоиться о том, как
именно это происходит — просто используйте уникальные ключи для хранения
значений. Если вам нужно хранить несколько значений для одного ключа,
рассмотрите возможность использования коллекций (например, List или Set) как
значений.

--------------------------------------------------------------------------------

## Бакеты

В контексте HashMap в Java "бакеты" (или "ведра") — это структуры данных,
которые используются для хранения пар "ключ-значение". Бакеты помогают
организовать данные в HashMap и обеспечивают эффективный доступ к ним. Давайте
рассмотрим, как это работает.

Основные концепции

1. Хеширование: Когда вы добавляете пару "ключ-значение" в HashMap, сначала
   вычисляется хеш-код ключа с помощью метода hashCode(). Этот хеш-код затем
   используется для определения индекса (или бакета) в массиве, который хранит
   все бакеты.
2. Массив бакетов: HashMap использует массив для хранения бакетов. Каждый
   элемент массива может содержать один или несколько объектов (пары "
   ключ-значение"). Индекс массива определяется на основе хеш-кода ключа.
3. Обработка коллизий: Если два или более ключа имеют одинаковый хеш-код и,
   следовательно, попадают в один и тот же индекс массива (это называется
   коллизией), HashMap использует метод цепочек (chaining) для обработки этих
   коллизий. В этом случае все пары "ключ-значение", которые имеют одинаковый
   индекс, будут храниться в связанном списке или дереве внутри соответствующего
   бакета.

Пример работы с бакетами

```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();

        // Добавление пар "ключ-значение"
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");

        // Получение значения по ключу
        System.out.println(map.get("key1")); // Вывод: value1
    }
}
```

Как это выглядит под капотом<br>

1. Добавление элемента:
    1. При добавлении "key1" вычисляется его хеш-код.
    2. На основе этого хеш-кода определяется индекс в массиве.
    3. Если по этому индексу еще нет других элементов, создается новый бакет и
       добавляется пара "key1" : "value1".
2. Обработка коллизий:
    1. Если вы добавите другой ключ, который имеет тот же хеш-код (например, "
       key4"), он попадет в тот же индекс.
    2. В этом случае HashMap создаст связанный список или дерево внутри этого
       бакета и добавит пару "key4" : "value4" туда.
3. Получение элемента:
    1. При получении значения по ключу сначала вычисляется его хеш-код.
    2. Затем определяется индекс массива.
    3. Если по этому индексу есть несколько элементов (из-за коллизий), HashMap
       будет перебирать элементы в связанном списке или дереве до тех пор, пока
       не найдет нужный ключ.

Заключение<br>
Бакеты в HashMap — это важная часть структуры данных, которая позволяет
эффективно хранить и извлекать пары "ключ-значение". Они обеспечивают обработку
коллизий и позволяют поддерживать производительность операций вставки и поиска
на высоком уровне.

_**Метод цепочек для обработки колизий**_

Метод цепочек (chaining) — это один из способов обработки коллизий в
хеш-таблицах, таких как HashMap в Java. Когда два или более ключа имеют
одинаковый хеш-код и, следовательно, попадают в один и тот же индекс массива (
бакета), метод цепочек позволяет хранить все эти пары "ключ-значение" в одной
структуре данных, связанной с этим индексом.

Как работает метод цепочек

1. Хеширование: Когда вы добавляете пару "ключ-значение" в HashMap, сначала
   вычисляется хеш-код ключа с помощью метода hashCode(). Этот хеш-код
   используется для определения индекса в массиве бакетов.
2. Создание бакета: Если по этому индексу еще нет других элементов, создается
   новый бакет. В Java это обычно реализуется как связный список или дерево.
3. Добавление элементов: Если по этому индексу уже есть элементы (из-за
   коллизий), новая пара "ключ-значение" добавляется в существующий бакет. В
   случае связного списка новый элемент добавляется в конец списка, а если
   используется сбалансированное дерево (например, Red-Black Tree), то элемент
   будет вставлен в соответствующее место дерева.
4. Поиск элементов: При поиске значения по ключу сначала вычисляется его хеш-код
   и индекс массива. Затем HashMap проверяет бакет по этому индексу:
    1. Если бакет представляет собой связный список, он перебирает элементы
       списка до тех пор, пока не найдет нужный ключ.
    2. Если бакет представляет собой дерево, поиск выполняется с использованием
       алгоритма поиска дерева.

Пример работы метода цепочек

```java
import java.util.LinkedList;

class HashMapWithChaining<K, V> {
    private static class Entry<K, V> {
        K key;
        V value;

        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private LinkedList<Entry<K, V>>[] buckets;
    private int capacity;

    @SuppressWarnings("unchecked")
    public HashMapWithChaining(int capacity) {
        this.capacity = capacity;
        buckets = new LinkedList[capacity];
        for (int i = 0; i < capacity; i++) {
            buckets[i] = new LinkedList<>();
        }
    }

    public void put(K key, V value) {
        int index = getIndex(key);
        LinkedList<Entry<K, V>> bucket = buckets[index];

        // Проверяем наличие ключа и обновляем значение
        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
        }

        // Если ключ не найден, добавляем новую пару
        bucket.add(new Entry<>(key, value));
    }

    public V get(K key) {
        int index = getIndex(key);
        LinkedList<Entry<K, V>> bucket = buckets[index];

        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }

        return null; // Ключ не найден
    }

    private int getIndex(K key) {
        return Math.abs(key.hashCode()) % capacity; // Вычисление индекса
    }
}
```

Преимущества метода цепочек<br>

1. Простота реализации: Метод цепочек легко реализовать с использованием
   стандартных структур данных (например, списков или деревьев).
2. Гибкость: Он позволяет хранить несколько значений для одного и того же
   индекса без необходимости перераспределения памяти.
3. Устойчивость к коллизиям: Даже если количество коллизий увеличивается,
   производительность операций вставки и поиска остается приемлемой.

Недостатки метода цепочек<br>

1. Память: Использование дополнительных структур данных для хранения элементов
   может привести к увеличению потребления памяти.
2. Производительность: В худшем случае (например, если все элементы попадают в
   один бакет) производительность операций может ухудшиться до O(n), где n —
   количество элементов в бакете.
3. Необходимость управления размером: При увеличении количества элементов может
   потребоваться перераспределение памяти и увеличение размера массива бакетов
   для поддержания производительности.

Заключение<br>
Метод цепочек — это эффективный способ обработки коллизий в хеш-таблицах. Он
позволяет сохранять производительность операций вставки и поиска на высоком
уровне даже при наличии коллизий за счет использования связанных списков или
деревьев для хранения пар "ключ-значение".

**Колизии**

Коллизия в контексте хеш-таблиц возникает, когда два или более ключа имеют
одинаковый хеш-код, что приводит к тому, что они попадают в один и тот же индекс
массива (бакета). Это может произойти по нескольким причинам:<br>

1. Ограниченное количество индексов<br>
   Хеш-таблицы используют фиксированный размер массива для хранения данных. Если
   количество возможных ключей превышает количество доступных индексов, то
   неизбежно будут коллизии. Например, если у вас есть 10 возможных индексов и
   15 различных ключей, то как минимум 5 ключей будут иметь одинаковый индекс.
2. Хеш-функция<br>
   Хеш-функция преобразует ключ в целое число (хеш-код), которое затем
   используется для определения индекса в массиве. Если хеш-функция не
   распределяет ключи равномерно по всем возможным индексам, это может привести
   к большому количеству коллизий. Например, если хеш-функция возвращает одно и
   то же значение для разных ключей или если она слишком проста (например,
   просто возвращает последний символ строки), это может привести к частым
   коллизиям.
3. Ограниченная длина хеша<br>
   Некоторые хеш-функции могут генерировать хеш-коды с ограниченной длиной (
   например, 32 бита), что также увеличивает вероятность коллизий. В этом случае
   множество различных входных данных будет отображаться на ограниченное
   количество выходных значений.
4. Сходство ключей<br>
   Если ключи имеют схожие характеристики (например, строки с одинаковыми
   префиксами или числа с одинаковыми значащими цифрами), это может привести к
   тому, что они будут генерировать одинаковые хеш-коды.

Примеры<br>

1. Простая хеш-функция: Если у вас есть строка "abc" и "cba", и ваша хеш-функция
   просто суммирует ASCII-коды символов, то обе строки могут дать один и тот же
   результат.
2. Ограниченный диапазон: Если вы используете целые числа в качестве ключей и
   ваша хеш-функция просто берет остаток от деления на 10 (например, key % 10),
   то все числа, заканчивающиеся на одну и ту же цифру (например, 12 и 22),
   будут иметь одинаковый индекс.

   Заключение<br>
   Коллизии — это естественная часть работы с хеш-таблицами из-за ограниченного
   количества индексов и особенностей хеш-функций. Эффективные алгоритмы
   обработки коллизий (такие как метод цепочек или открытая адресация) помогают
   минимизировать их влияние на производительность операций вставки и поиска в
   хеш-таблицах.

___
**Одинаковый hashcode**

В Java `HashMap` использует хеш-функцию для распределения ключей по "корзинам" (
buckets) в зависимости от их хеш-кода. Однако, разные объекты могут иметь
одинаковый хеш-код из-за особенностей хеширования. Это явление называется
коллизией.

Вот несколько причин, почему два ключа могут иметь одинаковый хеш-код:<br>

1. **Ограниченное пространство значений**: Хеш-функция преобразует объект в
   целое число (хеш-код), и поскольку количество возможных объектов значительно
   больше, чем количество возможных целых чисел, разные объекты могут быть
   преобразованы в одно и то же значение.
2. **Алгоритм хеширования**: Хеш-функции не идеальны и могут создавать коллизии.
   Например, если два объекта имеют одинаковые значения для всех полей, которые
   участвуют в вычислении хеш-кода, они будут иметь одинаковый хеш-код.
3. **Пользовательские классы**: Если вы создаете собственный класс и
   переопределяете метод `hashCode()`, вы можете случайно создать коллизии, если
   не будете учитывать все важные поля объекта.

Когда происходит коллизия (т.е. два ключа имеют одинаковый хеш-код), `HashMap`
использует дополнительную структуру данных (обычно связный список или дерево)
для хранения всех элементов с одинаковым хеш-кодом в одной корзине. При поиске
элемента по ключу `HashMap` сначала вычисляет хеш-код ключа, находит
соответствующую корзину и затем сравнивает ключи внутри этой корзины с помощью
метода `equals()`, чтобы найти нужный элемент.

Таким образом, хотя коллизии возможны, `HashMap` эффективно обрабатывает их,
обеспечивая корректное поведение при добавлении и поиске элементов.

### Сложности методов

В среднем, операция добавления, удаления и поиска элемента в HashMap имеют
временную сложность O(1). Однако, в худшем случае, когда все элементы попадают в
одну корзину, они будут связаны в связный список или дерево, и операция может
занимать время O(n), где n - количество элементов в корзине. Таким образом,
сложность операций в HashMap зависит от количества коллизий и хеш-функции.<br>
В среднем, сложность выборки элемента также составляет O(1), но в худшем случае
может достигать O(n).

================================================================================
--------------------------------------------------------------------------------

## ARRAYLIST, LINKEDLIST

> (Сложность получения элементов в ArrayList и LinkedList)

### ARRAYLIST

**ПРИНЦИП РАБОТЫ**

Каждый экземпляр ArrayList имеет емкость (CAPACITY). Емкость – это размер
массива, который используется для хранения элементов. По мере добавления
элементов в ArrayList его емкость автоматически увеличивается.

Когда массив заполняется, его ёмкость увеличивается. Новая ёмкость вычисляется
по формуле: старая ёмкость * 1.5 + 1. Например, если начальная ёмкость была 10,
то после расширения она станет 16.

При увеличении ёмкости создаётся новый массив, и все элементы из старого
копируются в новый, что является затратной операцией. Поэтому, если заранее
известно, что список будет большим, лучше сразу задать достаточную начальную
ёмкость.

Начальный размер capacity равен 10. Можно передать свое значение capacity
используя конструктор public ArrayList(int initialCapacity).

Удаление элементов из середины списка может быть затратной операцией, так как
все последующие элементы смещаются влево, что требует копирования данных. Также
стоит отметить, что размер внутреннего массива автоматически не уменьшается
после удаления элементов.

Метод trimToSize() позволяет уменьшить ёмкость ArrayList до фактического
количества элементов. Он полезен, если список часто изменяется и его размер
значительно сократился. Этот метод отсутствует в интерфейсе List, он доступен
только в ArrayList.

**АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ**

Алгоритмическая сложность операций с `ArrayList` в Java зависит от
конкретной операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

- В конец списка: O(1) в среднем (если массив не переполнен). Если массив
  переполнен, происходит его увеличение, что требует O(n) времени, но это
  происходит редко, поэтому в среднем сложность остается O(1).
- В начало или в произвольную позицию: O(n) (необходимо сдвинуть элементы).

2. **Удаление элемента**:

- Из конца списка: O(1) (если не требуется уменьшение размера массива).
- Из начала или из произвольной позиции: O(n) (необходимо сдвинуть
  элементы).

3. **Поиск элемента**:

- O(n) (в худшем случае необходимо пройти по всему списку).

4. **Доступ к элементу по индексу**:

- O(1) (доступ к элементу по индексу осуществляется за константное время,
  так как `ArrayList` основан на массиве).

Таким образом, `ArrayList` хорошо подходит для операций доступа по индексу и
добавления элементов в конец списка, но менее эффективен для вставки и удаления
элементов в начале или середине списка из-за необходимости сдвига элементов.

Для `ArrayList` в Java сложность вставки и удаления элементов из середины списка
составляет O(n).

Вот подробности:

1. **Вставка элемента в середину**:

- Чтобы вставить элемент в середину списка, необходимо сначала сдвинуть все
  элементы, находящиеся после позиции вставки, на одну позицию вправо. Это
  требует O(n) времени в худшем случае, так как вам нужно пройти по всем
  элементам после вставляемого.
- После сдвига сам процесс вставки (изменение значения по индексу)
  выполняется за O(1).
- В итоге общая сложность вставки элемента в середину списка составляет O(
  n).

2. **Удаление элемента из середины**:

- Для удаления элемента из середины списка также необходимо сначала найти
  этот элемент (если у вас нет ссылки на него), что требует O(n) времени.
- После нахождения элемента необходимо сдвинуть все элементы, находящиеся
  после удаляемого, на одну позицию влево. Это также требует O(n) времени.
- Таким образом, общая сложность удаления элемента из середины списка
  составляет O(n).

В общем, операции вставки и удаления в середине `ArrayList` имеют линейную
сложность из-за необходимости сдвига элементов.

### LINKEDLIST

LinkedList\<E> является реализацией двусвязного списка для интерфейса List
который работает эффективно как для вставки элементов, так и для удаления,
используя, как издержки, более сложную структуру.

**Принцип работы**

Добавление элементов в конец списка

- Создаётся новый узел (Node).
- Устанавливается значение (item) для нового узла.
- Ссылки узла добавляются в конец списка.
- Устанавливаются ссылки на предыдущий и следующий узлы (для нового и соседних
  узлов).

Добавление элемента в середину списка

- Проверяется индекс. Если он отрицательный или превышает размер списка,
  выбрасывается исключение IndexOutOfBoundsException.
- Если индекс равен размеру списка, элемент добавляется в конец.
- Вставка в середину происходит перед элементом с указанным индексом:
    - Метод node(index) находит узел по индексу.
    - Определяется место вставки (поиск узла идёт с начала или конца списка в
      зависимости от индекса).
    - Создаётся новый узел, и его ссылки устанавливаются между соседними узлами.
- Обновляются ссылки на предыдущие и следующие узлы для нового элемента и его
  соседей.
- Увеличивается размер списка.

Удаление элемента из связного списка по значению:

- Последовательно сравниваются элементы списка с заданным значением, начиная с
  первого узла.
- Когда найден узел с соответствующим значением, элемент сохраняется в отдельную
  переменную.
- Ссылки соседних узлов перенаправляются так, чтобы исключить удаляемый элемент.
- Очищаются ссылки и данные узла, который содержал удалённый элемент, и
  уменьшается размер списка.

**СЛОЖНОСТЬ**

Добавление и удаление из середины, доступ по индексу, значению происходит за
линейное время O(n), а из начала и конца за константное O(1). Так же, ввиду
реализации, данную коллекцию можно использовать как стек или очередь. Для этого
в ней реализованы соответствующие методы.

Алгоритмическая сложность операций с `LinkedList` в Java зависит от конкретной
операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

    - В конец списка: O(1) (если у вас есть ссылка на последний элемент).
    - В начало списка: O(1).
    - В произвольную позицию: O(n) (необходимо пройти до нужной позиции).

2. **Удаление элемента**:

    - Из конца списка: O(1) (если у вас есть ссылка на последний элемент).
    - Из начала списка: O(1).
    - Из произвольной позиции: O(n) (необходимо пройти до нужной позиции).

3. **Поиск элемента**:

    - O(n) (необходимо пройти по всему списку в худшем случае).

4. **Доступ к элементу по индексу**:

    - O(n) (необходимо пройти по списку до нужного индекса).

Таким образом, `LinkedList` хорошо подходит для операций добавления и удаления
элементов в начале или конце списка, но неэффективен для доступа по индексу и
поиска элементов.

Для `LinkedList` в Java сложность вставки и удаления элемента из середины списка
составляет O(n).

Вот подробности:

1. **Вставка элемента в середину**:

    - Чтобы вставить элемент в середину списка, необходимо сначала найти
      позицию, куда вы хотите вставить элемент. Это требует O(n) времени, так
      как вам нужно пройти по списку до нужного индекса.
    - После того как вы нашли нужную позицию, сама операция вставки (изменение
      ссылок) выполняется за O(1).
    - В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

    - Аналогично, для удаления элемента из середины списка сначала нужно найти
      этот элемент, что также требует O(n) времени.
    - После нахождения элемента операция удаления (изменение ссылок) выполняется
      за O(1).
    - Таким образом, общая сложность удаления элемента из середины списка также
      составляет O(n).

В общем, операции вставки и удаления в середине `LinkedList` имеют линейную
сложность из-за необходимости поиска нужной позиции.

Самый быстрый метод класса add(E element). Главным же достоинством
класса является скорость работы метода remove() на Iterator, после получения
его из LinkedList. Также очень быстро работает метод add(E element) на
ListIterator. Операция удаления из начала и конца списка выполняется достаточно
быстро, в отличие от операций поиска и извлечения.

Используется когда необходимо часто добавлять или удалять элементы, особенно в
начало списка. Либо когда нужна вставка элемента в конец за гарантированное
время.

Для манипуляций с первым и последним элементами списка в LinkedList\<E>
реализованы методы:

- **void addFirst(E e), void addLast(E e)** - добавление элементов в начало и
  конец списка;
- **E getFirst(), E getLast()** — извлекающие элементы;
- **E removeFirst(), E removeLast()** — удаляющие и извлекающие элементы;
- **E removeLastOccurrence(E elem), E removeFirstOccurrence(E elem)** —
  удаляющие и извлекающие элемент, первый или последний раз встречаемый
  в списке.

**_Отличия ArrayList и LinkedList:_**

`ArrayList` и `LinkedList` — это две реализации интерфейса `List` в Java, и у
них есть несколько ключевых отличий:

1. **Структура данных**:
    - `ArrayList` основан на массиве. Он использует динамический массив для
      хранения элементов, что позволяет быстро получать доступ к элементам по
      индексу.
    - `LinkedList` основан на связном списке. Каждый элемент (узел) содержит
      ссылку на следующий (и предыдущий) элемент, что позволяет легко добавлять
      и удалять элементы.

2. **Производительность**:
    - **Доступ по индексу**: В `ArrayList` доступ к элементам по индексу
      осуществляется за O(1), так как это просто обращение к массиву. В
      `LinkedList` доступ по индексу требует O(n), так как нужно пройти по
      узлам.
    - **Добавление/удаление элементов**: В `ArrayList` добавление элемента в
      конец списка обычно выполняется за O(1), но может потребовать O(n) в
      случае необходимости увеличения размера массива. Удаление элемента также
      может потребовать O(n) из-за необходимости сдвига элементов. В
      `LinkedList` добавление и удаление элементов (в начале, в конце или в
      середине) выполняется за O(1), если у вас есть ссылка на узел, но поиск
      узла требует O(n).

3. **Память**:
    - `ArrayList` использует меньше памяти на элемент, так как хранит только
      данные и индекс. Однако он может выделять больше памяти, чем фактически
      используется (из-за динамического массива).
    - `LinkedList` использует больше памяти на элемент, так как каждый узел
      хранит ссылки на следующий и предыдущий элементы.

4. **Итерация**:
    - Итерация по элементам в `ArrayList` обычно быстрее из-за лучшей
      локальности данных (элементы хранятся последовательно в памяти).
    - Итерация по `LinkedList` может быть медленнее из-за необходимости перехода
      от одного узла к другому.

5. **Использование**:
    - Используйте `ArrayList`, когда вам нужно часто получать доступ к элементам
      по индексу или когда размер списка не меняется часто.
    - Используйте `LinkedList`, когда вам нужно часто добавлять или удалять
      элементы из середины списка.

В общем, выбор между `ArrayList` и `LinkedList` зависит от конкретных требований
вашего приложения и того, какие операции вы будете выполнять чаще всего.

==============================

`LinkedList` в Java — это структура данных, которая реализует интерфейсы `List`,
`Deque` и `Queue`. Она представляет собой двусвязный список, где каждый
элемент (узел) содержит ссылку на предыдущий и следующий узел. Это позволяет
эффективно добавлять и удалять элементы в любом месте списка.

### Основные характеристики LinkedList

1. **Структура**: Каждый узел в `LinkedList` состоит из трех частей:
    - Ссылка на предыдущий узел.
    - Ссылка на следующий узел.
    - Данные (значение), хранящиеся в узле.

2. **Двусвязный список**: В отличие от односвязного списка, где каждый узел
   содержит только ссылку на следующий узел, в двусвязном списке каждый узел
   имеет ссылки как на предыдущий, так и на следующий узел. Это позволяет легко
   перемещаться в обоих направлениях.

3. **Гибкость**: `LinkedList` позволяет динамически изменять размер списка,
   добавляя или удаляя элементы без необходимости перераспределения памяти, как
   это происходит в массивах.

### Принцип работы LinkedList

#### Основные операции

1. **Добавление элемента (add)**:
    - При добавлении элемента в конец списка создается новый узел, который
      ссылается на `null` (если это последний элемент).
    - Если список не пустой, новый узел связывается с текущим последним узлом, а
      последний узел обновляется для ссылки на новый узел.
    - Если элемент добавляется в начало или в середину списка, ссылки
      соответствующих узлов обновляются для поддержания связности.

2. **Удаление элемента (remove)**:
    - При удалении элемента необходимо найти соответствующий узел.
    - После нахождения узла его предыдущий и следующий узлы обновляют свои
      ссылки так, чтобы пропустить удаляемый узел.
    - Если удаляется первый или последний элемент, необходимо обновить указатели
      на голову или хвост списка.

3. **Поиск элемента (get)**:
    - Для поиска элемента по индексу необходимо пройти по списку от начала до
      нужного индекса (или от конца, если индекс ближе к концу).
    - Сложность поиска составляет O(n) в худшем случае.

4. **Итерация**:
    - Итерация по элементам `LinkedList` может быть выполнена с помощью
      итератора или цикла for-each.
    - Итератор позволяет проходить по элементам без необходимости знать
      внутреннюю структуру списка.

#### Преимущества LinkedList

- **Эффективное добавление и удаление**: Операции добавления и удаления
  элементов выполняются за O(1) при условии, что у вас есть ссылка на нужный
  узел.
- **Динамическое выделение памяти**: Размер списка может изменяться динамически
  без необходимости перераспределения памяти.

#### Недостатки LinkedList

- **Память**: Каждый элемент требует дополнительной памяти для хранения ссылок
  на соседние элементы.
- **Поиск**: Поиск по индексу требует O(n) времени из-за необходимости
  последовательного прохода по списку.

### Пример использования LinkedList

Вот пример использования `LinkedList` в Java:

```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        // Создание LinkedList
        LinkedList<String> list = new LinkedList<>();

        // Добавление элементов
        list.add("Первый");
        list.add("Второй");
        list.add("Третий");

        // Вставка элемента в начало
        list.addFirst("Нулевой");

        // Вставка элемента в конец
        list.addLast("Четвертый");

        // Удаление элемента
        list.remove("Второй");

        // Итерация по элементам
        for (String item : list) {
            System.out.println(item);
        }

        // Получение элемента по индексу
        String secondElement = list.get(1);
        System.out.println("Второй элемент: " + secondElement);
    }
}
```

### Заключение

`LinkedList` — это мощная структура данных для работы с динамическими наборами
данных. Она обеспечивает гибкость при добавлении и удалении элементов, но может
быть менее эффективной при поиске элементов по индексу из-за своей линейной
структуры. Выбор между `ArrayList` и `LinkedList` зависит от конкретных
требований вашего приложения и характера операций, которые вы планируете
выполнять с данными.




