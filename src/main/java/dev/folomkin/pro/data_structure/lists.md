# List

В Java `List` — это **интерфейс** из коллекционного фреймворка, представляющий
**упорядоченную коллекцию элементов**, в которой допускаются **повторы** и
**доступ по индексу**.

## Основное о `List`

`List` — это интерфейс

Реализуется следующими основными классами:

| Класс          | Основан на          | Особенности                                                         |
|----------------|---------------------|---------------------------------------------------------------------|
| **ArrayList**  | массив              | Быстрый доступ по индексу, медленные вставки и удаления из середины |
| **LinkedList** | двусвязный список   | Быстрые вставки/удаления, медленный доступ по индексу               |
| **Vector**     | массив (устаревший) | Синхронизирован, медленнее `ArrayList`                              |

## Временная сложность (ArrayList vs LinkedList)

| Операция            | ArrayList | LinkedList |
|---------------------|-----------|------------|
| `get(i)`            | O(1)      | O(n)       |
| `add(element)`      | O(1)\*    | O(1)       |
| `add(i, element)`   | O(n)      | O(n)       |
| `remove(i)`         | O(n)      | O(n)       |
| `iterator.remove()` | O(n)      | O(1)       |

\* — при амортизированной стоимости (ArrayList расширяется при заполнении)

### Когда использовать:

- `ArrayList` — когда нужно **часто обращаться по индексу**
- `LinkedList` — когда нужно **часто добавлять/удалять в середине/начале**

---

## ARRAYLIST

Класс, реализующий интерфейс List, являющийся динамическим массивом объектных
ссылок. Несинхронизированный.

ArrayList, как и Vector является реализацией динамического массива объектов.
Позволяет хранить любые данные, включая null в качестве элемента. Реализация
основана на обычном массиве. Данную реализацию следует применять, если в
процессе работы с коллекцией предполагается
частое обращение к элементам по индексу. Из-за особенностей реализации
поиндексное обращение к элементам выполняется за константное время O(1). Но
данную коллекцию рекомендуется избегать, если требуется частое
удаление/добавление элементов в середину коллекции.

ArrayList создается с начальной емкостью capacity 10 ячеек.
Переменная size хранит количество добавленных элементов и изначально равна 0.

Если добавить в ArrayList больше элементов, чем его capacity – неявно для
пользователя произойдет вызов метода grow() и пересоздание внутреннего массива.

Алгоритм расширения внутреннего массива:

- Создается новый массив по формуле (capacity * 3) / 2 + 1
- Все элементы старого массива копируются в новый, методом System.arraycopy()
- Новый массив присваивается внутренней переменной elementData.
  Старый массив объявляется мусором – на него больше нет ссылки

Автоматически внутренний массив не уменьшается.
Чтобы обрезать емкость списка до реального количества элементов в нем –
используем метод trimToSize(). Этот метод есть только у ArrayList и отсутствует
у List.

Удаление и добавление элементов для такой коллекции представляет ресурсоемкую
задачу, поэтому объект ArrayList\<E> лучше всего подходит для хранения списков с
малым числом подобных действий. С другой стороны, навигация по списку
осуществляется очень быстро, поэтому операции поиска производятся за более
короткое время.

### Основные свойства `ArrayList`

- Хранит элементы в **массиве `Object[]`**.
- Размер массива фиксирован, но при заполнении создаётся новый массив большего
  размера, куда копируются старые элементы.
- Поддерживает **доступ по индексу** через массив (O(1)).
- Доступ к элементам по индексу - O(1)
- Вставка и удаление элементов с конца - O(1)
- Доступ к элементам по значению - O(n)
- Медленная вставка и удаление элементов из середины
- Использует под капотом обычный массив elementData <br>
- Хранит любые значения, в том числе и null<br>
- Не синхронизирован<br>
- Автоматически увеличивается, но не уменьшается<br>

### ПРИНЦИП РАБОТЫ

Каждый экземпляр ArrayList имеет емкость (CAPACITY). Емкость – это размер
массива, который используется для хранения элементов. По мере добавления
элементов в ArrayList его емкость автоматически увеличивается.

Когда массив заполняется, его ёмкость увеличивается. Новая ёмкость вычисляется
по формуле: старая ёмкость * 1.5 + 1. Например, если начальная ёмкость была 10,
то после расширения она станет 16.

При увеличении ёмкости создаётся новый массив, и все элементы из старого
копируются в новый, что является затратной операцией. Поэтому, если заранее
известно, что список будет большим, лучше сразу задать достаточную начальную
ёмкость.

Начальный размер capacity равен 10. Можно передать свое значение capacity
используя конструктор public ArrayList(int initialCapacity).

Удаление элементов из середины списка может быть затратной операцией, так как
все последующие элементы смещаются влево, что требует копирования данных. Также
стоит отметить, что размер внутреннего массива автоматически не уменьшается
после удаления элементов.

Метод trimToSize() позволяет уменьшить ёмкость ArrayList до фактического
количества элементов. Он полезен, если список часто изменяется и его размер
значительно сократился. Этот метод отсутствует в интерфейсе List, он доступен
только в ArrayList.

### АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ

Алгоритмическая сложность операций с `ArrayList` в Java зависит от
конкретной операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

- В конец списка: O(1) в среднем (если массив не переполнен). Если массив
  переполнен, происходит его увеличение, что требует O(n) времени, но это
  происходит редко, поэтому в среднем сложность остается O(1).
- В начало или в произвольную позицию: O(n) (необходимо сдвинуть элементы).

2. **Удаление элемента**:

- Из конца списка: O(1) (если не требуется уменьшение размера массива).
- Из начала или из произвольной позиции: O(n) (необходимо сдвинуть
  элементы).

3. **Поиск элемента**:

- O(n) (в худшем случае необходимо пройти по всему списку).

4. **Доступ к элементу по индексу**:

- O(1) (доступ к элементу по индексу осуществляется за константное время,
  так как `ArrayList` основан на массиве).

Таким образом, `ArrayList` хорошо подходит для операций доступа по индексу и
добавления элементов в конец списка, но менее эффективен для вставки и удаления
элементов в начале или середине списка из-за необходимости сдвига элементов.

Для `ArrayList` в Java сложность вставки и удаления элементов из середины списка
составляет O(n).

Вот подробности:

1. **Вставка элемента в середину**:

- Чтобы вставить элемент в середину списка, необходимо сначала сдвинуть все
  элементы, находящиеся после позиции вставки, на одну позицию вправо. Это
  требует O(n) времени в худшем случае, так как вам нужно пройти по всем
  элементам после вставляемого.
- После сдвига сам процесс вставки (изменение значения по индексу)
  выполняется за O(1).
- В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

- Для удаления элемента из середины списка также необходимо сначала найти
  этот элемент (если у вас нет ссылки на него), что требует O(n) времени.
- После нахождения элемента необходимо сдвинуть все элементы, находящиеся
  после удаляемого, на одну позицию влево. Это также требует O(n) времени.
- Таким образом, общая сложность удаления элемента из середины списка
  составляет O(n).

В общем, операции вставки и удаления в середине `ArrayList` имеют линейную
сложность из-за необходимости сдвига элементов.

========= ### Реализация

```java
public class MyArrayList<T> {
    private static final int DEFAULT_CAPACITY = 10;
    private Object[] elements;
    private int size;

    // Конструктор по умолчанию
    public MyArrayList() {
        this.elements = new Object[DEFAULT_CAPACITY];
        this.size = 0;
    }

    // Конструктор с начальной емкостью
    public MyArrayList(int initialCapacity) {
        if (initialCapacity < 0) {
            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
        }
        this.elements = new Object[initialCapacity];
        this.size = 0;
    }

    // Добавление элемента в конец списка
    public void add(T element) {
        ensureCapacity(size + 1);
        elements[size++] = element;
    }

    // Добавление элемента по индексу
    public void add(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        ensureCapacity(size + 1);
        // Сдвигаем элементы вправо
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    // Получение элемента по индексу
    @SuppressWarnings("unchecked")
    public T get(int index) {
        checkIndex(index);
        return (T) elements[index];
    }

    // Удаление элемента по индексу
    @SuppressWarnings("unchecked")
    public T remove(int index) {
        checkIndex(index);
        T oldValue = (T) elements[index];
        // Сдвигаем элементы влево
        for (int i = index; i < size - 1; i++) {
            elements[i] = elements[i + 1];
        }
        elements[size - 1] = null; // Очищаем последний элемент
        size--;
        return oldValue;
    }

    // Возвращает текущий размер списка
    public int size() {
        return size;
    }

    // Проверка, пуст ли список
    public boolean isEmpty() {
        return size == 0;
    }

    // Вспомогательный метод для проверки индекса
    private void checkIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }

    // Вспомогательный метод для увеличения емкости массива
    private void ensureCapacity(int minCapacity) {
        if (minCapacity > elements.length) {
            int newCapacity = elements.length * 3 / 2 + 1; // Увеличиваем в 1.5 раза
            if (newCapacity < minCapacity) {
                newCapacity = minCapacity;
            }
            Object[] newElements = new Object[newCapacity];
            for (int i = 0; i < size; i++) {
                newElements[i] = elements[i];
            }
            elements = newElements;
        }
    }

    // Тестовая программа
    public static void main(String[] args) {
        MyArrayList<String> list = new MyArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add(1, "Orange");
        System.out.println("Size: " + list.size()); // Size: 3
        System.out.println("Element at index 1: " + list.get(1)); // Orange
        list.remove(0);
        System.out.println("After removing index 0, size: " + list.size()); // Size: 2
        System.out.println("Element at index 0: " + list.get(0)); // Orange
    }
}
```

Я реализую собственную версию `ArrayList` на Java, которая будет поддерживать
основные операции, такие как добавление, удаление, получение элементов и
изменение размера массива. Реализация будет использовать динамический массив под
капотом, как и стандартный `ArrayList` в Java. Для упрощения я включу ключевые
методы (`add`, `get`, `remove`, `size`) и реализую механизм автоматического
расширения массива.

### План реализации

1. Создать класс `MyArrayList` с внутренним массивом для хранения элементов.
2. Реализовать:
    - Конструкторы (по умолчанию и с начальной емкостью).
    - Метод `add` для добавления элемента в конец или по индексу.
    - Метод `get` для получения элемента по индексу.
    - Метод `remove` для удаления элемента по индексу.
    - Метод `size` для возврата текущего числа элементов.
    - Вспомогательный метод для расширения массива при необходимости.
3. Добавить проверку границ и обработку исключений.
4. Использовать обобщения (generics) для типобезопасности.

### Реализация

```java
public class MyArrayList<T> {
    private static final int DEFAULT_CAPACITY = 10;
    private Object[] elements;
    private int size;

    // Конструктор по умолчанию
    public MyArrayList() {
        this.elements = new Object[DEFAULT_CAPACITY];
        this.size = 0;
    }

    // Конструктор с начальной емкостью
    public MyArrayList(int initialCapacity) {
        if (initialCapacity < 0) {
            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
        }
        this.elements = new Object[initialCapacity];
        this.size = 0;
    }

    // Добавление элемента в конец списка
    public void add(T element) {
        ensureCapacity(size + 1);
        elements[size++] = element;
    }

    // Добавление элемента по индексу
    public void add(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        ensureCapacity(size + 1);
        // Сдвигаем элементы вправо
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    // Получение элемента по индексу
    @SuppressWarnings("unchecked")
    public T get(int index) {
        checkIndex(index);
        return (T) elements[index];
    }

    // Удаление элемента по индексу
    @SuppressWarnings("unchecked")
    public T remove(int index) {
        checkIndex(index);
        T oldValue = (T) elements[index];
        // Сдвигаем элементы влево
        for (int i = index; i < size - 1; i++) {
            elements[i] = elements[i + 1];
        }
        elements[size - 1] = null; // Очищаем последний элемент
        size--;
        return oldValue;
    }

    // Возвращает текущий размер списка
    public int size() {
        return size;
    }

    // Проверка, пуст ли список
    public boolean isEmpty() {
        return size == 0;
    }

    // Вспомогательный метод для проверки индекса
    private void checkIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }

    // Вспомогательный метод для увеличения емкости массива
    private void ensureCapacity(int minCapacity) {
        if (minCapacity > elements.length) {
            int newCapacity = elements.length * 3 / 2 + 1; // Увеличиваем в 1.5 раза
            if (newCapacity < minCapacity) {
                newCapacity = minCapacity;
            }
            Object[] newElements = new Object[newCapacity];
            for (int i = 0; i < size; i++) {
                newElements[i] = elements[i];
            }
            elements = newElements;
        }
    }

    // Тестовая программа
    public static void main(String[] args) {
        MyArrayList<String> list = new MyArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add(1, "Orange");
        System.out.println("Size: " + list.size()); // Size: 3
        System.out.println("Element at index 1: " + list.get(1)); // Orange
        list.remove(0);
        System.out.println("After removing index 0, size: " + list.size()); // Size: 2
        System.out.println("Element at index 0: " + list.get(0)); // Orange
    }
}
```

### Объяснение кода

- **Внутренний массив**: `elements` — массив типа `Object[]` для хранения
  элементов. Используется `Object[]`, так как generics в Java стираются на этапе
  компиляции.
- **Размер**: Переменная `size` отслеживает количество элементов в списке.
- **Автоматическое расширение**: Метод `ensureCapacity` увеличивает размер
  массива в 1.5 раза, если текущая емкость недостаточна.
- **Обобщения**: Класс использует generics (`T`) для типобезопасности.
- **Проверка границ**: Метод `checkIndex` выбрасывает
  `IndexOutOfBoundsException` при некорректных индексах.
- **Основные операции**:
    - `add(T element)`: Добавляет элемент в конец, O(1) в среднем.
    - `add(int index, T element)`: Добавляет элемент по индексу, O(n) из-за
      сдвига элементов.
    - `get(int index)`: Возвращает элемент по индексу, O(1).
    - `remove(int index)`: Удаляет элемент по индексу, O(n) из-за сдвига.
    - `size()`: Возвращает количество элементов, O(1).
- **Тест**: Метод `main` демонстрирует базовое использование.

### Ограничения реализации

- Для простоты не реализованы методы, такие как `contains`, `clear`, `iterator`,
  или поддержка `List` интерфейса.
- Нет оптимизаций, таких как уменьшение массива при удалении элементов.
- Не реализована потокобезопасность (как и в стандартном `ArrayList`).

### Инструкции по использованию

1. Скомпилируйте и запустите код в среде Java.
2. Используйте класс `MyArrayList` как замену стандартного `ArrayList` для
   базовых операций.
3. Для добавления новых функций (например, `contains` или `toArray`) расширьте
   класс дополнительными методами.

Если нужна более сложная реализация (например, с итератором или дополнительными
методами), дайте знать, и я доработаю код!

### Преимущества `ArrayList`

1. Быстрый доступ по индексу (O(1)).
2. Амортизированная вставка в конец (O(1)).
3. Простая структура, основанная на массиве.

### Недостатки `ArrayList`

1. Медленное удаление/вставка в середине (O(n)), из-за сдвига элементов.
2. При росте массива создаётся новый массив, что требует копирования (временные
   затраты).

## LINKEDLIST

LinkedList\<E> является реализацией двусвязного списка для интерфейса List
который работает эффективно как для вставки элементов, так и для удаления,
используя, как издержки, более сложную структуру. LinkedList\<E> также реализует
интерфейсы Queue\<E> и Deque\<E> и может работать с обоих концов очереди. Он
может работать с очередью как по принципу FIFO, так и по принципу LIFO.  
Связанный список хранит ссылки на объекты отдельно вместе со ссылками
на следующее и предыдущее звенья последовательности, поэтому часто
называется двунаправленным списком.

В этом классе объявлены методы, позволяющие манипулировать им как
очередью, двунаправленной очередью и т.д. Двунаправленный список, кроме
обычного, имеет особый «нисходящий» итератор, позволяющий двигаться от
конца списка к началу, и извлекается методом descendingIterator().

Класс LinkedList содержит три основных поля:

- Node<E> first – Ссылка на первый элемент списка.
- Node<E> last – Ссылка на последний элемент списка.
- int size – Количество элементов в списке

### Ключевые операции:

| Операция            | Что происходит                                | Сложность |
|---------------------|-----------------------------------------------|-----------|
| `addFirst(E)`       | Добавление в начало — новая "голова"          | O(1)      |
| `addLast(E)`        | Добавление в конец — новая "хвостовая" нода   | O(1)      |
| `get(int index)`    | Пройти с начала или конца до нужного элемента | O(n)      |
| `remove(int index)` | Найти и удалить — переустановить ссылки       | O(n)      |
| `add(int index, E)` | Найти место и вставить, поменять ссылки       | O(n)      |
| `iterator.remove()` | Быстрое удаление по итератору                 | O(1)      |

### Основные характеристики LinkedList

1. **Структура**: Каждый узел в `LinkedList` состоит из трех частей:

- Ссылка на предыдущий узел.
- Ссылка на следующий узел.
- Данные (значение), хранящиеся в узле.

2. **Двусвязный список**: В отличие от односвязного списка, где каждый узел
   содержит только ссылку на следующий узел, в двусвязном списке каждый узел
   имеет ссылки как на предыдущий, так и на следующий узел. Это позволяет легко
   перемещаться в обоих направлениях.

3. **Гибкость**: `LinkedList` позволяет динамически изменять размер списка,
   добавляя или удаляя элементы без необходимости перераспределения памяти, как
   это происходит в массивах.

### Принцип работы LinkedList

_**Добавление элементов в конец списка**_

- Создаётся новый узел (Node).
- Устанавливается значение (item) для нового узла.
- Ссылки узла добавляются в конец списка.
- Устанавливаются ссылки на предыдущий и следующий узлы (для нового и соседних
  узлов).

_**Добавление элемента в середину списка**_

- Проверяется индекс. Если он отрицательный или превышает размер списка,
  выбрасывается исключение IndexOutOfBoundsException.
- Если индекс равен размеру списка, элемент добавляется в конец.
- Вставка в середину происходит перед элементом с указанным индексом:
    - Метод node(index) находит узел по индексу.
    - Определяется место вставки (поиск узла идёт с начала или конца списка в
      зависимости от индекса).
    - Создаётся новый узел, и его ссылки устанавливаются между соседними узлами.
- Обновляются ссылки на предыдущие и следующие узлы для нового элемента и его
  соседей.
- Увеличивается размер списка.

Удаление элемента из связного списка по значению:

- Последовательно сравниваются элементы списка с заданным значением, начиная с
  первого узла.
- Когда найден узел с соответствующим значением, элемент сохраняется в отдельную
  переменную.
- Ссылки соседних узлов перенаправляются так, чтобы исключить удаляемый элемент.
- Очищаются ссылки и данные узла, который содержал удалённый элемент, и
  уменьшается размер списка.

#### Основные операции

1. **Добавление элемента (add)**:

- При добавлении элемента в конец списка создается новый узел, который
  ссылается на `null` (если это последний элемент).
- Если список не пустой, новый узел связывается с текущим последним узлом, а
  последний узел обновляется для ссылки на новый узел.
- Если элемент добавляется в начало или в середину списка, ссылки
  соответствующих узлов обновляются для поддержания связности.

2. **Удаление элемента (remove)**:

- При удалении элемента необходимо найти соответствующий узел.
- После нахождения узла его предыдущий и следующий узлы обновляют свои
  ссылки так, чтобы пропустить удаляемый узел.
- Если удаляется первый или последний элемент, необходимо обновить указатели
  на голову или хвост списка.

3. **Поиск элемента (get)**:

- Для поиска элемента по индексу необходимо пройти по списку от начала до
  нужного индекса (или от конца, если индекс ближе к концу).
- Сложность поиска составляет O(n) в худшем случае.

4. **Итерация**:

- Итерация по элементам `LinkedList` может быть выполнена с помощью
  итератора или цикла for-each.
- Итератор позволяет проходить по элементам без необходимости знать
  внутреннюю структуру списка.

### АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ

Алгоритмическая сложность операций с `LinkedList` в Java зависит от конкретной
операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

    - В начало/конец списка: O(1)
    - В произвольную позицию: O(n) (необходимо пройти до нужной позиции).

2. **Удаление элемента**:

    - Из начала/конца списка: O(1).
    - Из произвольной позиции: O(n).

3. **Поиск элемента**:

    - O(n) (необходимо пройти по всему списку в худшем случае).

4. **Доступ к элементу по индексу**:

    - O(n) (необходимо пройти по списку до нужного индекса).

Таким образом, `LinkedList` хорошо подходит для операций добавления и удаления
элементов в начале или конце списка, но неэффективен для доступа по индексу и
поиска элементов.

Вот подробности:

1. **Вставка элемента в середину**:

    - Чтобы вставить элемент в середину списка, необходимо сначала найти
      позицию, куда вы хотите вставить элемент. Это требует O(n) времени, так
      как вам нужно пройти по списку до нужного индекса.
    - После того как вы нашли нужную позицию, сама операция вставки (изменение
      ссылок) выполняется за O(1).
    - В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

    - Аналогично, для удаления элемента из середины списка сначала нужно найти
      этот элемент, что также требует O(n) времени.
    - После нахождения элемента операция удаления (изменение ссылок) выполняется
      за O(1).
    - Таким образом, общая сложность удаления элемента из середины списка также
      составляет O(n).

Самый быстрый метод класса add(E element). Главным же достоинством
класса является скорость работы метода remove() на Iterator, после получения
его из LinkedList. Также очень быстро работает метод add(E element) на
ListIterator. Операция удаления из начала и конца списка выполняется достаточно
быстро, в отличие от операций поиска и извлечения.

Используется когда необходимо часто добавлять или удалять элементы, особенно в
начало списка. Либо когда нужна вставка элемента в конец за гарантированное
время.

Для манипуляций с первым и последним элементами списка в LinkedList\<E>
реализованы методы:

- **void addFirst(E e), void addLast(E e)** - добавление элементов в начало и
  конец списка;
- **E getFirst(), E getLast()** — извлекающие элементы;
- **E removeFirst(), E removeLast()** — удаляющие и извлекающие элементы;
- **E removeLastOccurrence(E elem), E removeFirstOccurrence(E elem)** —
  удаляющие и извлекающие элемент, первый или последний раз встречаемый
  в списке.

### ========================= Реализация

```java
public class MyLinkedList<T> {
    private class Node {
        T data;
        Node prev;
        Node next;

        Node(T data) {
            this.data = data;
            this.prev = null;
            this.next = null;
        }
    }

    private Node head;
    private Node tail;
    private int size;

    // Конструктор по умолчанию
    public MyLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    // Добавление элемента в конец списка
    public void add(T element) {
        Node newNode = new Node(element);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size++;
    }

    // Добавление элемента по индексу
    public void add(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        if (index == size) {
            add(element);
            return;
        }
        Node newNode = new Node(element);
        if (index == 0) {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        } else {
            Node current = getNode(index);
            newNode.prev = current.prev;
            newNode.next = current;
            current.prev.next = newNode;
            current.prev = newNode;
        }
        size++;
    }

    // Получение элемента по индексу
    public T get(int index) {
        checkIndex(index);
        return getNode(index).data;
    }

    // Удаление элемента по индексу
    public T remove(int index) {
        checkIndex(index);
        Node current = getNode(index);
        T removedData = current.data;

        if (size == 1) {
            head = tail = null;
        } else if (current == head) {
            head = head.next;
            head.prev = null;
        } else if (current == tail) {
            tail = tail.prev;
            tail.next = null;
        } else {
            current.prev.next = current.next;
            current.next.prev = current.prev;
        }
        size--;
        return removedData;
    }

    // Возвращает текущий размер списка
    public int size() {
        return size;
    }

    // Проверка, пуст ли список
    public boolean isEmpty() {
        return size == 0;
    }

    // Вспомогательный метод для проверки индекса
    private void checkIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }

    // Вспомогательный метод для получения узла по индексу
    private Node getNode(int index) {
        checkIndex(index);
        Node current;
        // Оптимизация: начинаем с головы или хвоста в зависимости от индекса
        if (index < size / 2) {
            current = head;
            for (int i = 0; i < index; i++) {
                current = current.next;
            }
        } else {
            current = tail;
            for (int i = size - 1; i > index; i--) {
                current = current.prev;
            }
        }
        return current;
    }

    // Тестовая программа
    public static void main(String[] args) {
        MyLinkedList<String> list = new MyLinkedList<>();
        list.add("Apple");
        list.add("Banana");
        list.add(1, "Orange");
        System.out.println("Size: " + list.size()); // Size: 3
        System.out.println("Element at index 1: " + list.get(1)); // Orange
        list.remove(0);
        System.out.println("After removing index 0, size: " + list.size()); // Size: 2
        System.out.println("Element at index 0: " + list.get(0)); // Orange
    }
}
```

Я реализую собственную версию `LinkedList` на Java, которая будет поддерживать
основные операции, такие как добавление, удаление, получение элементов и
определение размера списка. Реализация будет использовать двусвязный список (
doubly-linked list), как и стандартный `LinkedList` в Java, чтобы обеспечить
эффективные операции вставки и удаления. Для простоты включу ключевые методы (
`add`, `get`, `remove`, `size`) и использую обобщения для типобезопасности.

### План реализации

1. Создать класс `MyLinkedList` с внутренней структурой узлов для
   двусвязногоリスト.
2. Реализовать:
    - Внутренний класс `Node` для представления узлов (содержит данные, ссылки
      на предыдущий и следующий узлы).
    - Конструктор по умолчанию.
    - Метод `add` для добавления элемента в конец или по индексу.
    - Метод `get` для получения элемента по индексу.
    - Метод `remove` для удаления элемента по индексу.
    - Метод `size` для возврата текущего числа элементов.
    - Метод `isEmpty` для проверки, пуст ли список.
3. Добавить проверку границ и обработку исключений.
4. Использовать обобщения (generics) для типобезопасности.

### Реализация

```java
public class MyLinkedList<T> {
    private class Node {
        T data;
        Node prev;
        Node next;

        Node(T data) {
            this.data = data;
            this.prev = null;
            this.next = null;
        }
    }

    private Node head;
    private Node tail;
    private int size;

    // Конструктор по умолчанию
    public MyLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    // Добавление элемента в конец списка
    public void add(T element) {
        Node newNode = new Node(element);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size++;
    }

    // Добавление элемента по индексу
    public void add(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        if (index == size) {
            add(element);
            return;
        }
        Node newNode = new Node(element);
        if (index == 0) {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        } else {
            Node current = getNode(index);
            newNode.prev = current.prev;
            newNode.next = current;
            current.prev.next = newNode;
            current.prev = newNode;
        }
        size++;
    }

    // Получение элемента по индексу
    public T get(int index) {
        checkIndex(index);
        return getNode(index).data;
    }

    // Удаление элемента по индексу
    public T remove(int index) {
        checkIndex(index);
        Node current = getNode(index);
        T removedData = current.data;

        if (size == 1) {
            head = tail = null;
        } else if (current == head) {
            head = head.next;
            head.prev = null;
        } else if (current == tail) {
            tail = tail.prev;
            tail.next = null;
        } else {
            current.prev.next = current.next;
            current.next.prev = current.prev;
        }
        size--;
        return removedData;
    }

    // Возвращает текущий размер списка
    public int size() {
        return size;
    }

    // Проверка, пуст ли список
    public boolean isEmpty() {
        return size == 0;
    }

    // Вспомогательный метод для проверки индекса
    private void checkIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }

    // Вспомогательный метод для получения узла по индексу
    private Node getNode(int index) {
        checkIndex(index);
        Node current;
        // Оптимизация: начинаем с головы или хвоста в зависимости от индекса
        if (index < size / 2) {
            current = head;
            for (int i = 0; i < index; i++) {
                current = current.next;
            }
        } else {
            current = tail;
            for (int i = size - 1; i > index; i--) {
                current = current.prev;
            }
        }
        return current;
    }

    // Тестовая программа
    public static void main(String[] args) {
        MyLinkedList<String> list = new MyLinkedList<>();
        list.add("Apple");
        list.add("Banana");
        list.add(1, "Orange");
        System.out.println("Size: " + list.size()); // Size: 3
        System.out.println("Element at index 1: " + list.get(1)); // Orange
        list.remove(0);
        System.out.println("After removing index 0, size: " + list.size()); // Size: 2
        System.out.println("Element at index 0: " + list.get(0)); // Orange
    }
}
```

### Объяснение кода

- **Внутренняя структура**:
    - Класс `Node` представляет узел двусвязного списка с полями `data` (
      данные), `prev` (ссылка на предыдущий узел) и `next` (ссылка на следующий
      узел).
    - Поля `head` и `tail` указывают на начало и конец списка, `size`
      отслеживает количество элементов.
- **Обобщения**: Класс использует generics (`T`) для типобезопасности.
- **Основные операции**:
    - `add(T element)`: Добавляет элемент в конец списка, O(1).
    - `add(int index, T element)`: Добавляет элемент по индексу, O(n) из-за
      необходимости поиска узла.
    - `get(int index)`: Возвращает элемент по индексу, O(n).
    - `remove(int index)`: Удаляет элемент по индексу, O(n) из-за поиска.
    - `size()`: Возвращает количество элементов, O(1).
    - `isEmpty()`: Проверяет, пуст ли список, O(1).
- **Оптимизация**:
    - Метод `getNode` оптимизирован: для индексов ближе к началу начинается с
      `head`, для индексов ближе к концу — с `tail`.
- **Проверка границ**: Метод `checkIndex` выбрасывает
  `IndexOutOfBoundsException` при некорректных индексах.
- **Тест**: Метод `main` демонстрирует базовое использование.

### Сложность операций

| Операция      | Сложность |
|---------------|-----------|
| `add(T)`      | O(1)      |
| `add(int, T)` | O(n)      |
| `get(int)`    | O(n)      |
| `remove(int)` | O(n)      |
| `size()`      | O(1)      |
| `isEmpty()`   | O(1)      |

### Ограничения реализации

- Для простоты не реализованы методы, такие как `contains`, `clear`, `iterator`,
  или поддержка интерфейса `List`.
- Нет поддержки операций, специфичных для `Deque` (например, `addFirst`,
  `addLast`), хотя их легко добавить.
- Не реализована потокобезопасность (как и в стандартном `LinkedList`).

### Инструкции по использованию

1. Скомпилируйте и запустите код в среде Java.
2. Используйте класс `MyLinkedList` как замену стандартного `LinkedList` для
   базовых операций.
3. Для добавления новых функций (например, `iterator` или `addFirst`) расширьте
   класс дополнительными методами.

Если нужна более сложная реализация (например, с поддержкой `Iterator` или
методов `Deque`), дайте знать, и я доработаю код!

#### Преимущества LinkedList

- **Эффективное добавление и удаление**: Операции добавления и удаления
  элементов выполняются за O(1) при условии, что у вас есть ссылка на нужный
  узел.
- **Динамическое выделение памяти**: Размер списка может изменяться динамически
  без необходимости перераспределения памяти.

#### Недостатки LinkedList

- **Память**: Каждый элемент требует дополнительной памяти для хранения ссылок
  на соседние элементы.
- **Поиск**: Поиск по индексу требует O(n) времени из-за необходимости
  последовательного прохода по списку.

## ARRAYLIST и LINKEDLIST

### Отличия ArrayList и LinkedList:

При добавлении в середину, начало или конец списка LinkedList быстрее, чем
ArrayList.

Вставки и удаления элементов из LinkedList происходят за постоянное время, в том
числе и с использованием итераторов, в то же время вставка\удаление элемента в
ArrayList приводит к сдвигу всех элементов после позиции добавления\удаления, а
в случае, если базовый массив хранения переполняется, то еще и сам массив
увеличивается в полтора раза с копированием старого массива в новый.

Список LinkedList занимает больший объем памяти за счет необходимости
хранения ссылок на соседние объекты, что следует учитывать при создании
списков больших размеров. Список LinkedList занимает от 3,5 до 5 раз больше
памяти нежели аналогичный список ArrayList.

Если необходимо осуществлять быструю навигацию по списку, то следует применять
ArrayList, так как перебор элементов в LinkedList осуществляется на порядок
медленнее. С другой стороны, если требуется часто добавлять и удалять элементы
из списка, то уже класс LinkedList обеспечивает значительно более высокую
скорость переиндексации. То есть если коллекция формируется в начале процесса и
в дальнейшем используется только для доступа к информации, то применяется
ArrayList, если же коллекция подвергается изменениям на всем протяжении
функционирования приложения, то выгоднее LinkedList.

Выгода использования LinkedList в работе с серединой и началом списка.
Вставка и удаление в LinkedList устроены гораздо проще, чем в ArrayList – просто
переопределятся ссылки на соседние элементы.

1. **Структура данных**:

- `ArrayList` основан на массиве. Он использует динамический массив для
  хранения элементов, что позволяет быстро получать доступ к элементам по
  индексу.
- `LinkedList` основан на связном списке. Каждый элемент (узел) содержит
  ссылку на следующий (и предыдущий) элемент, что позволяет легко добавлять
  и удалять элементы.

2. **Производительность**:

- **Доступ по индексу**: В `ArrayList` доступ к элементам по индексу
  осуществляется за O(1), так как это просто обращение к массиву. В
  `LinkedList` доступ по индексу требует O(n), так как нужно пройти по
  узлам.
- **Добавление/удаление элементов**: В `ArrayList` добавление элемента в
  конец списка обычно выполняется за O(1), но может потребовать O(n) в
  случае необходимости увеличения размера массива. Удаление элемента также
  может потребовать O(n) из-за необходимости сдвига элементов. В
  `LinkedList` добавление и удаление элементов (в начале, в конце или в
  середине) выполняется за O(1), если у вас есть ссылка на узел, но поиск
  узла требует O(n).

3. **Память**:

- `ArrayList` использует меньше памяти на элемент, так как хранит только
  данные и индекс. Однако он может выделять больше памяти, чем фактически
  используется (из-за динамического массива).
- `LinkedList` использует больше памяти на элемент, так как каждый узел
  хранит ссылки на следующий и предыдущий элементы.

4. **Итерация**:

- Итерация по элементам в `ArrayList` обычно быстрее из-за лучшей
  локальности данных (элементы хранятся последовательно в памяти).
- Итерация по `LinkedList` может быть медленнее из-за необходимости перехода
  от одного узла к другому.

5. **Использование**:

- Используйте `ArrayList`, когда вам нужно часто получать доступ к элементам
  по индексу или когда размер списка не меняется часто.
- Используйте `LinkedList`, когда вам нужно часто добавлять или удалять
  элементы из середины списка.

В общем, выбор между `ArrayList` и `LinkedList` зависит от конкретных требований
вашего приложения и того, какие операции вы будете выполнять чаще всего.
-------

### Сравнение вставки (`add`) и удаления (`remove`):

| Операция               | ArrayList                   | LinkedList                          |
|------------------------|-----------------------------|-------------------------------------|
| `add(E)` в конец       | O(1)\* (амортизировано)     | O(1)                                |
| `add(0, E)` в начало   | O(n) – сдвиг всех элементов | O(1)                                |
| `add(i, E)` в середину | O(n) – сдвиг с позиции `i`  | O(n) – пройти до `i`, затем вставка |
| `remove(i)`            | O(n) – сдвиг всех после `i` | O(n) – пройти до `i`, затем удалить |
| `removeFirst()`        | O(n)                        | O(1)                                |
| `removeLast()`         | O(1)                        | O(1)                                |

\* амортизированное — потому что при переполнении массива `ArrayList` делает
копию большего массива (O(n))

#### Подробное объяснение:

##### `ArrayList`

* Основан на **массиве**, элементы хранятся подряд.
* Вставка или удаление **внутри массива** требует **сдвига** всех последующих
  элементов.
* Зато **доступ по индексу** и **добавление в конец** — очень быстрые (O(1)).

##### `LinkedList`

* Основан на **узлах**, связанных ссылками (`prev`, `next`).
* Вставка и удаление **в любом месте** по ссылке — O(1), но чтобы найти нужный
  узел по индексу — **нужно пройти список** (O(n)).
* Добавление и удаление **в начале/конце** — очень быстрое (O(1)).

### Вывод:

| Когда использовать                        | ArrayList лучше | LinkedList лучше                         |
|-------------------------------------------|-----------------|------------------------------------------|
| Частый доступ по индексу                  | ✅ Да (O(1))     | ❌ Нет (O(n))                             |
| Частые вставки/удаления в начале/середине | ❌ Нет (O(n))    | ✅ Да (O(1) при known-node) or O(n)       |
| Малое количество изменений                | ✅ Да            | ❌ Нет (перегрузка по памяти и структуре) |


