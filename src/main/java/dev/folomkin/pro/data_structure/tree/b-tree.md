# Деревья



# B-TREE


**B-Tree** (сбалансированное дерево) — это структура данных, широко используемая в базах данных (включая SQL) для реализации индексов, обеспечивающая эффективный поиск, вставку, удаление и доступ к данным. Она особенно популярна в СУБД, таких как MySQL, PostgreSQL, SQL Server и Oracle, благодаря своей способности поддерживать сбалансированную структуру и обрабатывать большие объемы данных.

### **Что такое B-Tree?**
B-Tree — это многоуровневое дерево, в котором:
- Каждый узел может содержать несколько ключей и указателей на дочерние узлы или данные.
- Дерево остаётся сбалансированным, что гарантирует логарифмическую сложность операций (O(log n)).
- Оно оптимизировано для работы с большими наборами данных, хранящихся на диске, минимизируя количество операций ввода-вывода.

### **Основные характеристики B-Tree**
1. **Сбалансированность**:
    - Все листовые узлы находятся на одном уровне, что обеспечивает одинаковое время доступа для всех ключей.
2. **Много ключей в узле**:
    - Каждый узел может содержать до `m` ключей, где `m` — порядок дерева. Обычно `m` выбирается так, чтобы узел помещался в один блок диска (например, 4 КБ).
    - Минимальное количество ключей в узле — примерно `m/2` (для некорневых узлов).
3. **Указатели**:
    - Каждый узел содержит ключи и указатели: в некластеризованных индексах указатели ведут к строкам таблицы, в кластеризованных — к самим данным.
4. **Листовые и внутренние узлы**:
    - Внутренние узлы содержат ключи и указатели на дочерние узлы.
    - Листовые узлы содержат ключи и указатели на строки таблицы (или сами данные в кластеризованных индексах).

### **Как устроен B-Tree?**
Пример структуры B-Tree с порядком `m=3` (максимум 3 указателя и 2 ключа на узел):
```
       [30 | 60]
      /   |     \
[10|20] [40|50] [70|80]
```
- **Корневой узел**: Содержит ключи `30` и `60`, указатели на три дочерних узла.
- **Внутренние узлы**: Например, узел `[10|20]` указывает на поддеревья с ключами `<10`, `10-20`, `>20`.
- **Листовые узлы**: Хранят ключи и указатели на строки таблицы (например, `[10|20]` может указывать на строки с этими значениями).

### **Как работает B-Tree в SQL?**
B-Tree используется для индексов, чтобы ускорить запросы, такие как `SELECT`, `WHERE`, `JOIN`, `ORDER BY`. Рассмотрим, как это работает:

1. **Поиск**:
    - Для запроса `SELECT * FROM table WHERE id = 50`:
        1. СУБД начинает с корневого узла, сравнивает ключ `50` с ключами узла (например, `30` и `60`).
        2. Выбирает подходящий указатель (например, между `30` и `60`) и переходит к дочернему узлу `[40|50]`.
        3. Находит ключ `50` в листовом узле и получает указатель на строку таблицы.
    - Сложность поиска: O(log n), где `n` — число строк.

2. **Диапазонные запросы**:
    - Для `WHERE id BETWEEN 40 AND 70` B-Tree позволяет быстро найти начальный ключ (`40`) и последовательно обойти листовые узлы до `70`.
    - Это эффективно благодаря упорядоченности ключей в листьях.

3. **Вставка и удаление**:
    - При вставке нового ключа B-Tree добавляет его в подходящий листовой узел.
    - Если узел переполняется (больше `m-1` ключей), он разделяется на два узла, и родительский узел обновляется.
    - При удалении ключ удаляется, и дерево ребалансируется, если узел становится слишком пустым.
    - Это обеспечивает, что дерево остаётся сбалансированным.

### **B-Tree vs. B+Tree**
В базах данных чаще используется **B+Tree**, разновидность B-Tree, с небольшими отличиями:
- **B-Tree**: Все узлы (включая внутренние) могут содержать указатели на данные.
- **B+Tree**:
    - Только листовые узлы содержат указатели на данные.
    - Листовые узлы связаны в двусвязный список, что ускоряет диапазонные запросы.
    - Внутренние узлы содержат только ключи для навигации.
- **Почему B+Tree популярнее**:
    - Меньше памяти для внутренних узлов (нет указателей на данные).
    - Связанные листья упрощают последовательный доступ (например, для `SELECT * FROM table WHERE id > 50`).
    - Большинство СУБД (MySQL InnoDB, PostgreSQL) используют B+Tree для индексов.

### **Преимущества B-Tree**
- **Эффективность**: Логарифмическая сложность (O(log n)) для поиска, вставки, удаления.
- **Универсальность**: Подходит для точечных запросов (`WHERE id = 5`), диапазонных запросов (`WHERE id BETWEEN 10 AND 20`), сортировки и соединений (`JOIN`).
- **Оптимизация для дисков**: Узлы соответствуют блокам диска, минимизируя операции ввода-вывода.
- **Сбалансированность**: Гарантирует предсказуемую производительность.

### **Недостатки B-Tree**
- **Затраты на обновление**: Вставка и удаление требуют ребалансировки дерева, что может быть дорого при больших объемах данных.
- **Пространство**: Индекс занимает дополнительное место на диске.
- **Не оптимально для всех случаев**: Например, хэш-индексы быстрее для точечных запросов, а битовые индексы лучше для столбцов с низкой селективностью.

### **Пример в SQL**
Допустим, таблица `orders`:
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    amount DECIMAL
);
```
Создаём индекс на `customer_id`:
```sql
CREATE INDEX idx_customer_id ON orders (customer_id);
```
- СУБД создаёт B-Tree (или B+Tree), где ключи — значения `customer_id`, а указатели — адреса строк.
- Запрос `SELECT * FROM orders WHERE customer_id = 100`:
    - B-Tree находит ключ `100` за O(log n) и возвращает указатели на строки.

### **Применение в СУБД**
- **MySQL (InnoDB)**: Использует B+Tree для всех индексов. Первичный ключ — кластеризованный индекс, остальные — некластеризованные.
- **PostgreSQL**: B-Tree — основная структура для индексов, поддерживает также GIN, GiST, BRIN.
- **SQL Server**: B-Tree для кластеризованных и некластеризованных индексов.
- **Oracle**: B-Tree для стандартных индексов, также поддерживает битовые индексы.

### **Когда B-Tree эффективен?**
- Столбцы с высокой селективностью (много уникальных значений, например, `id`, `email`).
- Запросы с фильтрацией (`WHERE`), сортировкой (`ORDER BY`) или соединениями (`JOIN`).
- Диапазонные запросы (`BETWEEN`, `>`, `<`).

Если нужен пример работы B-Tree для конкретного запроса или СУБД, напишите, и я разберу подробнее!





===========================
===========================
===========================
===========================
===========================


6. **Сегментное дерево (Segment Tree)**:
    - **Описание**: Дерево для хранения интервалов или сегментов, позволяющее
      эффективно выполнять запросы на диапазоны (например, сумму, минимум).
    - **Особенности**:
        - Используется в алгоритмах, связанных с обработкой массивов (например,
          RMQ — Range Minimum Query).
        - Реализуется вручную.
    - **Применение**: Алгоритмические задачи, обработка данных.

7. **Фенвиковое дерево (Binary Indexed Tree, BIT)**:
    - **Описание**: Компактное дерево для вычисления префиксных сумм и
      обновления элементов.
    - **Особенности**:
        - Эффективнее сегментного дерева для некоторых задач.
        - Реализуется вручную.
    - **Применение**: Алгоритмы на массивах, задачи на Codeforces и др.

8. **Общее n-арное дерево**:
    - **Описание**: Дерево, где каждый узел может иметь произвольное число
      детей (не обязательно бинарное).
    - **Особенности**:
        - Используется для представления иерархий (например, DOM в XML/HTML,
          файловые системы).
        - Реализуется вручную или через библиотеки (например, JDOM для XML).
    - **Пример**:
      ```java
      class NaryNode {
          String value;
          List<NaryNode> children = new ArrayList<>();
          NaryNode(String value) { this.value = value; }
          void addChild(NaryNode child) { children.add(child); }
      }
      ```

### **3. Деревья в сторонних библиотеках**

Java-разработчики часто используют сторонние библиотеки для специфических типов
деревьев:

- **Apache Commons Collections**: Предоставляет структуры вроде `TreeList`
  (гибрид дерева и списка).
- **Guava**: `TreeMultiset` и `TreeMultimap` используют красно-чёрные деревья
  для упорядоченного хранения с поддержкой дубликатов.
- **JGraphT**: Библиотека для работы с графами и деревьями, включая минимальные
  остовные деревья (Kruskal, Prim).

### **4. Деревья в специфических контекстах**

- **Синтаксические деревья (AST)**:
    - Используются в компиляторах и парсерах (например, в Java Parser или
      ANTLR).
    - Представляют структуру кода (операторы, выражения).
- **Деревья решений**:
    - Используются в машинном обучении (например, в библиотеке Weka).
    - Реализуются как n-арные деревья.
- **Пространственные деревья**:
    - **Квадродеревья (QuadTree)** и **Октодеревья (OctTree)**: Для работы с
      2D/3D данными (игры, графика).
    - **R-дерево**: Для пространственных индексов (например, в базах данных
      PostGIS).

### **Сравнение основных деревьев в Java**

| Тип дерева                   | Где используется            | Сбалансированность | Сложность операций         | Особенности                                 |
|------------------------------|-----------------------------|--------------------|----------------------------|---------------------------------------------|
| Красно-чёрное дерево         | `TreeMap`, `TreeSet`        | Да                 | \(O(\log n)\)              | Баланс через цвета, стандартная библиотека  |
| Список с пропусками          | `ConcurrentSkipListMap/Set` | Да (вероятностная) | \(O(\log n)\)              | Потокобезопасность, не дерево в явном виде  |
| Куча                         | `PriorityQueue`             | Да (частично)      | \(O(\log n)\)              | Для приоритетов, не упорядочивает полностью |
| Бинарное дерево поиска (BST) | Пользовательская реализация | Нет                | \(O(n)\) (худший)          | Простое, может выродиться                   |
| AVL-дерево                   | Пользовательская реализация | Да                 | \(O(\log n)\)              | Строгий баланс, больше ротаций              |
| Префиксное дерево (Trie)     | Пользовательская реализация | Нет                | \(O(m)\) (m — длина ключа) | Для строк, автодополнения                   |
| B-дерево/B+-дерево           | Базы данных, вручную        | Да                 | \(O(\log n)\)              | Для больших данных, много ключей в узле     |

### **Итог**

- **Стандартная библиотека**: Основные деревья — красно-чёрное (`TreeMap`,
  `TreeSet`), куча (`PriorityQueue`) и список с пропусками (
  `ConcurrentSkipListMap/Set`).
- **Пользовательские реализации**: BST, AVL, B-дерево, Trie, сегментное дерево,
  Фенвиковое дерево, n-арное дерево и др.
- **Сторонние библиотеки**: Apache Commons, Guava, JGraphT добавляют
  специфические деревья.
- **Применение**: От упорядоченного хранения до алгоритмов, баз данных и
  графики.

## _**ВИДЫ БИНАРНЫХ ДЕРЕВЬЕВ**_

Бинарные деревья — это структуры данных, в которых каждый узел имеет не более
двух дочерних узлов (левый и правый). В Java и в теории компьютерных наук
существует множество видов бинарных деревьев, которые отличаются по своим
свойствам, способам организации и применению. Вот основные виды бинарных
деревьев:

### **1. Общее бинарное дерево (Binary Tree)**

- **Описание**: Базовый тип бинарного дерева, где каждый узел имеет до двух
  детей (левый и правый), без дополнительных ограничений на структуру.
- **Особенности**:
    - Не обязательно упорядоченное или сбалансированное.
    - Может быть использовано для представления иерархий (например,
      синтаксических деревьев).
- **Применение**: Парсинг выражений, представление структуры данных.
- **Пример в Java**:
  ```java
  class Node {
      int value;
      Node left, right;
      Node(int value) { this.value = value; }
  }
  ```

### **2. Бинарное дерево поиска (Binary Search Tree, BST)**

- **Описание**: Бинарное дерево, в котором для каждого узла все ключи в левом
  поддереве меньше значения узла, а в правом — больше.
- **Особенности**:
    - Не обязательно сбалансированное, может выродиться в список (сложность (O(
      n)) в худшем случае).
    - Основа для многих сбалансированных деревьев.
- **Применение**: Поиск, вставка, удаление элементов в упорядоченном виде.
- **Пример в Java**:
  ```java
  class BST {
      Node root;
      void insert(int value) {
          root = insertRec(root, value);
      }
      Node insertRec(Node root, int value) {
          if (root == null) return new Node(value);
          if (value < root.value) root.left = insertRec(root.left, value);
          else if (value > root.value) root.right = insertRec(root.right, value);
          return root;
      }
  }
  ```

### **3. Сбалансированные бинарные деревья**

Эти деревья разработаны для поддержания высоты близкой к (log n), что
обеспечивает сложность операций (O(log n)).

#### **3.1. AVL-дерево**

- **Описание**: Бинарное дерево поиска, где разница высот левого и правого
  поддеревьев (баланс-фактор) не превышает 1.
- **Особенности**:
    - Строго сбалансированное, требует ротаций после вставки/удаления.
    - Более частые балансировки, чем в красно-чёрном дереве, но меньшая высота.
- **Применение**: Когда важна максимальная сбалансированность (например, в базах
  данных).
- **Связь с красно-чёрным деревом**: AVL-дерево строже, чем красно-чёрное, но
  красно-чёрное чаще используется в стандартных библиотеках (например,
  `TreeMap`) из-за меньшего числа ротаций.

#### **3.2. Красно-чёрное дерево (Red-Black Tree)**

- **Описание**: Сбалансированное бинарное дерево поиска, использующее цвета (
  красный/чёрный) для поддержания баланса (как обсуждалось ранее).
- **Особенности**:
    - Менее строгое, чем AVL: высота до \(2 \cdot \log(n + 1)\).
    - Балансировка через перекрашивание и ротации.
    - Используется в Java в `TreeMap` и `TreeSet`.
- **Применение**: Упорядоченное хранение данных, стандартные структуры данных.
- **Пример в Java**:
  ```java
  import java.util.TreeMap;
  TreeMap<Integer, String> map = new TreeMap<>();
  map.put(1, "Один");
  map.put(2, "Два");
  ```

#### **3.3. Сплей-дерево (Splay Tree)**

- **Описание**: Самоадаптивное бинарное дерево поиска, где часто используемые
  узлы перемещаются ближе к корню через операцию "сплей" (splay).
- **Особенности**:
    - Не гарантирует строгую сбалансированность, но обеспечивает
      амортизированную сложность (O(log n)).
    - Нет в стандартной библиотеке Java, но может быть реализовано вручную.
- **Применение**: Кэширование, задачи с частым доступом к одним данным.
- **Связь с красно-чёрным деревом**: Менее предсказуемо, но может быть
  эффективнее в сценариях с локальностью доступа.

### **4. Куча (Heap)**

- **Описание**: Бинарное дерево, где значение каждого узла больше (max-heap) или
  меньше (min-heap) значений его детей.
- **Особенности**:
    - Не является деревом поиска, но поддерживает эффективное извлечение
      минимального/максимального элемента (\(O(\log n)\)).
    - В Java реализовано в `PriorityQueue` (min-heap).
    - Хранится в массиве, но логически представляет дерево.
- **Применение**: Очереди с приоритетами, алгоритмы (например, Dijkstra,
  HeapSort).
- **Пример в Java**:
  ```java
  import java.util.PriorityQueue;
  PriorityQueue<Integer> queue = new PriorityQueue<>();
  queue.add(3);
  queue.add(1);
  System.out.println(queue.poll()); // 1
  ```

### **5. Заполненное бинарное дерево (Complete Binary Tree)**

- **Описание**: Бинарное дерево, в котором все уровни, кроме, возможно,
  последнего, полностью заполнены, а последний уровень заполняется слева
  направо.
- **Особенности**:
    - Используется в кучах (например, в `PriorityQueue`).
    - Эффективно хранится в массиве без явных указателей.
- **Применение**: Реализация куч, компактное представление деревьев.

### **6. Полное бинарное дерево (Full Binary Tree)**

- **Описание**: Бинарное дерево, в котором каждый узел имеет либо 0, либо 2
  ребёнка.
- **Особенности**:
    - Не обязательно сбалансированное или упорядоченное.
    - Используется в специфических задачах (например, для вычисления выражений).
- **Применение**: Парсинг математических выражений.

### **7. Идеально сбалансированное бинарное дерево (Perfect Binary Tree)**

- **Описание**: Бинарное дерево, в котором все внутренние узлы имеют двух детей,
  а все листья находятся на одном уровне.
- **Особенности**:
    - Максимально компактное: (2^h-1) узлов, где (h) — высота.
    - Редко встречается на практике из-за строгих требований.
- **Применение**: Теоретические модели, тестирование алгоритмов.

### **8. Сегментное дерево (Segment Tree)**

- **Описание**: Бинарное дерево для хранения информации о сегментах или
  интервалах (например, суммы или минимума на диапазоне массива).
- **Особенности**:
    - Не является деревом поиска, а специализированным деревом для запросов на
      диапазоны.
    - Реализуется вручную.
    - Сложность запросов и обновлений: \(O(\log n)\).
- **Применение**: Алгоритмические задачи (например, Range Minimum Query).
- **Пример**:
  ```java
  class SegmentTree {
      int[] tree;
      int n;
      SegmentTree(int[] arr) {
          n = arr.length;
          tree = new int[4 * n];
          build(arr, 0, 0, n - 1);
      }
      void build(int[] arr, int node, int start, int end) {
          if (start == end) {
              tree[node] = arr[start];
          } else {
              int mid = (start + end) / 2;
              build(arr, 2 * node + 1, start, mid);
              build(arr, 2 * node + 2, mid + 1, end);
              tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
          }
      }
  }
  ```

### **9. Фенвиковое дерево (Binary Indexed Tree, BIT)**

- **Описание**: Компактное бинарное дерево для вычисления префиксных сумм и
  обновления элементов.
- **Особенности**:
    - Не является классическим деревом с узлами, а реализуется через массив.
    - Эффективнее сегментного дерева для некоторых задач (\(O(\log n)\)).
    - Реализуется вручную.
- **Применение**: Алгоритмы на массивах, задачи на динамическое
  программирование.

### **10. Декартово дерево (Treap)**

- **Описание**: Бинарное дерево поиска, сочетающее свойства BST и кучи. Каждый
  узел имеет ключ и приоритет, где BST-условие выполняется по ключу, а
  приоритеты образуют кучу.
- **Особенности**:
    - Вероятностная сбалансированность: случайные приоритеты обеспечивают высоту
      \(O(\log n)\) в среднем.
    - Реализуется вручную.
- **Применение**: Динамические структуры данных, задачи с объединением деревьев.
- **Связь с красно-чёрным деревом**: Похоже по сложности, но проще в реализации
  для некоторых задач.

### **11. Синтаксическое дерево (Abstract Syntax Tree, AST)**

- **Описание**: Бинарное или n-арное дерево, представляющее структуру программы
  или выражения.
- **Особенности**:
    - Не является деревом поиска, а иерархической структурой.
    - Используется в компиляторах (например, в Java Compiler API).
- **Применение**: Парсинг кода, оптимизация программ.

### **Сравнение основных видов бинарных деревьев**

| Тип дерева                   | Сбалансированность | Сложность операций | Где используется в Java     | Применение                         |
|------------------------------|--------------------|--------------------|-----------------------------|------------------------------------|
| Общее бинарное дерево        | Нет                | \(O(n)\)           | Пользовательская реализация | Иерархии, парсинг                  |
| Бинарное дерево поиска (BST) | Нет                | \(O(n)\) (худший)  | Пользовательская реализация | Поиск, основа для сбалансированных |
| AVL-дерево                   | Да                 | \(O(\log n)\)      | Пользовательская реализация | Строгий баланс, базы данных        |
| Красно-чёрное дерево         | Да                 | \(O(\log n)\)      | `TreeMap`, `TreeSet`        | Упорядоченное хранение             |
| Сплей-дерево                 | Нет (амортизир.)   | \(O(\log n)\)      | Пользовательская реализация | Кэширование, частый доступ         |
| Куча (Heap)                  | Да (частично)      | \(O(\log n)\)      | `PriorityQueue`             | Очереди с приоритетами, алгоритмы  |
| Сегментное дерево            | Да                 | \(O(\log n)\)      | Пользовательская реализация | Запросы на диапазонах              |
| Фенвиковое дерево (BIT)      | Да                 | \(O(\log n)\)      | Пользовательская реализация | Префиксные суммы, массивы          |
| Декартово дерево (Treap)     | Да (вероятностная) | \(O(\log n)\)      | Пользовательская реализация | Динамические структуры             |

### **Связь с красно-чёрным деревом**

- Красно-чёрное дерево — один из видов сбалансированных бинарных деревьев,
  используемых в Java (`TreeMap`, `TreeSet`).
- Оно менее строгое, чем AVL-дерево, но более эффективное для вставки/удаления
  за счёт меньшего числа ротаций.
- В отличие от кучи, оно поддерживает упорядоченный доступ к элементам.
- По сравнению с несбалансированным BST, красно-чёрное дерево гарантирует \(O(
  \log n)\) за счёт цветовых правил и балансировки.

### **Итог**

- Основные виды бинарных деревьев: общее бинарное дерево, BST,
  сбалансированные (AVL, красно-чёрное, сплей), куча, сегментное, Фенвиковое,
  декартово, синтаксическое.
- В Java стандартная библиотека использует красно-чёрное дерево (`TreeMap`,
  `TreeSet`) и кучу (`PriorityQueue`).
- Другие виды (AVL, Trie, сегментное и т.д.) реализуются вручную для
  специфических задач.

## ВИДЫ ДЕРЕВЬЕВ ПОДРОБНО

## 1. _**БИНАРНОЕ ДЕРЕВО(Binary Tree)**_

**Бинарное дерево** в Java — это структура данных, в которой каждый узел имеет
не более двух потомков, обычно называемых **левым** и **правым**. Оно
используется для представления иерархических данных, таких как деревья поиска,
кучи или синтаксические деревья. В стандартной библиотеке Java нет готового
класса для бинарного дерева, поэтому его обычно реализуют вручную.

### Основные характеристики бинарного дерева:

- **Узел**: Содержит значение (данные) и ссылки на левого и правого потомка.
- **Корень**: Верхний узел дерева.
- **Лист**: Узел без потомков.
- **Глубина/высота**: Максимальное расстояние от корня до листа.

### Пример реализации бинарного дерева в Java:

```java
// Класс для узла бинарного дерева
class Node {
    int value; // Значение узла
    Node left; // Левый потомок
    Node right; // Правый потомок

    Node(int value) {
        this.value = value;
        left = null;
        right = null;
    }
}

// Класс для бинарного дерева
class BinaryTree {
    Node root; // Корень дерева

    // Конструктор
    BinaryTree() {
        root = null;
    }

    // Метод для добавления узла (пример для бинарного поискового дерева)
    void insert(int value) {
        root = insertRec(root, value);
    }

    Node insertRec(Node root, int value) {
        if (root == null) {
            root = new Node(value);
            return root;
        }
        if (value < root.value) {
            root.left = insertRec(root.left, value);
        } else if (value > root.value) {
            root.right = insertRec(root.right, value);
        }
        return root;
    }

    // Обход дерева (in-order traversal)
    void inOrderTraversal(Node node) {
        if (node != null) {
            inOrderTraversal(node.left);
            System.out.print(node.value + " ");
            inOrderTraversal(node.right);
        }
    }

    // Пример использования
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(50);
        tree.insert(30);
        tree.insert(70);
        tree.insert(20);
        tree.insert(40);

        System.out.println("In-order traversal:");
        tree.inOrderTraversal(tree.root); // Вывод: 20 30 40 50 70
    }
}
```

### Использование в Java:

- **В стандартной библиотеке**:
    - `TreeMap` и `TreeSet` используют **красно-черное дерево** (разновидность
      сбалансированного бинарного дерева).
    - `PriorityQueue` основана на **куче**, которая является бинарным деревом.
- **Применение**:
    - Поиск и сортировка (BST).
    - Построение выражений (деревья выражений).
    - Реализация алгоритмов (например, обход графа, Huffman coding).
    - Хранение иерархических данных (например, структура каталогов).

### Операции в бинарном дереве:

| Операция        | Время (BST)                       |
|-----------------|-----------------------------------|
| Вставка         | O(log n) в среднем, O(n) в худшем |
| Поиск           | O(log n) в среднем                |
| Удаление        | O(log n) в среднем                |
| Обход (DFS/BFS) | O(n)                              |

_**Обход бинарного дерева:**_

Существует три основных способа обхода:

1. **In-order** (`левый -> корень -> правый`): Используется для BST, чтобы
   получить элементы в отсортированном порядке.
2. **Pre-order** (`корень -> левый -> правый`): Для копирования дерева или
   сериализации.
3. **Post-order** (`левый -> правый -> корень`): Для удаления дерева или
   вычисления выражений.

_**Пример структуры дерева:**_

```
       50
      /  \
     30   70
    /  \
   20  40
```

- **In-order**: 20, 30, 40, 50, 70
- **Pre-order**: 50, 30, 20, 40, 70
- **Post-order**: 20, 40, 30, 70, 50

### Заключение:

Бинарное дерево в Java — это мощная структура данных, которую можно реализовать
вручную для решения множества задач. Оно лежит в основе многих алгоритмов и
встроенных классов (`TreeMap`, `TreeSet`). Если вам нужен конкретный пример (
например, реализация BST, AVL или обхода), уточните, и я предоставлю подробный
код или объяснение!

## 2. **Бинарное дерево поиска (Binary Search Tree — BST)**

**Бинарное дерево поиска (Binary Search Tree, BST)** — это разновидность
бинарного дерева, в котором каждый узел имеет не более двух потомков (левый и
правый), и выполняются следующие условия:

- Значение в каждом узле больше всех значений в его **левом поддереве**.
- Значение в каждом узле меньше всех значений в его **правом поддереве**.
- Значения в узлах обычно уникальны (дубликаты могут обрабатываться особым
  образом, если требуется).

Эти свойства делают BST эффективной структурой данных для операций поиска,
вставки и удаления, особенно если дерево сбалансировано.

### Основные характеристики:

- **Узел**: Содержит значение и ссылки на левого и правого потомка.
- **Корень**: Верхний узел дерева.
- **Лист**: Узел без потомков.
- **Свойство BST**: Для любого узла с значением `value` все значения в левом
  поддереве < `value`, а в правом > `value`.

### Пример структуры BST:

```
       50
      /  \
     30   70
    /  \
   20  40
```

- Узел `50` — корень.
- Левое поддерево (`30`, `20`, `40`) содержит значения < `50`.
- Правое поддерево (`70`) содержит значения > `50`.

### Основные операции в BST:

1. **Поиск (Search)**:
    - Сравниваем искомое значение с текущим узлом:
        - Если равно — узел найден.
        - Если меньше — идем в левое поддерево.
        - Если больше — идем в правое поддерево.
    - Время: (O(h)), где (h) — высота дерева ((O(log n)) для
      сбалансированного дерева, (O(n)) для вырожденного).

2. **Вставка (Insert)**:
    - Находим место для нового значения, следуя свойствам BST, и добавляем новый
      узел.
    - Время: (O(h)).

3. **Удаление (Delete)**:
    - Находим узел для удаления. Возможны три случая:
        - Узел — лист: просто удаляем.
        - Узел имеет одного потомка: заменяем узел на потомка.
        - Узел имеет двух потомков: заменяем узел на минимальный элемент из
          правого поддерева (или максимальный из левого) и удаляем этот
          минимальный узел.
    - Время: (O(h)).

4. **Обход (Traversal)**:
    - **In-order** (`левый -> корень -> правый`): Возвращает элементы в
      отсортированном порядке.
    - **Pre-order** (`корень -> левый -> правый`): Для копирования дерева.
    - **Post-order** (`левый -> правый -> корень`): Для удаления дерева.

### Реализация BST в Java:

```java
// Класс для узла
class Node {
    int value;
    Node left, right;

    Node(int value) {
        this.value = value;
        left = right = null;
    }
}

// Класс для бинарного дерева поиска
class BinarySearchTree {
    Node root;

    // Вставка
    void insert(int value) {
        root = insertRec(root, value);
    }

    Node insertRec(Node root, int value) {
        if (root == null) {
            root = new Node(value);
            return root;
        }
        if (value < root.value) {
            root.left = insertRec(root.left, value);
        } else if (value > root.value) {
            root.right = insertRec(root.right, value);
        }
        return root;
    }

    // Поиск
    boolean search(int value) {
        return searchRec(root, value) != null;
    }

    Node searchRec(Node root, int value) {
        if (root == null || root.value == value) {
            return root;
        }
        if (value < root.value) {
            return searchRec(root.left, value);
        }
        return searchRec(root.right, value);
    }

    // In-order обход
    void inOrderTraversal(Node node) {
        if (node != null) {
            inOrderTraversal(node.left);
            System.out.print(node.value + " ");
            inOrderTraversal(node.right);
        }
    }

    // Пример использования
    public static void main(String[] args) {
        BinarySearchTree bst = new BinarySearchTree();
        bst.insert(50);
        bst.insert(30);
        bst.insert(70);
        bst.insert(20);
        bst.insert(40);

        System.out.println("In-order traversal:");
        bst.inOrderTraversal(bst.root); // Вывод: 20 30 40 50 70

        System.out.println("\nSearch 40: " + bst.search(40)); // true
        System.out.println("Search 90: " + bst.search(90)); // false
    }
}
```

### Преимущества BST:

- Эффективный поиск, вставка и удаление ((O(log n)) в среднем для
  сбалансированного дерева).
- Поддерживает упорядоченное хранение данных (in-order обход дает
  отсортированный список).
- Простота реализации базовых операций.

### Недостатки:

- **Несбалансированность**: Если дерево становится вырожденным (например, при
  вставке отсортированных данных), оно превращается в связный список, и операции
  занимают (O(n)).
- Для устранения этого недостатка используются **сбалансированные деревья**
  (AVL, красно-черное), которые поддерживают высоту порядка (O(log n)).

### Использование в Java:

- В стандартной библиотеке Java классы `TreeMap` и `TreeSet` используют *
  *красно-черное дерево**, которое является сбалансированной версией BST.
- BST часто применяется в задачах:
    - Поиск и сортировка.
    - Хранение словарей или ассоциативных массивов.
    - Реализация алгоритмов (например, построение интервальных деревьев).

## AVL - ДЕРЕВО

**AVL-дерево** — это **сбалансированное бинарное поисковое дерево** (Binary
Search Tree, BST), в котором для каждого узла разница высот левого и правого
поддерева (называемая **баланс-фактором**) не превышает 1 по модулю. Это
обеспечивает, что высота дерева остается \( O(\log n) \), гарантируя
эффективность операций поиска, вставки и удаления. AVL-дерево названо в честь
его изобретателей — Георгия Адельсона-Вельского и Евгения Ландиса.

### Основные характеристики AVL-дерева

- **Бинарное поисковое дерево**: Как и в обычном BST, для каждого узла значение
  в левом поддереве меньше, а в правом — больше значения узла.
- **Балансировка**: Для каждого узла баланс-фактор = высота правого поддерева -
  высота левого поддерева должен быть равен (-1), (0) или (1).
- **Самобалансировка**: После операций вставки или удаления, если баланс-фактор
  какого-либо узла выходит за пределы ([-1, 1]), выполняются **повороты**
  ( rotations) для восстановления баланса.

### Свойства AVL-дерева

1. Для любого узла | высота правого поддерева - высота левого
   поддерева | = 1.
2. Высота дерева (O(log n)), где (n) — количество узлов, что
   обеспечивает логарифмическую сложность операций.
3. Поддерживает свойства BST: упорядоченность данных (in-order обход дает
   отсортированный список).

### Основные операции

1. **Поиск**: Как в обычном BST, сравниваем искомое значение с узлом и движемся
   влево или вправо. Сложность: \( O(\log n) \).
2. **Вставка**:
    - Вставляем узел, как в BST.
    - Проверяем баланс-фактор для всех узлов на пути от нового узла к корню.
    - Если баланс нарушен (\( > 1 \) или \( < -1 \)), выполняем повороты.
    - Сложность: \( O(\log n) \).
3. **Удаление**:
    - Удаляем узел, как в BST.
    - Проверяем баланс-фактор и выполняем повороты при необходимости.
    - Сложность: \( O(\log n) \).

### Балансировка (повороты)

Если баланс-фактор узла становится \( > 1 \) или \( < -1 \), выполняются
следующие типы поворотов:

1. **Левый поворот (Left Rotation)**: Используется, когда правое поддерево
   слишком высокое.
2. **Правый поворот (Right Rotation)**: Используется, когда левое поддерево
   слишком высокое.
3. **Лево-правый поворот (Left-Right Rotation)**: Сначала левый поворот для
   левого поддерева, затем правый поворот.
4. **Право-левый поворот (Right-Left Rotation)**: Сначала правый поворот для
   правого поддерева, затем левый поворот.

### Пример структуры AVL-дерева

```
       30
      /  \
     20  40
    /      \
   10      50
```

- Баланс-фактор узла \( 30 \): \( \text{высота}(40) - \text{высота}(20) = 2 -
  2 = 0 \).
- Баланс-фактор узла \( 20 \): \( \text{высота}(10) - \text{высота}(null) = 1 -
  0 = 1 \).
- Баланс-фактор узла \( 40 \): \( \text{высота}(null) - \text{высота}(50) = 0 -
  1 = -1 \).

Если добавить узел, нарушающий баланс (например, \( 5 \)), потребуется поворот.

### Реализация AVL-дерева в Java

Ниже приведен пример реализации AVL-дерева с вставкой и балансировкой:

```java
class Node {
    int value, height;
    Node left, right;

    Node(int value) {
        this.value = value;
        this.height = 1; // Новый узел — лист
        left = right = null;
    }
}

class AVLTree {
    Node root;

    // Получение высоты узла
    int height(Node node) {
        return node == null ? 0 : node.height;
    }

    // Получение баланс-фактора
    int balanceFactor(Node node) {
        return node == null ? 0 : height(node.right) - height(node.left);
    }

    // Обновление высоты узла
    void updateHeight(Node node) {
        node.height = Math.max(height(node.left), height(node.right)) + 1;
    }

    // Правый поворот
    Node rightRotate(Node y) {
        Node x = y.left;
        Node T2 = x.right;

        x.right = y;
        y.left = T2;

        updateHeight(y);
        updateHeight(x);

        return x;
    }

    // Левый поворот
    Node leftRotate(Node x) {
        Node y = x.right;
        Node T2 = y.left;

        y.left = x;
        x.right = T2;

        updateHeight(x);
        updateHeight(y);

        return y;
    }

    // Вставка узла
    Node insert(Node node, int value) {
        // Шаг 1: Вставка как в BST
        if (node == null) {
            return new Node(value);
        }
        if (value < node.value) {
            node.left = insert(node.left, value);
        } else if (value > node.value) {
            node.right = insert(node.right, value);
        } else {
            return node; // Дубликаты не вставляем
        }

        // Шаг 2: Обновляем высоту
        updateHeight(node);

        // Шаг 3: Проверяем баланс
        int balance = balanceFactor(node);

        // Лево-лево (LL)
        if (balance < -1 && value < node.left.value) {
            return rightRotate(node);
        }
        // Право-право (RR)
        if (balance > 1 && value > node.right.value) {
            return leftRotate(node);
        }
        // Лево-право (LR)
        if (balance < -1 && value > node.left.value) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        // Право-лево (RL)
        if (balance > 1 && value < node.right.value) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    void insert(int value) {
        root = insert(root, value);
    }

    // In-order обход
    void inOrder(Node node) {
        if (node != null) {
            inOrder(node.left);
            System.out.print(node.value + " ");
            inOrder(node.right);
        }
    }

    public static void main(String[] args) {
        AVLTree tree = new AVLTree();
        tree.insert(10);
        tree.insert(20);
        tree.insert(30);
        tree.insert(40);
        tree.insert(50);
        tree.insert(25);

        System.out.println("In-order traversal:");
        tree.inOrder(tree.root); // Вывод: 10 20 25 30 40 50
    }
}
```

### Преимущества AVL-дерева

- **Гарантированная сбалансированность**: Высота всегда \( O(\log n) \), что
  обеспечивает \( O(\log n) \) для всех операций.
- **Эффективность поиска**: Быстрее, чем в несбалансированном BST.
- **Упорядоченность**: Поддерживает свойства BST, удобные для сортировки и
  диапазонных запросов.

### Недостатки

- **Сложность реализации**: Повороты и проверки баланса усложняют код по
  сравнению с обычным BST.
- **Дополнительные затраты на балансировку**: Вставка и удаление требуют
  дополнительных операций для поворотов, что может быть накладно для частых
  обновлений.
- **Менее гибкое, чем красно-черное дерево**: AVL-деревья строже балансируются,
  что иногда делает их менее эффективными для операций модификации по сравнению
  с красно-черными деревьями (например, в `TreeMap`/`TreeSet`).

### Сравнение с красно-черным деревом

- **AVL-дерево**:
    - Строгая балансировка (баланс-фактор \([-1, 1]\)).
    - Быстрее для операций поиска (меньшая высота).
    - Больше поворотов при вставке/удалении.
- **Красно-черное дерево**:
    - Менее строгая балансировка (использует цвета и свойства).
    - Чуть выше высота, но меньше операций балансировки.
    - Используется в стандартной библиотеке Java (`TreeMap`, `TreeSet`).

### Применение

- Хранение данных с частыми операциями поиска.
- Реализация словарей, где требуется упорядоченность.
- Алгоритмы, требующие сбалансированного дерева (например, интервальные
  деревья).

### Заключение

AVL-дерево — это эффективная структура данных для задач, где важна быстрая
операция поиска и гарантированная сбалансированность. Оно сложнее в реализации,
чем обычное BST, но обеспечивает \( O(\log n) \) для всех операций благодаря
строгой балансировке.

## КУЧА

**Куча (Heap)** как бинарное дерево — это специальная структура данных, которая
представлена в виде **полного** или **почти полного бинарного дерева** и
удовлетворяет свойству кучи. Куча используется для эффективного управления
приоритетами, сортировки и реализации алгоритмов, таких как алгоритм Дейкстры
или сортировка кучей (Heap Sort). В Java куча реализована, например, в классе
`PriorityQueue`.

### Основные характеристики кучи

1. **Бинарное дерево**:
    - Каждый узел имеет не более двух потомков (левый и правый).
    - Куча является **полным бинарным деревом** (все уровни, кроме, возможно,
      последнего, полностью заполнены, а последний уровень заполняется слева
      направо).

2. **Свойство кучи**:
    - **Max-Heap**: Значение каждого узла больше или равно значениям его
      потомков. Корень содержит максимальное значение.
    - **Min-Heap**: Значение каждого узла меньше или равно значениям его
      потомков. Корень содержит минимальное значение.

3. **Высота**: Высота кучи равна \( \lfloor \log_2 n \rfloor \), где \( n \) —
   количество узлов, что обеспечивает логарифмическую сложность операций.

### Пример структуры кучи

**Max-Heap**:

```
       90
      /  \
     60   80
    /  \  /  \
   30  20 40  50
```

- Корень (\( 90 \)) — максимальное значение.
- Для каждого узла значение больше, чем у его потомков (например, \( 60 > 30,
  20 \)).

**Min-Heap**:

```
       10
      /  \
     20   30
    /  \  /  \
   40  50 60  70
```

- Корень (\( 10 \)) — минимальное значение.
- Для каждого узла значение меньше, чем у его потомков (например, \( 20 < 40,
  50 \)).

### Свойства кучи как бинарного дерева

- **Полнота**: Куча — почти полное бинарное дерево, что позволяет эффективно
  хранить её в массиве.
- **Хранение в массиве**:
    - Узлы хранятся в массиве по уровням (слева направо).
    - Для узла с индексом \( i \):
        - Левый ребенок: \( 2i + 1 \).
        - Правый ребенок: \( 2i + 2 \).
        - Родитель: \( \lfloor (i - 1) / 2 \rfloor \).
    - Пример для Max-Heap выше: массив \( [90, 60, 80, 30, 20, 40, 50] \).

### Основные операции кучи

1. **Вставка (Insert)**:
    - Добавляем элемент в конец кучи (последний уровень, слева направо).
    - Выполняем **всплытие (sift up)**: сравниваем новый элемент с родителем и
      меняем их местами, если нарушается свойство кучи.
    - Сложность: \( O(\log n) \).

2. **Извлечение максимума/минимума (Extract Max/Min)**:
    - Возвращаем значение корня (максимум для Max-Heap, минимум для Min-Heap).
    - Заменяем корень последним элементом кучи.
    - Выполняем **погружение (sift down)**: сравниваем новый корень с потомками
      и меняем с большим (для Max-Heap) или меньшим (для Min-Heap), пока
      свойство кучи не восстановится.
    - Сложность: \( O(\log n) \).

3. **Получение максимума/минимума (Peek)**:
    - Возвращаем значение корня без удаления.
    - Сложность: \( O(1) \).

### Реализация кучи в Java (Min-Heap)

Ниже приведен пример реализации Min-Heap с использованием массива:

```java
class MinHeap {
    private int[] heap;
    private int size;
    private int capacity;

    public MinHeap(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity];
    }

    // Получение индексов родителя и потомков
    private int parent(int index) {
        return (index - 1) / 2;
    }

    private int leftChild(int index) {
        return 2 * index + 1;
    }

    private int rightChild(int index) {
        return 2 * index + 2;
    }

    // Всплытие для восстановления свойства кучи
    private void siftUp(int index) {
        while (index > 0 && heap[parent(index)] > heap[index]) {
            swap(index, parent(index));
            index = parent(index);
        }
    }

    // Погружение для восстановления свойства кучи
    private void siftDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);

        if (left < size && heap[left] < heap[minIndex]) {
            minIndex = left;
        }
        if (right < size && heap[right] < heap[minIndex]) {
            minIndex = right;
        }

        if (index != minIndex) {
            swap(index, minIndex);
            siftDown(minIndex);
        }
    }

    // Обмен элементов
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    // Вставка элемента
    public void insert(int value) {
        if (size >= capacity) {
            throw new IllegalStateException("Heap is full");
        }
        heap[size] = value;
        siftUp(size);
        size++;
    }

    // Извлечение минимального элемента
    public int extractMin() {
        if (size <= 0) {
            throw new IllegalStateException("Heap is empty");
        }
        int result = heap[0];
        heap[0] = heap[size - 1];
        size--;
        siftDown(0);
        return result;
    }

    // Получение минимального элемента
    public int peek() {
        if (size <= 0) {
            throw new IllegalStateException("Heap is empty");
        }
        return heap[0];
    }

    public static void main(String[] args) {
        MinHeap heap = new MinHeap(10);
        heap.insert(30);
        heap.insert(20);
        heap.insert(10);
        heap.insert(40);
        heap.insert(50);

        System.out.println("Min element: " + heap.peek()); // Вывод: 10
        System.out.println("Extracted min: " + heap.extractMin()); // Вывод: 10
        System.out.println("New min: " + heap.peek()); // Вывод: 20
    }
}
```

### Использование кучи в Java

- **В стандартной библиотеке**: Класс `PriorityQueue` реализует **Min-Heap** по
  умолчанию (можно настроить на Max-Heap с помощью компаратора).
  ```java
  PriorityQueue<Integer> minHeap = new PriorityQueue<>();
  minHeap.add(30);
  minHeap.add(20);
  minHeap.add(10);
  System.out.println(minHeap.poll()); // Вывод: 10
  ```
- Для Max-Heap:
  ```java
  PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
  ```

### Применение кучи

- **Приоритетные очереди**: Управление задачами с приоритетами (например,
  планировщик задач).
- **Сортировка кучей (Heap Sort)**: Сложность \( O(n \log n) \).
- **Алгоритмы на графах**: Алгоритм Дейкстры, Прима.
- **Обработка потоков данных**: Например, нахождение медианы в потоке.

### Преимущества кучи как бинарного дерева

- Эффективное извлечение минимального/максимального элемента (\( O(1) \) для
  получения, \( O(\log n) \) для удаления).
- Логарифмическая сложность вставки и удаления.
- Компактное хранение в массиве, минимизирующее накладные расходы.

### Недостатки

- Не поддерживает эффективный поиск произвольного элемента (\( O(n) \)).
- Менее гибкая, чем сбалансированные BST (например, AVL или красно-черное
  дерево), для задач, требующих упорядоченности.

### Заключение

Куча как бинарное дерево — это структура данных, которая эффективно управляет
приоритетами благодаря свойствам полноты и кучи. Она идеально подходит для
задач, где нужно быстро получать минимальный или максимальный элемент. В Java
куча реализована в `PriorityQueue`, но её можно создать вручную для
специфических нужд. Если нужен пример конкретной операции или более детальное
объяснение, напишите!

### Куча как структура данных

В Java бинарная куча (binary heap) — это специальная структура данных,
представляющая собой полное бинарное дерево, которое удовлетворяет свойству
кучи. Она широко используется для реализации приоритетных очередей (например,
`PriorityQueue` в Java) и в алгоритмах, таких как HeapSort. Рассмотрим, что из
себя представляет бинарная куча, её свойства, реализацию в Java и связь с
коллекциями.

### 1. **Определение и свойства бинарной кучи**

Бинарная куча — это дерево, где:

- **Полное бинарное дерево**: Все уровни, кроме последнего, полностью заполнены,
  а последний уровень заполняется слева направо.
- **Свойство кучи**:
    - **Минимальная куча (min-heap)**: Значение каждого узла меньше или равно
      значениям его потомков. Корень содержит минимальный элемент.
    - **Максимальная куча (max-heap)**: Значение каждого узла больше или равно
      значениям его потомков. Корень содержит максимальный элемент.
- **Высота**: Для \( n \) узлов высота кучи равна \( \lfloor \log_2(n)
  \rfloor \), что обеспечивает логарифмическую сложность операций.

В Java стандартная реализация (`PriorityQueue`) по умолчанию использует *
*минимальную кучу**, но можно настроить максимальную кучу, указав компаратор.

### 2. **Представление в памяти**

Бинарная куча обычно хранится в **массиве** для эффективности:

- Для узла с индексом \( i \) (нумерация с 0):
    - Левый потомок: \( 2i + 1 \).
    - Правый потомок: \( 2i + 2 \).
    - Родитель: \( \lfloor (i-1)/2 \rfloor \).
- Пример массива для min-heap: \( [1, 3, 5, 4, 6] \).
    - Корень (\( 1 \)) — минимальный элемент.
    - Левый потомок (\( 3 \)), правый (\( 5 \)), и т.д.

Такое представление компактно и позволяет-- позволяет избежать рекурсии и
указателей, как в древовидных структурах.

### 3. **Основные операции**

Бинарная куча поддерживает следующие операции с **логарифмической сложностью
** (\( O(\log n) \)):

- **Добавление элемента (`add` или `offer`)**:
    - Элемент добавляется в конец массива.
    - Затем он "всплывает" (bubble up) вверх по дереву, пока не восстановится
      свойство кучи (сравнивается с родителем и меняется местами, если нужно).
- **Удаление корня (`poll`)**:
    - Удаляется минимальный (или максимальный) элемент (корень).
    - Последний элемент массива перемещается в корень.
    - Затем он "погружается" (bubble down), меняясь с меньшим (или большим) из
      своих потомков, пока свойство кучи не восстановится.
- **Просмотр корня (`peek`)**:
    - Возвращает минимальный (или максимальный) элемент без удаления, \( O(
      1) \).

### 4. **Бинарная куча в Java: `PriorityQueue`**

В Java бинарная куча реализована в классе `PriorityQueue`, который находится в
пакете `java.util`. Это приоритетная очередь, основанная на минимальной куче по
умолчанию, но можно настроить поведение через компаратор.

#### Пример использования:

```java
import java.util.PriorityQueue;

public class Main {
    public static void main(String[] args) {
        // Минимальная куча (по умолчанию)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.add(5);
        minHeap.add(2);
        minHeap.add(8);
        System.out.println(minHeap.poll()); // 2
        System.out.println(minHeap.poll()); // 5
        System.out.println(minHeap.poll()); // 8

        // Максимальная куча (с компаратором)
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
        maxHeap.add(5);
        maxHeap.add(2);
        maxHeap.add(8);
        System.out.println(maxHeap.poll()); // 8
        System.out.println(maxHeap.poll()); // 5
        System.out.println(maxHeap.poll()); // 2
    }
}
```

#### Ключевые методы `PriorityQueue`:

- `add(E e)` или `offer(E e)`: Добавляет элемент, \( O(\log n) \).
- `poll()`: Удаляет и возвращает корень, \( O(\log n) \).
- `peek()`: Возвращает корень без удаления, \( O(1) \).
- `size()`: Возвращает количество элементов, \( O(1) \).
- `isEmpty()`: Проверяет, пуста ли куча, \( O(1) \).

### 5. **Сложность операций**

| Операция        | Сложность       |
|-----------------|-----------------|
| Добавление      | \( O(\log n) \) |
| Удаление корня  | \( O(\log n) \) |
| Просмотр корня  | \( O(1) \)      |
| Построение кучи | \( O(n) \)      |

- **Построение кучи** из \( n \) элементов (например, при создании
  `PriorityQueue` из коллекции) занимает \( O(n) \), так как можно эффективно
  преобразовать массив в кучу за линейное время.
- **Логарифмическая сложность** для добавления и удаления обусловлена высотой
  кучи (\( \log_2(n) \)).

### 6. **Применение бинарной кучи**

Бинарные кучи используются в:

- **Приоритетные очереди**: Для задач, где нужно обрабатывать элементы в порядке
  приоритета (например, алгоритм Дейкстры, планировщик задач).
- **Сортировка (HeapSort)**:
    - Построить max-heap (\( O(n) \)).
    - Последовательно извлекать максимальный элемент (\( O(n \log n) \)).
- **Алгоритмы на графах**:
    - Алгоритм Дейкстры (\( O((V + E) \log V) \)) использует `PriorityQueue` для
      выбора вершины с минимальным расстоянием.
    - Алгоритм Прима для минимального остовного дерева.
- **Событийные системы**: Для управления событиями, упорядоченными по времени.

#### Пример: Алгоритм Дейкстры с `PriorityQueue`

```java
import java.util.*;

class Graph {
    static class Edge {
        int to, weight;

        Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }

    public static int[] dijkstra(List<List<Edge>> graph, int start) {
        int n = graph.size();
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        pq.offer(new int[]{start, 0});

        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int vertex = curr[0], distance = curr[1];

            if (distance > dist[vertex]) continue;

            for (Edge e : graph.get(vertex)) {
                int newDist = distance + e.weight;
                if (newDist < dist[e.to]) {
                    dist[e.to] = newDist;
                    pq.offer(new int[]{e.to, newDist});
                }
            }
        }
        return dist;
    }
}
```

### 7. **Связь с коллекциями в Java**

- **PriorityQueue** — основная реализация бинарной кучи в Java, используемая для
  задач, связанных с приоритетами.
- **Collections.sort** косвенно использует идеи кучи в некоторых реализациях (
  например, TimSort не использует кучу напрямую, но HeapSort — альтернативный
  алгоритм сортировки).
- **TreeSet/TreeMap** (основаны на красно-черном дереве) имеют схожую
  логарифмическую сложность (\( O(\log n) \)), но бинарная куча компактнее и
  проще для приоритетных очередей.

### 8. **Ограничения и особенности**

- **Не поддерживает прямое изменение приоритета**: Если нужно изменить приоритет
  элемента, его нужно удалить и добавить заново (или использовать более сложные
  структуры, например, индексированную кучу).
- **Не отсортирована полностью**: Куча гарантирует, что корень —
  минимальный/максимальный элемент, но остальные элементы не полностью
  упорядочены.
- **Пространственная сложность**: \( O(n) \) для хранения \( n \) элементов в
  массиве.

### 9. **Ручная реализация бинарной кучи**

Если вы хотите реализовать бинарную кучу самостоятельно, вот пример минимальной
кучи:

```java
import java.util.ArrayList;

public class MinHeap {
    private ArrayList<Integer> heap;

    public MinHeap() {
        heap = new ArrayList<>();
    }

    private int parent(int index) {
        return (index - 1) / 2;
    }

    private int leftChild(int index) {
        return 2 * index + 1;
    }

    private int rightChild(int index) {
        return 2 * index + 2;
    }

    public void add(int value) {
        heap.add(value);
        bubbleUp(heap.size() - 1);
    }

    private void bubbleUp(int index) {
        while (index > 0) {
            int parent = parent(index);
            if (heap.get(parent) <= heap.get(index)) break;
            swap(index, parent);
            index = parent;
        }
    }

    public int poll() {
        if (heap.isEmpty()) throw new IllegalStateException("Heap is empty");
        int result = heap.get(0);
        heap.set(0, heap.get(heap.size() - 1));
        heap.remove(heap.size() - 1);
        if (!heap.isEmpty()) bubbleDown(0);
        return result;
    }

    private void bubbleDown(int index) {
        int minIndex = index;
        while (true) {
            int left = leftChild(index);
            int right = rightChild(index);

            if (left < heap.size() && heap.get(left) < heap.get(minIndex))
                minIndex = left;
            if (right < heap.size() && heap.get(right) < heap.get(minIndex))
                minIndex = right;

            if (minIndex == index) break;
            swap(index, minIndex);
            index = minIndex;
        }
    }

    private void swap(int i, int j) {
        int temp = heap.get(i);
        heap.set(i, heap.get(j));
        heap.set(j, temp);
    }

    public int peek() {
        if (heap.isEmpty()) throw new IllegalStateException("Heap is empty");
        return heap.get(0);
    }

    public boolean isEmpty() {
        return heap.isEmpty();
    }
}
```

#### Использование:

```java

void(){
    MinHeap heap = new MinHeap();
    heap.add(5);
    heap.add(2);
    heap.add(8);
    System.out.println(heap.poll()); // 2
    System.out.println(heap.poll()); // 5
    System.out.println(heap.poll()); // 8
    
}
```

### Итог

Бинарная куча в Java — это эффективная структура данных, реализованная в
`PriorityQueue`, которая использует массив для хранения полного бинарного дерева
с логарифмической сложностью операций (\( O(\log n) \)). Она идеально подходит
для приоритетных очередей, сортировки и алгоритмов на графах. Если нужен разбор
конкретного применения или помощь с реализацией, уточните!

## B - дерево

**B-дерево** (B-tree) — это сбалансированная структура данных в виде дерева,
предназначенная для эффективного хранения, поиска, вставки и удаления больших
объемов данных, особенно в системах, где данные хранятся на диске (например, в
базах данных и файловых системах). B-дерево является обобщением бинарного
поискового дерева, но отличается тем, что каждый узел может содержать *
*множество ключей** и иметь **более двух потомков**. Это делает B-дерево
особенно подходящим для минимизации операций ввода-вывода (I/O) при работе с
внешней памятью.

### Основные характеристики B-дерева

1. **Многоуровневая структура**:
    - Каждый узел может содержать несколько ключей и указателей на дочерние
      узлы.
    - Количество ключей в узле ограничено параметром \( t \), называемым *
      *порядком** или **минимальной степенью** дерева.

2. **Свойства B-дерева** (для порядка \( t \)):
    - Каждый узел (кроме корня) содержит от \( t-1 \) до \( 2t-1 \) ключей.
    - Каждый узел (кроме корня и листьев) имеет от \( t \) до \( 2t \) дочерних
      узлов.
    - Все листья находятся на одном уровне (дерево сбалансировано).
    - Ключи в узле хранятся в отсортированном порядке.
    - Для узла с \( k \) ключами \( k_1, k_2, \ldots, k_k \) и указателями \(
      p_1, p_2, \ldots, p_{k+1} \):
        - Все ключи в поддереве \( p_i \) меньше \( k_i \).
        - Все ключи в поддереве \( p_{i+1} \) больше \( k_i \).

3. **Высота**:
    - Высота B-дерева \( O(\log_t n) \), где \( n \) — количество ключей, а \(
      t \) — порядок. Благодаря большому числу ключей в узле высота мала, что
      минимизирует количество дисковых операций.

### Пример структуры B-дерева

Предположим, B-дерево порядка \( t = 2 \):

- Каждый узел содержит от 1 до 3 ключей (\( t-1 = 1 \), \( 2t-1 = 3 \)).
- Каждый узел (кроме корня) имеет от 2 до 4 потомков (\( t = 2 \), \( 2t =
  4 \)).

Пример дерева:

```
       [30]
      /     \
   [10,20] [40,50]
   /  |  \  /  |  \
 [5] [15] [25] [35] [45] [55]
```

- Ключи в узлах отсортированы.
- Все листья (\( [5], [15], [25], [35], [45], [55] \)) на одном уровне.

### Основные операции B-дерева

1. **Поиск (Search)**:
    - Начинается с корня, для каждого узла выполняется бинарный поиск (или
      линейный) среди ключей.
    - Если ключ найден, возвращается результат. Иначе переход в соответствующее
      поддерево.
    - Сложность: \( O(\log_t n) \), так как высота дерева мала.

2. **Вставка (Insert)**:
    - Находим подходящий лист для вставки ключа.
    - Если лист переполняется (\( > 2t-1 \) ключей), узел **разделяется**:
        - Средний ключ поднимается в родительский узел.
        - Узел разбивается на два новых узла с \( t-1 \) ключами.
    - Если родительский узел переполняется, процесс повторяется.
    - Сложность: \( O(\log_t n) \).

3. **Удаление (Delete)**:
    - Находим ключ и удаляем его.
    - Если узел становится "недозаполненным" (\( < t-1 \) ключей), выполняются:
        - **Заимствование** ключей у соседних узлов.
        - **Слияние** узлов, если заимствование невозможно.
    - Сложность: \( O(\log_t n) \).

### Реализация B-дерева в Java

Реализация B-дерева сложна из-за множества случаев для вставки, удаления и
балансировки. Ниже приведен упрощённый пример структуры узла и базового поиска:

```java
class BTreeNode {
    int[] keys; // Массив ключей
    BTreeNode[] children; // Массив указателей на дочерние узлы
    int numKeys; // Текущее количество ключей
    boolean isLeaf; // Является ли узел листом
    int t; // Порядок дерева

    BTreeNode(int t, boolean isLeaf) {
        this.t = t;
        this.isLeaf = isLeaf;
        keys = new int[2 * t - 1];
        children = new BTreeNode[2 * t];
        numKeys = 0;
    }
}

class BTree {
    BTreeNode root;
    int t; // Порядок

    BTree(int t) {
        this.t = t;
        root = null;
    }

    // Поиск ключа
    BTreeNode search(int key) {
        return root == null ? null : searchRec(root, key);
    }

    BTreeNode searchRec(BTreeNode node, int key) {
        int i = 0;
        while (i < node.numKeys && key > node.keys[i]) {
            i++;
        }
        if (i < node.numKeys && key == node.keys[i]) {
            return node;
        }
        if (node.isLeaf) {
            return null;
        }
        return searchRec(node.children[i], key);
    }

    // Вставка (упрощённая)
    void insert(int key) {
        if (root == null) {
            root = new BTreeNode(t, true);
            root.keys[0] = key;
            root.numKeys = 1;
        } else {
            // Реальная вставка требует разделения узлов и балансировки
            // Здесь только заглушка
            System.out.println("Inserting " + key + " (not fully implemented)");
        }
    }

    public static void main(String[] args) {
        BTree tree = new BTree(2); // Порядок t=2
        tree.insert(10);
        tree.insert(20);
        tree.insert(30);
    }
}
```

Полная реализация включает сложные процедуры разделения узлов, слияния и
перераспределения ключей, что выходит за рамки краткого ответа.

### Преимущества B-дерева

- **Эффективность для дисковых операций**: Благодаря большому количеству ключей
  в узле высота дерева мала, что сокращает количество обращений к диску.
- **Сбалансированность**: Все листья на одном уровне, что гарантирует \( O(
  \log_t n) \) для всех операций.
- **Подходит для больших данных**: Используется в базах данных (например, MySQL,
  PostgreSQL) и файловых системах (NTFS, ext4).

### Недостатки

- **Сложность реализации**: По сравнению с бинарными деревьями (например, AVL
  или красно-черное) B-дерево сложнее в программировании.
- **Менее эффективно для памяти**: Узлы содержат много ключей и указателей, что
  может быть избыточным для небольших данных.

### Применение

- **Базы данных**: Индексы (например, B+-дерево, производное от B-дерева).
- **Файловые системы**: Организация каталогов и файлов.
- **Системы с большими объемами данных**: Эффективное управление записями, где
  доступ к диску дорог.

### Отличие от B+-дерева

- **B-дерево**: Ключи и данные хранятся во всех узлах (внутренних и листовых).
- **B+-дерево**: Данные хранятся только в листьях, а внутренние узлы содержат
  только ключи для навигации. B+-дерево чаще используется в базах данных, так
  как листья связаны списком, что упрощает диапазонные запросы.

### Заключение

B-дерево — это мощная структура данных для работы с большими объемами данных,
особенно в системах с медленным доступом к памяти (диски). Оно обеспечивает
сбалансированность и логарифмическую сложность операций благодаря множеству
ключей в узлах и низкой высоте. В Java B-дерево редко реализуют вручную, так как
оно чаще встроено в базы данных или файловые системы, но понимание его структуры
полезно для работы с такими системами. Если нужен пример конкретной операции (
например, вставка или удаление), уточните, и я помогу!

## ЧТО ТАКОЕ СБАЛАНСИРОВАННОЕ ДЕРЕВО

## Grok:

Сбалансированное дерево — это бинарное дерево поиска, в котором высота
поддеревьев каждого узла поддерживается таким образом, чтобы минимизировать
разницу в их высотах. Это обеспечивает эффективные операции (поиск, вставка,
удаление) с временной сложностью \(O(\log n)\), где \(n\) — количество узлов.
Рассмотрим подробнее:

### **Что значит "сбалансированное"?**

В обычном бинарном дереве поиска (BST) узлы добавляются в зависимости от их
значений, что может привести к **несбалансированности**. Например, если
вставлять элементы в порядке возрастания (1, 2, 3, ...), дерево выродится в
связный список с высотой \(O(n)\), и операции станут медленными (\(O(n)\)).

Сбалансированное дерево предотвращает это, поддерживая высоту дерева близкой к
\(\log n\). Это достигается за счёт дополнительных правил или операций, которые
ограничивают разницу в высотах левого и правого поддеревьев.

### **Ключевые характеристики сбалансированного дерева**

- **Ограниченная разница высот**: Разница в высотах поддеревьев (баланс-фактор)
  ограничена. Например:
    - В **AVL-дереве** разница высот не превышает 1.
    - В **красно-чёрном дереве** высота ограничена косвенно через правила
      цветов (максимум \(2 \cdot \log(n + 1)\)).
- **Логарифмическая высота**: Высота дерева близка к \(\log n\), что гарантирует
  быстрые операции.
- **Автоматическая балансировка**: После вставки или удаления выполняются
  операции (ротации, перекрашивание), чтобы восстановить баланс.

### **Примеры сбалансированных деревьев**

1. **AVL-дерево**:
    - Строго сбалансированное: разница высот левого и правого поддеревьев не
      больше 1.
    - Балансировка через ротации (левые, правые, лево-правые, право-левые).
    - Используется, когда важна максимальная сбалансированность.
2. **Красно-чёрное дерево** (о котором мы говорили ранее):
    - Менее строгое, чем AVL: использует цвета (красный/чёрный) для контроля
      баланса.
    - Высота может быть до \(2 \cdot \log(n + 1)\), но операции проще, чем в
      AVL.
    - Используется в Java (`TreeMap`, `TreeSet`).
3. **B-дерево** и **B+-дерево**:
    - Многоуровневые сбалансированные деревья, оптимизированные для работы с
      большими данными (например, в базах данных).
4. **Сплей-дерево**:
    - Самоадаптивное сбалансированное дерево, где часто используемые узлы
      перемещаются ближе к корню.

### **Зачем нужна сбалансированность?**

- **Эффективность операций**: Поиск, вставка и удаление выполняются за \(O(\log
  n)\), так как высота дерева минимальна.
- **Предсказуемость**: Сбалансированное дерево предотвращает вырождение в
  линейную структуру, что гарантирует стабильную производительность.
- **Применение**: Используется в структурах данных (например, `TreeMap` в Java),
  базах данных, файловых системах и других системах, где важна быстрая работа с
  упорядоченными данными.

### **Как достигается сбалансированность?**

Сбалансированность поддерживается через **балансировочные операции**:

1. **Ротации**:
    - Левый поворот: поднимает правое поддерево, опуская левое.
    - Правый поворот: поднимает левое поддерево, опуская правое.
    - Используются в AVL и красно-чёрных деревьях.
2. **Перекрашивание** (в красно-чёрных деревьях):
    - Изменение цветов узлов (красный/чёрный) для соблюдения правил, что
      косвенно ограничивает высоту.
3. **Реорганизация структуры**:
    - В B-деревьях: разделение или слияние узлов.
    - В сплей-деревьях: перемещение узлов ближе к корню.

### **Красно-чёрное дерево как сбалансированное**

Красно-чёрное дерево, является сбалансированным благодаря своим цветовым
правилам:

- Запрет на два красных узла подряд ограничивает длину путей с красными узлами.
- Равная чёрная высота на всех путях гарантирует, что дерево не станет слишком
  "вытянутым".
- После вставки или удаления выполняются перекрашивание и ротации, чтобы
  восстановить свойства, обеспечивающие сбалансированность.

**Пример**:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

Это сбалансированное красно-чёрное дерево: чёрная высота путей одинакова (2), а
высота дерева минимальна (\(\approx \log n\)).

### **Сравнение с несбалансированным деревом**

**Несбалансированное дерево** (например, обычное BST):

```
10
 \
  15
   \
    20
```

- Высота \(O(n)\), операции за \(O(n)\).
- Похоже на связный список.

**Сбалансированное дерево** (например, красно-чёрное):

```
   15
  /  \
10    20
```

- Высота \(O(\log n)\), операции за \(O(\log n)\).

### **Реализация в Java**

В Java сбалансированное дерево (красно-чёрное) используется в `TreeMap` и
`TreeSet`. Они автоматически поддерживают баланс, скрывая детали (цвета,
ротации) от пользователя. Например:

```java
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(10, "Десять");
        map.put(5, "Пять");
        map.put(15, "Пятнадцать");
        System.out.println(map); // {5=Пять, 10=Десять, 15=Пятнадцать}
    }
}
```

`TreeMap` гарантирует, что дерево остаётся сбалансированным, а ключи
упорядочены.

### **Итог**

- Сбалансированное дерево — это бинарное дерево поиска с ограниченной высотой (
  \(\approx \log n\)), что обеспечивает быстрые операции.
- Красно-чёрное дерево — пример сбалансированного дерева, где баланс достигается
  через цвета и правила.
- Сбалансированность важна для производительности и предсказуемости в задачах с
  большими объёмами данных.

Если хотите углубиться, например, в сравнение AVL и красно-чёрных деревьев или в
код ротаций, дайте знать!

## Самобалансирующееся бинарное дерево поиска

Самобалансирующееся бинарное дерево поиска (Self-Balancing Binary Search Tree)
— это разновидность бинарного дерева поиска (BST), которое **автоматически
поддерживает сбалансированную структуру** после вставки или удаления элементов.

### Почему нужно самобалансирующееся дерево?

Обычное BST может **выродиться в список**, если элементы вставляются в
отсортированном порядке:

```
Вставка: 1 → 2 → 3 → 4 → 5

BST становится:
1
 \
  2
   \
    3
     ...
```

➡ В таком случае **поиск, вставка и удаление становятся O(n)**.
Самобалансирующееся дерево сохраняет **высоту O(log n)**.

### Как оно балансируется?

После вставки или удаления:

* **выполняются повороты (ротации)** узлов
* **перекрашиваются** (в случае красно-чёрного дерева)
* **пересчитываются факторы баланса** (например, в AVL)

### Популярные типы самобалансирующихся деревьев:

| Дерево                   | Особенности                                                   |
|--------------------------|---------------------------------------------------------------|
| **AVL-дерево**           | Поддерживает строгое равновесие по высоте (макс. разница 1)   |
| **Красно-чёрное дерево** | Более "лениво" балансирует, но быстрее при вставке и удалении |
| **Splay-дерево**         | Перемещает часто используемые элементы вверх                  |
| **Treap**                | Комбинирует свойства BST и кучи                               |
| **B-дерево / B+**        | Используется в базах данных и файловых системах               |

### Сложность (у всех O(log n) в среднем и худшем случае):

| Операция | Время    |
|----------|----------|
| Поиск    | O(log n) |
| Вставка  | O(log n) |
| Удаление | O(log n) |

### Применение:

* `TreeMap`, `TreeSet` в Java (на основе красно-чёрного дерева)
* Индексация в базах данных (например, B-деревья)
* Алгоритмы с приоритетами, сбалансированными интервалами

## КАК РАБОТАЕТ БАЛАНСИРОВКА

Балансировка в **самобалансирующихся бинарных деревьях поиска (например, AVL или
красно-чёрное дерево)** — это процесс, при котором после **вставки или удаления
узла** дерево автоматически изменяет свою структуру, чтобы сохранить
**логарифмическую высоту**, а значит — эффективную производительность (O(log
n)).

### Рассмотрим на примере **AVL-дерева**

_**Что такое "фактор баланса" узла?**_

Фактор баланса = высота левого поддерева − высота правого поддерева.

* Допустимы значения: **−1, 0, 1**
* Если выходит за эти пределы → требуется **балансировка**

#### Сценарии дисбаланса и повороты (ротации):

1. **LL (Left-Left) — правый поворот (Right Rotation)**

```
  30            20
 /             / \
20    →      10  30
/
10
```

2. **RR (Right-Right) — левый поворот (Left Rotation)**

```
10               20
  \             /  \
   20    →     10  30
     \
     30
```

3. **LR (Left-Right) — левый + правый поворот**

```
   30          30          20
  /           /           /  \
10    →     20    →     10  30
  \         /
   20     10
```

4. **RL (Right-Left) — правый + левый поворот**

```
10             10             20
  \              \           /  \
   30     →       20   →   10   30
  /                  \
 20                   30
```

### В Java (на уровне логики):

1. После вставки/удаления — пересчитываются высоты всех узлов.
2. Если нарушен баланс (|фактор| > 1) → определяется тип дисбаланса.
3. Выполняется соответствующий поворот.

### Зачем это всё?

* Без балансировки: вставка 1, 2, 3, 4, 5 → **линейное дерево**
* С балансировкой: всегда сохраняется **почти идеальная форма**

## Что из себя представляет бинарное дерево в памяти java?

В памяти Java бинарное дерево представляет собой **набор связанных объектов**,
каждый из которых — это **узел дерева** (класс `Node`), содержащий:

1. Данные (например, `int value`)
2. Ссылку на **левого потомка** (`left`)
3. Ссылку на **правого потомка** (`right`)

### Структура узла:

```java
class Node {
    int value;
    Node left;
    Node right;

    Node(int value) {
        this.value = value;
    }
}
```

### В памяти:

Каждый узел — это объект в куче (heap), содержащий:

* Поле `value` (например, 10)
* Ссылки `left` и `right` (указатели на другие объекты `Node`)
* Эти указатели формируют структуру дерева

### 📊 Пример:

```java
void demo() {
    Node root = new Node(10);
    root.left = new Node(5);
    root.right = new Node(15);
}
```

В памяти Java:

```
     [10]
     /   \
  [5]     [15]
```

Каждый `[]` — отдельный объект в памяти.

_**Где это хранится в памяти?**_

| Часть                                   | Расположение                                       |
|-----------------------------------------|----------------------------------------------------|
| `Node` объекты                          | Куча (Heap)                                        |
| Локальные переменные (например, `root`) | Стек (Stack), содержит **ссылку** на объект в куче |

## Особенности:

* Узлы дерева не обязательно хранятся последовательно в памяти.
* Каждая связь между узлами — это **ссылка**.
* Если дерево большое, то оно может быть **разбросано по куче**.

---

## Балансировка в jvm

Процесс балансировки красно-чёрного дерева в JVM (Java Virtual Machine),
например, в реализации `TreeMap` из пакета `java.util`, представляет собой
внутренний механизм, который автоматически восстанавливает свойства
красно-чёрного дерева после операций вставки или удаления. Поскольку вы
спрашивали о красно-чёрных деревьях и сбалансированности, я сосредоточусь на
том, как JVM (точнее, реализация `TreeMap` в стандартной библиотеке Java)
выполняет балансировку, опираясь на цвета узлов, ротации и перекрашивание.

---

### **Контекст: Красно-чёрное дерево в `TreeMap`**

В Java `TreeMap` использует красно-чёрное дерево для хранения пар ключ-значение,
где ключи упорядочены. Балансировка происходит после:

- **Вставки** нового узла (метод `put`).
- **Удаления** узла (метод `remove`).

Цель балансировки — восстановить **пять свойств красно-чёрного дерева**:

1. Каждый узел красный или чёрный.
2. Корень чёрный.
3. Листья (NIL) чёрные.
4. Нет двух красных узлов подряд.
5. Чёрная высота одинакова для всех путей от узла до листьев.

JVM скрывает детали реализации от пользователя, но мы можем разобрать, как это
работает, основываясь на стандартной реализации в OpenJDK.

### **Как выглядит процесс балансировки?**

#### **1. Структура узла**

Внутренне `TreeMap` использует класс `Entry` для представления узла:

```java
static class Entry<K, V> {
    K key;
    V value;
    Entry<K, V> left, right, parent;
    boolean color; // true = красный, false = чёрный
}
```

- `color` хранит цвет узла (обычно `false` для чёрного, `true` для красного).
- `left`, `right`, `parent` — ссылки на дочерние узлы и родителя.

#### **2. Балансировка после вставки**

Когда новый узел добавляется в `TreeMap` (через `put`), он вставляется как *
*красный** узел, чтобы минимизировать нарушение чёрной высоты. После вставки
метод `fixAfterInsertion` восстанавливает свойства дерева.

**Шаги балансировки после вставки**:

1. **Проверка нарушений**:
    - Если новый узел — корень, он перекрашивается в чёрный (свойство 2).
    - Если родитель нового узла красный, возникает нарушение свойства 4 (два
      красных узла подряд). Тогда начинаются корректирующие действия.
2. **Случаи обработки (для узла \(x\))**:
    - **Случай 1: Родитель \(p\) красный, а его брат (дядя) тоже красный**:
        - Перекрашиваем родителя \(p\) и дядю в чёрный.
        - Деда \(g\) (родителя \(p\)) перекрашиваем в красный.
        - Проверяем деда рекурсивно, так как он теперь красный и может нарушать
          свойства.
    - **Случай 2: Родитель красный, дядя чёрный или отсутствует, \(x\) — внешний
      внук**:
        - Выполняется одна ротация (левая или правая) вокруг деда.
        - Родитель становится чёрным, дед — красным.
    - **Случай 3: Родитель красный, дядя чёрный или отсутствует, \(x\) —
      внутренний внук**:
        - Выполняется двойная ротация: сначала вокруг родителя, потом вокруг
          деда.
        - Родитель становится чёрным, дед — красным.
3. **Финальный шаг**:
    - Корень всегда перекрашивается в чёрный.

**Пример**:
Допустим, дерево:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

Вставляем узел 4 (красный) как левого ребёнка 5:

- 5 (родитель) красный, 4 (новый узел) красный → нарушение свойства 4.
- Дядя (7) чёрный, 4 — левый ребёнок 5 (внешний внук).
- Выполняется правая ротация вокруг деда (10), 5 становится новым корнем:

```
       5 (чёрный)
      /  \
   3 (чёрный)  10 (красный)
  /             / \
 4 (красный)  7 (чёрный) 15 (чёрный)
```

- Перекрашиваем 5 в чёрный, 10 в красный. Свойства восстановлены.

**Код в OpenJDK** (упрощённо, метод `fixAfterInsertion`):

```java
private void fixAfterInsertion(Entry<K, V> x) {
    x.color = RED;
    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K, V> y = rightOf(parentOf(parentOf(x))); // дядя
            if (colorOf(y) == RED) { // случай 1
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else { // случаи 2 и 3
                if (x == rightOf(parentOf(x))) { // случай 3
                    x = parentOf(x);
                    rotateLeft(x);
                }
                setColor(parentOf(x), BLACK); // случай 2
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else { // симметрично для правой стороны
            // аналогичная логика
        }
    }
    root.color = BLACK; // корень всегда чёрный
}
```

#### **3. Балансировка после удаления**

Удаление узла (через `remove`) сложнее, так как удаление чёрного узла может
нарушить чёрную высоту (свойство 5). Метод `fixAfterDeletion` корректирует
дерево.

**Шаги балансировки после удаления**:

1. **Замена узла**:
    - Удаляемый узел заменяется его преемником (например, минимальным узлом
      правого поддерева).
    - Если удаляемый узел или его преемник чёрный, это может уменьшить чёрную
      высоту на одном из путей.
2. **Случаи обработки (для узла \(x\), который заменил удалённый)**:
    - Если \(x\) красный, его просто перекрашивают в чёрный, и чёрная высота
      восстанавливается.
    - Если \(x\) чёрный, проверяется его брат \(s\) (sibling):
        - **Случай 1: Брат красный**:
            - Перекрашиваем брата в чёрный, родителя в красный, выполняем
              ротацию.
            - Переходим к другим случаям.
        - **Случай 2: Брат чёрный, оба его ребёнка чёрные**:
            - Перекрашиваем брата в красный, родителя проверяем рекурсивно.
        - **Случай 3: Брат чёрный, один из его детей красный**:
            - Выполняются ротации и перекрашивание, чтобы восстановить чёрную
              высоту.
3. **Финальный шаг**:
    - Корень перекрашивается в чёрный.

**Пример**:
Допустим, удаляем узел 3 из дерева:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

- 3 — чёрный, его удаление уменьшает чёрную высоту левого пути.
- Заменяем 3 на NIL (чёрный лист).
- Проверяем брата 7 (чёрный) и его детей (NIL, чёрные).
- Перекрашиваем 7 в красный, 5 проверяем рекурсивно.
- Если нужно, выполняем ротации.

**Код в OpenJDK** (упрощённо, метод `fixAfterDeletion`):

```java
private void fixAfterDeletion(Entry<K, V> x) {
    while (x != root && colorOf(x) == BLACK) {
        if (x == leftOf(parentOf(x))) {
            Entry<K, V> sib = rightOf(parentOf(x)); // брат
            if (colorOf(sib) == RED) { // случай 1
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateLeft(parentOf(x));
                sib = rightOf(parentOf(x));
            }
            if (colorOf(leftOf(sib)) == BLACK && colorOf(rightOf(sib)) == BLACK) { // случай 2
                setColor(sib, RED);
                x = parentOf(x);
            } else { // случай 3
                if (colorOf(rightOf(sib)) == BLACK) {
                    setColor(leftOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateRight(sib);
                    sib = rightOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(rightOf(sib), BLACK);
                rotateLeft(parentOf(x));
                x = root;
            }
        } else { // симметрично для правой стороны
            // аналогичная логика
        }
    }
    setColor(x, BLACK);
}
```

#### **4. Ротации**

Ротации — это ключевой механизм балансировки, используемый при вставке и
удалении. Они изменяют структуру дерева, сохраняя порядок ключей.

**Левая ротация** (на узле \(p\)):

```
   p           r
  / \         / \
 l   r  →    p   rr
    / \     / \
   rl  rr  l   rl
```

- \(r\) становится родителем, \(p\) — левым ребёнком \(r\).
- \(rl\) становится правым ребёнком \(p\).

**Правая ротация** (на узле \(p\)):

```
     p         l
    / \       / \
   l   r  →  ll  p
  / \           / \
 ll  lr        lr  r
```

- \(l\) становится родителем, \(p\) — правым ребёнком \(l\).
- \(lr\) становится левым ребёнком \(p\).

Код ротации (пример из OpenJDK):

```java
private void rotateLeft(Entry<K, V> p) {
    if (p != null) {
        Entry<K, V> r = p.right;
        p.right = r.left;
        if (r.left != null)
            r.left.parent = p;
        r.parent = p.parent;
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p;
        p.parent = r;
    }
}
```

### **Как это работает в JVM?**

- **Память**: Каждый узел (`Entry`) хранит ключ, значение, ссылки (`left`,
  `right`, `parent`) и цвет. JVM управляет выделением памяти через сборщик
  мусора.
- **Производительность**: Ротации и перекрашивание — быстрые операции (\(O(
  1)\)), а общее количество итераций балансировки ограничено высотой дерева (
  \(O(\log n)\)).
- **Оптимизация**: Реализация в OpenJDK оптимизирована для минимизации операций
  с памятью и проверок условий.
- **Потокобезопасность**: `TreeMap` не потокобезопасен. Для параллельного
  доступа используется `ConcurrentSkipListMap`, который реализует другую
  структуру.

### **Итог**

- Балансировка в `TreeMap` (красно-чёрное дерево) в JVM происходит через:
    - **Перекрашивание**: изменение цветов узлов для соблюдения свойств (нет
      двух красных подряд, равная чёрная высота).
    - **Ротации**: перестройка структуры дерева (левые/правые ротации).
- После **вставки** корректируются нарушения из-за красных узлов (
  `fixAfterInsertion`).
- После **удаления** восстанавливается чёрная высота (`fixAfterDeletion`).
- Все операции выполняются за \(O(\log n)\), что гарантирует эффективность.

## Алгоритмы балансировки деревьев

В Java балансировка деревьев актуальна для структур данных, таких как *
*красно-черные деревья** и **AVL-деревья**, которые используются для поддержания
эффективного времени операций (O(log n) для вставки, удаления и поиска). В
стандартной библиотеке Java (`java.util`) встроенные коллекции, такие как
`TreeSet` и `TreeMap`, используют **красно-черное дерево**, но AVL-деревья и
другие типы деревьев требуют собственной реализации. Рассмотрим основные
алгоритмы балансировки деревьев и их применение в Java.

---

### 1. **Красно-черное дерево (Red-Black Tree)**

Красно-черное дерево — это самобалансирующееся бинарное дерево поиска, которое
используется в `TreeSet` и `TreeMap`. Оно поддерживает баланс, обеспечивая, что
высота дерева остается O(log n).

#### Алгоритм балансировки

Балансировка основана на соблюдении следующих свойств:

1. Каждый узел либо красный, либо черный.
2. Корень всегда черный.
3. Все листья (NIL-узлы) черные.
4. Если узел красный, оба его потомка черные (нет двух красных узлов подряд).
5. Для каждого узла все пути от него до листьев содержат одинаковое количество
   черных узлов.

**Операции балансировки**:

- **Вставка**:
    1. Вставляем новый узел (всегда красный).
    2. Если нарушаются свойства (например, два красных узла подряд), выполняем *
       *повороты** (левый или правый) и **перекраску** узлов.
    3. Если корень стал красным, перекрашиваем его в черный.
- **Удаление**:
    1. Удаляем узел, как в обычном бинарном дереве поиска.
    2. Если удаленный узел был черным, это может нарушить свойство черной
       высоты. Выполняем повороты и перекраску для восстановления баланса.

**Сложность**: O(log n) для вставки, удаления и поиска.

**Пример в Java**:
В стандартной библиотеке реализация красно-черного дерева скрыта в `TreeMap` и
`TreeSet`. Прямой доступ к алгоритму невозможен, но можно написать свою
реализацию:

```java
class RedBlackTree {
    private static final boolean RED = true;
    private static final boolean BLACK = false;

    class Node {
        int key;
        Node left, right, parent;
        boolean color;

        Node(int key) {
            this.key = key;
            this.color = RED;
        }
    }

    private Node root;

    private void leftRotate(Node x) {
        Node y = x.right;
        x.right = y.left;
        if (y.left != null) y.left.parent = x;
        y.parent = x.parent;
        if (x.parent == null) root = y;
        else if (x == x.parent.left) x.parent.left = y;
        else x.parent.right = y;
        y.left = x;
        x.parent = y;
    }

    // Аналогично реализуется rightRotate, insert, delete и балансировка
}
```

---

### 2. **AVL-дерево**

AVL-дерево — это другое самобалансирующееся бинарное дерево поиска, где разница
высот левого и правого поддерева (баланс-фактор) для каждого узла не превышает

1. В Java стандартной реализации AVL-дерева нет, но его можно реализовать
   вручную.

#### Алгоритм балансировки

- **Баланс-фактор**: `balance = height(left) - height(right)`. Допустимые
  значения: -1, 0, 1.
- **Операции**:
    - **Вставка**:
        1. Вставляем узел, как в обычном бинарном дереве поиска.
        2. Обновляем высоты узлов.
        3. Проверяем баланс-фактор. Если он выходит за пределы [-1, 1],
           выполняем **повороты**:
            - **LL (Left-Left)**: Правый поворот.
            - **RR (Right-Right)**: Левый поворот.
            - **LR (Left-Right)**: Левый поворот для левого поддерева, затем
              правый поворот.
            - **RL (Right-Left)**: Правый поворот для правого поддерева, затем
              левый поворот.
    - **Удаление**: Аналогично вставке, с последующей проверкой баланса и
      поворотами.

**Сложность**: O(log n) для всех операций.

**Пример в Java**:

```java
class AVLTree {
    class Node {
        int key, height;
        Node left, right;

        Node(int key) {
            this.key = key;
            this.height = 1;
        }
    }

    private Node root;

    private int height(Node node) {
        return node == null ? 0 : node.height;
    }

    private int getBalance(Node node) {
        return node == null ? 0 : height(node.left) - height(node.right);
    }

    private Node rightRotate(Node y) {
        Node x = y.left;
        Node T2 = x.right;
        x.right = y;
        y.left = T2;
        y.height = Math.max(height(y.left), height(y.right)) + 1;
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        return x;
    }

    private Node insert(Node node, int key) {
        if (node == null) return new Node(key);

        if (key < node.key) node.left = insert(node.left, key);
        else if (key > node.key) node.right = insert(node.right, key);
        else return node; // Дубликаты не допускаются

        node.height = Math.max(height(node.left), height(node.right)) + 1;
        int balance = getBalance(node);

        // LL
        if (balance > 1 && key < node.left.key) return rightRotate(node);
        // RR
        if (balance < -1 && key > node.right.key) return leftRotate(node);
        // LR
        if (balance > 1 && key > node.left.key) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        // RL
        if (balance < -1 && key < node.right.key) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    private Node leftRotate(Node x) {
        Node y = x.right;
        Node T2 = y.left;
        y.left = x;
        x.right = T2;
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        y.height = Math.max(height(y.left), height(y.right)) + 1;
        return y;
    }
}
```

---

### 3. **Другие алгоритмы балансировки**

Хотя красно-черные деревья и AVL-деревья наиболее распространены, существуют и
другие подходы к балансировке деревьев, которые могут быть реализованы в Java:

#### a) **B-дерево (B-Tree)**

- Используется в базах данных и файловых системах.
- Балансировка: Узлы могут содержать несколько ключей и потомков, а при
  переполнении узел разделяется.
- В Java нет стандартной реализации, но B-дерево можно реализовать для работы с
  большими данными.

#### b) **Splay-дерево**

- Самобалансирующееся дерево, которое перемещает часто используемые узлы ближе к
  корню с помощью операции **splay** (последовательность поворотов).
- Нет стандартной реализации в Java, но подходит для кэширования или приложений,
  где важны недавние запросы.

#### c) **Treap (Дерево + куча)**

- Комбинирует бинарное дерево поиска и кучу, используя случайные приоритеты для
  балансировки.
- Балансировка: Повороты выполняются для поддержания свойств кучи.
- Реализация требует генерации случайных приоритетов и не встроена в Java.

---

### 4. **Сравнение AVL и красно-черного дерева**

| Характеристика                | AVL-дерево                       | Красно-черное дерево       |
|-------------------------------|----------------------------------|----------------------------|
| **Балансировка**              | Более строгая (баланс-фактор ±1) | Менее строгая (O(log n))   |
| **Скорость поиска**           | Быстрее (меньшая высота)         | Чуть медленнее             |
| **Скорость вставки/удаления** | Медленнее (больше поворотов)     | Быстрее (меньше поворотов) |
| **Применение в Java**         | Нет в стандартной библиотеке     | `TreeSet`, `TreeMap`       |

---

### 5. **Когда использовать?**

- **Красно-черное дерево**:
    - Используйте встроенные `TreeSet`/`TreeMap` для большинства задач.
    - Подходит для общего использования, где важны быстрые вставки/удаления.
- **AVL-дерево**:
    - Реализуйте вручную, если требуется более быстрый поиск за счет более
      медленных вставок.
    - Подходит для приложений с частыми запросами и редкими изменениями.
- **Другие деревья**:
    - B-дерево для работы с большими данными (например, базы данных).
    - Splay-дерево для кэширования.
    - Treap для экспериментальных задач с вероятностной балансировкой.

---

### 6. **Заключение**

В Java стандартная библиотека предоставляет только красно-черные деревья через
`TreeSet` и `TreeMap`. Для AVL-деревьев и других структур (B-дерево,
Splay-дерево, Treap) требуется собственная реализация. Алгоритмы балансировки (
повороты, перекраска, разделение узлов) обеспечивают логарифмическую сложность
операций, но выбор структуры зависит от конкретной задачи.


