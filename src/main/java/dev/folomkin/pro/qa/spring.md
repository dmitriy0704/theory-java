# SPRING

> ## Scope бинов

В Spring Framework "scope" (область видимости) бинов определяет, как и когда
создаются экземпляры бинов, а также как они управляются контейнером Spring.
Области видимости позволяют контролировать жизненный цикл бинов и их доступность
в приложении. В Spring есть несколько основных областей видимости бинов:

### 1. Singleton (по умолчанию)

- **Описание**: В этой области видимости контейнер Spring создает только один
  экземпляр бина на весь контекст приложения. Этот экземпляр будет
  использоваться для всех запросов к этому бину. Этот экземпляр помещается в кэш
  таких же бинов (синглтонов) и все последующие вызовы бина с таким именем будут
  возвращать объект из кэша.
- **Жизненный цикл**: Бин создается при старте приложения и уничтожается при
  завершении работы приложения.
- **Пример**:
  ```java
  @Component
  public class MySingletonBean {
      // ...
  }
  ```

### 2. Prototype

- **Описание**: При этой области видимости каждый запрос к контейнеру Spring
  создает новый экземпляр бина. Это означает, что каждый раз, когда вы
  запрашиваете бин, вы получаете новый объект.
- **Жизненный цикл**: Бин создается при каждом запросе и уничтожается, когда на
  него больше нет ссылок (сборщик мусора).
- **Пример**:
  ```java
  @Component
  @Scope("prototype")
  public class MyPrototypeBean {
      // ...
  }
  ```

### 3. Request

- **Описание**: Эта область видимости используется в веб-приложениях. Бин
  создается для каждого HTTP-запроса и уничтожается по завершении обработки
  этого запроса.
- **Жизненный цикл**: Бин существует только в течение одного HTTP-запроса.
- **Пример**:
  ```java
  @Component
  @Scope("request")
  public class MyRequestBean {
      // ...
  }
  ```

### 4. Session

- **Описание**: Также используется в веб-приложениях. Бин создается для каждой
  HTTP-сессии и уничтожается, когда сессия завершается. Это полезно для хранения
  информации, специфичной для пользователя, в течение всего времени его сессии.
- **Жизненный цикл**: Бин существует в течение одной HTTP-сессии.
- **Пример**:
  ```java
  @Component
  @Scope("session")
  public class MySessionBean {
      // ...
  }
  ```

### 5. Global Session/Application

- **Описание**: Application: Бин с данной областью видимости создается один раз
  для всего сервлет-контекста. Это полезно для данных, которые должны быть
  общими для всех пользователей и сессий в приложении.
- **Жизненный цикл**: Бин существует в течение глобальной сессии.
- **Пример**:
  ```java
  @Component
  @Scope("globalSession")
  public class MyGlobalSessionBean {
      // ...
  }
  ```

### 6. WebSocket

Бин с данной областью видимости создается для каждой сессии WebSocket. Это
полезно для работы с данными, специфичными для каждой WebSocket-сессии.

### Применение области видимости

Чтобы задать область видимости для бина, можно использовать аннотацию `@Scope`
вместе с аннотацией `@Component`, `@Service`, `@Repository` или `@Controller`.
Например:

```java
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope("prototype")
public class MyPrototypeBean {
    // ...
}
```

### Примечания

1. По умолчанию все бины имеют область видимости "singleton", если не указано
   иное.
2. Области видимости "request", "session" и "globalSession" могут использоваться
   только в контексте веб-приложений (например, при использовании Spring MVC).
3. Для использования областей видимости "request" и "session" необходимо
   убедиться, что приложение настроено как веб-приложение.

### Заключение

Области видимости бинов в Spring позволяют гибко управлять жизненным циклом
объектов и их доступностью в приложении. Понимание этих областей помогает
разработчикам правильно проектировать архитектуру приложения и эффективно
управлять ресурсами.

> ## Жизненный цикл бинов

В контексте Java и, в частности, фреймворка Spring, жизненный цикл бинов (или
компонентов) описывает последовательность этапов, через которые проходит бин от
его создания до уничтожения. Понимание этого жизненного цикла важно для
правильного управления ресурсами и поведения ваших компонентов. Давайте
рассмотрим основные этапы жизненного цикла бинов в Spring.

### 1. Создание бина

- **Инстанцирование**: Когда Spring контейнер создает бин, он использует
  конструктор класса для создания его экземпляра. Это может быть стандартный
  конструктор или конструктор с параметрами, если используется внедрение
  зависимостей.

### 2. Внедрение зависимостей

- **Внедрение зависимостей**: После создания бина Spring инжектирует все
  необходимые зависимости (например, другие бины или конфигурационные параметры)
  в созданный объект. Это может происходить через конструкторы, сеттеры или
  поля (в зависимости от конфигурации).

### 3. Инициализация

- **Методы инициализации**: После внедрения зависимостей Spring вызывает методы
  инициализации, если они определены. Это может быть:
    - Метод с аннотацией `@PostConstruct`, который будет вызван после завершения
      инъекции зависимостей.
    - Метод, указанный в атрибуте `init-method` в XML-конфигурации.

Пример использования `@PostConstruct`:

```java

@Component
public class MyBean {

    @PostConstruct
    public void init() {
        // Логика инициализации
    }
}
```

### 4. Использование

- **Использование бина**: На этом этапе бин готов к использованию в приложении.
  Он может обрабатывать запросы, выполнять бизнес-логику и взаимодействовать с
  другими компонентами.

### 5. Уничтожение

- **Методы уничтожения**: Когда контейнер Spring закрывается или бин больше не
  нужен, он проходит процесс уничтожения. На этом этапе могут быть вызваны
  методы для освобождения ресурсов или выполнения завершающих действий:
    - Метод с аннотацией `@PreDestroy`, который будет вызван перед уничтожением
      бина.
    - Метод, указанный в атрибуте `destroy-method` в XML-конфигурации.

Пример использования `@PreDestroy`:

```java

@Component
public class MyBean {

    @PreDestroy
    public void cleanup() {
        // Логика освобождения ресурсов
    }
}
```

### Полный жизненный цикл бина

1. **Создание**: Инстанцирование бина.
2. **Внедрение зависимостей**: Инъекция необходимых зависимостей.
3. **Инициализация**: Вызов методов инициализации.
4. **Использование**: Бин готов к использованию.
5. **Уничтожение**: Вызов методов для освобождения ресурсов перед уничтожением.

### Заключение

Понимание жизненного цикла бинов в Spring позволяет разработчикам эффективно
управлять ресурсами и поведением своих компонентов. Знание о том, когда
происходят различные этапы жизненного цикла, помогает избежать утечек памяти и
других проблем с производительностью приложения.

> ## Self injection. Работа аннотациями в Spring. Transaction

## Self injection

**Self Injection** в Spring — это практика, когда компонент (например,
Spring-бин) внедряет (инжектит) сам себя через контейнер Spring.
Вместо того, чтобы просто вызывать методы внутри класса напрямую, класс получает
ссылку на самого себя из Spring-контекста и вызывает методы через эту ссылку.

### Зачем это нужно?

Основная причина — **корректная работа аспектов (AOP), прокси и транзакций**.

Например, если у вас есть метод с аннотацией `@Transactional`, и вы вызываете
этот метод из другого метода того же класса напрямую (
`this.someTransactionalMethod()`), то Spring **не применит прокси и не создаст
транзакцию**, потому что вызов идёт внутри одного объекта.

Если же вызвать метод через прокси (через self injection), то аспекты сработают
корректно.

#### Пример self injection

```java

@Component
public class MyService {

    @Autowired
    private MyService self;  // self injection

    public void methodA() {
        // вызов метода с транзакцией через прокси
        self.methodB();
    }

    @Transactional
    public void methodB() {
        // код, который должен выполняться в транзакции
    }
}
```

Здесь вызов `self.methodB()` пройдет через прокси Spring, и транзакция будет
создана. Если бы вызвали `this.methodB()`, то аннотация `@Transactional` не
сработала бы.

#### Как работает?

Spring создает прокси-объект для бина и внедряет его в поле `self`. Таким
образом, при вызове методов через `self` вызывается проксированный объект с
применением аспектов.


#### Важные моменты

- Self injection может привести к циклическим зависимостям, если не аккуратно
  использовать.
- Альтернативы: использовать `ApplicationContext` для получения бина или
  рефакторить код так, чтобы методы с аспектами вызывались извне.
- В Spring 5+ можно использовать аннотацию `@Lazy` при инжекции самого себя,
  чтобы избежать проблем с циклическими зависимостями:

```java

@Autowired
@Lazy
private MyService self;
```

#### Кратко

**Self Injection** — это когда бин внедряет сам себя из контекста Spring для
того, чтобы внутренние вызовы методов проходили через прокси и корректно
работали такие механизмы как транзакции и AOP.

## Как работать с аннотациями в Spring

### 1. Что такое аннотации?

Аннотация — это специальный мета-элемент в Java, который можно применять к
классам, методам, полям и другим элементам кода для передачи дополнительной
информации.

Spring использует собственные аннотации для:

- Определения компонентов (бинов)
- Управления зависимостями (внедрение зависимостей)
- Конфигурации транзакций
- Обработки аспектов и многое другое

### 2. Основные аннотации Spring

| Аннотация        | Назначение                                     |
|------------------|------------------------------------------------|
| `@Component`     | Определяет класс как компонент Spring (бин)    |
| `@Service`       | Специализация `@Component` для сервисного слоя |
| `@Repository`    | Специализация `@Component` для DAO слоя        |
| `@Controller`    | Для контроллеров MVC                           |
| `@Autowired`     | Внедрение зависимости по типу                  |
| `@Qualifier`     | Уточнение бина при внедрении                   |
| `@Value`         | Внедрение значений из свойств                  |
| `@Configuration` | Класс конфигурации Spring                      |
| `@Bean`          | Метод, создающий бин                           |
| `@Transactional` | Управление транзакциями                        |


### 3. Пример использования основных аннотаций

```java

@Service
public class UserService {

    private final UserRepository userRepository;

    // Внедрение зависимости через конструктор
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
    }
}
```

### 4. Как Spring обрабатывает аннотации?

- При запуске приложения Spring сканирует классы (если включён component
  scanning).
- Находит классы с аннотациями типа `@Component`, `@Service`, и регистрирует их
  как бины.
- Внедряет зависимости, помеченные `@Autowired`.
- Применяет дополнительные механизмы (например, проксирование для транзакций с
  помощью `@Transactional`).


### 5. Создание собственных аннотаций

Можно создавать свои аннотации, комбинируя существующие.

```java

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface MyCustomService {
}
```

Использование:

```java

@MyCustomService
public class MyService {
}
```

### 6. Включение поддержки аннотаций

В XML-конфигурации:

```xml

<context:component-scan base-package="com.example"/>
```

В Java-конфигурации:

```java

@Configuration
@ComponentScan("com.example")
public class AppConfig {
}
```

#### Итог

Работа с аннотациями в Spring — это декларативный способ настройки приложения:

- Помечаете классы и методы нужными аннотациями.
- Spring автоматически создаёт и управляет бинами.
- Упрощается внедрение зависимостей и управление поведением (например,
  транзакциями).

Если хочешь — могу помочь с примерами конкретных сценариев или объяснить работу
определённых аннотаций подробнее!

## Проксирование для транзакций

Отличный вопрос! Проксирование — ключевой механизм, который Spring использует
для реализации таких возможностей, как управление транзакциями через аннотацию
`@Transactional`.

---

## Что такое проксирование в контексте Spring и транзакций?

**Прокси (proxy)** — это объект-заместитель, который "оборачивает" оригинальный
объект (например, сервис), перехватывает вызовы его методов и добавляет
дополнительное поведение.

В случае транзакций прокси:

- При вызове метода с `@Transactional` прокси **открывает транзакцию** перед
  выполнением метода.
- Затем вызывает сам метод.
- После успешного завершения — **коммитит транзакцию**.
- Если метод выбрасывает исключение — **откатывает транзакцию**.

Таким образом, бизнес-логика остаётся чистой и не содержит кода управления
транзакциями — этим занимается прокси.

---

## Как это работает технически?

1. Spring создаёт прокси-объект для бина с `@Transactional`.
2. Вызов метода идёт через прокси.
3. Прокси запускает соответствующий код из Transaction Manager (
   начало/коммит/откат).
4. Затем прокси вызывает реальный метод целевого объекта.

---

## Виды проксирования в Spring

### 1. JDK Dynamic Proxy

- Используется, если класс реализует интерфейс.
- Прокси создаётся на основе интерфейса.
- Ограничение: можно проксировать только методы интерфейса.

### 2. CGLIB Proxy

- Используется, если класс не реализует интерфейс или явно указано.
- Создаётся подкласс целевого класса с переопределёнными методами.
- Позволяет проксировать любые методы класса.

---

## Пример

```java

@Service
public class UserService {

    @Transactional
    public void createUser(User user) {
        // здесь бизнес-логика
    }
}
```

При вызове `createUser()` фактически вызывается метод через прокси:

```text
Прокси:
  -> открыть транзакцию
  -> вызвать UserService.createUser()
  -> если успешно — коммит
  -> если ошибка — откат
```

---

## Почему важно понимать проксирование?

- Вызовы методов внутри того же класса **не проходят через прокси**, поэтому
  аннотация `@Transactional` не сработает при вызове метода из другого метода
  того же класса.

  ```java
  @Service
  public class MyService {
  
      @Transactional
      public void methodA() { ... }
  
      public void methodB() {
          methodA(); // @Transactional не сработает!
      }
  }
  ```

- Чтобы транзакции работали корректно, вызовы должны идти через
  Spring-контейнер (через прокси).

---

## Разницу между JDK-прокси и CGLIB подробнее!

Конечно! Разница между **JDK Dynamic Proxy** и **CGLIB Proxy** — это важный
момент в понимании, как Spring реализует проксирование, в том числе для
`@Transactional`.

---

## 1. JDK Dynamic Proxy

- **Что это?**  
  Механизм создания прокси на основе интерфейсов, встроенный в Java (пакет
  `java.lang.reflect.Proxy`).

- **Как работает?**  
  Spring создаёт объект-прокси, который реализует один или несколько интерфейсов
  целевого класса. Все вызовы методов интерфейса перехватываются прокси.

- **Ограничения:**
    - Прокси может быть создан только для интерфейсов.
    - Если у класса нет интерфейса, JDK-прокси использовать нельзя.
    - Прокси не наследует класс, а реализует интерфейс.

- **Когда используется?**  
  По умолчанию, если у класса есть хотя бы один интерфейс, Spring создаёт
  JDK-прокси.

---

## 2. CGLIB Proxy

- **Что это?**  
  Библиотека CGLIB (Code Generation Library) позволяет создавать прокси путём
  создания подкласса целевого класса с переопределёнными методами.

- **Как работает?**  
  Spring создаёт подкласс целевого класса и переопределяет методы, чтобы
  добавить дополнительное поведение (например, управление транзакциями).

- **Преимущества:**
    - Можно проксировать классы без интерфейсов.
    - Прокси наследует класс, поэтому можно вызывать любые методы.

- **Ограничения:**
    - Не может проксировать `final` классы и `final` методы (их нельзя
      переопределить).
    - Немного более затратен по производительности по сравнению с JDK-прокси.

- **Когда используется?**  
  Если у класса нет интерфейсов или явно указано использовать CGLIB (например,
  через настройку `proxyTargetClass=true`).

---

## Итоговая таблица сравнения

| Характеристика             | JDK Dynamic Proxy                           | CGLIB Proxy                                 |
|----------------------------|---------------------------------------------|---------------------------------------------|
| Основа                     | Интерфейсы Java (`java.lang.reflect.Proxy`) | Генерация подкласса через CGLIB             |
| Требования                 | Класс должен реализовывать интерфейс        | Работает с классами без интерфейсов         |
| Ограничения                | Не может проксировать методы вне интерфейса | Не может проксировать `final` классы/методы |
| Производительность         | Быстрее                                     | Немного медленнее                           |
| Использование по умолчанию | Если есть интерфейс                         | Если нет интерфейса или явно указано        |

---

## Как выбрать?

Spring сам выбирает тип прокси:

- Если бин реализует хотя бы один интерфейс — создаётся JDK-прокси.
- Иначе — CGLIB.
- Можно принудительно использовать CGLIB через настройку:

```java
@EnableTransactionManagement(proxyTargetClass = true)
```

---

## Почему это важно?

- При использовании JDK-прокси можно вызывать только методы из интерфейса через
  прокси.
- При использовании CGLIB можно проксировать любые публичные и защищённые методы
  класса.
- Знание этого помогает избежать проблем с тем, что аннотации вроде
  `@Transactional` не работают на методах вне интерфейса при использовании
  JDK-прокси.

---

Если хочешь — могу показать примеры кода с обоими типами проксирования!

## @Transactional

В Spring аннотации — это удобный способ конфигурировать поведение компонентов,
например, управлять транзакциями, аспектами, валидацией и т.д. Рассмотрим на
примере аннотации `@Transactional`, которая отвечает за управление транзакциями.

#### 1. Подключение необходимых зависимостей

Для работы с транзакциями в Spring обычно нужны зависимости:

- `spring-tx`
- Драйвер и библиотека для работы с базой данных (например, `spring-data-jpa`)

#### 2. Включение поддержки транзакций

В конфигурации Spring нужно включить обработку аннотации `@Transactional`.

Если используете Java-конфигурацию:

```java

@Configuration
@EnableTransactionManagement
public class AppConfig {
    // Настройка DataSource, EntityManagerFactory и TransactionManager
}
```

Если XML-конфигурацию:

```xml

<tx:annotation-driven/>
```

#### 3. Настройка TransactionManager

Spring должен знать, какой менеджер транзакций использовать. Например, для JPA:

```java

@Bean
public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
    return new JpaTransactionManager(emf);
}
```

#### 4. Использование аннотации `@Transactional`

Аннотацию можно ставить на класс или на отдельные методы сервиса:

```java

@Service
public class UserService {

    @Transactional
    public void createUser(User user) {
        // код, который будет выполнен в рамках транзакции
    }
}
```

При вызове метода `createUser` Spring автоматически откроет транзакцию перед
выполнением метода и закроет (зафиксирует или откатит) после.

#### 5. Особенности использования

- **Транзакция работает только при вызове метода извне через прокси**  
  Если метод с `@Transactional` вызывается из другого метода того же класса
  напрямую — аннотация не сработает (см. self injection).

- **Настройка параметров**  
  Можно указать параметры: уровень изоляции, тип распространения (
  `propagation`), таймаут и т.д.

```java

@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED)
public void updateUser(User user) { ...}
```

- **Обработка исключений**  
  По умолчанию транзакция откатывается при unchecked исключениях (
  `RuntimeException`). Для отката при checked исключениях нужно явно указать:

```java

@Transactional(rollbackFor = Exception.class)
public void someMethod() { ...}
```

#### 6. Как Spring обрабатывает аннотации?

Spring создает прокси вокруг бина и перехватывает вызовы методов с аннотацией
`@Transactional`. Перед выполнением метода прокси открывает транзакцию, после —
коммитит или откатывает её.

### Кратко: как работать с аннотациями в Spring

1. Включить поддержку нужной функциональности (например,
   `@EnableTransactionManagement`).
2. Настроить необходимые бины (например, менеджер транзакций).
3. Пометить классы/методы нужными аннотациями (`@Transactional`).
4. Вызывать методы через Spring-контекст (чтобы работали прокси).

## Свойства транзакций ACID

- **Атомарность (Atomicity)** гарантирует, что никакая транзакция не будет
  зафиксирована в системе частично. Будут либо выполнены все операции, либо ни
  одной.

- **Согласованность (Consistency)**. Выполненая транзакция, сохраняет
  согласованность базы данных. Согласованность является более широким понятием,
  чем может показаться.<br>
  Например, в банковской системе может существовать требование равенства суммы,
  списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и
  оно не может быть гарантировано только проверками целостности базы данных. Это
  поведение должны учитывать программисты при написании кода транзакций. Если
  какая-либо транзакция произведёт списание, но не произведёт зачисления, то
  система останется в некорректном состоянии и свойство согласованности будет
  нарушено.

- **Изолированность (Isolation)**. Во время выполнения транзакции параллельные
  транзакции не должны оказывать влияние на её результат.
  Изолированность обходится дорого, поэтому в реальных базах данных существуют
  режимы, не полностью изолирующие транзакцию. Об уровнях изоляции мы поговорим
  в отдельной статье.

- **Устойчивость (Durability)**. Независимо от проблем с оборудованием,
  изменения, сделанные успешно завершённой транзакцией, должны остаться
  сохранёнными после возвращения системы в работу.

Конечно! Свойства **ACID** — это набор ключевых принципов, которые обеспечивают
надежность и корректность транзакций в системах управления базами данных (СУБД)
и других системах, работающих с данными.

-----------------------

## Что такое ACID?

ACID — это аббревиатура из четырёх свойств транзакций:

| Буква | Свойство                      | Описание                                                                                                   |
|-------|-------------------------------|------------------------------------------------------------------------------------------------------------|
| A     | Atomicity (Атомарность)       | Транзакция выполняется полностью или не выполняется вовсе. Нет частичных изменений.                        |
| C     | Consistency (Согласованность) | Транзакция переводит систему из одного корректного состояния в другое, сохраняя все правила и ограничения. |
| I     | Isolation (Изолированность)   | Параллельные транзакции не влияют друг на друга, как если бы они выполнялись последовательно.              |
| D     | Durability (Долговечность)    | После успешного завершения транзакции её изменения сохраняются навсегда, даже при сбоях.                   |

---

### Подробнее о каждом свойстве

#### 1. Atomicity (Атомарность)

- Транзакция — это единое целое.
- Все операции внутри транзакции либо выполняются полностью, либо не выполняются
  вовсе.
- Если что-то пошло не так — все изменения откатываются.

**Пример:** перевод денег между счетами: списание с одного и зачисление на
другой — обе операции должны пройти вместе.

---

#### 2. Consistency (Согласованность)

- После выполнения транзакции база данных остаётся в корректном состоянии.
- Все бизнес-правила, ограничения целостности данных соблюдены.
- Транзакция не нарушает целостность данных.

**Пример:** сумма денег на счетах до и после перевода должна оставаться
неизменной.

---

#### 3. Isolation (Изолированность)

- Одновременное выполнение нескольких транзакций не должно приводить к
  некорректным результатам.
- Каждая транзакция "изолирована" от других до её завершения.
- В разных СУБД есть разные уровни изоляции (Read Uncommitted, Read Committed,
  Repeatable Read, Serializable).

**Пример:** если одна транзакция читает данные, другая не должна изменять их до
завершения первой.

---

#### 4. Durability (Долговечность)

- После успешного завершения транзакции её результаты сохраняются навсегда.
- Даже при сбое системы или отключении питания данные не теряются.
- Обычно достигается с помощью журналирования и записи на диск.

---

## Итог

ACID гарантирует, что работа с данными будет:

- Надёжной,
- Предсказуемой,
- Безопасной от ошибок и сбоев.

Это фундамент для построения устойчивых систем с базами данных и другими
критичными приложениями.

### Реализация ACID в Spring

Конечно! В Spring Framework поддержка транзакций и обеспечение свойств ACID
реализуются через модуль **Spring Transaction Management**. Рассмотрим, как
Spring помогает реализовать каждое из свойств ACID на практике.

---

## 1. Atomicity (Атомарность)

- В Spring атомарность достигается с помощью аннотации `@Transactional`.
- Все операции внутри метода, помеченного `@Transactional`, выполняются как
  единое целое.
- Если в процессе выполнения возникает исключение (например,
  `RuntimeException`), транзакция откатывается — все изменения отменяются.

**Пример:**

```java

@Service
public class BankService {

    @Transactional
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        debit(fromAccountId, amount);
        credit(toAccountId, amount);
        // Если здесь выбросится исключение — изменения откатятся
    }

    private void debit(Long accountId, BigDecimal amount) {
        // списание денег
    }

    private void credit(Long accountId, BigDecimal amount) {
        // зачисление денег
    }
}
```

---

## 2. Consistency (Согласованность)

- Spring не проверяет бизнес-правила напрямую, но обеспечивает согласованность
  через интеграцию с СУБД.
- Все ограничения базы данных (например, внешние ключи, уникальные индексы)
  применяются при коммите транзакции.
- Если транзакция нарушает ограничения — она откатывается.

**Пример:**

Если в базе есть ограничение уникальности по email пользователя, попытка
сохранить дубликат вызовет ошибку и откатит транзакцию.

---

## 3. Isolation (Изолированность)

- В Spring можно задать уровень изоляции транзакции через параметр `isolation` в
  `@Transactional`.

```java

@Transactional(isolation = Isolation.REPEATABLE_READ)
public void someMethod() {
    // ...
}
```

- Это позволяет контролировать видимость изменений между параллельными
  транзакциями и предотвращать аномалии чтения.

---

## 4. Durability (Долговечность)

- Обеспечивается на уровне СУБД и системы хранения.
- Spring гарантирует вызов коммита транзакции после успешного выполнения метода.
- После коммита данные сохраняются в базе и не теряются при сбоях.

---

## Дополнительно: пример конфигурации

```java

@Configuration
@EnableTransactionManagement
public class AppConfig {

    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

---

## Итог

| Свойство ACID | Как реализуется в Spring                       |
|---------------|------------------------------------------------|
| Atomicity     | Аннотация `@Transactional` + откат при ошибках |
| Consistency   | Интеграция с СУБД + ограничения базы данных    |
| Isolation     | Параметр `isolation` в `@Transactional`        |
| Durability    | Коммит транзакции + надёжное хранение данных   |

---

Если хочешь — могу помочь с примерами настройки уровней изоляции или обработкой
ошибок для управления откатом!

## Уровни изоляции

- READ UNCOMMITTED (чтение незафиксированных или «грязных» данных)<br>
  наименее защищенный уровень изоляции, при котором транзакции способны читать
  незафиксированные изменения, сделанные другими транзакциями. При этом возможно
  считывание не только логически несогласованных данных, но и данных, изменения
  которых ещё не зафиксированы;

- READ COMMITTED (чтение фиксированных данных)<br>
  исключается «грязное» чтение, транзакция увидит только изменения,
  зафиксированные другими транзакциями. Тем не менее, в процессе работы одной
  транзакции другая может быть успешно завершена и сделанные ею изменения
  зафиксированы. В итоге первая транзакция будет работать с другим набором
  данных. Большинство промышленных СУБД, в частности, Microsoft SQL Server,
  PostgreSQL и Oracle по умолчанию используют именно этот уровень изоляции;

- REPEATABLE READ (повторяющееся чтение)<br>
  накладывает блокировки на обрабатываемые транзакцией строки и не допускает их
  изменения другими транзакциями. В результате транзакция видит только те
  строки, которые были зафиксированы на момент ее запуска. Однако другие
  транзакции могут вставлять новые строки, соответствующие условиям поиска
  инструкций, содержащихся в текущей транзакции. При повторном запуске
  инструкции текущей транзакцией будут извлечены новые строки, что приведёт к
  фантомному чтению. Это уровень изоляции по умолчанию в MySQL;

- SERIALIZABLE (сериализуемость)<br>
  самый надежный уровень изоляции, полностью исключающий взаимное влияние
  транзакций. Только на этом уровне параллельные транзакции не подвержены
  эффекту «фантомного чтения».

____

Конечно! Уровни изоляции транзакций определяют, насколько одна транзакция
изолирована от изменений, выполняемых другими параллельными транзакциями. Они
помогают контролировать проблемы, которые могут возникать при одновременном
доступе к данным.

## Основные проблемы параллелизма

При одновременной работе нескольких транзакций могут возникать следующие
аномалии:

- **Dirty Read (грязное чтение):** чтение данных, которые были изменены, но ещё
  не зафиксированы (не закоммичены) другой транзакцией.
- **Non-repeatable Read (неповторяемое чтение):** повторный запрос одних и тех
  же данных в рамках одной транзакции возвращает разные результаты из-за
  изменений другой транзакцией.
- **Phantom Read (фантомное чтение):** при повторном выполнении запроса
  появляются новые строки, добавленные другой транзакцией.

---

## Уровни изоляции (по стандарту SQL)

| Уровень изоляции     | Описание                                                                                                        | Возможные аномалии                            |
|----------------------|-----------------------------------------------------------------------------------------------------------------|-----------------------------------------------|
| **Read Uncommitted** | Самый низкий уровень. Транзакция может читать незакоммиченные изменения других транзакций.                      | Dirty Read, Non-repeatable Read, Phantom Read |
| **Read Committed**   | Транзакция видит только зафиксированные данные. Незакоммиченные изменения других транзакций не видны.           | Non-repeatable Read, Phantom Read             |
| **Repeatable Read**  | Гарантирует, что повторное чтение одних и тех же данных в рамках транзакции даст одинаковый результат.          | Phantom Read                                  |
| **Serializable**     | Самый высокий уровень изоляции. Транзакции выполняются так, как если бы они шли последовательно друг за другом. | Нет аномалий                                  |

---

### Кратко о каждом уровне

1. **Read Uncommitted**

- Позволяет читать незакоммиченные данные.
- Быстрый, но ненадёжный.
- Редко используется на практике.

2. **Read Committed**

- Читает только подтверждённые данные.
- Избегает грязных чтений.
- Может возникать неповторяемое чтение и фантомы.

3. **Repeatable Read**

- Повторные чтения одних и тех же строк дают одинаковые результаты.
- Избегает грязных и неповторяемых чтений.
- Фантомы всё ещё возможны (зависит от СУБД).

4. **Serializable**

- Полная изоляция.
- Транзакции выполняются последовательно.
- Самый безопасный, но самый медленный уровень.

---

## Пример в SQL

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN
TRANSACTION;

SELECT *
FROM accounts
WHERE id = 1;
/* ... другие операции ... */

COMMIT;
```

---

## Особенности в разных СУБД

- В Oracle уровень по умолчанию — Read Committed.
- В PostgreSQL — Read Committed по умолчанию, поддерживает Serializable.
- В MySQL InnoDB — Repeatable Read по умолчанию.

---

## Проблемы которые решают уровни изоляции

При параллельном выполнении транзакций возможны следую-
щие проблемы:

- **потерянное обновление** (lost update) -
  при одновременном
  изменении одного блока данных разными транзакциями теряются
  все изменения, кроме последнего. Т.е. в этом случае
  одна транзакция переписывает изменения, осуществленные
  другой транзакцией, в результате одно из изменений будет
  утеряно;

- **«грязное» чтение** (dirty read)- чтение данных, добавленных
  или изменённых транзакцией, которая впоследствии не подтвердится
  (откатится). В этом случае незафиксированные
  изменения, осуществленные одной транзакцией, читаются
  (или обновляются) другой. В случае перезаписи этих промежуточных
  значений или отката первой транзакции незафиксированные
  изменения могут быть отменены, а прочитавшая
  их транзакция с этого момента станет работать с неверными
  данными;

- **неповторяющееся чтение** (non-repeataЫe read) -
  при повторном
  чтении в рамках одной транзакции ранее прочитанные
  данные оказываются изменёнными. Возникает тогда,
  когда транзакция считывает из базы значение, после чего
  вторая транзакция обновляет это значение. Если в этот момент
  времени первая транзакция продолжает выполняться,
  то имеющиеся в ее распоряжении данные становятся неактуальными;

- **фантомное чтение (phantom reads)** - одна транзакция в ходе
  своего выполнения несколько раз выбирает множество
  строк по одним и тем же критериям. Другая транзакция в
  интервалах между этими выборками добавляет строки или
  изменяет столбцы некоторых строк, используемых в критериях
  выборки первой транзакции, и успешно заканчивается.
  В результате получится, что одни и те же выборки в первой
  транзакции дают разные множества строк.

Конечно! Уровни изоляции транзакций в базах данных предназначены для решения
проблем, возникающих при параллельном выполнении нескольких транзакций. Основные
проблемы, которые решают уровни изоляции, связаны с некорректным или
непредсказуемым чтением данных.

---

## Основные проблемы параллелизма, решаемые уровнями изоляции

### 1. Dirty Read (грязное чтение)

- **Что это?** Транзакция читает данные, которые были изменены другой
  транзакцией, но ещё не зафиксированы (не закоммичены).
- **Проблема:** Если другая транзакция откатится, то прочитанные данные окажутся
  недействительными.
- **Пример:** Транзакция A изменила значение, но не закоммитила. Транзакция B
  прочитала это значение. Если A откатится — B работала с неверными данными.

---

### 2. Non-repeatable Read (неповторяемое чтение)

- **Что это?** В рамках одной транзакции повторный запрос одних и тех же данных
  возвращает разные результаты из-за изменений другой транзакцией.
- **Проблема:** Нарушается согласованность данных при повторных чтениях.
- **Пример:** Транзакция A читает строку. Транзакция B изменяет эту строку и
  коммитит. При повторном чтении в A данные уже другие.

---

### 3. Phantom Read (фантомное чтение)

- **Что это?** При повторном выполнении запроса в рамках одной транзакции
  появляются новые строки, добавленные другой транзакцией.
- **Проблема:** Нарушается целостность выборки данных.
- **Пример:** Транзакция A выполняет запрос с условием (например, все заказы за
  сегодня). Транзакция B добавляет новый заказ и коммитит. При повторном запросе
  в A появляется "фантом" — новая строка.

---

## Как уровни изоляции решают эти проблемы

| Уровень изоляции | Dirty Read   | Non-repeatable Read | Phantom Read |
|------------------|--------------|---------------------|--------------|
| Read Uncommitted | возможен     | возможен            | возможен     |
| Read Committed   | предотвращён | возможен            | возможен     |
| Repeatable Read  | предотвращён | предотвращён        | возможен     |
| Serializable     | предотвращён | предотвращён        | предотвращён |

---

## Кратко о каждом уровне

- **Read Uncommitted:** Позволяет читать незакоммиченные данные — грязные чтения
  возможны.
- **Read Committed:** Запрещает грязные чтения, но неповторяемые и фантомные
  чтения остаются.
- **Repeatable Read:** Гарантирует стабильность прочитанных строк — нет грязных
  и неповторяемых чтений, но фантомы могут появляться.
- **Serializable:** Полная изоляция — все три проблемы исключены за счёт
  последовательного выполнения транзакций.

---

Если хочешь — могу привести примеры SQL-запросов или сценариев с конкретными
аномалиями!

## Тип распространения транзакции

**Тип распространения транзакции (Transaction Propagation)** — это поведение,
определяющее, как транзакция ведёт себя при вызове одного транзакционного метода
из другого транзакционного метода. Другими словами, это правила, по которым
новая или существующая транзакция используется или создаётся при вложенных
вызовах.

#### Зачем это нужно?

В приложениях с бизнес-логикой часто один метод вызывает другой, и оба могут
быть помечены как транзакционные. Важно понять, будет ли использоваться одна
общая транзакция или для каждого метода создаётся своя.

#### Основные типы распространения транзакции (на примере Spring Framework):

| Тип распространения         | Описание                                                                                 |
|-----------------------------|------------------------------------------------------------------------------------------|
| **REQUIRED** (по умолчанию) | Если есть текущая транзакция — использовать её, иначе создать новую.                     |
| **REQUIRES_NEW**            | Всегда создавать новую транзакцию, при этом существующая (если есть) приостанавливается. |
| **SUPPORTS**                | Если есть текущая транзакция — использовать её, иначе работать без транзакции.           |
| **NOT_SUPPORTED**           | Всегда работать без транзакции, при этом существующая приостанавливается.                |
| **MANDATORY**               | Обязательно должна быть существующая транзакция, иначе выбрасывается исключение.         |
| **NEVER**                   | Никогда не работать в рамках транзакции, если она есть — выбрасывается исключение.       |
| **NESTED**                  | Если есть текущая транзакция — создать вложенную (savepoint), иначе создать новую.       |

#### Пример

```java

@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // ...
    methodB(); // вызов другого метода
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // ...
}
```

В этом примере:

- `methodA` запускает или использует текущую транзакцию.
- `methodB` всегда запускает новую отдельную транзакцию, приостанавливая ту, что
  была в `methodA`.

#### Почему это важно?

- Позволяет контролировать атомарность операций.
- Помогает избежать проблем с блокировками и откатами.
- Позволяет гибко управлять поведением вложенных операций.

### подробнее рассказать про каждый тип с примерами!

Конечно! В контексте Spring и транзакций под **распространением транзакции** (
transaction propagation) понимается поведение, которое определяет, как метод с
аннотацией `@Transactional` взаимодействует с уже существующей транзакцией при
вызове. Это очень важно для управления тем, когда транзакция создаётся заново,
когда используется существующая, а когда откатывается или коммитится.

---

# Основные типы распространения транзакций (Propagation) в Spring

Spring определяет несколько стратегий распространения транзакций через enum
`Propagation`. Рассмотрим самые распространённые и важные из них с примерами.

---

## 1. `REQUIRED` (по умолчанию)

- **Что значит?**  
  Если текущая транзакция есть — использовать её. Если нет — создать новую.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // выполняется в текущей или новой транзакции
        serviceB.methodB();
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodB() {
        // будет выполнен в той же транзакции, что и methodA()
    }
}
```

- **Итог:**  
  `methodA()` и `methodB()` работают в одной транзакции.

---

## 2. `REQUIRES_NEW`

- **Что значит?**  
  Всегда создаёт новую транзакцию. Если есть текущая — она приостанавливается до
  завершения новой.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        serviceB.methodB(); // новая транзакция
        // продолжение старой транзакции
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // выполняется в отдельной новой транзакции
    }
}
```

- **Итог:**  
  `methodB()` работает в своей собственной транзакции, независимо от
  `methodA()`. Если `methodB()` откатится — это не повлияет на основную
  транзакцию `methodA()`.

---

## 3. `SUPPORTS`

- **Что значит?**  
  Если есть текущая транзакция — использовать её, если нет — выполнять без
  транзакции.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.SUPPORTS)
    public void methodA() {
        // если вызван из метода с транзакцией — будет в ней,
        // иначе без неё.
    }
}
```

- **Итог:**  
  Гибкое поведение: метод может работать как внутри, так и вне транзакции.

---

## 4. `NOT_SUPPORTED`

- **Что значит?**  
  Метод всегда выполняется вне транзакции. Если есть текущая — она
  приостанавливается.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void methodA() {
        // выполняется без транзакции,
        // даже если вызывается из метода с ней.
    }
}
```

- **Итог:**  
  Используется для операций, которые не должны быть частью транзакции (например,
  чтение без блокировок).

---

## 5. `MANDATORY`

- **Что значит?**  
  Метод должен вызываться только внутри существующей транзакции. Если нет —
  выбрасывается исключение.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.MANDATORY)
    public void methodA() {
        // если вызывается вне транзакции — ошибка!
    }
}
```

---

## 6. `NEVER`

- **Что значит?**  
  Метод должен вызываться только вне транзакции. Если есть активная —
  выбрасывается исключение.

---

## 7. `NESTED` (работает только с DataSourceTransactionManager)

- **Что значит?**  
  Создаёт вложенную (savepoint) транзакцию внутри текущей. При ошибке можно
  откатить только вложенную часть без отката всей внешней.

- **Пример:**

```java

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        serviceB.methodB(); // nested transaction внутри основной
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.NESTED)
    public void methodB() {
        // вложенная точка сохранения (savepoint)
        // можно откатить отдельно от основной.
    }
}
```

---

# Краткое резюме

| Тип распространения | Поведение                                       | Когда использовать                      |
|---------------------|-------------------------------------------------|-----------------------------------------|
| REQUIRED            | Использует текущую или создаёт новую            | Большинство случаев                     |
| REQUIRES_NEW        | Всегда новая, приостанавливает текущую          | Независимые операции                    |
| SUPPORTS            | Использует текущую или без транзации            | Опциональная работа в/вне трансакций    |
| NOT_SUPPORTED       | Всегда без трансакций, приостанавливает текущую | Операции без блокировок                 |
| MANDATORY           | Только внутри существующей                      | Гарантия наличия трансакции             |
| NEVER               | Только вне трансакций                           | Гарантия отсутствия трансакции          |
| NESTED              | Вложенная (savepoint) внутри текущей            | Частичный откат внутри большой операции |

---

Если хочешь, могу привести более подробные примеры кода или объяснить конкретный
сценарий!
