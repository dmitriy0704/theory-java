# SOLID

## 1. S - Single Responsibility Principle

(Принцип единственной ответственности)

**Определение**: Класс должен иметь только одну причину для изменения, то есть
он должен выполнять только одну задачу.

**Смысл**: Если класс отвечает за несколько несвязанных функций, его сложнее
поддерживать, так как изменения в одной функции могут повлиять на другую.

**Пример на Java**:

```java
// Плохо: Класс делает слишком много
class User {
    void saveToDatabase() { /* Сохранение в БД */ }

    void sendEmail() { /* Отправка email */ }
}

// Хорошо: Разделяем ответственность
class UserRepository {
    void saveToDatabase() { /* Сохранение в БД */ }
}

class EmailService {
    void sendEmail() { /* Отправка email */ }
}
```

**Пояснение**: Теперь `UserRepository` отвечает только за работу с базой данных,
а `EmailService` — за отправку писем. Это упрощает тестирование и поддержку.

---

## 2. O - Open/Closed Principle

(Принцип открытости/закрытости)

**Определение**: Классы должны быть открыты для расширения, но закрыты для
модификации.

**Смысл**: Вместо изменения существующего кода для добавления новой
функциональности, лучше расширять его через наследование или интерфейсы.

**Пример на Java**:

```java
// Плохо: Изменяем класс для новой функциональности
class PaymentProcessor {
    void processPayment(String paymentType) {
        if (paymentType.equals("CreditCard")) {
            // Обработка кредитной карты
        } else if (paymentType.equals("PayPal")) {
            // Обработка PayPal
        }
    }
}

// Хорошо: Используем интерфейс для расширения
interface Payment {
    void process();
}

class CreditCardPayment implements Payment {
    public void process() { /* Обработка кредитной карты */ }
}

class PayPalPayment implements Payment {
    public void process() { /* Обработка PayPal */ }
}

class PaymentProcessor {
    void processPayment(Payment payment) {
        payment.process();
    }
}
```

**Пояснение**: Теперь для добавления нового типа оплаты (например, Bitcoin)
достаточно создать новый класс, реализующий `Payment`, без изменения
`PaymentProcessor`.

---

## 3. L - Liskov Substitution Principle

(Принцип подстановки Барбары Лисков)

**Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)** —
это один из пяти принципов SOLID, который гласит: объекты базового класса должны
быть заменяемы объектами производных классов без изменения корректности
поведения программы. Иными словами, подклассы должны вести себя так, чтобы их
использование вместо базового класса не нарушало ожидаемого поведения системы.

### Формальное определение

Если у вас есть базовый класс (или интерфейс) `T`, и его подкласс `S`, то любой
код, работающий с `T`, должен корректно работать с `S` без необходимости знать,
что это `S`. Подкласс должен полностью соответствовать контракту, заданному
базовым классом.

### Смысл принципа

LSP направлен на то, чтобы:

- Гарантировать, что наследование используется правильно.
- Избежать ситуаций, когда подкласс нарушает ожидания, заданные базовым классом.
- Обеспечить предсказуемое и безопасное поведение при полиморфизме.

Нарушение LSP приводит к ошибкам, трудноотслеживаемым багам и усложняет
поддержку кода.

### Формальные требования к подклассам, а точнее, к переопределённым в них методам.

- **Типы параметров метода подкласса должны совпадать или
  быть более абстрактными, чем типы параметров базового метода.**
    - Базовый класс содержит метод feed(Cat c), который умеет кормить домашних
      котов. Клиентский код это знает и всегда передаёт в метод кота.
    - **Хорошо**: Вы создали подкласс и переопределили метод
      кормёжки так, чтобы накормить любое животное:
      feed(Animal c). Если подставить этот подкласс в клиентский код, то ничего
      страшного не произойдёт. Клиентский код подаст в метод кота, но метод
      умеет кормить всех животных, поэтому накормит и кота.
    - **Плохо**: Вы создали другой подкласс, в котором метод умеет кормить
      только бенгальскую породу котов (подкласс котов): feed(BengalCat c). Что
      будет с клиентским кодом? Он всё так же подаст в метод обычного кота. Но
      метод умеет кормить только бенгалов, поэтому не сможет отработать, сломав
      клиентский код.
- **Тип возвращаемого значения метода подкласса должен совпадать или быть
  подтипом
  возвращаемого значения базового метода.**
    - Базовый метод: buyCat(): Cat. Клиентский код ожидает на выходе любого
      домашнего кота.
    - Хорошо: Метод подкласса: buyCat(): BengalCat. Клиентский код получит
      бенгальского кота, который является домашним котом, поэтому всё будет
      хорошо.
    - Плохо: Метод подкласса: buyCat(): Animal. Клиентский
      код сломается, так как это непонятное животное (возможно, крокодил)
      не поместится в ящике-переноске для кота.
- **Метод не должен выбрасывать исключения, которые не свойственны базовому
  методу.** Типы исключений в переопределённом методе должны совпадать или быть
  подтипами исключений, которые выбрасывает базовый метод. Блоки try-catch в
  клиентском коде нацелены на конкретные типы исключений, выбрасываемые базовым
  методом. Поэтому неожиданное исключение, выброшенное подклассом, может
  проскочить сквозь обработчики клиентского кода и обрушить программу.
- **Метод не должен ужесточать пред-условия.** Например, базовый метод работает
  с параметром типа int. Если подкласс требует, чтобы значение этого параметра к
  тому же было больше нуля, то это ужесточает предусловия. Клиентский код,
  который до этого отлично работал, подавая в метод негативные числа, теперь
  сломается при работе с объектом подкласса.
- **Метод не должен ослаблять пост-условия.** Например, базовый метод требует,
  чтобы по завершению метода все подключения к базе данных были закрыты, а
  подкласс оставляет эти подключения открытыми, чтобы потом повторно
  использовать. Но клиентский код базового класса ничего об этом не знает. Он
  может завершить программу сразу после вызова метода, оставив запущенные
  процессы-призраки в системе.
- **Инварианты класса должны остаться без изменений.** Инвариант — это набор
  условий, при которых объект имеет смысл. Например, инвариант кота — это
  наличие четырёх лап, хвоста, способность мурчать и прочее. Инвариант может
  быть описан не только явным контрактом или проверками в методах класса, но и
  косвенно, например, юнит-тестами или клиентским кодом.
- **Подкласс не должен изменять значения приватных полей базового
  класса.** Этот пункт звучит странно, но в некоторых языках доступ к приватным
  полям можно получить через механизм рефлексии. В некоторых других языках (
  Python, JavaScript) и вовсе нет жёсткой защиты приватных полей.

### Пример на Java: Нарушение LSP

Рассмотрим классический пример с птицами:

```java
class Bird {
    void fly() {
        System.out.println("Птица летает");
    }
}

class Ostrich extends Bird {
    @Override
    void fly() {
        throw new UnsupportedOperationException("Страус не летает!");
    }
}

class Main {
    public static void makeBirdFly(Bird bird) {
        bird.fly(); // Ожидаем, что птица летает
    }

    public static void main(String[] args) {
        Bird sparrow = new Bird();
        Bird ostrich = new Ostrich();

        makeBirdFly(sparrow); // OK: "Птица летает"
        makeBirdFly(ostrich); // Ошибка: UnsupportedOperationException
    }
}
```

**Проблема**: Метод `makeBirdFly` ожидает, что любая `Bird` может летать. Однако
`Ostrich` нарушает это ожидание, бросая исключение. Это нарушение LSP, так как
подкласс (`Ostrich`) нельзя безопасно подставить вместо базового класса (
`Bird`).

### Исправление: Соответствие LSP

Чтобы соблюсти LSP, нужно переосмыслить иерархию классов, разделив поведение
так, чтобы контракт базового класса (или интерфейса) не нарушался.

```java
interface Bird {
    void move();
}

interface FlyingBird extends Bird {
    void fly();
}

class Sparrow implements FlyingBird {
    @Override
    public void fly() {
        System.out.println("Воробей летает");
    }

    @Override
    public void move() {
        fly();
    }
}

class Ostrich implements Bird {
    @Override
    public void move() {
        System.out.println("Страус бегает");
    }
}

class Main {
    public static void makeBirdMove(Bird bird) {
        bird.move(); // Все птицы могут двигаться
    }

    public static void makeBirdFly(FlyingBird bird) {
        bird.fly(); // Только летающие птицы
    }

    public static void main(String[] args) {
        Bird sparrow = new Sparrow();
        Bird ostrich = new Ostrich();

        makeBirdMove(sparrow); // OK: "Воробей летает"
        makeBirdMove(ostrich); // OK: "Страус бегает"

        makeBirdFly(new Sparrow()); // OK: "Воробей летает"
        // makeBirdFly(new Ostrich()); // Ошибка компиляции, Ostrich не реализует FlyingBird
    }
}
```

**Решение**:

- Интерфейс `Bird` задает общее поведение (`move`), которое применимо ко всем
  птицам.
- Интерфейс `FlyingBird` добавляет специфичное поведение (`fly`) только для
  летающих птиц.
- `Ostrich` реализует только `Bird`, а `Sparrow` — оба интерфейса.
- Теперь подстановка `Ostrich` вместо `Bird` безопасна, а попытка использовать
  `Ostrich` как `FlyingBird` невозможна на уровне компиляции.

### Ключевые аспекты LSP

1. **Соблюдение контракта**:
    - Подкласс должен уважать все предусловия (preconditions), постусловия (
      postconditions) и инварианты базового класса.
    - Например, если базовый класс гарантирует, что метод возвращает
      положительное число, подкласс не должен возвращать отрицательное.

2. **Предусловия и постусловия**:
    - Предусловия в подклассе не должны быть строже, чем в базовом классе.
    - Постусловия не должны быть слабее, чем в базовом классе.

3. **Исключения**:
    - Подкласс не должен бросать новые типы исключений, которых нет в базовом
      классе, если это не указано в контракте.

4. **Поведение**:
    - Подкласс может расширять поведение, но не должен его ломать или
      кардинально менять.

### Реальный пример: Геометрические фигуры

Частый пример нарушения LSP — это классы `Rectangle` и `Square`.

```java
class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width; // Квадрат должен иметь равные стороны
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height;
    }
}

class Main {
    public static void testRectangle(Rectangle rect) {
        rect.setWidth(5);
        rect.setHeight(4);
        assert rect.getArea() == 20; // Ожидаем 5 * 4 = 20
    }

    public static void main(String[] args) {
        testRectangle(new Rectangle()); // OK: 20
        testRectangle(new Square()); // Ошибка: 16, так как Square установит 4 * 4
    }
}
```

**Проблема**: `Square` изменяет поведение `Rectangle`, так как не позволяет
независимо задавать ширину и высоту. Это нарушает LSP, так как `Square` нельзя
безопасно подставить вместо `Rectangle`.

**Решение**: Не использовать наследование, а создать отдельные классы или
интерфейсы, либо сделать `Square` и `Rectangle` независимыми.

### Зачем нужен LSP?

1. **Надежность кода**: Гарантирует, что полиморфизм работает предсказуемо.
2. **Поддерживаемость**: Упрощает добавление новых подклассов без риска сломать
   существующий код.
3. **Тестируемость**: Легче тестировать код, так как поведение подклассов
   соответствует ожиданиям базового класса.

### Как соблюдать LSP в Java?

1. **Используйте интерфейсы**: Они позволяют четко определить контракт и
   избежать ненужного поведения.
2. **Проверяйте контракт**: Убедитесь, что подклассы не нарушают пред- и
   постусловия.
3. **Избегайте глубокого наследования**: Чем глубже иерархия, тем выше риск
   нарушения LSP.
4. **Тестируйте подстановку**: Пишите тесты, которые проверяют, что подклассы
   ведут себя корректно при использовании вместо базового класса.

### Заключение

Принцип подстановки Лисков — это способ сделать наследование и полиморфизм
безопасными и предсказуемыми. В Java он часто реализуется через продуманную
работу с интерфейсами и абстрактными классами. Нарушение LSP приводит к хрупкому
коду, поэтому важно проектировать иерархии классов так, чтобы подклассы
полностью соответствовали ожиданиям базового класса.

---

## 4. **I - Interface Segregation Principle (Принцип разделения интерфейсов)**

> Клиенты не должны зависеть от интерфейсов, которые они не используют.

**Смысл**: Интерфейсы должны быть узкими и специфичными, чтобы классы не
реализовывали ненужные методы.

**Пример на Java**:

```java
// Плохо: Слишком общий интерфейс
interface Worker {
    void work();

    void eat();
}

class Robot implements Worker {
    public void work() { /* Работает */ }

    public void eat() { /* Робот не ест! */ }
}

// Хорошо: Разделяем интерфейсы
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Robot implements Workable {
    public void work() { /* Работает */ }
}

class Human implements Workable, Eatable {
    public void work() { /* Работает */ }

    public void eat() { /* Ест */ }
}
```

**Пояснение**: Теперь `Robot` реализует только `Workable`, а `Human` — оба
интерфейса, что логично и исключает ненужные методы.

---

## 5. **D - Dependency Inversion Principle (Принцип инверсии зависимостей)**

> Классы верхних уровней не должны зависеть от классов нижних уровней. <br>
> Оба должны зависеть от абстракций. <br>
> Абстракции не должны зависеть от деталей. <br>
> Детали должны зависеть от абстракций.

**Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)** — это
пятый принцип SOLID, который направлен на уменьшение связанности между
компонентами программы. Он гласит:

1. **Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба
   должны зависеть от абстракций.**
2. **Абстракции не должны зависеть от деталей. Детали должны зависеть от
   абстракций.**

---

### Смысл принципа

DIP помогает создавать гибкие и масштабируемые системы, где компоненты можно
легко заменять или модифицировать без изменения кода других частей программы.
Вместо прямых зависимостей между классами используются абстракции (интерфейсы
или абстрактные классы), что снижает связанность и упрощает тестирование.

**Ключевые идеи**:

- Модули высокого уровня (бизнес-логика) задают контракт через абстракции.
- Модули низкого уровня (реализация деталей, например, доступ к базе данных)
  подстраиваются под этот контракт.
- Это позволяет подменять реализации без изменения кода высокого уровня.

---

### Пример на Java: Нарушение DIP

Рассмотрим пример, где принцип нарушен:

```java
class OrderService {
    private MySQLDatabase db = new MySQLDatabase(); // Прямая зависимость от конкретной реализации

    void saveOrder(Order order) {
        db.save(order);
    }
}

class MySQLDatabase {
    void save(Order order) {
        System.out.println("Сохранение заказа в MySQL");
    }
}

class Main {
    public static void main(String[] args) {
        OrderService service = new OrderService();
        service.saveOrder(new Order());
    }
}
```

**Проблема**:

- `OrderService` (модуль высокого уровня) напрямую зависит от `MySQLDatabase` (
  модуль низкого уровня).
- Если нужно заменить MySQL на PostgreSQL или файл, придется менять код
  `OrderService`.
- Тестирование затруднено, так как нельзя легко подменить `MySQLDatabase` на
  заглушку (mock).

---

### Исправление: Соответствие DIP

Чтобы соблюсти DIP, вводим абстракцию (интерфейс) и передаем зависимость извне:

```java
// Абстракция
interface Database {
    void save(Order order);
}

// Конкретная реализация
class MySQLDatabase implements Database {
    @Override
    public void save(Order order) {
        System.out.println("Сохранение заказа в MySQL");
    }
}

// Еще одна реализация
class PostgreSQLDatabase implements Database {
    @Override
    public void save(Order order) {
        System.out.println("Сохранение заказа в PostgreSQL");
    }
}

// Модуль высокого уровня зависит от абстракции
class OrderService {
    private final Database db;

    // Внедрение зависимости через конструктор
    public OrderService(Database db) {
        this.db = db;
    }

    void saveOrder(Order order) {
        db.save(order);
    }
}

class Main {
    public static void main(String[] args) {
        // Внедряем нужную реализацию
        Database db = new MySQLDatabase(); // Или new PostgreSQLDatabase()
        OrderService service = new OrderService(db);
        service.saveOrder(new Order());
    }
}
```

**Улучшения**:

- `OrderService` зависит от интерфейса `Database`, а не от конкретной
  реализации.
- Можно легко подменить `MySQLDatabase` на `PostgreSQLDatabase` или другую
  реализацию.
- Для тестирования можно передать заглушку (mock), реализующую `Database`.

---

### Ключевые аспекты DIP

1. **Абстракции**:
    - Используйте интерфейсы или абстрактные классы для определения контрактов.
    - Абстракции должны быть стабильными и не зависеть от конкретных деталей.

2. **Внедрение зависимостей (Dependency Injection)**:
    - Зависимости передаются извне (через конструктор, сеттер или параметры
      метода), а не создаются внутри класса.
    - Популярные способы: конструктор, сеттер, или использование
      DI-фреймворков (например, Spring).

3. **Инверсия управления (Inversion of Control, IoC)**:
    - DIP часто реализуется через IoC, где управление созданием и связыванием
      объектов передается контейнеру (например, Spring IoC Container).

4. **Тестируемость**:
    - DIP упрощает модульное тестирование, так как зависимости можно заменить на
      моки или стабы.

---

### Реальный пример: Логирование

Предположим, у нас есть сервис, который логирует события:

```java
// Плохо: Нарушение DIP
class UserService {
    private FileLogger logger = new FileLogger();

    void createUser(String name) {
        logger.log("Пользователь создан: " + name);
    }
}

class FileLogger {
    void log(String message) {
        System.out.println("Запись в файл: " + message);
    }
}
```

**Проблема**: `UserService` привязан к `FileLogger`. Если нужно логировать в
консоль или базу данных, придется менять код.

**Решение с DIP**:

```java
interface Logger {
    void log(String message);
}

class FileLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("Запись в файл: " + message);
    }
}

class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("Запись в консоль: " + message);
    }
}

class UserService {
    private final Logger logger;

    public UserService(Logger logger) {
        this.logger = logger;
    }

    void createUser(String name) {
        logger.log("Пользователь создан: " + name);
    }
}

class Main {
    public static void main(String[] args) {
        Logger logger = new ConsoleLogger(); // Или new FileLogger()
        UserService service = new UserService(logger);
        service.createUser("Alice");
    }
}
```

**Преимущества**:

- `UserService` зависит от абстракции `Logger`.
- Легко добавить новые типы логирования (например, `DatabaseLogger`).
- Для тестов можно передать `MockLogger`.

---

### Зачем нужен DIP?

1. **Гибкость**:
    - Легко заменять реализации (например, сменить базу данных или способ
      логирования).
    - Упрощает адаптацию к новым требованиям.

2. **Снижение связанности**:
    - Модули становятся независимыми, что уменьшает эффект "домино" при
      изменениях.

3. **Тестируемость**:
    - Легко подменять зависимости в тестах, используя моки или стабы.

4. **Масштабируемость**:
    - Упрощает добавление новых компонентов в систему.

---

### DIP в экосистеме Java

1. **Spring Framework**:
    - Spring активно использует DIP через IoC-контейнер и аннотации
      `@Autowired`, `@Bean`.
    - Пример: `@Autowired private Database db;` внедряет нужную реализацию
      `Database`.

2. **Тестирование**:
    - Фреймворки вроде JUnit и Mockito упрощают создание моков для зависимостей,
      что идеально сочетается с DIP.

3. **Микросервисы**:
    - DIP помогает создавать слабосвязанные сервисы, где компоненты
      взаимодействуют через интерфейсы или API.

---

### Как соблюдать DIP?

1. **Определяйте четкие интерфейсы**:
    - Создавайте минимальные и специфичные контракты для взаимодействия.

2. **Используйте внедрение зависимостей**:
    - Передавайте зависимости через конструктор (предпочтительно) или сеттер.

3. **Избегайте прямых зависимостей**:
    - Не создавайте экземпляры конкретных классов внутри других классов (
      `new ConcreteClass()`).

4. **Применяйте DI-фреймворки**:
    - В крупных проектах используйте Spring, Guice или другие инструменты для
      управления зависимостями.

5. **Пишите тесты**:
    - Убедитесь, что зависимости можно подменить, и проверьте поведение с
      разными реализациями.

---

### Потенциальные сложности

- **Чрезмерная абстракция**:
    - Слишком много интерфейсов может усложнить код. Создавайте абстракции
      только там, где они оправданы.
- **Начальная сложность**:
    - Новичкам DIP может казаться избыточным, но с опытом его ценность
      становится очевидной.
- **Производительность**:
    - В редких случаях DI-фреймворки могут добавлять накладные расходы, но в
      современных системах это минимально.

---

### Заключение

Принцип инверсии зависимостей делает код более гибким, тестируемым и
масштабируемым за счет использования абстракций и передачи зависимостей извне. В
Java он особенно эффективен благодаря интерфейсам и DI-фреймворкам вроде Spring.
На практике DIP помогает избежать жесткой привязки к конкретным реализациям, что
упрощает поддержку и развитие проекта.

---

### Зачем использовать SOLID в Java?

1. **Гибкость**: Легче добавлять новую функциональность без изменения старого
   кода.
2. **Поддерживаемость**: Код становится чище, понятнее и легче тестируется.
3. **Масштабируемость**: Проекты проще расширять, так как зависимости и
   ответственности четко разделены.
4. **Тестируемость**: Модули, следующие SOLID, проще подменять в тестах (
   например, с помощью моков).

### Практическое применение в Java

- **Spring Framework**: Использует DI (Dependency Inversion) через
  IoC-контейнер.
- **Микросервисы**: Принципы SOLID помогают создавать независимые и
  слабосвязанные сервисы.
- **Тестирование**: JUnit и Mockito упрощают тестирование кода, следующего
  SOLID, благодаря инверсии зависимостей и разделению ответственностей.

### Заключение

Применение SOLID в Java делает код более структурированным и устойчивым к
изменениям. На практике важно балансировать: избыточное следование принципам
может усложнить проект. Начните с небольших улучшений, таких как разделение
ответственностей или внедрение зависимостей через интерфейсы, и постепенно
углубляйтесь.

Если хотите примеры для конкретного случая или разбор кода, напишите — помогу!