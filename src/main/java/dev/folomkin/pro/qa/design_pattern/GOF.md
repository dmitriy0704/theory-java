# Паттерны проектирования

---
Самые популярные:

Порождающие паттерны (Creational Patterns)

1. Фабричный метод (Factory Method)
2. Абстрактная фабрика ( Abstract Factory)
3. Одиночка (Singleton)

Структурные паттерны (Structural Patterns)

1. Декоратор (Decorator)

Поведенческие паттерны (Behavioral Patterns)

1. Наблюдатель (Observer)
2. Стратегия (Strategy)

Мои:

Порождающие паттерны (Creational Patterns)

1. ФАБРИЧНЫЙ МЕТОД (Factory Method)
2. АБСТРАКТНАЯ ФАБРИКА (Abstract Factory)
3. ОДИНОЧКА (Singleton)

4. СТРОИТЕЛЬ (Builder)
5. ПРОТОТИП (Prototype)

Структурные паттерны (Structural Patterns)

1. ДЕКОРАТОР (Decorator)

2. ФАСАД (Facade)
3. ЗАМЕСТИТЕЛЬ (Proxy)

Поведенческие паттерны (Behavioral Patterns)

1. НАБЛЮДАТЕЛЬ (Observer)
2. Стратегия (Strategy)

3. ШАБЛОННЫЙ МЕТОД (Template Method)
4. ИТЕРАТОР (Iterator)

---


Основные паттерны проектирования в Java делятся на три категории: порождающие,
структурные и поведенческие. Вот краткий обзор с основными примерами:

### 1. **Порождающие паттерны** (Creational Patterns)

Отвечают за создание объектов, упрощая их инициализацию и управление.

- **Фабричный метод (Factory Method)**: Определяет интерфейс для создания
  объектов, позволяя подклассам решать, какой класс создавать. Пример: создание
  разных типов документов в редакторе.
- **Абстрактная фабрика (Abstract Factory)**: Создает семейства связанных
  объектов без указания их конкретных классов. Пример: создание UI-элементов для
  разных ОС.
- **Одиночка (Singleton)**: Гарантирует, что у класса только один экземпляр, и
  предоставляет к нему глобальную точку доступа. Пример: логгер или пул
  соединений.
- **Строитель (Builder)**: Разделяет создание сложного объекта от его
  представления. Пример: создание сложных объектов, таких как HTML-документы.
- **Прототип (Prototype)**: Создает новые объекты путем копирования
  существующего. Пример: клонирование объектов в графическом редакторе.

### 2. **Структурные паттерны** (Structural Patterns)

Определяют, как объекты и классы объединяются в более крупные структуры.

- **Адаптер (Adapter)**: Преобразует интерфейс одного класса в интерфейс,
  ожидаемый клиентом. Пример: адаптация старого API к новому.
- **Мост (Bridge)**: Разделяет абстракцию и реализацию, позволяя изменять их
  независимо. Пример: разделение логики рисования фигур и их рендеринга.
- **Компоновщик (Composite)**: Объединяет объекты в древовидные структуры для
  работы с ними как с единым объектом. Пример: структура GUI-компонентов.
- **Декоратор (Decorator)**: Динамически добавляет обязанности объекту. Пример:
  добавление функционала к потоку ввода-вывода.
- **Фасад (Facade)**: Предоставляет упрощенный интерфейс к сложной подсистеме.
  Пример: упрощение работы с библиотекой.
- **Легковес (Flyweight)**: Экономит память, разделяя состояние объектов.
  Пример: повторное использование символов в текстовом редакторе.
- **Заместитель (Proxy)**: Контролирует доступ к объекту, добавляя
  дополнительную логику. Пример: ленивая загрузка изображений.

### 3. **Поведенческие паттерны** (Behavioral Patterns)

Регулируют взаимодействие и распределение обязанностей между объектами.

- **Цепочка обязанностей (Chain of Responsibility)**: Передает запрос по цепочке
  обработчиков. Пример: обработка событий в GUI.
- **Команда (Command)**: Инкапсулирует запрос как объект, позволяя передавать
  его как параметр. Пример: реализация операций "отмена/повтор".
- **Итератор (Iterator)**: Предоставляет способ последовательного доступа к
  элементам коллекции. Пример: обход списка или массива.
- **Посредник (Mediator)**: Упрощает взаимодействие между объектами, централизуя
  управление. Пример: чат между пользователями.
- **Снимок (Memento)**: Сохраняет состояние объекта для последующего
  восстановления. Пример: сохранение состояния игры.
- **Наблюдатель (Observer)**: Определяет зависимость "один ко многим", уведомляя
  объекты об изменениях. Пример: подписка на события.
- **Состояние (State)**: Позволяет объекту изменять поведение в зависимости от
  состояния. Пример: автомат с напитками.
- **Стратегия (Strategy)**: Определяет семейство алгоритмов и позволяет их
  взаимозаменяемость. Пример: сортировка разными алгоритмами.
- **Шаблонный метод (Template Method)**: Определяет скелет алгоритма, позволяя
  подклассам переопределять шаги. Пример: процесс обработки данных.
- **Посетитель (Visitor)**: Разделяет алгоритм от структуры данных, позволяя
  добавлять новые операции. Пример: обход дерева объектов.

### Примечания:

- Эти паттерны описаны в книге "Design Patterns" (Gang of Four) и широко
  применяются в Java.
- В Java некоторые паттерны реализуются проще благодаря встроенным механизмам (
  например, `Iterator` в коллекциях или `Observer` в `java.util.Observable`).
- Выбор паттерна зависит от задачи: изучайте контекст и проблему, чтобы избежать
  избыточной сложности.

---

# ПОДРОБНО

Паттерны проектирования GoF (Gang of Four) из книги *Design Patterns: Elements
of Reusable Object-Oriented Software* широко используются в программировании,
включая Java. Некоторые из них более популярны, чем другие, благодаря их
универсальности, простоте применения и частоте встречающихся задач, которые они
решают. Популярность паттернов зависит от контекста, но на основе опыта
разработки, анализа Stack Overflow, GitHub и обсуждений в сообществе Java можно
выделить наиболее часто используемые паттерны GoF.

Ниже приведены **самые популярные паттерны GoF**, их описание, примеры
применения в Java и причины их популярности.

---

### 1. **Singleton (Одиночка)**

**Категория**: Порождающий<br>
**Описание**: Гарантирует, что у класса есть только один экземпляр, и
предоставляет глобальную точку доступа к нему.<br>
**Почему популярен**: Используется для управления ресурсами, которые должны быть
единичными (например, логгеры, пулы соединений, конфигурации).

**Пример в Java**:

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
    } // Приватный конструктор

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**Применение**:

- Логгеры (например, `java.util.logging.Logger` или `SLF4J`).
- Конфигурационные классы.
- Пул соединений с базой данных.

**Осторожно**: Чрезмерное использование Singleton может привести к
антипаттерну (см. "Singleton Abuse" в предыдущем ответе). В современных
приложениях часто заменяется Dependency Injection (например, в Spring).

---

### 2. Фабричный метод / Абстрактная фабрика

**Factory Method (Фабричный метод) / Abstract Factory (Абстрактная фабрика)**

**Категория**: Порождающий  
**Описание**:

- **Factory Method**: Определяет интерфейс для создания объектов, позволяя
  подклассам решать, какой класс создавать.
- **Abstract Factory**: Создаёт семейства связанных объектов без указания их
  конкретных классов.

**Почему популярен**: Упрощает создание объектов, особенно когда нужно управлять
различными реализациями. Широко используется в библиотеках и фреймворках.

**Пример Factory Method в Java**:

```java
interface Product {
    void use();
}

class ConcreteProductA implements Product {
    public void use() {
        System.out.println("Using Product A");
    }
}

class ConcreteProductB implements Product {
    public void use() {
        System.out.println("Using Product B");
    }
}

abstract class Creator {
    public abstract Product factoryMethod();
}

class ConcreteCreatorA extends Creator {
    public Product factoryMethod() {
        return new ConcreteProductA();
    }
}

class ConcreteCreatorB extends Creator {
    public Product factoryMethod() {
        return new ConcreteProductB();
    }
}
```

**Применение**:

- Создание объектов в зависимости от конфигурации (например,
  `java.sql.DriverManager`).
- Фреймворки, такие как Spring (BeanFactory).
- Работа с различными форматами данных (например, парсеры XML/JSON).

**Причина популярности**: Позволяет писать гибкий код, соответствующий принципу
Open/Closed из SOLID.

---

### 3. **Observer (Наблюдатель)**

**Категория**: Поведенческий  
**Описание**: Определяет зависимость "один ко многим" между объектами, чтобы при
изменении состояния одного объекта все зависимые объекты уведомлялись
автоматически.  
**Почему популярен**: Идеально подходит для событийно-ориентированных систем,
GUI, и асинхронных приложений.

**Пример в Java**:
Java имеет встроенную поддержку этого паттерна через `java.util.Observable` и
`java.util.Observer` (хотя они устарели с Java 9). Современный пример с
использованием `java.beans.PropertyChangeSupport`:

```java
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;

public class Subject {
    private PropertyChangeSupport support = new PropertyChangeSupport(this);
    private String state;

    public void addObserver(PropertyChangeListener listener) {
        support.addPropertyChangeListener(listener);
    }

    public void setState(String newState) {
        String oldState = this.state;
        this.state = newState;
        support.firePropertyChange("state", oldState, newState);
    }
}

public class Observer implements PropertyChangeListener {
    public void propertyChange(java.beans.PropertyChangeEvent evt) {
        System.out.println("State changed from " + evt.getOldValue() + " to " + evt.getNewValue());
    }
}
```

**Применение**:

- Слушатели событий в Swing/JavaFX.
- Реактивные приложения (например, с RxJava).
- Обновление UI при изменении модели (MVC).

**Причина популярности**: Широко используется в любых системах, где нужно
реагировать на изменения (например, в реальном времени).

---

### 4. **Strategy (Стратегия)**

**Категория**: Поведенческий  
**Описание**: Определяет семейство алгоритмов, инкапсулирует каждый из них и
делает их взаимозаменяемыми.  
**Почему популярен**: Позволяет легко переключать поведение в runtime, что
полезно для обработки различных сценариев.

**Пример в Java**:

```java
interface PaymentStrategy {
    void pay(double amount);
}

class CreditCardPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " via Credit Card");
    }
}

class PayPalPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " via PayPal");
    }
}

class Order {
    private PaymentStrategy paymentStrategy;

    public Order(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void processPayment(double amount) {
        paymentStrategy.pay(amount);
    }
}
```

**Применение**:

- Различные алгоритмы сортировки (например, `java.util.Comparator`).
- Обработка платежей в e-commerce.
- Настраиваемые валидаторы или парсеры.

**Причина популярности**: Упрощает добавление нового поведения без изменения
существующего кода, соответствует принципу Open/Closed.

---

### 5. **Decorator (Декоратор)**

**Категория**: Структурный  
**Описание**: Динамически добавляет новые обязанности объекту, оборачивая его в
другой объект.  
**Почему популярен**: Позволяет гибко расширять функциональность без изменения
исходного класса, особенно в работе с потоками и API.

**Пример в Java**:
Java I/O — классический пример декоратора:

```java
import java.io.*;

public class DecoratorExample {
    public static void main(String[] args) throws IOException {
        File file = new File("test.txt");
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
            writer.write("Hello, Decorator!");
        }
    }
}
```

Здесь `BufferedWriter` декорирует `FileWriter`, добавляя буферизацию.

**Применение**:

- Потоки ввода-вывода (`InputStream`, `OutputStream`).
- Расширение функциональности API (например, добавление логирования).
- UI-компоненты (например, в Swing).

**Причина популярности**: Удобен для постепенного добавления функциональности,
особенно в библиотеках и фреймворках.

---

### Почему именно эти паттерны популярны?

1. **Универсальность**: Эти паттерны решают типичные задачи (создание объектов,
   управление поведением, реакция на события).
2. **Поддержка в Java**: Многие встроены в стандартную библиотеку (например, I/O
   для Decorator, `Comparator` для Strategy).
3. **Фреймворки**: Spring, Hibernate и другие активно используют Factory,
   Singleton, Observer.
4. **Сообщество**: На Stack Overflow и GitHub эти паттерны часто упоминаются в
   решениях (например, Singleton и Factory — лидеры по вопросам).

### Менее популярные паттерны GoF

Некоторые паттерны, такие как **Memento**, **Interpreter** или **Flyweight**,
менее популярны, так как применяются в специфических сценариях (например,
реализация undo, парсинг языков, оптимизация памяти). Они реже встречаются в
типичных Java-приложениях.

### Замечания

- **Контекст имеет значение**: Популярность зависит от домена. Например, в
  веб-разработке (Spring) чаще встречаются Factory и Singleton, а в GUI —
  Observer и Decorator.
- **Современные альтернативы**: В Java многие паттерны упрощаются с помощью
  функционального программирования (например, лямбда-выражения заменяют Strategy
  в некоторых случаях).
- **Антипаттерны**: Неправильное использование популярных паттернов (например,
  Singleton) может привести к проблемам, как обсуждалось ранее.

Если вы хотите углубиться в конкретный паттерн, получить больше примеров или
обсудить их применение в вашем проекте, напишите!
