# Паттерны проектирования

Основные паттерны проектирования в Java делятся на три категории: **порождающие
**, **структурные** и **поведенческие**. Вот краткий обзор с основными
примерами:

### 1. **Порождающие паттерны** (Creational Patterns)

Отвечают за создание объектов, упрощая их инициализацию и управление.

- **Фабричный метод (Factory Method)**: Определяет интерфейс для создания
  объектов, позволяя подклассам решать, какой класс создавать. Пример: создание
  разных типов документов в редакторе.
- **Абстрактная фабрика (Abstract Factory)**: Создает семейства связанных
  объектов без указания их конкретных классов. Пример: создание UI-элементов для
  разных ОС.
- **Одиночка (Singleton)**: Гарантирует, что у класса только один экземпляр, и
  предоставляет к нему глобальную точку доступа. Пример: логгер или пул
  соединений.
- **Строитель (Builder)**: Разделяет создание сложного объекта от его
  представления. Пример: создание сложных объектов, таких как HTML-документы.
- **Прототип (Prototype)**: Создает новые объекты путем копирования
  существующего. Пример: клонирование объектов в графическом редакторе.

### 2. **Структурные паттерны** (Structural Patterns)

Определяют, как объекты и классы объединяются в более крупные структуры.

- **Адаптер (Adapter)**: Преобразует интерфейс одного класса в интерфейс,
  ожидаемый клиентом. Пример: адаптация старого API к новому.
- **Мост (Bridge)**: Разделяет абстракцию и реализацию, позволяя изменять их
  независимо. Пример: разделение логики рисования фигур и их рендеринга.
- **Компоновщик (Composite)**: Объединяет объекты в древовидные структуры для
  работы с ними как с единым объектом. Пример: структура GUI-компонентов.
- **Декоратор (Decorator)**: Динамически добавляет обязанности объекту. Пример:
  добавление функционала к потоку ввода-вывода.
- **Фасад (Facade)**: Предоставляет упрощенный интерфейс к сложной подсистеме.
  Пример: упрощение работы с библиотекой.
- **Легковес (Flyweight)**: Экономит память, разделяя состояние объектов.
  Пример: повторное использование символов в текстовом редакторе.
- **Заместитель (Proxy)**: Контролирует доступ к объекту, добавляя
  дополнительную логику. Пример: ленивая загрузка изображений.

### 3. **Поведенческие паттерны** (Behavioral Patterns)

Регулируют взаимодействие и распределение обязанностей между объектами.

- **Цепочка обязанностей (Chain of Responsibility)**: Передает запрос по цепочке
  обработчиков. Пример: обработка событий в GUI.
- **Команда (Command)**: Инкапсулирует запрос как объект, позволяя передавать
  его как параметр. Пример: реализация операций "отмена/повтор".
- **Итератор (Iterator)**: Предоставляет способ последовательного доступа к
  элементам коллекции. Пример: обход списка или массива.
- **Посредник (Mediator)**: Упрощает взаимодействие между объектами, централизуя
  управление. Пример: чат между пользователями.
- **Снимок (Memento)**: Сохраняет состояние объекта для последующего
  восстановления. Пример: сохранение состояния игры.
- **Наблюдатель (Observer)**: Определяет зависимость "один ко многим", уведомляя
  объекты об изменениях. Пример: подписка на события.
- **Состояние (State)**: Позволяет объекту изменять поведение в зависимости от
  состояния. Пример: автомат с напитками.
- **Стратегия (Strategy)**: Определяет семейство алгоритмов и позволяет их
  взаимозаменяемость. Пример: сортировка разными алгоритмами.
- **Шаблонный метод (Template Method)**: Определяет скелет алгоритма, позволяя
  подклассам переопределять шаги. Пример: процесс обработки данных.
- **Посетитель (Visitor)**: Разделяет алгоритм от структуры данных, позволяя
  добавлять новые операции. Пример: обход дерева объектов.

### Примечания:

- Эти паттерны описаны в книге "Design Patterns" (Gang of Four) и широко
  применяются в Java.
- В Java некоторые паттерны реализуются проще благодаря встроенным механизмам (
  например, `Iterator` в коллекциях или `Observer` в `java.util.Observable`).
- Выбор паттерна зависит от задачи: изучайте контекст и проблему, чтобы избежать
  избыточной сложности.

Если нужен пример кода для какого-то паттерна или более глубокое объяснение,
дайте знать!

## Singleton

**Паттерн Одиночка (Singleton)** — это порождающий паттерн проектирования,
который гарантирует, что у класса будет только **один экземпляр**, и
предоставляет к нему **глобальную точку доступа**. Он полезен, когда нужен
единственный объект для координации действий в системе, например, для управления
конфигурацией, пулом соединений или логгером.

### Основные характеристики:

1. **Один экземпляр**: Класс имеет только один объект, создаваемый при первом
   обращении.
2. **Глобальный доступ**: Экземпляр доступен через статический метод (обычно
   `getInstance()`).
3. **Ленивая инициализация** (опционально): Экземпляр создается только при
   необходимости.
4. **Контроль создания**: Класс сам управляет своим экземпляром, предотвращая
   создание дополнительных объектов.

### Когда использовать:

- Когда нужен ровно один экземпляр класса (например, для логгера, менеджера
  конфигурации, пула соединений с БД).
- Когда требуется глобальная точка доступа к этому экземпляру.
- Когда создание нескольких экземпляров может привести к проблемам (например,
  дублирование ресурсов).

### Реализация в Java

Существует несколько способов реализации Singleton, но я покажу два популярных
подхода: **ленивая инициализация** и **инициализация при загрузке класса**.

#### 1. **Ленивая инициализация (Lazy Initialization)**

Экземпляр создается только при первом вызове `getInstance()`.

```java
public class Singleton {
    // Статическая переменная для хранения единственного экземпляра
    private static Singleton instance;

    // Приватный конструктор предотвращает создание объектов извне
    private Singleton() {
        // Защита от создания экземпляров через рефлексию
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method to get the single instance of this class.");
        }
    }

    // Метод для получения экземпляра
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) { // Синхронизация для потокобезопасности
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**Особенности**:

- **Потокобезопасность**: Используется `synchronized` для защиты от создания
  нескольких экземпляров в многопоточной среде.
- **Двойная проверка (Double-Checked Locking)**: Уменьшает накладные расходы на
  синхронизацию после создания экземпляра.
- **Проблемы**: Требует осторожности при использовании в многопоточных
  приложениях.

#### 2. **Инициализация при загрузке класса (Eager Initialization)**

Экземпляр создается сразу при загрузке класса.

```java
public class Singleton {
    // Статическая переменная инициализируется при загрузке класса
    private static final Singleton instance = new Singleton();

    // Приватный конструктор
    private Singleton() {
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method to get the single instance of this class.");
        }
    }

    // Метод для получения экземпляра
    public static Singleton getInstance() {
        return instance;
    }
}
```

**Особенности**:

- **Простота**: Нет необходимости в синхронизации, так как JVM гарантирует
  потокобезопасность при инициализации статических полей.
- **Недостаток**: Экземпляр создается даже если он не нужен, что может быть
  неэффективно.

#### 3. **Инициализация через статический блок или Bill Pugh Singleton**

Более современный подход с использованием внутреннего статического класса (
держателя).

```java
public class Singleton {
    // Приватный конструктор
    private Singleton() {
        if (Holder.INSTANCE != null) {
            throw new RuntimeException("Use getInstance() method to get the single instance of this class.");
        }
    }

    // Внутренний статический класс для ленивой инициализации
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // Метод для получения экземпляра
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

**Особенности**:

- **Ленивая инициализация**: Экземпляр создается только при первом обращении к
  `Holder.INSTANCE`.
- **Потокобезопасность**: Гарантируется JVM, так как статические поля
  инициализируются потокобезопасно.
- **Эффективность**: Нет необходимости в `synchronized`.

### Пример использования

```java
public class Main {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();

        // Проверка, что это один и тот же объект
        System.out.println(singleton1 == singleton2); // true
    }
}
```

### Преимущества:

- Гарантия единственного экземпляра.
- Глобальный доступ к объекту.
- Ленивая инициализация (в некоторых реализациях) экономит ресурсы.

### Недостатки:

- Может усложнить тестирование (зависимость от глобального состояния).
- Проблемы с сериализацией или рефлексией, если не учесть их (например, нужно
  реализовать `readResolve()` для сериализации).
- Злоупотребление Singleton может привести к плохой архитектуре, так как он
  действует как глобальная переменная.

### Защита от нарушений Singleton

1. **Рефлексия**: Проверяйте в конструкторе, не существует ли уже экземпляр.
2. **Сериализация**: Реализуйте метод `readResolve()`:
   ```java
   private Object readResolve() {
       return getInstance();
   }
   ```
3. **Клонирование**: Переопределите `clone()` для предотвращения клонирования:
   ```java
   @Override
   protected Object clone() throws CloneNotSupportedException {
       throw new CloneNotSupportedException("Singleton cannot be cloned");
   }
   ```

### Реальные примеры использования:

- **Логгер**: `java.util.logging.Logger` или библиотеки вроде Log4j.
- **Пул соединений**: Управление соединениями с базой данных.
- **Конфигурация**: Хранение настроек приложения.

## Прототип

**Паттерн Прототип (Prototype)** — это порождающий паттерн проектирования,
который позволяет создавать новые объекты путем **копирования существующего
объекта** (прототипа), вместо создания с нуля. Это полезно, когда создание
объекта дорогостоящее или сложное, либо когда нужно сохранить состояние объекта
для последующего воспроизведения.

### Основные характеристики:

1. **Копирование объекта**: Новый объект создается как копия прототипа.
2. **Интерфейс клонирования**: Обычно используется метод `clone()`, который
   возвращает копию объекта.
3. **Гибкость**: Позволяет создавать разные вариации объектов, изменяя копии
   прототипа.
4. **Избежание сложной инициализации**: Упрощает создание объектов с похожим
   состоянием.

### Когда использовать:

- Когда создание объекта требует больших затрат (например, сложные вычисления
  или запросы к базе данных).
- Когда нужно создавать множество объектов с похожими свойствами.
- Когда нужно сохранить независимую копию объекта для дальнейших изменений.
- Примеры: клонирование графических объектов в редакторе, создание шаблонов
  документов.

### Реализация в Java

```java
### Реализация в Java
        В Java паттерн Прототип часто реализуется с использованием интерфейса `Cloneable` и метода `clone()` из класса `Object`.Есть два типа клонирования:
        -**Поверхностное копирование(Shallow Copy)**:Копируются только ссылки на объекты,а не сами объекты.
        -**Глубокое копирование(Deep Copy)**:Копируются все объекты,включая вложенные.

        #### Пример:Простая реализация с глубоким копированием
        ```java
import java.util.ArrayList;
import java.util.List;

// Класс, реализующий интерфейс Cloneable
public class Prototype implements Cloneable {
    private String name;
    private List<String> attributes;

    public Prototype(String name, List<String> attributes) {
        this.name = name;
        this.attributes = attributes;
    }

    // Реализация метода clone для глубокого копирования
    @Override
    public Prototype clone() {
        try {
            // Поверхностное копирование объекта
            Prototype cloned = (Prototype) super.clone();
            // Глубокое копирование списка attributes
            cloned.attributes = new ArrayList<>(this.attributes);
            return cloned;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cloning failed", e);
        }
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public List<String> getAttributes() {
        return attributes;
    }

    @Override
    public String toString() {
        return "Prototype{name='" + name + "', attributes=" + attributes + "}";
    }
}

// Тестовый класс
public class Main {
    public static void main(String[] args) {
        List<String> attributes = new ArrayList<>();
        attributes.add("attr1");
        attributes.add("attr2");

        // Создаем прототип
        Prototype prototype = new Prototype("Original", attributes);

        // Клонируем прототип
        Prototype clonedPrototype = prototype.clone();

        // Изменяем клон
        clonedPrototype.setName("Cloned");
        clonedPrototype.getAttributes().add("attr3");

        // Выводим оба объекта
        System.out.println(prototype);       // Original, [attr1, attr2]
        System.out.println(clonedPrototype); // Cloned, [attr1, attr2, attr3]
    }
}
```

### Объяснение кода:

1. **Интерфейс `Cloneable`**: Класс должен реализовать `Cloneable`, чтобы
   разрешить клонирование.
2. **Метод `clone()`**: Переопределяется для выполнения глубокого копирования.
   Сначала вызывается `super.clone()` для поверхностной копии, затем вручную
   копируется список `attributes`.
3. **Глубокое копирование**: Создается новый `ArrayList` для `attributes`, чтобы
   изменения в клоне не затрагивали оригинал.
4. **Результат**: Оригинал и клон независимы, изменения в одном не влияют на
   другой.

### Альтернативный подход: Конструктор копирования

Если не использовать `Cloneable`, можно реализовать паттерн через конструктор
копирования:

```java
public class Prototype {
    private String name;
    private List<String> attributes;

    public Prototype(String name, List<String> attributes) {
        this.name = name;
        this.attributes = attributes;
    }

    // Конструктор копирования
    public Prototype(Prototype prototype) {
        this.name = prototype.name;
        this.attributes = new ArrayList<>(prototype.attributes);
    }

    // Геттеры, сеттеры и toString как выше
}
```

**Использование**:

```java
Prototype prototype = new Prototype("Original", new ArrayList<>(List.of("attr1", "attr2")));
Prototype cloned = new Prototype(prototype);
cloned.

setName("Cloned");
cloned.

getAttributes().

add("attr3");
```

### Преимущества:

- **Эффективность**: Избегает повторной сложной инициализации.
- **Гибкость**: Клоны можно модифицировать независимо.
- **Упрощение создания**: Удобно для создания объектов с похожим состоянием.

### Недостатки:

- **Сложность глубокого копирования**: Требует тщательной реализации для
  копирования всех вложенных объектов.
- **Ошибки при клонировании**: Неправильная реализация может привести к
  неожиданным связям между объектами.
- **Не всегда интуитивно**: Нужно явно учитывать, какие поля копируются и как.

### Реальные примеры использования:

- **Графические редакторы**: Клонирование фигур или объектов на холсте.
- **Шаблоны документов**: Создание новых документов на основе шаблона.
- **Игры**: Клонирование игровых объектов (например, врагов с одинаковыми
  характеристиками).
- **Java API**: Классы вроде `java.util.ArrayList` или `java.util.HashMap`
  поддерживают `clone()` для создания копий.

### Важные замечания:

1. **Глубокое vs Поверхностное копирование**: Поверхностное копирование подходит
   для простых объектов, но для сложных структур требуется глубокое копирование.
2. **Исключения**: Метод `clone()` может выбросить `CloneNotSupportedException`,
   поэтому нужна обработка.
3. **Альтернативы**: В некоторых случаях вместо `Cloneable` лучше использовать
   конструкторы копирования или библиотеки сериализации (например, Apache
   Commons Lang для глубокого клонирования).

## Строитель

**Паттерн Строитель (Builder)** — это порождающий паттерн проектирования,
который позволяет пошагово создавать сложные объекты, отделяя процесс
конструирования от представления объекта. Он полезен, когда объект имеет
множество параметров или сложную логику инициализации, а также когда нужно
создавать разные конфигурации одного и того же объекта.

### Основные характеристики:

1. **Пошаговое создание**: Объект собирается по частям через вызов методов
   строителя.
2. **Отделение конструирования**: Логика создания объекта вынесена в отдельный
   класс (`Builder`).
3. **Гибкость**: Позволяет создавать разные варианты объекта, изменяя параметры
   или порядок сборки.
4. **Читаемость**: Упрощает создание объектов с большим количеством параметров,
   избегая громоздких конструкторов.

### Когда использовать:

- Когда объект имеет много опциональных параметров, и использование
  конструкторов становится неудобным (телескопический конструктор).
- Когда процесс создания объекта сложный и требует нескольких шагов.
- Когда нужно создавать разные конфигурации одного объекта.
- Примеры: создание сложных объектов, таких как документы, графические элементы,
  конфигурации запросов (например, HTTP-запросы).

### Структура паттерна:

1. **Продукт (Product)**: Класс, представляющий создаваемый объект.
2. **Строитель (Builder)**: Интерфейс или абстрактный класс, определяющий методы
   для пошагового создания продукта.
3. **Конкретный строитель (Concrete Builder)**: Реализует строитель, создавая
   конкретный продукт.
4. **Директор (Director)** (опционально): Класс, управляющий процессом сборки,
   используя строителя.

### Реализация в Java

В Java паттерн Строитель часто реализуется с использованием вложенного
статического класса `Builder` внутри класса продукта. Вот пример:

#### Пример: Создание объекта `House`

```java
// Продукт
public class House {
    private final String foundation; // Обязательное поле
    private final String walls;      // Обязательное поле
    private final String roof;       // Обязательное поле
    private final String garage;     // Опциональное поле
    private final String pool;       // Опциональное поле

    // Приватный конструктор, доступный только для Builder
    private House(Builder builder) {
        this.foundation = builder.foundation;
        this.walls = builder.walls;
        this.roof = builder.roof;
        this.garage = builder.garage;
        this.pool = builder.pool;
    }

    // Геттеры
    public String getFoundation() {
        return foundation;
    }

    public String getWalls() {
        return walls;
    }

    public String getRoof() {
        return roof;
    }

    public String getGarage() {
        return garage;
    }

    public String getPool() {
        return pool;
    }

    @Override
    public String toString() {
        return "House{foundation='" + foundation + "', walls='" + walls + "', roof='" + roof +
                "', garage='" + garage + "', pool='" + pool + "'}";
    }

    // Вложенный статический класс Builder
    public static class Builder {
        private String foundation;
        private String walls;
        private String roof;
        private String garage;
        private String pool;

        // Обязательные параметры задаются через конструктор или методы
        public Builder(String foundation, String walls, String roof) {
            this.foundation = foundation;
            this.walls = walls;
            this.roof = roof;
        }

        // Методы для опциональных параметров
        public Builder withGarage(String garage) {
            this.garage = garage;
            return this;
        }

        public Builder withPool(String pool) {
            this.pool = pool;
            return this;
        }

        // Метод для создания объекта
        public House build() {
            return new House(this);
        }
    }
}

// Тестовый класс
public class Main {
    public static void main(String[] args) {
        // Создаем дом с обязательными параметрами и гаражом
        House house1 = new House.Builder("Concrete", "Brick", "Tile")
                .withGarage("Two-car garage")
                .build();

        // Создаем дом с обязательными параметрами и бассейном
        House house2 = new House.Builder("Wood", "Stone", "Metal")
                .withPool("Outdoor pool")
                .build();

        System.out.println(house1); // House{foundation='Concrete', walls='Brick', roof='Tile', garage='Two-car garage', pool='null'}
        System.out.println(house2); // House{foundation='Wood', walls='Stone', roof='Metal', garage='null', pool='Outdoor pool'}
    }
}
```

### Объяснение кода:

1. **Класс `House` (Продукт)**:

- Содержит поля, описывающие объект (обязательные и опциональные).
- Имеет приватный конструктор, доступный только для `Builder`.
- Поля неизменяемы (`final`), что делает объект иммутабельным.

2. **Класс `Builder`**:

- Вложенный статический класс, содержащий те же поля, что и `House`.
- Обязательные параметры задаются через конструктор `Builder`.
- Опциональные параметры задаются через методы `withXxx()`, которые возвращают
  `this` для цепочки вызовов (fluent interface).
- Метод `build()` создает и возвращает объект `House`.

3. **Использование**:

- Клиент создает объект, вызывая `Builder` с обязательными параметрами и
  добавляя опциональные через методы.
- Цепочка методов делает код читаемым и гибким.

### Пример с Директором

Если процесс сборки сложный, можно добавить класс `Director` для управления
строителем:

```java
public class HouseDirector {
    public House constructLuxuryHouse(House.Builder builder) {
        return builder
                .withGarage("Three-car garage")
                .withPool("Infinity pool")
                .build();
    }
}

// Использование
HouseDirector director = new HouseDirector();
House luxuryHouse = director.constructLuxuryHouse(new House.Builder("Marble", "Glass", "Slate"));
System.out.

println(luxuryHouse);
```

### Преимущества:

- **Читаемость**: Код создания объекта понятен и не перегружен конструкторами.
- **Гибкость**: Легко добавлять новые параметры или конфигурации.
- **Иммутабельность**: Объект можно сделать неизменяемым, задавая поля через
  `final`.
- **Управление сложностью**: Пошаговое создание упрощает работу со сложными
  объектами.

### Недостатки:

- **Увеличение кода**: Требуется дополнительный класс `Builder` и методы для
  каждого параметра.
- **Сложность для простых объектов**: Для объектов с 1–2 параметрами паттерн
  может быть избыточным.
- **Дублирование полей**: Поля в `Builder` дублируют поля продукта.

### Реальные примеры использования:

- **Java API**:
    - `StringBuilder` и `StringBuffer` для пошагового построения строк.
    - `java.util.Calendar.Builder` для создания объектов `Calendar`.
    - `java.time.LocalDateTime` и подобные классы с методами `of()` и `with()`.
- **Библиотеки**:
    - OkHttp (`Request.Builder`) для построения HTTP-запросов.
    - Jackson (`ObjectMapper` с конфигурацией).
- **Приложения**: Создание сложных объектов, таких как конфигурации, документы,
  UI-элементы.

### Важные замечания:

1. **Fluent Interface**: Возвращение `this` в методах `Builder` делает API
   удобным для цепочки вызовов.
2. **Валидация**: Можно добавить проверки в метод `build()`, чтобы гарантировать
   корректность объекта (например, что обязательные поля заполнены).
3. **Иммутабельность**: Использование `final` полей в продукте делает объект
   безопасным для многопоточной среды.
4. **Альтернативы**: Для простых случаев можно использовать конструкторы с
   параметрами по умолчанию или фабричные методы.

Если нужен пример для другого случая, разбор с валидацией или сравнение с
другими паттернами, напишите!

## Фасад

**Паттерн Фасад (Facade)** — это структурный паттерн проектирования, который
предоставляет **упрощенный интерфейс** к сложной подсистеме, состоящей из
множества классов и компонентов. Он скрывает сложность внутренней реализации,
делая взаимодействие с подсистемой более удобным и понятным для клиента.

### Основные характеристики:

1. **Упрощение интерфейса**: Фасад предоставляет высокоуровневый API, скрывая
   детали работы подсистемы.
2. **Инкапсуляция**: Объединяет взаимодействие с несколькими классами в одном
   месте.
3. **Снижение связности**: Клиент работает только с фасадом, а не напрямую с
   компонентами подсистемы.
4. **Универсальность**: Может предоставлять несколько методов для разных
   сценариев использования подсистемы.

### Когда использовать:

- Когда подсистема сложная, содержит множество классов, и клиент должен
  выполнять рутинные операции без погружения в детали.
- Когда нужно уменьшить зависимость клиента от подсистемы.
- Когда требуется предоставить ограниченный, но удобный доступ к подсистеме.
- Примеры: упрощение работы с библиотекой, управление сложными процессами (
  например, запуск системы).

### Структура паттерна:

1. **Подсистема (Subsystem)**: Набор классов, выполняющих сложные функции.
   Каждый класс отвечает за свою задачу.
2. **Фасад (Facade)**: Класс, предоставляющий упрощенный интерфейс для работы с
   подсистемой. Он знает, как взаимодействовать с классами подсистемы.
3. **Клиент (Client)**: Использует фасад для выполнения операций, не
   взаимодействуя напрямую с подсистемой.

### Реализация в Java

Рассмотрим пример, где подсистема управляет процессом заказа в
интернет-магазине (проверка инвентаря, оплата, доставка). Фасад упрощает процесс
оформления заказа.

#### Пример: Подсистема интернет-магазина

```java
// Классы подсистемы
class InventorySystem {
    public boolean checkAvailability(String productId) {
        System.out.println("Checking availability for product: " + productId);
        return true; // Предположим, товар есть
    }
}

class PaymentSystem {
    public boolean processPayment(String paymentDetails, double amount) {
        System.out.println("Processing payment of $" + amount + " with details: " + paymentDetails);
        return true; // Платеж успешен
    }
}

class ShippingSystem {
    public String shipOrder(String productId, String address) {
        System.out.println("Shipping product " + productId + " to " + address);
        return "TRK12345"; // Трек-код
    }
}

// Фасад
class OrderFacade {
    private final InventorySystem inventorySystem;
    private final PaymentSystem paymentSystem;
    private final ShippingSystem shippingSystem;

    public OrderFacade() {
        this.inventorySystem = new InventorySystem();
        this.paymentSystem = new PaymentSystem();
        this.shippingSystem = new ShippingSystem();
    }

    // Упрощенный метод для оформления заказа
    public String placeOrder(String productId, String paymentDetails, double amount, String address) {
        // Шаг 1: Проверка наличия товара
        if (!inventorySystem.checkAvailability(productId)) {
            return "Order failed: Product " + productId + " is out of stock";
        }

        // Шаг 2: Обработка платежа
        if (!paymentSystem.processPayment(paymentDetails, amount)) {
            return "Order failed: Payment processing error";
        }

        // Шаг 3: Организация доставки
        String trackingNumber = shippingSystem.shipOrder(productId, address);
        return "Order placed successfully! Tracking number: " + trackingNumber;
    }
}

// Тестовый класс
public class Main {
    public static void main(String[] args) {
        OrderFacade orderFacade = new OrderFacade();

        // Клиент использует фасад для оформления заказа
        String result = orderFacade.placeOrder("PROD123", "CreditCard:1234", 99.99, "123 Main St");
        System.out.println(result);
    }
}
```

### Объяснение кода:

1. **Подсистема**:
    - `InventorySystem`: Проверяет наличие товара.
    - `PaymentSystem`: Обрабатывает платеж.
    - `ShippingSystem`: Организует доставку.
2. **Фасад (`OrderFacade`)**:
    - Содержит ссылки на классы подсистемы.
    - Предоставляет метод `placeOrder`, который координирует работу подсистемы
      для выполнения заказа.
    - Скрывает сложность последовательных вызовов и проверок.
3. **Клиент**:
    - Вызывает один метод фасада, не взаимодействуя напрямую с подсистемой.
    - Получает результат в виде строки (например, трек-код или сообщение об
      ошибке).

**Вывод программы**:

```
Checking availability for product: PROD123
Processing payment of $99.99 with details: CreditCard:1234
Shipping product PROD123 to 123 Main St
Order placed successfully! Tracking number: TRK12345
```

### Преимущества:

- **Упрощение работы**: Клиенту не нужно знать, как взаимодействовать с
  подсистемой.
- **Снижение связности**: Клиент зависит только от фасада, а не от множества
  классов.
- **Инкапсуляция**: Скрывает сложность и внутреннюю реализацию подсистемы.
- **Гибкость**: Можно добавлять новые методы в фасад для других сценариев.

### Недостатки:

- **Ограничение функциональности**: Фасад может не предоставлять доступ ко всем
  возможностям подсистемы.
- **Риск усложнения**: Если фасад становится слишком большим, он может
  превратиться в "божественный объект".
- **Дополнительный слой**: Добавляет еще один класс, что может быть избыточным
  для простых систем.

### Реальные примеры использования:

- **Java API**:
    - `java.sql.DriverManager`: Упрощает подключение к базе данных, скрывая
      детали драйверов.
    - `javax.faces.context.FacesContext`: Фасад для работы с JSF-компонентами.
- **Библиотеки**:
    - OkHttp: `OkHttpClient` скрывает сложность HTTP-запросов.
    - Hibernate: `SessionFactory` и `Session` упрощают взаимодействие с базой
      данных.
- **Приложения**:
    - Управление мультимедиа: Фасад для работы с аудио, видео и субтитрами.
    - Подсистемы биллинга: Упрощение процессов оплаты и выставления счетов.

### Важные замечания:

1. **Не полная изоляция**: Фасад не запрещает клиенту напрямую обращаться к
   подсистеме, если это нужно.
2. **Множественные фасады**: Для большой подсистемы можно создать несколько
   фасадов для разных задач.
3. **Комбинация с другими паттернами**: Фасад часто используется с **Фабрикой**
   или **Одиночкой** для создания объектов подсистемы.
4. **Валидация**: Фасад может включать проверки и обработку ошибок, чтобы
   сделать API надежнее.

Если нужен пример для другого случая, разбор с другими паттернами или более
сложная реализация, напишите!

## Наблюдатель

**Паттерн Наблюдатель (Observer)** — это поведенческий паттерн проектирования,
который устанавливает механизм **"один ко многим"** между объектами: когда
состояние одного объекта (субъекта) изменяется, все зависимые объекты (
наблюдатели) автоматически уведомляются и обновляются. Этот паттерн широко
используется для реализации событийно-ориентированных систем.

### Основные характеристики:

1. **Субъект (Subject)**: Объект, за состоянием которого следят. Хранит список
   наблюдателей и уведомляет их при изменении.
2. **Наблюдатель (Observer)**: Объект, который получает уведомления об
   изменениях субъекта и реагирует на них.
3. **Подписка/отписка**: Наблюдатели могут динамически подписываться на субъект
   или отписываться от него.
4. **Автоматическое уведомление**: Субъект вызывает методы наблюдателей при
   изменении своего состояния.

### Когда использовать:

- Когда изменение состояния одного объекта должно автоматически отражаться в
  других объектах.
- Когда нужно реализовать систему событий (например, GUI, подписка на новости).
- Когда требуется слабая связанность между субъектом и наблюдателями.
- Примеры: обновление интерфейса при изменении данных, рассылка уведомлений,
  системы событий.

### Структура паттерна:

1. **Интерфейс `Observer`**: Определяет метод (обычно `update()`), который
   вызывается для уведомления наблюдателя.
2. **Интерфейс `Subject`**: Определяет методы для управления наблюдателями (
   `addObserver`, `removeObserver`, `notifyObservers`).
3. **Конкретный субъект**: Реализует субъект, хранит состояние и уведомляет
   наблюдателей.
4. **Конкретный наблюдатель**: Реализует логику обработки уведомлений.

### Реализация в Java

В Java паттерн Наблюдатель поддерживается встроенными средствами через класс
`java.util.Observable` и интерфейс `java.util.Observer`, но они устарели с Java

9. Поэтому рассмотрим современную реализацию с собственными интерфейсами.

#### Пример: Система новостей

Субъект — новостное агентство, наблюдатели — подписчики, которые получают
новости.

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс наблюдателя
interface Observer {
    void update(String news);
}

// Интерфейс субъекта
interface Subject {
    void addObserver(Observer observer);

    void removeObserver(Observer observer);

    void notifyObservers();
}

// Конкретный субъект
class NewsAgency implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String latestNews;

    @Override
    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(latestNews);
        }
    }

    // Метод для установки новостей и уведомления наблюдателей
    public void setNews(String news) {
        this.latestNews = news;
        notifyObservers();
    }
}

// Конкретные наблюдатели
class Subscriber implements Observer {
    private String name;

    public Subscriber(String name) {
        this.name = name;
    }

    @Override
    public void update(String news) {
        System.out.println(name + " received news: " + news);
    }
}

// Тестовый класс
public class Main {
    public static void main(String[] args) {
        // Создаем субъект
        NewsAgency newsAgency = new NewsAgency();

        // Создаем наблюдателей
        Observer subscriber1 = new Subscriber("Alice");
        Observer subscriber2 = new Subscriber("Bob");

        // Подписываем наблюдателей
        newsAgency.addObserver(subscriber1);
        newsAgency.addObserver(subscriber2);

        // Публикуем новости
        newsAgency.setNews("Breaking: New discovery in space!");

        // Отписываем одного наблюдателя
        newsAgency.removeObserver(subscriber2);

        // Публикуем новые новости
        newsAgency.setNews("Weather: Sunny all week!");
    }
}
```

### Объяснение кода:

1. **Интерфейс `Observer`**:
    - Определяет метод `update`, который вызывается субъектом для передачи
      данных (в данном случае — новости).
2. **Интерфейс `Subject`**:
    - Определяет методы для управления наблюдателями: `addObserver`,
      `removeObserver`, `notifyObservers`.
3. **Класс `NewsAgency` (Субъект)**:
    - Хранит список наблюдателей и текущее состояние (`latestNews`).
    - При вызове `setNews` обновляет новости и уведомляет всех наблюдателей
      через `notifyObservers`.
4. **Класс `Subscriber` (Наблюдатель)**:
    - Реализует `update`, выводя полученные новости с именем подписчика.
5. **Клиент**:
    - Создает субъект и наблюдателей, подписывает их, публикует новости,
      отписывает одного наблюдателя.

**Вывод программы**:

```
Alice received news: Breaking: New discovery in space!
Bob received news: Breaking: New discovery in space!
Alice received news: Weather: Sunny all week!
```

### Преимущества:

- **Слабая связанность**: Субъект и наблюдатели не зависят друг от друга
  напрямую, взаимодействуя через интерфейсы.
- **Гибкость**: Наблюдатели могут добавляться или удаляться динамически.
- **Повторное использование**: Легко добавлять новых наблюдателей без изменения
  субъекта.
- **Поддержка событий**: Идеально для событийно-ориентированных систем.

### Недостатки:

- **Утечки памяти**: Если наблюдатели не отписываются, они могут оставаться в
  памяти.
- **Производительность**: Уведомление большого числа наблюдателей может быть
  затратным.
- **Сложность отладки**: Трудно отслеживать, какие наблюдатели получают
  уведомления и как они реагируют.
- **Асинхронность**: В многопоточных приложениях требуется синхронизация.

### Реальные примеры использования:

- **Java API**:
    - События в GUI (например, `ActionListener` в Swing или `OnClickListener` в
      Android).
    - `java.util.Observable` и `java.util.Observer` (устарели, но использовались
      для событий).
    - `java.beans.PropertyChangeListener` для отслеживания изменений свойств.
- **Библиотеки**:
    - RxJava: Реактивное программирование с использованием наблюдателей.
    - Spring: События через `ApplicationListener`.
- **Приложения**:
    - Обновление UI при изменении данных (например, в MVC).
    - Системы уведомлений (почта, мессенджеры).
    - Мониторинг изменений в базе данных или файлах.

### Важные замечания:

1. **Push vs Pull**:
    - В примере используется **push-модель** (субъект передает данные в
      `update`).
    - В **pull-модели** наблюдатель запрашивает данные у субъекта (например,
      через геттер).
2. **Потокобезопасность**: В многопоточных приложениях список наблюдателей и
   уведомления нужно синхронизировать (например, с `synchronized` или
   `CopyOnWriteArrayList`).
3. **Альтернативы**: Для сложных систем можно использовать библиотеки событий (
   EventBus, RxJava) или встроенные механизмы Java (например, `Flow API` для
   реактивного программирования).
4. **Отписка**: Важно предоставлять возможность отписки, чтобы избежать утечек
   памяти.

## Заместитель

**Паттерн Заместитель (Proxy)** — это структурный паттерн проектирования,
который предоставляет **объект-заместитель** (прокси) для другого объекта, чтобы
**контролировать доступ** к нему, добавить дополнительную логику или
оптимизировать взаимодействие. Прокси действует как посредник, перехватывая
вызовы к реальному объекту и выполняя предварительные или дополнительные
действия.

### Основные характеристики:

1. **Контроль доступа**: Прокси управляет доступом к реальному объекту (
   например, проверяет права или лениво инициализирует объект).
2. **Прозрачность**: Клиент работает с прокси так же, как с реальным объектом,
   благодаря общему интерфейсу.
3. **Дополнительная логика**: Прокси может выполнять действия до или после
   вызова методов реального объекта (например, логирование, кэширование).
4. **Типы прокси**:
    - **Виртуальный прокси**: Откладывает создание тяжелого объекта до его
      фактического использования (ленивая инициализация).
    - **Защитный прокси**: Контролирует доступ на основе прав или условий.
    - **Удаленный прокси**: Управляет взаимодействием с объектом в другой
      системе (например, через сеть).
    - **Кэширующий прокси**: Сохраняет результаты для оптимизации.

### Когда использовать:

- Когда нужно отложить создание дорогостоящего объекта (виртуальный прокси).
- Когда требуется ограничить доступ к объекту (защитный прокси).
- Когда нужно добавить логирование, кэширование или другие действия перед
  вызовом методов.
- Когда объект находится в другой системе, и нужно скрыть детали удаленного
  взаимодействия (удаленный прокси).
- Примеры: ленивая загрузка изображений, контроль доступа к ресурсам, работа с
  удаленными сервисами.

### Структура паттерна:

1. **Интерфейс `Subject`**: Общий интерфейс для реального объекта и прокси,
   чтобы клиент мог работать с ними одинаково.
2. **Реальный объект (Real Subject)**: Класс, выполняющий основную работу.
3. **Прокси (Proxy)**: Класс, который реализует тот же интерфейс, содержит
   ссылку на реальный объект и добавляет дополнительную логику.
4. **Клиент (Client)**: Работает с объектом через интерфейс, не зная, прокси это
   или реальный объект.

### Реализация в Java

Рассмотрим пример виртуального прокси для ленивой загрузки изображения. Прокси
загружает изображение только при первом обращении.

#### Пример: Ленивая загрузка изображения

```java
// Интерфейс Subject
interface Image {
    void display();
}

// Реальный объект
class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadImageFromDisk(); // Тяжелая операция
    }

    private void loadImageFromDisk() {
        System.out.println("Loading image: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

// Прокси
class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // Ленивая инициализация
        }
        realImage.display();
    }
}

// Тестовый класс
public class Main {
    public static void main(String[] args) {
        // Клиент работает с прокси
        Image image = new ProxyImage("photo.jpg");

        // Изображение загружается только при первом вызове
        image.display();
        // Повторный вызов не загружает изображение снова
        image.display();
    }
}
```

### Объяснение кода:

1. **Интерфейс `Image`**:
    - Определяет метод `display`, который должны реализовать реальный объект и
      прокси.
2. **Класс `RealImage` (Реальный объект)**:
    - Выполняет тяжелую операцию загрузки изображения при создании.
    - Реализует метод `display` для отображения изображения.
3. **Класс `ProxyImage` (Прокси)**:
    - Хранит имя файла и ссылку на `RealImage` (изначально `null`).
    - При вызове `display` проверяет, создан ли `RealImage`. Если нет, создает
      его (ленивая инициализация).
    - Делегирует вызов `display` реальному объекту.
4. **Клиент**:
    - Работает с `ProxyImage` через интерфейс `Image`, не зная, что это прокси.
    - Изображение загружается только при первом вызове `display`.

**Вывод программы**:

```
Loading image: photo.jpg
Displaying image: photo.jpg
Displaying image: photo.jpg
```

### Типы прокси (другие примеры):

1. **Защитный прокси**:
   ```java
   interface Database {
       void query(String user, String query);
   }

   class RealDatabase implements Database {
       @Override
       public void query(String user, String query) {
           System.out.println("Executing query: " + query);
       }
   }

   class ProxyDatabase implements Database {
       private RealDatabase realDatabase = new RealDatabase();
       private List<String> allowedUsers = List.of("admin", "manager");

       @Override
       public void query(String user, String query) {
           if (allowedUsers.contains(user)) {
               realDatabase.query(user, query);
           } else {
               System.out.println("Access denied for user: " + user);
           }
       }
   }
   ```
   Прокси проверяет права доступа перед выполнением запроса.

2. **Кэширующий прокси**:
   ```java
   class ProxyDatabase implements Database {
       private RealDatabase realDatabase = new RealDatabase();
       private Map<String, String> cache = new HashMap<>();

       @Override
       public void query(String user, String query) {
           if (cache.containsKey(query)) {
               System.out.println("Returning cached result for: " + query);
               return;
           }
           realDatabase.query(user, query);
           cache.put(query, "Result");
       }
   }
   ```
   Прокси кэширует результаты запросов для повышения производительности.

### Преимущества:

- **Контроль доступа**: Прокси может ограничивать доступ или проверять права.
- **Оптимизация**: Ленивая инициализация или кэширование экономят ресурсы.
- **Прозрачность**: Клиент не замечает разницы между прокси и реальным объектом.
- **Гибкость**: Легко добавить новую логику (логирование, мониторинг).

### Недостатки:

- **Дополнительный слой**: Прокси увеличивает сложность системы.
- **Задержки**: Дополнительная логика в прокси может замедлить выполнение.
- **Сложность тестирования**: Прокси может усложнить написание тестов, так как
  поведение зависит от его логики.

### Реальные примеры использования:

- **Java API**:
    - `java.lang.reflect.Proxy`: Динамические прокси для создания объектов,
      реализующих интерфейсы.
    - RMI (Remote Method Invocation): Удаленные прокси для вызова методов на
      другом JVM.
- **Библиотеки**:
    - Spring AOP: Прокси для реализации аспектов (например, логирование,
      транзакции).
    - Hibernate: Прокси для ленивой загрузки сущностей из базы данных.
- **Приложения**:
    - Ленивая загрузка ресурсов (например, изображения в браузере).
    - Контроль доступа в системах безопасности.
    - Кэширование данных в веб-приложениях.

### Важные замечания:

1. **Интерфейс**: Прокси и реальный объект должны реализовывать один интерфейс
   для прозрачной замены.
2. **Потокобезопасность**: В многопоточных приложениях прокси должен быть
   синхронизирован (например, для ленивой инициализации).
3. **Динамические прокси**: Java предоставляет `java.lang.reflect.Proxy` для
   создания прокси на лету, что полезно для универсальных решений.
4. **Сравнение с другими паттернами**:
    - **Фасад**: Упрощает интерфейс к подсистеме, но не контролирует доступ.
    - **Декоратор**: Добавляет функциональность, но не управляет созданием или
      доступом.
    - **Адаптер**: Изменяет интерфейс, а не добавляет контроль.

Если нужен пример другого типа прокси, разбор с динамическими прокси или
сравнение с другими паттернами, напишите!

## Шаблонный метод

**Паттерн Шаблонный метод (Template Method)** — это поведенческий паттерн
проектирования, который определяет **общий алгоритм** (шаблон) в суперклассе,
позволяя подклассам переопределять отдельные шаги этого алгоритма, не изменяя
его общей структуры. Он используется, когда есть общий процесс, но некоторые его
части могут варьироваться в зависимости от конкретной реализации.

### Основные характеристики:

1. **Фиксированный алгоритм**: Суперкласс определяет последовательность шагов (
   шаблон) в методе, который обычно помечен как `final`.
2. **Переопределяемые шаги**: Подклассы могут переопределять отдельные методы,
   реализующие конкретные шаги алгоритма.
3. **Инкапсуляция структуры**: Общая логика алгоритма остается в суперклассе,
   что обеспечивает повторное использование кода.
4. **Гибкость**: Подклассы изменяют только те части алгоритма, которые
   специфичны для них.

### Когда использовать:

- Когда есть общий алгоритм, но некоторые его шаги различаются в зависимости от
  контекста.
- Когда нужно избежать дублирования кода, вынося общую логику в суперкласс.
- Когда подклассы должны следовать фиксированной структуре алгоритма, но могут
  настраивать детали.
- Примеры: обработка данных, рендеринг документов, выполнение транзакций.

### Структура паттерна:

1. **Абстрактный класс (Abstract Class)**: Определяет шаблонный метод (основной
   алгоритм) и абстрактные методы для шагов, которые должны реализовать
   подклассы.
2. **Шаблонный метод**: Метод в суперклассе, содержащий последовательность
   вызовов шагов алгоритма. Обычно `final`, чтобы подклассы не могли его
   изменить.
3. **Конкретные классы (Concrete Classes)**: Подклассы, реализующие абстрактные
   методы для конкретных шагов.
4. **Клиент**: Вызывает шаблонный метод, не заботясь о деталях реализации.

### Реализация в Java

Рассмотрим пример, где шаблонный метод описывает процесс приготовления напитка (
например, чая или кофе). Общий алгоритм одинаков, но некоторые шаги различаются.

#### Пример: Приготовление напитка

```java
// Абстрактный класс с шаблонным методом
abstract class BeverageMaker {
    // Шаблонный метод, определяющий алгоритм
    public final void prepareBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    // Общие шаги, реализованные в суперклассе
    private void boilWater() {
        System.out.println("Boiling water");
    }

    private void pourInCup() {
        System.out.println("Pouring into cup");
    }

    // Абстрактные шаги, которые должны реализовать подклассы
    abstract void brew();

    abstract void addCondiments();

    // Хук (опциональный метод с реализацией по умолчанию)
    boolean customerWantsCondiments() {
        return true;
    }
}

// Конкретный класс для чая
class TeaMaker extends BeverageMaker {
    @Override
    void brew() {
        System.out.println("Steeping the tea");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding lemon");
    }

    // Переопределяем хук, чтобы отключить добавление специй
    @Override
    boolean customerWantsCondiments() {
        return false;
    }
}

// Конкретный класс для кофе
class CoffeeMaker extends BeverageMaker {
    @Override
    void brew() {
        System.out.println("Dripping coffee through filter");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding sugar and milk");
    }
}

// Тестовый класс
public class Main {
    public static void main(String[] args) {
        System.out.println("Making tea:");
        BeverageMaker tea = new TeaMaker();
        tea.prepareBeverage();

        System.out.println("\nMaking coffee:");
        BeverageMaker coffee = new CoffeeMaker();
        coffee.prepareBeverage();
    }
}
```

### Объяснение кода:

1. **Абстрактный класс `BeverageMaker`**:
    - Метод `prepareBeverage` — шаблонный метод, определяющий алгоритм
      приготовления напитка: кипячение воды, заваривание, наливание в чашку и (
      опционально) добавление специй.
    - Помечен как `final`, чтобы подклассы не могли изменить порядок шагов.
    - Содержит общие методы (`boilWater`, `pourInCup`) и абстрактные методы (
      `brew`, `addCondiments`).
    - Метод `customerWantsCondiments` — **хук**, который подклассы могут
      переопределить для настройки поведения.
2. **Конкретные классы**:
    - `TeaMaker`: Реализует заваривание чая и добавление лимона. Отключает
      специи через хук.
    - `CoffeeMaker`: Реализует заваривание кофе и добавление сахара с молоком.
3. **Клиент**:
    - Вызывает `prepareBeverage` для создания разных напитков, не зная деталей
      реализации.

**Вывод программы**:

```
Making tea:
Boiling water
Steeping the tea
Pouring into cup

Making coffee:
Boiling water
Dripping coffee through filter
Pouring into cup
Adding sugar and milk
```

### Преимущества:

- **Повторное использование кода**: Общая логика вынесена в суперкласс, что
  уменьшает дублирование.
- **Фиксированная структура**: Гарантирует, что подклассы следуют заданному
  алгоритму.
- **Гибкость**: Подклассы могут настраивать отдельные шаги.
- **Легкость расширения**: Новые реализации добавляются через создание
  подклассов.

### Недостатки:

- **Жесткость структуры**: Изменить порядок шагов в алгоритме можно только через
  изменение суперкласса.
- **Ограниченная гибкость**: Подходит только для случаев, когда структура
  алгоритма фиксирована.
- **Наследование**: Требует создания подклассов, что может быть неудобно, если
  предпочтительнее композиция.

### Реальные примеры использования:

- **Java API**:
    - `java.util.AbstractList`, `java.util.AbstractMap`: Абстрактные классы с
      шаблонными методами, где подклассы реализуют конкретные операции.
    - `javax.servlet.http.HttpServlet`: Метод `service` как шаблонный метод,
      вызывающий `doGet`, `doPost` и т.д., которые переопределяются в
      подклассах.
- **Библиотеки**:
    - Spring: `AbstractController` определяет шаблон для обработки
      HTTP-запросов.
    - Hibernate: Шаблонные методы для управления жизненным циклом сессий.
- **Приложения**:
    - Обработка файлов: Общий алгоритм (открыть, прочитать, закрыть), но разные
      форматы (XML, JSON).
    - Игры: Шаблон для игрового цикла (инициализация, обновление, рендеринг).
    - Тестирование: Шаблон для тестов (setUp, test, tearDown).

### Важные замечания:

1. **Хуки**: Методы с реализацией по умолчанию (как `customerWantsCondiments`)
   позволяют подклассам настраивать поведение без обязательного переопределения.
2. **Модификаторы доступа**: Шаги алгоритма, не предназначенные для
   переопределения, можно сделать `private` или `final`.
3. **Сравнение с другими паттернами**:
    - **Стратегия**: Позволяет полностью заменить алгоритм, а не отдельные шаги,
      и использует композицию вместо наследования.
    - **Фабричный метод**: Фокусируется на создании объектов, а не на
      алгоритмах.
4. **Потокобезопасность**: Если шаблонный метод используется в многопоточной
   среде, нужно учитывать синхронизацию.

Если нужен пример для другого сценария, разбор с хуками или сравнение с другими
паттернами, напишите!