# Заместитель (Proxy)

**Паттерн Proxy (Заместитель)** — это структурный паттерн проектирования,
который предоставляет объект-заместитель (прокси) для управления доступом к
другому объекту, добавляя дополнительную функциональность, такую как ленивая
инициализация, контроль доступа, логирование или кэширование, без изменения
исходного объекта. Прокси действует как посредник между клиентом и реальным
объектом.

### **Описание паттерна**

**Цель**:

- Контролировать доступ к объекту, добавляя промежуточный слой.
- Отложить создание или выполнение операций до момента, когда они действительно
  нужны.
- Предоставить дополнительную функциональность (например, проверку прав,
  кэширование).

**Когда использовать**:

- Когда нужно отложить создание дорогостоящего объекта до его фактического
  использования (ленивая инициализация).
- Когда требуется ограничить доступ к объекту (например, проверка прав).
- Когда нужно логировать операции или кэшировать результаты.
- Когда требуется управлять доступом к удалённым объектам (например, в
  распределённых системах).

**Примеры использования**:

- Ленивая загрузка данных (например, изображений в приложении).
- Проверка прав доступа перед вызовом методов сервиса.
- Прокси для удалённых объектов (например, RMI в Java).
- Кэширование результатов операций.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/proxy_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Интерфейс сервиса определяет общий интерфейс для сервиса и заместителя.
   Благодаря этому, объект заместителя можно использовать там, где ожидается
   объект сервиса.
2. Сервис содержит полезную бизнес-логику.
3. Заместитель хранит ссылку на объект сервиса. После того как заместитель
   заканчивает свою работу (например, инициализацию, логирование, защиту или
   другое), он передаёт вызовы вложенному сервису. Заместитель может сам
   отвечать за создание и удаление объекта сервиса.
4. Клиент работает с объектами через интерфейс сервиса. Благодаря этому, его
   можно «одурачить», подменив объект сервиса объектом заместителя.

### **Типы прокси**

1. **Виртуальный прокси**: Откладывает создание реального объекта до момента его
   использования (ленивая инициализация).
2. **Защитный прокси**: Контролирует доступ к объекту (например, проверяет
   права).
3. **Удалённый прокси**: Управляет доступом к объекту, расположенному в другом
   адресном пространстве (например, в распределённых системах).
4. **Кэширующий прокси**: Сохраняет результаты операций для повторного
   использования.
5. **Логирующий прокси**: Добавляет логирование вызовов методов.

### **Реализация в Java**

Пример: виртуальный прокси для ленивой загрузки изображения.

```java
// Интерфейс субъекта
interface Image {
    void display();
}

// Реальный объект
class RealImage implements Image {
    private final String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadImageFromDisk();
    }

    private void loadImageFromDisk() {
        System.out.println("Loading image: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

// Прокси
class ProxyImage implements Image {
    private RealImage realImage;
    private final String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // Ленивая инициализация
        }
        realImage.display();
    }
}

// Клиентский код
public class ProxyExample {
    public static void main(String[] args) {
        Image image = new ProxyImage("photo.jpg");

        // Изображение загружается только при первом вызове
        image.display();
        // Вывод:
        // Loading image: photo.jpg
        // Displaying image: photo.jpg

        // При повторном вызове загрузка не происходит
        image.display();
        // Вывод:
        // Displaying image: photo.jpg
    }
}
```

### **Как это работает**

1. Клиент работает с прокси (`ProxyImage`) через интерфейс `Image`, не зная, что
   это не реальный объект.
2. Прокси создаёт реальный объект (`RealImage`) только при первом вызове метода
   `display` (ленивая инициализация).
3. Последующие вызовы используют уже созданный объект, избегая повторной
   загрузки.

### **Реальное использование в Java**

1. **Java RMI (Remote Method Invocation)**:
   RMI использует удалённый прокси для доступа к объектам на другом JVM:
   ```java
   import java.rmi.Remote;
   import java.rmi.RemoteException;

   public interface MyRemote extends Remote {
       String sayHello() throws RemoteException;
   }
   ```
   Прокси-объект, созданный RMI, управляет сетевыми вызовами.

2. **Spring AOP**:
   Spring использует прокси для добавления сквозной функциональности, например,
   транзакций или логирования:
   ```java
   @Service
   class MyService {
       @Transactional
       public void doWork() { /* Логика */ }
   }
   ```
   Spring создаёт прокси, который оборачивает метод `doWork` транзакционной
   логикой.

3. **Hibernate Lazy Loading**:
   В Hibernate прокси используются для ленивой загрузки сущностей:
   ```java
   @Entity
   class User {
       @OneToMany(fetch = FetchType.LAZY)
       private List<Order> orders;
   }
   ```
   Hibernate создаёт прокси для коллекции `orders`, загружая данные только при
   обращении.

4. **Dynamic Proxy API**:
   Java предоставляет `java.lang.reflect.Proxy` для создания динамических
   прокси:
   ```java
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.Proxy;

   interface Service {
       void perform();
   }

   class RealService implements Service {
       public void perform() { System.out.println("Performing service"); }
   }

   class LoggingHandler implements InvocationHandler {
       private final Object target;

       public LoggingHandler(Object target) { this.target = target; }

       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("Before: " + method.getName());
           Object result = method.invoke(target, args);
           System.out.println("After: " + method.getName());
           return result;
       }
   }

   Service service = (Service) Proxy.newProxyInstance(
           Service.class.getClassLoader(),
           new Class[]{Service.class},
           new LoggingHandler(new RealService())
   );
   service.perform();
   // Вывод:
   // Before: perform
   // Performing service
   // After: perform
   ```

### **Преимущества**

- **Контроль доступа**: Прокси может проверять права или ограничивать операции.
- **Ленивая инициализация**: Экономит ресурсы, откладывая создание объекта.
- **Дополнительная функциональность**: Легко добавить логирование, кэширование
  или проверку.
- **Прозрачность**: Клиент работает с прокси, как с реальным объектом.
- **Изоляция**: Скрывает детали реализации подсистемы.

### **Недостатки**

- **Дополнительный слой**: Прокси добавляет сложность в архитектуру.
- **Задержки**: Ленивая инициализация может вызвать задержки при первом вызове.
- **Сложность отладки**: Прокси может затруднить отслеживание вызовов.
- **Ограничение интерфейса**: Прокси должен соответствовать интерфейсу реального
  объекта, что ограничивает добавление новых методов.

### **Отличие от других паттернов**

- **Proxy vs Decorator**:
    - **Proxy** управляет доступом или жизненным циклом объекта (например,
      ленивая инициализация).
    - **Decorator** добавляет новое поведение, сохраняя тот же интерфейс.
- **Proxy vs Adapter**:
    - **Proxy** работает с тем же интерфейсом, что и реальный объект, добавляя
      функциональность.
    - **Adapter** преобразует интерфейс одного класса в другой.
- **Proxy vs Facade**:
    - **Proxy** управляет доступом к одному объекту.
    - **Facade** упрощает интерфейс к целой подсистеме.

### **Проблемы и антипаттерны**

1. **Слишком сложный прокси**: Если прокси выполняет слишком много функций, он
   может стать трудно поддерживаемым.
    - **Решение**: Ограничивайте прокси одной задачей (например, только ленивая
      инициализация).
2. **Утечки ресурсов**: Ленивая инициализация может привести к созданию объектов
   в неподходящий момент.
    - **Решение**: Тестируйте прокси в сценариях с высокой нагрузкой.
3. **Нарушение прозрачности**: Если прокси изменяет поведение реального объекта,
   это может вызвать ошибки.
    - **Решение**: Убедитесь, что прокси строго следует интерфейсу субъекта.

### **Современные альтернативы в Java**

- **Spring AOP и Proxy**:
  Spring автоматически создаёт прокси для добавления сквозной функциональности (
  транзакции, логирование):
  ```java
  @Transactional
  public void saveData() { /* Логика */ }
  ```
- **Dynamic Proxy**:
  Использование `java.lang.reflect.Proxy` для динамического создания прокси (см.
  пример выше).
- **Bytecode Manipulation**:
  Библиотеки, такие как CGLIB, создают прокси на уровне байт-кода, что
  используется в Spring и Hibernate.
- **Functional Wrappers**:
  В Java 8+ можно использовать лямбда-выражения для обёртывания вызовов:
  ```java
  Function<String, String> loggingProxy = input -> {
      System.out.println("Processing: " + input);
      return input.toUpperCase();
  };
  ```

### **Итог**

Паттерн Proxy — это мощный инструмент для управления доступом к объектам,
добавления функциональности и оптимизации ресурсов. В Java он широко
используется в стандартной библиотеке (RMI), фреймворках (Spring, Hibernate) и
для реализации ленивой загрузки или кэширования. Прокси обеспечивает
прозрачность и гибкость, но требует осторожности, чтобы не усложнить
архитектуру. В современных приложениях динамические прокси и AOP часто заменяют
ручную реализацию.

