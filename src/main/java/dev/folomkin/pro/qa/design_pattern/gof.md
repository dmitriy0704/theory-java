# Паттерны проектирования

Популярные:

1. Одиночка (Singleton)
2. Фабричный метод (Factory Method)
3. Абстрактная фабрика ( Abstract Factory)
4. Декоратор (Decorator)
5. Наблюдатель (Observer)
6. Стратегия (Strategy)

Дополнительно:

1. Прототип (Prototype)
2. Строитель (Builder)
3. Фасад (Facade)
4. Заместитель (Proxy)
5. Шаблонный метод(Template Method)
6. Итератор(Iterator)

---

### 1. **Порождающие паттерны** (Creational Patterns)

Отвечают за создание объектов, упрощая их инициализацию и управление.

- **Фабричный метод (Factory Method)**: — это порождающий паттерн
  проектирования, который определяет общий интерфейс для создания объектов в
  суперклассе, позволяя подклассам изменять тип создаваемых объектов.
- **Абстрактная фабрика (Abstract Factory)**: — это
  порождающий паттерн проектирования, который позволяет создавать семейства
  связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
- **Строитель (Builder)**: — это порождающий паттерн проектирования,
  который позволяет создавать сложные объекты пошагово. Строитель даёт
  возможность использовать один и тот же код строительства для получения разных
  представлений объектов.
- **Одиночка (Singleton)**: — это порождающий паттерн проектирования,
  который гарантирует, что у класса есть только один экземпляр, и предоставляет
  к нему глобальную точку доступа.
- **Прототип (Prototype)**: — это порождающий паттерн проектирования,
  который позволяет копировать объекты, не вдаваясь в подробности их реализации.

### 2. **Структурные паттерны** (Structural Patterns)

Определяют, как объекты и классы объединяются в более крупные структуры.

- **Адаптер (Adapter)**: — это структурный паттерн проектирования, который
  позволяет объектам с несовместимыми интерфейсами работать вместе.
  Преобразует интерфейс одного класса в интерфейс,
  ожидаемый клиентом. Пример: адаптация старого API к новому.
- **Мост (Bridge)**: Разделяет абстракцию и реализацию, позволяя изменять их
  независимо. Пример: разделение логики рисования фигур и их рендеринга.
- **Компоновщик (Composite)**: Объединяет объекты в древовидные структуры для
  работы с ними как с единым объектом. Пример: структура GUI-компонентов.
- **Декоратор (Decorator)**: Динамически добавляет обязанности объекту. Пример:
  добавление функционала к потоку ввода-вывода.
- **Фасад (Facade)**: Предоставляет упрощенный интерфейс к сложной подсистеме.
  Пример: упрощение работы с библиотекой.
- **Легковес (Flyweight)**: Экономит память, разделяя состояние объектов.
  Пример: повторное использование символов в текстовом редакторе.
- **Заместитель (Proxy)**: Контролирует доступ к объекту, добавляя
  дополнительную логику. Пример: ленивая загрузка изображений.

### 3. **Поведенческие паттерны** (Behavioral Patterns)

Регулируют взаимодействие и распределение обязанностей между объектами.

- **Цепочка обязанностей (Chain of Responsibility)**: Передает запрос по цепочке
  обработчиков. Пример: обработка событий в GUI.
- **Команда (Command)**: Инкапсулирует запрос как объект, позволяя передавать
  его как параметр. Пример: реализация операций "отмена/повтор".
- **Итератор (Iterator)**: Предоставляет способ последовательного доступа к
  элементам коллекции. Пример: обход списка или массива.
- **Посредник (Mediator)**: Упрощает взаимодействие между объектами, централизуя
  управление. Пример: чат между пользователями.
- **Снимок (Memento)**: Сохраняет состояние объекта для последующего
  восстановления. Пример: сохранение состояния игры.
- **Наблюдатель (Observer)**: Определяет зависимость "один ко многим", уведомляя
  объекты об изменениях. Пример: подписка на события.
- **Состояние (State)**: Позволяет объекту изменять поведение в зависимости от
  состояния. Пример: автомат с напитками.
- **Стратегия (Strategy)**: Определяет семейство алгоритмов и позволяет их
  взаимозаменяемость. Пример: сортировка разными алгоритмами.
- **Шаблонный метод (Template Method)**: Определяет скелет алгоритма, позволяя
  подклассам переопределять шаги. Пример: процесс обработки данных.
- **Посетитель (Visitor)**: Разделяет алгоритм от структуры данных, позволяя
  добавлять новые операции. Пример: обход дерева объектов.

### Примечания:

- Эти паттерны описаны в книге "Design Patterns" (Gang of Four) и широко
  применяются в Java.
- В Java некоторые паттерны реализуются проще благодаря встроенным механизмам (
  например, `Iterator` в коллекциях или `Observer` в `java.util.Observable`).
- Выбор паттерна зависит от задачи: изучайте контекст и проблему, чтобы избежать
  избыточной сложности.

---

# ПОДРОБНО

## 1. **Singleton (Одиночка)**

**Паттерн Singleton (Одиночка)** — это порождающий паттерн проектирования,
который гарантирует, что у класса есть только один экземпляр, и предоставляет
глобальную точку доступа к этому экземпляру. Он часто используется в ситуациях,
когда требуется единый доступ к ресурсу или состоянию, например, для логгеров,
конфигураций или пулов соединений.

### **Описание паттерна**

**Когда использовать**:

- Необходим ровно один экземпляр класса (например, для управления доступом к
  общему ресурсу).
- Требуется глобальная точка доступа (например, для логгера или конфигурации).
- Создание нескольких экземпляров дорого или нежелательно.
- Логгер (`java.util.logging.Logger` или `SLF4J`).
- Пул соединений с базой данных.
- Кэш или конфигурация приложения.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/singleton_structure.png" alt="singleton" style="width:100%; max-width: 550px">

1. Одиночка определяет статический метод getInstance,
   который возвращает единственный экземпляр своего
   класса.<br>
   Конструктор одиночки должен быть скрыт от клиентов.
   Вызов метода getInstance должен стать единственным
   способом получить объект этого класса.

### **Реализация в Java**

Существует несколько способов реализации Singleton в Java, каждый с учётом
потокобезопасности и производительности. Рассмотрим основные варианты.

#### Двойная проверка блокировки (Double-Checked Locking)

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**Плюсы**: Потокобезопасен, минимизирует накладные расходы синхронизации.  
**Особенности**: Ключевое слово `volatile` предотвращает проблемы с частичной
инициализацией объекта в многопоточной среде.

### **Пример реального использования**

Допустим, нам нужен логгер, который используется во всём приложении:

```java
public class Logger {
    private static final Logger instance = new Logger();

    private Logger() {
    }

    public static Logger getInstance() {
        return instance;
    }

    public void log(String message) {
        System.out.println("Log: " + message);
    }
}

public class Application {
    public static void main(String[] args) {
        Logger logger = Logger.getInstance();
        logger.log("Application started");
    }
}
```

### **Проблемы и антипаттерны**

Паттерн **Singleton (Одиночка)** решает ряд проблем, связанных с управлением
ресурсами и доступом к объектам в приложении. Он обеспечивает наличие только
одного экземпляра класса и предоставляет глобальную точку доступа к нему. Вот
основные проблемы, которые решает этот паттерн:

### 1. **Гарантия единственного экземпляра объекта**

- **Проблема**: В некоторых случаях требуется, чтобы в приложении существовал
  только один экземпляр определённого объекта, например, для управления общим
  ресурсом (конфигурация, логгер, пул соединений). Множественные экземпляры
  могут привести к конфликтам, неэффективному использованию ресурсов или
  непредсказуемому поведению.
- **Решение**: Singleton гарантирует, что создаётся и используется только один
  экземпляр класса. Это достигается через приватный конструктор и статический
  метод доступа (`getInstance()`).
- **Пример**: Логгер приложения (`SLF4J` или `java.util.logging.Logger`) должен
  быть единым, чтобы все записи логов писались в один файл или поток.

### 2. **Глобальная точка доступа**

- **Проблема**: Некоторые объекты должны быть доступны из разных частей
  приложения без необходимости передавать их экземпляры через параметры или
  зависимости. Без единой точки доступа это может привести к сложностям в
  управлении или дублированию кода.
- **Решение**: Singleton предоставляет статический метод (`getInstance()`),
  через который любой компонент приложения может получить доступ к единственному
  экземпляру.
- **Пример**: Конфигурация приложения (например, настройки базы данных) может
  быть доступна через Singleton, чтобы любой модуль мог её использовать.

### 3. **Экономия ресурсов**

- **Проблема**: Создание нескольких экземпляров объекта, особенно если он
  требует значительных ресурсов (например, подключение к базе данных или
  загрузка большого файла конфигурации), может быть дорогостоящим по памяти и
  времени.
- **Решение**: Singleton позволяет создать объект один раз и переиспользовать
  его, минимизируя затраты ресурсов. Ленивая инициализация (lazy initialization)
  дополнительно откладывает создание до первого обращения.
- **Пример**: Пул соединений с базой данных создаётся один раз и используется
  всеми частями приложения.

### 4. **Управление общим состоянием**

- **Проблема**: Некоторые объекты должны хранить общее состояние, доступное всем
  компонентам приложения, например, счётчик запросов или кэш данных.
  Множественные экземпляры могут привести к рассинхронизации состояния.
- **Решение**: Singleton обеспечивает единое место для хранения и управления
  общим состоянием, гарантируя, что все компоненты работают с одними и теми же
  данными.
- **Пример**: Кэш данных, где все запросы к внешнему API сохраняются в одном
  месте для повторного использования.

### 5. **Упрощение взаимодействия с подсистемами**

- **Проблема**: Взаимодействие с подсистемами, которые требуют единой точки
  управления (например, диспетчер событий или менеджер ресурсов), может быть
  сложным, если каждый компонент создаёт свои экземпляры.
- **Решение**: Singleton предоставляет централизованную точку управления,
  упрощая координацию и взаимодействие.
- **Пример**: Менеджер событий в GUI-приложении, который распределяет события
  между компонентами, должен быть единым.

### **Конкретные примеры в Java**

- **Логгеры**: Классы, такие как `java.util.logging.Logger` или
  `org.slf4j.Logger`, часто реализуются как Singleton (или с аналогичным
  поведением), чтобы все логи писались в один поток.
- **Пулы соединений**: Объекты, управляющие соединениями с базой данных (
  например, `DataSource` в JDBC), используют Singleton для управления единым
  пулом.
- **Конфигурации**: Классы, хранящие настройки приложения (например,
  `Properties` или пользовательские конфигурации), часто делают Singleton, чтобы
  избежать дублирования.

### **Дополнительные аспекты**

- **Потокобезопасность**: В многопоточных приложениях Singleton решает проблему
  создания нескольких экземпляров, используя механизмы синхронизации или ленивую
  инициализацию (например, `double-checked locking` или
  `Initialization-on-demand Holder`).
    - **Пример**:
      ```java
      public class Singleton {
          private static volatile Singleton instance;
  
          private Singleton() {}
  
          public static Singleton getInstance() {
              if (instance == null) {
                  synchronized (Singleton.class) {
                      if (instance == null) {
                          instance = new Singleton();
                      }
                  }
              }
              return instance;
          }
      }
      ```

- **Сериализация и рефлексия**: Singleton решает проблемы, связанные с
  сохранением единственности экземпляра при сериализации или использовании
  рефлексии, через специальные методы (например, `readResolve`) или
  enum-реализацию.
    - **Пример с enum**:
      ```java
      public enum Singleton {
          INSTANCE;
          public void doSomething() { /* Логика */ }
      }
      ```

### **Проблемы, которые НЕ решает Singleton**

- **Тестирование**: Singleton может усложнить тестирование, так как его
  глобальное состояние сохраняется между тестами.
- **Гибкость**: Singleton фиксирует единственный экземпляр, что может быть
  ограничивающим, если в будущем потребуется несколько экземпляров.
- **Антипаттерны**: Неправильное использование (например, для хранения
  изменяемого состояния) может привести к проблемам, таким как скрытые
  зависимости или трудно отслеживаемые ошибки.

### **Современные альтернативы**

В современных Java-приложениях Singleton часто заменяется другими подходами,
которые решают те же проблемы, но с большей гибкостью:

- **Dependency Injection (DI)**: Фреймворки, такие как Spring, создают и
  управляют единственным экземпляром объекта (scope `singleton`), передавая его
  через зависимости.
    - **Пример**:
      ```java
      @Component
      class Logger {
          public void log(String message) { /* Логика */ }
      }
  
      @Autowired
      private Logger logger; // Spring обеспечивает единственный экземпляр
      ```
- **Статические утилитные классы**: Для простых случаев, где не требуется
  состояние, можно использовать статические методы вместо Singleton.
- **Фабрики**: Для управления ресурсами можно использовать Factory Method или
  Abstract Factory, предоставляя больше контроля над созданием объектов.

### **Итог**

Паттерн Singleton решает проблемы, связанные с необходимостью единственного
экземпляра объекта, глобального доступа, экономии ресурсов и управления общим
состоянием. Он особенно полезен для логгеров, пулов соединений, кэшей и
конфигураций. Однако его следует использовать с осторожностью, чтобы избежать
антипаттернов, таких как скрытые зависимости или сложности с тестированием. В
современных приложениях Dependency Injection часто является более гибкой
альтернативой.

Если вам нужен пример реализации для конкретной задачи, разбор проблем с
Singleton в вашем проекте или сравнение с другими подходами, напишите!

### **Современные альтернативы в Java**

В современных Java-приложениях Singleton часто заменяется другими подходами:

- **Dependency Injection**: Фреймворки, такие как Spring, создают и управляют
  единственным экземпляром объекта (например, `@Bean` с областью `singleton`).
  ```java
  @Component
  public class Logger {
      public void log(String message) {
          System.out.println("Log: " + message);
      }
  }
  ```
  Spring гарантирует, что `Logger` будет единственным экземпляром.
- **Enum Singleton**: Использование перечислений для реализации Singleton (по
  Джошуа Блоху).
  ```java
  public enum Singleton {
      INSTANCE;

      public void doSomething() {
          System.out.println("Doing something");
      }
  }
  ```
  **Плюсы**: Простота, потокобезопасность, защита от рефлексии и сериализации.

### **Преимущества Singleton**

- Гарантирует единственный экземпляр.
- Упрощает доступ к общему ресурсу.
- Ленивая инициализация (в некоторых реализациях) экономит ресурсы.

### **Недостатки Singleton**

- Может привести к скрытым зависимостям.
- Усложняет модульное тестирование.
- Потенциальные проблемы в многопоточной среде.
- Нарушение принципа единственной ответственности, если Singleton выполняет
  слишком много функций.

### **Когда НЕ использовать Singleton**

- Если класс имеет изменяемое состояние, которое должно быть независимым для
  разных контекстов.
- Когда требуется несколько экземпляров в будущем (Singleton трудно
  переработать).
- В тестах, где нужно подменять реализацию (лучше использовать DI).

### **Итог**

Singleton — это мощный и популярный паттерн, особенно в Java, благодаря своей
простоте и встроенной поддержке в языке (например, статические поля). Однако его
следует использовать с осторожностью, чтобы избежать антипаттернов. В
современных приложениях часто предпочтительнее использовать Dependency Injection
через фреймворки, такие, как Spring, или enum-реализацию для простых случаев.

---

## 2.1 Фабричный метод

Фабричный метод — это порождающий паттерн проектирования, который определяет
общий интерфейс для создания объектов в суперклассе, позволяя подклассам
изменять тип создаваемых объектов.

**Паттерн Factory Method (Фабричный метод)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания объектов в
суперклассе, позволяя подклассам определять, какой конкретный класс создавать.
Он помогает делегировать процесс создания объектов подклассам, обеспечивая
гибкость и расширяемость.

### **Описание паттерна**

**Цель**:

- Определить интерфейс для создания объектов, позволяя подклассам решать, какой
  класс создавать.
- Изолировать процесс создания объектов от их использования.

**Когда использовать**:

- Когда заранее неизвестно, какие именно объекты нужно создавать.
- Когда вы хотите предоставить подклассам возможность определять создаваемые
  объекты.
- Когда нужно обеспечить расширяемость системы для добавления новых типов
  объектов.

**Примеры использования**:

- Создание различных реализаций соединений с базой данных
  (`java.sql.DriverManager`).
- Генерация документов разных форматов (PDF, Word).
- Создание UI-компонентов, зависящих от платформы (Windows, macOS).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/factory_method_structure.png" alt="factory_method" width="100%" style="max-width: 550px">

1. **Продукт (Product)**: общий интерфейс объектов, которые может произвести
   создатель и его подклассы.
2. **Конкретный продукт (Concrete Product)**: содержит код различных продуктов.
   Продукты будут отличаться реализацией, но интерфейс у них будет общий.
3. **Создатель (Creator)**: Абстрактный класс или интерфейс, содержащий
   фабричный метод (обычно абстрактный). <br>
   Создатель объявляет фабричный метод, который должен возвращать новые объекты
   продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом
   продуктов.<br>
   Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы
   реализовать его по-своему. Но он может возвращать и некий стандартный
   продукт.<br>
   Несмотря на название, важно понимать, что создание продуктов не является
   единственной функцией создателя. Обычно он содержит и другой полезный код
   работы с продуктом. Аналогия: большая софтверная компания может иметь центр
   подготовки программистов, но основная задача компании — создавать программные
   продукты, а не готовить программистов.
4. **Конкретный создатель (Concrete Creator)**: Подклассы, реализующие фабричный
   метод для создания конкретных продуктов.

### **Реализация в Java**

Ниже приведён пример реализации паттерна Factory Method для создания
транспортных средств (например, автомобилей и мотоциклов).

```java
// Интерфейс продукта
interface Vehicle {
    void drive();
}

// Конкретные продукты
class Car implements Vehicle {
    public void drive() {
        System.out.println("Driving a car");
    }
}

class Motorcycle implements Vehicle {
    public void drive() {
        System.out.println("Riding a motorcycle");
    }
}

// Абстрактный создатель
abstract class VehicleFactory {
    // Фабричный метод переопределяется в подклассах, 
    // чтобы изменить тип создаваемого продукта
    public abstract Vehicle createVehicle();

    // Метод, использующий фабричный метод
    public void deliverVehicle() {
        Vehicle vehicle = createVehicle();
        vehicle.drive();
    }
}

// Конкретные создатели
class CarFactory extends VehicleFactory {
    public Vehicle createVehicle() {
        return new Car();
    }
}

class MotorcycleFactory extends VehicleFactory {
    public Vehicle createVehicle() {
        return new Motorcycle();
    }
}

// Клиентский код
public class FactoryMethodExample {
    public static void main(String[] args) {
        VehicleFactory carFactory = new CarFactory();
        carFactory.deliverVehicle(); // Вывод: Driving a car

        VehicleFactory motorcycleFactory = new MotorcycleFactory();
        motorcycleFactory.deliverVehicle(); // Вывод: Riding a motorcycle
    }
}
```

### **Как это работает**

1. Клиент работает с абстрактным классом `VehicleFactory` и вызывает метод
   `deliverVehicle()`.
2. Конкретные фабрики (`CarFactory`, `MotorcycleFactory`) реализуют
   `createVehicle()`, возвращая нужный объект (`Car` или `Motorcycle`).
3. Клиент не знает, какой конкретный класс создаётся, что делает код гибким и
   независимым от конкретных реализаций.

### **Преимущества**

- **Гибкость**: Легко добавить новый тип продукта, создав новый подкласс фабрики
  и продукта.
- **Соответствие принципу Open/Closed**: Система открыта для расширения (новые
  продукты), но закрыта для модификации.
- **Изоляция**: Клиентский код работает с абстракциями, а не с конкретными
  классами.
- **Упрощение тестирования**: Можно подменять реализации продуктов в тестах.

### **Недостатки**

- **Усложнение кода**: Для каждого нового продукта нужно создавать новый класс
  фабрики.
- **Дополнительные классы**: Может увеличить количество классов в проекте.

### **Пример реального использования в Java**

В стандартной библиотеке Java паттерн Factory Method встречается, например, в
`java.util.Calendar`:

```java
Calendar calendar = Calendar.getInstance(); // Фабричный метод
```

- `getInstance()` возвращает конкретную реализацию `Calendar` (например,
  `GregorianCalendar`) в зависимости от локали и конфигурации.
- Клиент не знает, какой конкретный класс возвращается, но может работать с
  абстрактным интерфейсом.

Другой пример — Spring Framework:

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
MyBean bean = context.getBean(MyBean.class);
```

`ApplicationContext` действует как фабрика, создавая объекты (beans) на основе
конфигурации.

### **Проблемы и антипаттерны**

Паттерн **Factory Method (Фабричный метод)** — это порождающий паттерн
проектирования, который решает ряд проблем, связанных с созданием объектов,
предоставляя гибкий и расширяемый способ их instantiation. Он позволяет
делегировать создание объектов подклассам, обеспечивая независимость клиентского
кода от конкретных классов. Вот основные проблемы, которые решает этот паттерн:

### 1. **Создание объектов без привязки к конкретным классам**

- **Проблема**: Клиентский код, создающий объекты напрямую с помощью `new`,
  становится зависимым от их конкретных классов. Это усложняет замену или
  добавление новых типов объектов без изменения кода.
- **Решение**: Factory Method определяет абстрактный метод для создания объектов
  в суперклассе, а подклассы решают, какой конкретный класс создавать. Клиент
  работает с абстрактным интерфейсом, а не с конкретными классами.
- **Пример**: В приложении для обработки документов клиентский код может
  создавать документы (`PDFDocument`, `WordDocument`) через фабричный метод, не
  зная их конкретных реализаций.
  ```java
  abstract class DocumentFactory {
      public abstract Document createDocument();
  }

  class PdfFactory extends DocumentFactory {
      @Override
      public Document createDocument() {
          return new PdfDocument();
      }
  }
  ```

### 2. **Упрощение добавления новых типов объектов**

- **Проблема**: Если система должна поддерживать новые типы объектов, добавление
  их требует изменения существующего кода (например, добавления новых условий в
  `if-else` или `switch` для создания объектов), что нарушает принцип
  Open/Closed (открытость для расширения, закрытость для модификации).
- **Решение**: Factory Method позволяет добавлять новые типы объектов, просто
  создавая новый подкласс фабрики, реализующий абстрактный метод создания.
  Клиентский код остаётся неизменным.
- **Пример**: В игре для создания разных типов врагов (например, `Soldier`,
  `Wizard`) достаточно добавить новый подкласс фабрики (`WizardFactory`), не
  меняя логику игры.

### 3. **Изоляция логики создания объектов**

- **Проблема**: Логика создания объектов, особенно если она сложная (например,
  включает инициализацию, настройку зависимостей или выбор типа), может
  загромождать клиентский код, делая его менее читаемым и трудным для поддержки.
- **Решение**: Factory Method выносит логику создания объектов в отдельные
  классы (фабрики), отделяя её от бизнес-логики клиента. Это улучшает читаемость
  и поддерживаемость кода.
- **Пример**: Создание соединений с базой данных (`MySQLConnection`,
  `PostgreSQLConnection`) может быть инкапсулировано в фабриках, чтобы
  клиентский код вызывал только `createConnection()`.

### 4. **Поддержка полиморфизма при создании объектов**

- **Проблема**: В системах, где требуется создавать объекты с общим интерфейсом,
  но разной реализацией, клиентский код должен вручную определять, какой класс
  создавать, что усложняет поддержку.
- **Решение**: Factory Method использует полиморфизм, позволяя подклассам
  фабрики возвращать объекты, соответствующие общему интерфейсу. Клиент работает
  с абстракцией, а конкретная реализация определяется подклассом.
- **Пример**: В UI-фреймворке фабричный метод может создавать кнопки (
  `WindowsButton`, `MacOSButton`), реализующие интерфейс `Button`.

### 5. **Управление зависимостями при создании объектов**

- **Проблема**: Создание объектов может включать сложные зависимости или
  конфигурации (например, установка параметров, внедрение зависимостей), что
  усложняет процесс instantiation.
- **Решение**: Factory Method позволяет фабрикам управлять зависимостями и
  конфигурацией объектов, скрывая эти детали от клиента.
- **Пример**: Фабрика для создания HTTP-клиентов может настраивать тайм-ауты,
  заголовки или прокси, возвращая готовый объект:
  ```java
  class HttpClientFactory extends ClientFactory {
      @Override
      public HttpClient createClient() {
          return HttpClient.newBuilder()
                  .connectTimeout(Duration.ofSeconds(10))
                  .build();
      }
  }
  ```

### 6. **Упрощение тестирования**

- **Проблема**: Жёсткая привязка к конкретным классам через `new` затрудняет
  подмену объектов в тестах (например, для создания мок-объектов).
- **Решение**: Factory Method позволяет легко подменять фабрики в тестах,
  возвращая заглушки (stubs) или моки вместо реальных объектов, что упрощает
  тестирование.
- **Пример**: В тестах можно создать `MockDocumentFactory`, которая возвращает
  `MockDocument` для проверки поведения без реальных файлов.

### 7. **Поддержка расширяемости в системах**

- **Проблема**: Системы, которые должны быть легко расширяемыми для новых
  сценариев (например, добавление новых платформ, форматов или устройств),
  требуют гибкого механизма создания объектов.
- **Решение**: Factory Method делает систему расширяемой, так как новые типы
  объектов можно интегрировать, добавив новый подкласс фабрики, не трогая
  существующий код.
- **Пример**: В платформе для рендеринга графики фабричный метод может
  поддерживать новые рендеры (`OpenGLRenderer`, `VulkanRenderer`) через новые
  фабрики.

### **Проблемы, которые НЕ решает Factory Method**

- **Сложность для простых случаев**: Если система имеет только один тип объекта
  или создание объектов тривиально, Factory Method может добавить ненужную
  сложность.
- **Множество фабрик**: Для большого числа типов объектов требуется создавать
  много подклассов фабрик, что увеличивает количество кода.
- **Ограниченная гибкость параметров**: Factory Method не так удобен для
  создания объектов с множеством параметров (в таких случаях лучше использовать
  Builder).

### **Современные альтернативы**

- **Dependency Injection (DI)**: Фреймворки, такие как Spring, управляют
  созданием объектов, внедряя зависимости, что часто заменяет Factory Method:
  ```java
  @Component
  class PdfDocument implements Document { /* ... */ }

  @Autowired
  private Document document; // Spring создаёт нужный объект
  ```
- **Лямбда-выражения**: В Java 8+ можно использовать `Supplier` для создания
  объектов:
  ```java
  Supplier<Document> pdfFactory = PdfDocument::new;
  Document doc = pdfFactory.get();
  ```
- **Abstract Factory**: Для создания семейств связанных объектов может
  использоваться Abstract Factory вместо Factory Method.

### **Итог**

Паттерн Factory Method решает проблемы, связанные с жёсткой привязкой к
конкретным классам, сложностью добавления новых типов объектов, изоляцией логики
создания и поддержкой полиморфизма. Он делает код более гибким, расширяемым и
тестируемым, особенно в системах, где требуется создавать разные реализации
одного интерфейса. Однако для сложных объектов с множеством параметров или
простых случаев могут быть более подходящими другие паттерны (Builder, DI). В
Java Factory Method широко используется в стандартной библиотеке и фреймворках,
таких как Spring.

---

## 2.2 Абстрактная фабрика

Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет
создавать семейства связанных объектов, не привязываясь к конкретным классам
создаваемых объектов.

**Паттерн Abstract Factory (Абстрактная фабрика)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания семейств связанных
или взаимозависимых объектов без указания их конкретных классов. Он позволяет
создавать группы объектов, которые работают вместе, обеспечивая совместимость
между ними.

### **Описание паттерна**

**Цель**:

- Создавать семейства связанных объектов, не привязываясь к их конкретным
  классам.
- Гарантировать, что создаваемые объекты совместимы друг с другом.

**Когда использовать**:

- Когда система должна поддерживать несколько семейств объектов (например,
  UI-компоненты для разных платформ: Windows, macOS).
- Когда нужно гарантировать совместимость создаваемых объектов.
- Когда требуется изолировать клиентский код от конкретных реализаций.

**Примеры использования**:

- Создание UI-компонентов (кнопки, текстовые поля) для разных операционных
  систем.
- Генерация объектов для разных баз данных (например, драйверы и соединения для
  MySQL, PostgreSQL).
- Поддержка различных тем оформления в приложении (светлая, тёмная).

### Структура паттерна

<img src="/img/design_pattern/design_patterns/abstract_factory_structure.png" alt="factory_method" style="max-width: 550px">

1. Абстрактные продукты объявляют интерфейсы продуктов, которые связаны друг с
   другом по смыслу, но выполняют разные функции.
2. Конкретные продукты — большой набор классов, которые относятся к различным
   абстрактным продуктам (кресло/столик), но имеют одни и те же вариации (
   Викторианский/Модерн).
3. Абстрактная фабрика объявляет методы создания различных абстрактных
   продуктов (кресло/столик).
4. Конкретные фабрики относятся каждая к своей вариации продуктов (
   Викторианский/Модерн) и реализуют методы абстрактной фабрики, позволяя
   создавать все продукты определённой вариации.
5. Несмотря на то, что конкретные фабрики порождают конкретные продукты,
   сигнатуры их методов должны возвращать соответствующие абстрактные продукты.
   Это позволит клиентскому коду, использующему фабрику, не привязываться к
   конкретным классам продуктов. Клиент сможет работать с любыми вариациями
   продуктов через абстрактные интерфейсы.

### **Реализация в Java**

Пример: создание UI-компонентов (кнопок и текстовых полей) для разных
операционных систем (Windows и macOS).

```java
// Абстрактные продукты
interface Button {
    void render();
}

interface TextField {
    void input();
}

// Конкретные продукты для Windows
class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering Windows Button");
    }
}

class WindowsTextField implements TextField {
    public void input() {
        System.out.println("Input in Windows TextField");
    }
}

// Конкретные продукты для macOS
class MacOSButton implements Button {
    public void render() {
        System.out.println("Rendering macOS Button");
    }
}

class MacOSTextField implements TextField {
    public void input() {
        System.out.println("Input in macOS TextField");
    }
}

// Абстрактная фабрика
interface UIFactory {
    Button createButton();

    TextField createTextField();
}

// Конкретные фабрики
class WindowsUIFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public TextField createTextField() {
        return new WindowsTextField();
    }
}

class MacOSUIFactory implements UIFactory {
    public Button createButton() {
        return new MacOSButton();
    }

    public TextField createTextField() {
        return new MacOSTextField();
    }
}

// Клиентский код
public class Application {
    private final Button button;
    private final TextField textField;

    public Application(UIFactory factory) {
        this.button = factory.createButton();
        this.textField = factory.createTextField();
    }

    public void renderUI() {
        button.render();
        textField.input();
    }

    public static void main(String[] args) {
        UIFactory windowsFactory = new WindowsUIFactory();
        Application windowsApp = new Application(windowsFactory);
        windowsApp.renderUI(); // Вывод: Rendering Windows Button, Input in Windows TextField

        UIFactory macOSFactory = new MacOSUIFactory();
        Application macOSApp = new Application(macOSFactory);
        macOSApp.renderUI(); // Вывод: Rendering macOS Button, Input in macOS TextField
    }
}
```

### **Как это работает**

1. Клиентский код работает с абстрактной фабрикой (`UIFactory`) и абстрактными
   продуктами (`Button`, `TextField`).
2. Конкретная фабрика (`WindowsUIFactory` или `MacOSUIFactory`) создаёт
   семейство совместимых продуктов (например, только Windows-компоненты).
3. Клиент не знает, какие конкретные классы создаются, что делает систему гибкой
   и независимой от реализаций.

### **Преимущества**

- **Совместимость продуктов**: Гарантирует, что создаваемые объекты принадлежат
  одному семейству (например, Windows-кнопка не смешивается с macOS-полем).
- **Гибкость**: Легко добавить новое семейство продуктов, создав новую фабрику.
- **Соответствие принципу Open/Closed**: Система открыта для расширения (новые
  фабрики), но закрыта для модификации.
- **Изоляция**: Клиентский код работает с абстракциями, а не с конкретными
  классами.

### **Недостатки**

- **Усложнение кода**: Требует создания множества классов (фабрики, продукты).
- **Дополнительная абстракция**: Может быть избыточной для простых систем.
- **Сложность поддержки**: При добавлении нового продукта нужно обновлять все
  фабрики.

### **Пример реального использования в Java**

1. **Java AWT/Swing**:
   В Java библиотеки для создания UI (AWT и Swing) используют паттерн, похожий
   на Abstract Factory, для создания компонентов, специфичных для платформы.
   Например, `Toolkit` действует как фабрика, создающая платформозависимые
   компоненты:
   ```java
   import java.awt.*;
   Button button = Toolkit.getDefaultToolkit().createButton("Click me");
   ```
   `Toolkit` возвращает компоненты, соответствующие текущей ОС.

2. **JDBC** В JDBC разные драйверы (MySQL, PostgreSQL) предоставляют семейства
   объектов (соединения, подготовленные запросы), что можно рассматривать как
   реализацию Abstract Factory.

3. **Spring Framework**:
   Spring `ApplicationContext` может создавать семейства связанных beans, что
   напоминает Abstract Factory:
   ```java
   ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
   ```

### **Проблемы и антипаттерны**

Паттерн **Abstract Factory (Абстрактная фабрика)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания семейств связанных
или взаимозависимых объектов без указания их конкретных классов. Он решает ряд
проблем, связанных с созданием групп объектов, которые должны быть совместимыми
и работать вместе. Вот основные проблемы, которые решает этот паттерн:

### 1. **Создание семейств связанных объектов**

- **Проблема**: В системе может потребоваться создавать группы объектов, которые
  связаны между собой и должны быть совместимыми (например, UI-компоненты для
  разных платформ, такие как кнопки и текстовые поля для Windows или macOS).
  Создание таких объектов напрямую в клиентском коде приводит к жёсткой привязке
  к конкретным классам и усложняет поддержку.
- **Решение**: Abstract Factory предоставляет интерфейс для создания семейств
  объектов, гарантируя, что все созданные объекты принадлежат одному семейству (
  например, только Windows-компоненты). Клиент работает с абстрактным
  интерфейсом фабрики, не зная конкретных классов.
- **Пример**: В UI-фреймворке фабрика создаёт кнопки и текстовые поля,
  совместимые с конкретной платформой:
  ```java
  interface UIFactory {
      Button createButton();
      TextField createTextField();
  }

  class WindowsUIFactory implements UIFactory {
      public Button createButton() { return new WindowsButton(); }
      public TextField createTextField() { return new WindowsTextField(); }
  }
  ```

### 2. **Гарантия совместимости создаваемых объектов**

- **Проблема**: Если клиентский код создаёт объекты напрямую, есть риск
  смешивания объектов из разных семейств (например, Windows-кнопка с
  macOS-полем), что может привести к несовместимости или некорректному
  поведению.
- **Решение**: Abstract Factory обеспечивает, что все объекты, созданные одной
  фабрикой, принадлежат одному семейству и совместимы друг с другом. Это
  особенно важно для систем, где объекты должны работать в связке.
- **Пример**: В игре фабрика создаёт оружие и броню для разных фракций (
  например, эльфы или орки), гарантируя, что экипировка соответствует фракции.

### 3. **Упрощение добавления новых семейств объектов**

- **Проблема**: Добавление нового семейства объектов (например, поддержка новой
  платформы или темы оформления) требует значительных изменений в коде, если
  создание объектов не структурировано. Это нарушает принцип Open/Closed (
  открытость для расширения, закрытость для модификации).
- **Решение**: Abstract Factory позволяет добавить новое семейство объектов,
  просто создав новый класс фабрики, реализующий абстрактный интерфейс.
  Клиентский код остаётся неизменным, так как работает с абстракцией.
- **Пример**: Для добавления поддержки Linux в UI-фреймворк достаточно создать
  `LinuxUIFactory`, не меняя клиентский код.

### 4. **Изоляция клиентского кода от конкретных реализаций**

- **Проблема**: Клиентский код, создающий объекты напрямую через `new`,
  становится зависимым от конкретных классов, что усложняет замену реализаций и
  увеличивает связанность.
- **Решение**: Abstract Factory скрывает детали создания объектов, предоставляя
  клиенту только абстрактный интерфейс фабрики и продуктов. Это уменьшает
  связанность и упрощает поддержку.
- **Пример**: Клиентский код работает с `UIFactory`, не зная, создаются ли
  `WindowsButton` или `MacOSButton`.

### 5. **Поддержка принципа Open/Closed**

- **Проблема**: Без структурированного подхода к созданию объектов добавление
  новых типов или семейств требует изменения существующего кода, что делает
  систему хрупкой.
- **Решение**: Abstract Factory делает систему открытой для расширения (новые
  фабрики и продукты добавляются легко) и закрытой для модификации (клиентский
  код не меняется).
- **Пример**: В системе рендеринга графики можно добавить новую фабрику для
  Vulkan, не трогая код, работающий с OpenGL.

### 6. **Упрощение работы с подсистемами**

- **Проблема**: Если подсистема состоит из множества взаимосвязанных объектов,
  клиентский код должен знать, как их создавать и комбинировать, что увеличивает
  сложность.
- **Решение**: Abstract Factory предоставляет единый интерфейс для создания всех
  объектов подсистемы, упрощая их интеграцию и использование.
- **Пример**: В JDBC фабрика может создавать объекты для соединения, запросов и
  транзакций, специфичных для базы данных (MySQL, PostgreSQL).

### 7. **Упрощение тестирования**

- **Проблема**: Жёсткая привязка к конкретным классам затрудняет подмену
  объектов в тестах (например, для создания мок-объектов).
- **Решение**: Abstract Factory позволяет подменять фабрику в тестах, возвращая
  заглушки или моки вместо реальных объектов, что упрощает тестирование.
- **Пример**: В тестах можно использовать `MockUIFactory`, которая возвращает
  `MockButton` и `MockTextField`.

### **Проблемы, которые НЕ решает Abstract Factory**

- **Добавление новых продуктов**: Если нужно добавить новый тип продукта (
  например, `Checkbox` к `Button` и `TextField`), требуется изменить интерфейс
  фабрики и все её реализации, что нарушает принцип Open/Closed.
- **Сложность для простых систем**: Для систем с одним типом объекта или без
  семейств Abstract Factory может быть избыточной.
- **Увеличение числа классов**: Требует создания множества классов (фабрики,
  продукты), что может усложнить архитектуру.

### **Современные альтернативы**

- **Dependency Injection (DI)**: Фреймворки, такие как Spring, управляют
  созданием семейств объектов, внедряя зависимости:
  ```java
  @Component
  class WindowsButton implements Button { /* ... */ }

  @Autowired
  private Button button; // Spring создаёт нужный объект
  ```
- **Лямбда-выражения и Supplier**: В Java 8+ можно использовать функциональные
  интерфейсы для создания объектов:
  ```java
  Supplier<Button> buttonFactory = WindowsButton::new;
  Button button = buttonFactory.get();
  ```
- **Factory Method**: Если требуется создавать только один тип объекта, Factory
  Method может быть проще, чем Abstract Factory.

### **Итог**

Паттерн Abstract Factory решает проблемы, связанные с созданием семейств
связанных объектов, обеспечением их совместимости, изоляцией клиентского кода от
реализаций и поддержкой расширяемости. Он особенно полезен в системах, где
требуется поддержка нескольких платформ, тем или подсистем (например, UI, базы
данных). Однако он может быть сложным для поддержки при добавлении новых
продуктов и избыточным для простых случаев. В Java паттерн используется в
стандартной библиотеке (AWT, JDBC) и фреймворках (Spring), а в современных
приложениях его часто дополняют DI или функциональные подходы.

---

## 3. **Observer (Наблюдатель)**

Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм
подписки, позволяющий одним объектам следить и реагировать на события,
происходящие в других объектах.

**Паттерн Observer (Наблюдатель)** — это поведенческий паттерн проектирования,
который устанавливает зависимость "один ко многим" между объектами, чтобы при
изменении состояния одного объекта (субъекта) все зависимые объекты (
наблюдатели) автоматически уведомлялись и обновлялись. Этот паттерн широко
используется в событийно-ориентированных системах, где изменения в одном
компоненте должны отражаться в других.

### **Описание паттерна**

**Цель**:

- Обеспечить механизм уведомления нескольких объектов об изменениях состояния
  другого объекта.
- Поддерживать слабую связанность между субъектом и наблюдателями.

**Когда использовать**:

- Когда изменение состояния одного объекта должно автоматически обновлять другие
  объекты (например, обновление UI при изменении данных).
- В системах, основанных на событиях (например, GUI, обработка кликов мыши).
- Для реализации моделей "паблишер-субскрайбер" (publisher-subscriber).
- Когда нужно динамически добавлять или удалять наблюдателей.

**Примеры использования**:

- Обновление пользовательского интерфейса при изменении модели (паттерн MVC).
- Слушатели событий в Java (например, `ActionListener` в Swing).
- Реактивные системы (например, RxJava, Project Reactor).
- Уведомления в мессенджерах или новостных лентах.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/observer_structure.png" alt="factory_method" style="max-width: 550px">

1. Издатель владеет внутренним состоянием, изменение которого интересно
   отслеживать подписчикам. Издатель содержит механизм подписки: список
   подписчиков и методы подписки/отписки.
2. Когда внутреннее состояние издателя меняется, он оповещает своих подписчиков.
   Для этого издатель проходит по списку подписчиков и вызывает их метод
   оповещения, заданный в общем интерфейсе подписчиков.
3. Подписчик определяет интерфейс, которым пользуется издатель для отправки
   оповещения. В большинстве случаев для этого достаточно единственного метода.
4. Конкретные подписчики выполняют что-то в ответ на оповещение, пришедшее от
   издателя. Эти классы должны следовать общему интерфейсу подписчиков, чтобы
   издатель не зависел от конкретных классов подписчиков.
5. По приходу оповещения подписчику нужно получить обновлённое состояние
   издателя. Издатель может передать это состояние через параметры метода
   оповещения. Более гибкий вариант — передавать через параметры весь объект
   издателя, чтобы подписчик мог сам получить требуемые данные. Как вариант,
   подписчик может постоянно хранить ссылку на объект издателя, переданный ему в
   конструкторе.
6. Клиент создаёт объекты издателей и подписчиков, а затем регистрирует
   подписчиков на обновления в издателях.

### **Реализация в Java**

Пример: новостное агентство (субъект) рассылает новости подписчикам
(наблюдателям).

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс наблюдателя
interface Observer {
    void update(String message);
}

// Интерфейс субъекта
interface Subject {
    void addObserver(Observer observer);

    void removeObserver(Observer observer);

    void notifyObservers();
}

// Конкретный субъект
class NewsAgency implements Subject {
    private final List<Observer> observers = new ArrayList<>();
    private String news;

    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }

    @Override
    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
}

// Конкретный наблюдатель
class NewsChannel implements Observer {
    private final String channelName;

    public NewsChannel(String channelName) {
        this.channelName = channelName;
    }

    @Override
    public void update(String message) {
        System.out.println(channelName + " received news: " + message);
    }
}

// Клиентский код
public class ObserverExample {
    public static void main(String[] args) {
        NewsAgency agency = new NewsAgency();
        NewsChannel channel1 = new NewsChannel("Channel 1");
        NewsChannel channel2 = new NewsChannel("Channel 2");

        agency.addObserver(channel1);
        agency.addObserver(channel2);

        agency.setNews("Breaking News!"); // Вывод:
        // Channel 1 received news: Breaking News!
        // Channel 2 received news: Breaking News!

        agency.removeObserver(channel2);
        agency.setNews("Update!");       // Вывод:
        // Channel 1 received news: Update!
    }
}
```

### **Как это работает**

1. Субъект (`NewsAgency`) хранит список наблюдателей и состояние (например,
   `news`).
2. При изменении состояния (`setNews`) субъект вызывает `notifyObservers`,
   который уведомляет всех наблюдателей.
3. Каждый наблюдатель (`NewsChannel`) реализует метод `update`, определяющий,
   как реагировать на изменения.
4. Клиентский код управляет регистрацией и удалением наблюдателей.

### **Реальное использование в Java**

1. **Swing/JavaFX**:
   В GUI-фреймворках Java события (например, клик по кнопке) обрабатываются
   через наблюдателей:
   ```java
   import javax.swing.*;
   import java.awt.event.ActionListener;

   public class ButtonExample {
       public static void main(String[] args) {
           JButton button = new JButton("Click me");
           button.addActionListener(e -> System.out.println("Button clicked!"));
           JFrame frame = new JFrame();
           frame.add(button);
           frame.setSize(200, 200);
           frame.setVisible(true);
       }
   }
   ```
   Здесь `ActionListener` — это наблюдатель, а кнопка — субъект.

2. **Java Observable (устаревший)**:
   До Java 9 стандартная библиотека предоставляла класс `java.util.Observable` и
   интерфейс `java.util.Observer`:
   ```java
   import java.util.Observable;
   import java.util.Observer;

   class MyObservable extends Observable {
       void changeState(String data) {
           setChanged();
           notifyObservers(data);
       }
   }

   class MyObserver implements Observer {
       public void update(Observable o, Object arg) {
           System.out.println("Received: " + arg);
       }
   }
   ```
   Этот подход устарел, так как был слишком ограниченным и не поддерживал
   современные практики.

3. **PropertyChangeListener**:
   Более современный подход в Java — использование
   `java.beans.PropertyChangeSupport`:
   ```java
   import java.beans.PropertyChangeListener;
   import java.beans.PropertyChangeSupport;

   public class NewsAgency {
       private final PropertyChangeSupport support = new PropertyChangeSupport(this);
       private String news;

       public void addObserver(PropertyChangeListener listener) {
           support.addPropertyChangeListener(listener);
       }

       public void setNews(String news) {
           String oldNews = this.news;
           this.news = news;
           support.firePropertyChange("news", oldNews, news);
       }
   }
   ```

4. **Реактивные библиотеки**:
   В современных Java-приложениях паттерн Observer часто реализуется через
   библиотеки, такие как RxJava или Project Reactor:
   ```java
   import io.reactivex.rxjava3.core.Observable;

   public class RxJavaExample {
       public static void main(String[] args) {
           Observable.just("Breaking News!")
                     .subscribe(news -> System.out.println("Received: " + news));
       }
   }
   ```

### **Преимущества**

- **Слабая связанность**: Субъект и наблюдатели не зависят друг от друга
  напрямую, взаимодействуя через интерфейсы.
- **Гибкость**: Наблюдатели можно добавлять или удалять динамически.
- **Поддержка событий**: Идеально подходит для асинхронных и
  событийно-ориентированных систем.
- **Широкое применение**: Используется в GUI, реактивном программировании и
  архитектурах, таких как MVC.

### **Недостатки**

- **Утечки памяти**: Если наблюдатели не удаляются, они могут оставаться в
  памяти, удерживая ссылки на субъект.
    - **Решение**: Используйте `WeakReference` или явно удаляйте наблюдателей.
- **Производительность**: Уведомление большого числа наблюдателей может быть
  затратным.
    - **Решение**: Оптимизируйте уведомления, например, используя фильтры или
      асинхронные вызовы.
- **Сложность отладки**: Поток уведомлений может быть трудно отследить в больших
  системах.
    - **Решение**: Используйте логирование или реактивные библиотеки с
      встроенной диагностикой.

### **Проблемы и антипаттерны**

1. **Забытые наблюдатели**: Незарегистрированные наблюдатели могут вызывать
   утечки памяти.
    - **Решение**: Используйте `removeObserver` или слабые ссылки (
      `WeakReference`).
2. **Слишком много уведомлений**: Частые или ненужные уведомления снижают
   производительность.
    - **Решение**: Вводите фильтры или условия для уведомлений.
3. **Сложная логика в наблюдателях**: Если наблюдатели выполняют тяжёлые
   операции, система может замедлиться.
    - **Решение**: Выполняйте сложные задачи асинхронно (например, с помощью
      `ExecutorService`).

### **Современные альтернативы в Java**

- **Реактивное программирование**: Библиотеки, такие как RxJava, Project Reactor
  или Flow API (Java 9+), предоставляют мощные инструменты для реализации
  Observer:
  ```java
  import java.util.concurrent.Flow;

  class NewsPublisher implements Flow.Publisher<String> {
      // Реализация паблишер-субскрайбер
  }
  ```
- **Spring Events**: В Spring можно использовать `@EventListener` для обработки
  событий:
  ```java
  @Component
  class NewsListener {
      @EventListener
      public void handleNews(NewsEvent event) {
          System.out.println("Received: " + event.getNews());
      }
  }
  ```
- **Лямбда-выражения**: В Java 8+ наблюдатели можно реализовать через
  функциональные интерфейсы:
  ```java
  List<Consumer<String>> observers = new ArrayList<>();
  observers.add(message -> System.out.println("Received: " + message));
  ```

### **Итог**

Паттерн Observer — это мощный инструмент для реализации
событийно-ориентированных систем, особенно в GUI, реактивных приложениях и
архитектурах, таких как MVC. Он обеспечивает слабую связанность и гибкость, но
требует осторожности, чтобы избежать утечек памяти и проблем с
производительностью. В современных Java-приложениях паттерн часто реализуется
через встроенные механизмы (Swing, PropertyChangeListener) или библиотеки (
RxJava, Spring).

---

### 4. **Strategy (Стратегия)**

Стратегия — это поведенческий паттерн проектирования, который определяет
семейство схожих алгоритмов и помещает каждый из них в собственный класс, после
чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

Он особенно полезен, когда нужно поддерживать разные варианты поведения или
алгоритмов для одной задачи.

### **Описание паттерна**

**Цель**:

- Определить семейство алгоритмов и сделать их взаимозаменяемыми.
- Позволить клиентскому коду выбирать алгоритм во время выполнения.
- Изолировать логику алгоритма от контекста, который его использует.

**Когда использовать**:

- Когда нужно использовать разные варианты одного алгоритма (например, разные
  способы оплаты, сортировки, сжатия данных).
- Когда в коде много условных операторов (`if-else`), зависящих от типа
  поведения, которые можно вынести в отдельные классы.
- Когда нужно заменять алгоритм без изменения клиентского кода.
- Когда требуется изолировать реализацию алгоритма от его использования.

**Примеры использования**:

- Различные способы оплаты в интернет-магазине (PayPal, кредитная карта,
  криптовалюта).
- Алгоритмы сортировки (`Comparator` в Java).
- Разные стратегии рендеринга графики (2D, 3D).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/strategy_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Контекст хранит ссылку на объект конкретной стратегии, работая с ним через
   общий интерфейс стратегий.
2. Стратегия определяет интерфейс, общий для всех вариаций алгоритма. Контекст
   использует этот интерфейс для вызова алгоритма.<br>
   Для контекста неважно, какая именно вариация алгоритма будет выбрана, так как
   все они имеют одинаковый интерфейс.
3. Конкретные стратегии реализуют различные вариации алгоритма.
4. Во время выполнения программы контекст получает вызовы от клиента и
   делегирует их объекту конкретной стратегии.
5. Клиент должен создать объект конкретной стратегии и передать его в
   конструктор контекста. Кроме этого, клиент должен иметь возможность заменить
   стратегию на лету, используя сеттер. Благодаря этому, контекст не будет знать
   о том, какая именно стратегия сейчас выбрана.

### **Реализация в Java**

Пример: реализация разных способов оплаты в интернет-магазине.

```java
import java.util.*;

// Интерфейс стратегии
interface PaymentStrategy {
    void pay(double amount);
}

// Конкретные стратегии
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Credit Card ending in " + cardNumber.substring(cardNumber.length() - 4));
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;

    public PayPalPayment(String email) {
        this.email = email;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using PayPal account " + email);
    }
}

// Контекст
class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    private List<Double> items;

    public ShoppingCart() {
        this.items = new ArrayList<>();
    }

    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void addItem(double price) {
        items.add(price);
    }

    public void checkout() {
        double total = items.stream().mapToDouble(Double::doubleValue).sum();
        if (paymentStrategy == null) {
            throw new IllegalStateException("Payment strategy not set");
        }
        paymentStrategy.pay(total);
    }
}

// Клиентский код
public class StrategyExample {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        cart.addItem(100.0);
        cart.addItem(50.0);

        // Оплата кредитной картой
        cart.setPaymentStrategy(new CreditCardPayment("1234-5678-9012-3456"));
        cart.checkout(); // Вывод: Paid 150.0 using Credit Card ending in 3456

        // Оплата через PayPal
        cart.setPaymentStrategy(new PayPalPayment("user@example.com"));
        cart.checkout(); // Вывод: Paid 150.0 using PayPal account user@example.com
    }
}
```

### **Как это работает**

1. Клиент создаёт контекст (`ShoppingCart`) и задаёт конкретную стратегию (
   `CreditCardPayment` или `PayPalPayment`) через метод `setPaymentStrategy`.
2. Контекст использует стратегию для выполнения действия (`pay`) без знания её
   внутренней реализации.
3. Клиент может менять стратегию во время выполнения, не изменяя код контекста.

### **Реальное использование в Java**

1. **Java Collections (Comparator)**:
   `Collections.sort` использует паттерн Strategy через интерфейс `Comparator`:
   ```java
   List<String> names = Arrays.asList("Bob", "Alice", "Charlie");
   Collections.sort(names, String::compareToIgnoreCase); // Стратегия сортировки
   System.out.println(names); // [Alice, Bob, Charlie]
   ```
   Здесь `Comparator` — это стратегия, определяющая порядок сортировки.

2. **Spring Framework**:
   В Spring разные реализации сервисов (например, для обработки запросов) могут
   быть инкапсулированы как стратегии:
   ```java
   @Service
   interface PaymentService {
       void pay(double amount);
   }

   @Service
   class CreditCardService implements PaymentService {
       public void pay(double amount) { /* Логика */ }
   }

   @Autowired
   private PaymentService paymentService; // Инъекция стратегии
   ```

3. **Stream API**:
   Функции, передаваемые в методы `map`, `filter` или `reduce`, действуют как
   стратегии:
   ```java
   List<Integer> numbers = Arrays.asList(1, 2, 3);
   numbers.stream().map(n -> n * 2).forEach(System.out::println); // Стратегия: умножение на 2
   ```

### **Преимущества**

- **Гибкость**: Легко добавлять новые алгоритмы, создавая новые классы
  стратегий.
- **Соответствие принципу Open/Closed**: Контекст открыт для расширения (новые
  стратегии), но закрыт для модификации.
- **Изоляция**: Логика алгоритма отделена от контекста, что упрощает
  тестирование.
- **Устранение условных операторов**: Вместо `if-else` для выбора поведения
  используется полиморфизм.
- **Динамическая смена поведения**: Стратегию можно менять во время выполнения.

### **Недостатки**

- **Увеличение числа классов**: Каждая новая стратегия требует отдельного
  класса.
- **Дополнительная сложность**: Для простых случаев паттерн может быть
  избыточным.
- **Необходимость настройки**: Клиент должен знать, какую стратегию выбрать, и
  передать её в контекст.

### **Отличие от других паттернов**

- **Strategy vs State**:
    - **Strategy** определяет взаимозаменяемые алгоритмы, которые не зависят от
      состояния контекста.
    - **State** управляет поведением, зависящим от внутреннего состояния
      объекта, и может изменять состояние контекста.
- **Strategy vs Command**:
    - **Strategy** фокусируется на выборе алгоритма для одной задачи.
    - **Command** инкапсулирует запрос как объект, часто для выполнения действий
      позже (например, undo/redo).
- **Strategy vs Template Method**:
    - **Strategy** использует композицию (стратегия передаётся в контекст).
    - **Template Method** использует наследование (подклассы переопределяют шаги
      алгоритма).

### **Проблемы и антипаттерны**

1. **Слишком много стратегий**: Если стратегий становится слишком много, код
   может стать громоздким.
    - **Решение**: Рассмотрите использование функциональных интерфейсов или
      лямбда-выражений для простых случаев.
2. **Жёсткая привязка клиента**: Клиент должен знать о всех стратегиях и
   выбирать подходящую.
    - **Решение**: Используйте Factory или DI (например, Spring) для создания
      стратегий.
3. **Избыточность для простых случаев**: Если есть только один алгоритм, паттерн
   может быть лишним.
    - **Решение**: Используйте Strategy только для задач с несколькими
      вариантами поведения.

### **Современные альтернативы в Java**

- **Лямбда-выражения и функциональные интерфейсы**:
  В Java 8+ Strategy часто заменяется лямбда-выражениями, что уменьшает
  необходимость в отдельных классах:
  ```java
  interface PaymentStrategy {
      void pay(double amount);
  }

  PaymentStrategy creditCard = amount -> System.out.println("Paid " + amount + " via Credit Card");
  PaymentStrategy payPal = amount -> System.out.println("Paid " + amount + " via PayPal");

  cart.setPaymentStrategy(creditCard);
  cart.checkout();
  ```
- **Spring Dependency Injection**:
  Spring позволяет внедрять стратегии как зависимости, упрощая их выбор:
  ```java
  @Service("creditCard")
  class CreditCardPayment implements PaymentStrategy { /* ... */ }

  @Autowired
  @Qualifier("creditCard")
  private PaymentStrategy paymentStrategy;
  ```
- **Map с перечислениями**:
  Для простых случаев можно использовать `Enum` и `Map` для выбора стратегии:
  ```java
  enum PaymentType {
      CREDIT_CARD(amount -> System.out.println("Paid " + amount + " via Credit Card")),
      PAYPAL(amount -> System.out.println("Paid " + amount + " via PayPal"));

      private final Consumer<Double> paymentAction;

      PaymentType(Consumer<Double> paymentAction) {
          this.paymentAction = paymentAction;
      }

      void pay(double amount) {
          paymentAction.accept(amount);
      }
  }
  ```

### **Итог**

Паттерн Strategy — это мощный инструмент для управления различными алгоритмами
или поведениями, обеспечивающий гибкость и изоляцию кода. Он широко используется
в Java, особенно в стандартной библиотеке (`Comparator`, Stream API) и
фреймворках (Spring). В современных приложениях Strategy часто упрощается с
помощью лямбда-выражений или DI, что делает код компактнее. Однако для сложных
систем с множеством алгоритмов классическая реализация Strategy остаётся
предпочтительной.

---

### 5. **Decorator (Декоратор)**

Декоратор — это структурный паттерн проектирования, который позволяет
динамически добавлять объектам новую функциональность, оборачивая их в полезные
«обёртки».

**Паттерн Decorator (Декоратор)** — это структурный паттерн проектирования,
который позволяет динамически добавлять новые обязанности или поведение объекту,
оборачивая его в другой объект. Он предоставляет гибкую альтернативу
наследованию для расширения функциональности, сохраняя интерфейс исходного
объекта.

### **Описание паттерна**

**Цель**:

- Динамически добавлять новые обязанности объекту без изменения его кода.
- Обеспечить гибкое расширение функциональности через композицию вместо
  наследования.

**Когда использовать**:

- Когда нужно добавлять функциональность объектам на лету (например, добавление
  логирования, кэширования, шифрования).
- Когда наследование нецелесообразно из-за большого числа комбинаций поведения.
- Когда требуется сохранить интерфейс исходного объекта, но расширить его
  поведение.
- Для реализации принципа единственной ответственности (SRP), разделяя основную
  логику и дополнительные функции.

**Примеры использования**:

- Потоки ввода-вывода в Java (`BufferedInputStream`, `DataInputStream`).
- Добавление функциональности в UI-компоненты (например, прокрутка или рамка в
  Swing).
- Декорирование сервисов (логирование, проверка прав доступа).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/decorator_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Компонент задаёт общий интерфейс обёрток и оборачиваемых объектов.
2. Конкретный компонент определяет класс оборачиваемых объектов. Он содержит
   какое-то базовое поведение, которое потом изменяют декораторы.
3. Базовый декоратор хранит ссылку на вложенный объект-компонент. Им может быть
   как конкретный компонент, так и один из конкретных декораторов. Базовый
   декоратор делегирует все свои операции вложенному объекту. Дополнительное
   поведение будет жить в конкретных декораторах.
4. Конкретные декораторы — это различные вариации декораторов, которые содержат
   добавочное поведение. Оно выполняется до или после вызова аналогичного
   поведения обёрнутого объекта.
5. Клиент может оборачивать простые компоненты и декораторы в другие декораторы,
   работая со всеми объектами через общий интерфейс компонентов.

### **Реализация в Java**

Пример: декорирование напитков в кофейне, где к базовому напитку (например,
кофе) можно добавлять ингредиенты (молоко, сироп).

```java
// Компонент
interface Beverage {
    String getDescription();

    double getCost();
}

// Конкретный компонент
class Espresso implements Beverage {
    @Override
    public String getDescription() {
        return "Espresso";
    }

    @Override
    public double getCost() {
        return 2.0;
    }
}

// Абстрактный декоратор
abstract class BeverageDecorator implements Beverage {
    protected Beverage beverage;

    public BeverageDecorator(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription();
    }

    @Override
    public double getCost() {
        return beverage.getCost();
    }
}

// Конкретные декораторы
class Milk extends BeverageDecorator {
    public Milk(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Milk";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.5;
    }
}

class Syrup extends BeverageDecorator {
    public Syrup(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Syrup";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.7;
    }
}

// Клиентский код
public class DecoratorExample {
    public static void main(String[] args) {
        Beverage espresso = new Espresso();
        System.out.println(espresso.getDescription() + " $" + espresso.getCost());
        // Вывод: Espresso $2.0

        Beverage latte = new Milk(espresso);
        System.out.println(latte.getDescription() + " $" + latte.getCost());
        // Вывод: Espresso, Milk $2.5

        Beverage fancyLatte = new Syrup(new Milk(espresso));
        System.out.println(fancyLatte.getDescription() + " $" + fancyLatte.getCost());
        // Вывод: Espresso, Milk, Syrup $3.2
    }
}
```

### **Как это работает**

1. Клиент создаёт базовый объект (`Espresso`) и передаёт его в декоратор
   (`Milk`, `Syrup`).
2. Каждый декоратор реализует интерфейс `Beverage`, вызывая методы исходного
   объекта и добавляя своё поведение (например, увеличивая стоимость или изменяя
   описание).
3. Декораторы можно комбинировать в цепочку, добавляя несколько уровней
   функциональности (`Syrup` оборачивает `Milk`, который оборачивает
   `Espresso`).
4. Клиент работает с декорированным объектом через тот же интерфейс `Beverage`.

### **Реальное использование в Java**

1. **Java I/O**:
   Потоки ввода-вывода в Java — классический пример паттерна Decorator:
   ```java
   import java.io.*;

   public class IOExample {
       public static void main(String[] args) throws IOException {
           FileInputStream fis = new FileInputStream("test.txt");
           BufferedInputStream bis = new BufferedInputStream(fis); // Декоратор
           int data = bis.read();
           bis.close();
       }
   }
   ```
    - `BufferedInputStream` декорирует `FileInputStream`, добавляя буферизацию.
    - `DataInputStream` может добавить методы для чтения примитивных типов.

2. **Swing UI**:
   В Swing декораторы используются для добавления функциональности компонентам,
   например, рамок или полос прокрутки:
   ```java
   import javax.swing.*;

   JScrollPane scrollPane = new JScrollPane(new JTextArea()); // Декоратор
   ```

3. **Spring Framework**:
   В Spring декораторы часто используются для добавления функциональности,
   например, кэширования или логирования:
   ```java
   @Cacheable("results")
   public Result computeExpensiveResult() { /* Логика */ }
   ```
   Здесь `@Cacheable` действует как декоратор, добавляя кэширование к методу.

### **Преимущества**

- **Гибкость**: Можно комбинировать декораторы в любом порядке и количестве.
- **Соответствие принципу Open/Closed**: Функциональность расширяется без
  изменения исходного класса.
- **Альтернатива наследованию**: Избегает создания множества подклассов для
  комбинаций поведения.
- **Переиспользуемость**: Декораторы можно применять к разным объектам одного
  интерфейса.

### **Недостатки**

- **Увеличение числа классов**: Каждый декоратор — это отдельный класс.
- **Сложность отладки**: Цепочка декораторов может затруднить отслеживание
  выполнения.
- **Не всегда интуитивно**: Многослойное декорирование может быть трудно понять
  новичкам.
- **Ограничение интерфейса**: Декораторы должны строго следовать интерфейсу
  компонента, что ограничивает добавление новых методов.

### **Отличие от других паттернов**

- **Decorator vs Adapter**:
    - **Decorator** добавляет поведение, сохраняя тот же интерфейс.
    - **Adapter** преобразует интерфейс одного класса в другой.
- **Decorator vs Proxy**:
    - **Decorator** фокусируется на добавлении функциональности.
    - **Proxy** управляет доступом или жизненным циклом объекта (например,
      ленивая инициализация).
- **Decorator vs Composite**:
    - **Decorator** оборачивает один объект, добавляя поведение.
    - **Composite** управляет группой объектов как единым целым (древовидная
      структура).

### **Проблемы и антипаттерны**

1. **Слишком длинные цепочки декораторов**: Многослойное декорирование может
   снизить читаемость и производительность.
    - **Решение**: Ограничивайте количество декораторов или используйте другие
      паттерны (например, Strategy) для сложных случаев.
2. **Нарушение инкапсуляции**: Если декоратор изменяет внутреннее состояние
   объекта, это может привести к ошибкам.
    - **Решение**: Декораторы должны быть прозрачными и работать только с
      публичным интерфейсом.
3. **Сложность тестирования**: Тестирование цепочек декораторов может быть
   затруднительным.
    - **Решение**: Используйте мок-объекты (например, с Mockito) для изоляции
      компонентов.

### **Современные альтернативы в Java**

- **Лямбда-выражения**:
  В Java 8+ декораторы иногда заменяются функциональными композициями:
  ```java
  Function<Beverage, Beverage> addMilk = bev -> new Beverage() {
      public String getDescription() { return bev.getDescription() + ", Milk"; }
      public double getCost() { return bev.getCost() + 0.5; }
  };

  Beverage espresso = new Espresso();
  Beverage latte = addMilk.apply(espresso);
  ```
- **Spring AOP**:
  В Spring аспекты могут действовать как декораторы, добавляя сквозную
  функциональность (логирование, транзакции):
  ```java
  @Transactional
  public void saveOrder(Order order) { /* Логика */ }
  ```
- **Аннотации**:
  Аннотации, такие как `@Log` в SLF4J или `@Cacheable` в Spring, часто заменяют
  явные декораторы для простых случаев.

### **Итог**

Паттерн Decorator — это мощный инструмент для динамического расширения
функциональности объектов, особенно в системах, где требуется множество
комбинаций поведения. В Java он широко используется в стандартной библиотеке (
I/O, Swing) и фреймворках (Spring). Его гибкость делает его идеальным для
случаев, где наследование неудобно, но он может усложнить код при чрезмерном
использовании. В современных Java-приложениях декораторы часто упрощаются с
помощью лямбда-выражений, AOP или аннотаций.

### Почему именно эти паттерны популярны?

1. **Универсальность**: Эти паттерны решают типичные задачи (создание объектов,
   управление поведением, реакция на события).
2. **Поддержка в Java**: Многие встроены в стандартную библиотеку (например, I/O
   для Decorator, `Comparator` для Strategy).
3. **Фреймворки**: Spring, Hibernate и другие активно используют Factory,
   Singleton, Observer.
4. **Сообщество**: На Stack Overflow и GitHub эти паттерны часто упоминаются в
   решениях (например, Singleton и Factory — лидеры по вопросам).

### Менее популярные паттерны GoF

Некоторые паттерны, такие как **Memento**, **Interpreter** или **Flyweight**,
менее популярны, так как применяются в специфических сценариях (например,
реализация undo, парсинг языков, оптимизация памяти). Они реже встречаются в
типичных Java-приложениях.

### Замечания

- **Контекст имеет значение**: Популярность зависит от домена. Например, в
  веб-разработке (Spring) чаще встречаются Factory и Singleton, а в GUI —
  Observer и Decorator.
- **Современные альтернативы**: В Java многие паттерны упрощаются с помощью
  функционального программирования (например, лямбда-выражения заменяют Strategy
  в некоторых случаях).
- **Антипаттерны**: Неправильное использование популярных паттернов (например,
  Singleton) может привести к проблемам, как обсуждалось ранее.

# ===== ДОПОЛНИТЕЛЬНО =====

## Прототип (Prototype)

Прототип — это порождающий паттерн проектирования, который позволяет копировать
объекты, не вдаваясь в подробности их реализации.

**Паттерн Prototype (Прототип)** — это порождающий паттерн проектирования,
который позволяет создавать новые объекты путём копирования существующего
объекта, называемого прототипом, без привязки к их конкретным классам. Этот
паттерн полезен, когда создание объекта с нуля дорогостоящее или когда нужно
создать объект с похожими характеристиками, но с небольшими изменениями.

### **Описание паттерна**

**Цель**:

- Создавать новые объекты путём клонирования существующего экземпляра
  (прототипа).
- Избегать затрат на создание объектов с нуля.
- Обеспечить независимость от конкретных классов создаваемых объектов.

**Когда использовать**:

- Когда создание объекта с нуля требует значительных ресурсов (например,
  загрузка данных из базы данных или сложные вычисления).
- Когда нужно создать копию объекта с минимальными изменениями.
- Когда классы объектов определяются динамически, и создание через конструкторы
  затруднено.
- Когда система должна быть независимой от процесса создания объектов.

**Примеры использования**:

- Клонирование графических объектов в редакторах (например, копирование фигур в
  графическом редакторе).
- Создание шаблонных объектов в играх (например, копирование врагов с
  одинаковыми характеристиками).
- Кэширование объектов для повторного использования.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/prototype_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Интерфейс прототипов описывает операции клонирования. В большинстве случаев —
   это единственный метод clone.
2. Конкретный прототип реализует операцию клонирования самого себя. Помимо
   банального копирования значений всех полей, здесь могут быть спрятаны
   различные сложности, о которых не нужно знать клиенту. Например, клонирование
   связанных объектов, распутывание рекурсивных зависимостей и прочее.
3. Клиент создаёт копию объекта, обращаясь к нему через общий интерфейс
   прототипов.

### **Реализация в Java**

В Java паттерн Prototype часто использует встроенный интерфейс `Cloneable` и
метод `clone()` из класса `Object`. Пример: клонирование графических фигур.

```java
// Интерфейс прототипа
interface Shape extends Cloneable {
    Shape clone();

    void draw();
}

// Конкретный прототип
class Circle implements Shape {
    private int radius;
    private String color;

    public Circle(int radius, String color) {
        this.radius = radius;
        this.color = color;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override
    public Shape clone() {
        try {
            return (Shape) super.clone(); // Поверхностное копирование
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cloning failed", e);
        }
    }

    @Override
    public void draw() {
        System.out.println("Drawing Circle [color=" + color + ", radius=" + radius + "]");
    }
}

// Конкретный прототип
class Rectangle implements Shape {
    private int width;
    private int height;
    private String color;

    public Rectangle(int width, int height, String color) {
        this.width = width;
        this.height = height;
        this.color = color;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    @Override
    public Shape clone() {
        try {
            return (Shape) super.clone(); // Поверхностное копирование
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cloning failed", e);
        }
    }

    @Override
    public void draw() {
        System.out.println("Drawing Rectangle [color=" + color + ", width=" + width + ", height=" + height + "]");
    }
}

// Клиентский код
public class PrototypeExample {
    public static void main(String[] args) {
        // Создаём прототипы
        Shape circle = new Circle(10, "Red");
        Shape rectangle = new Rectangle(20, 15, "Blue");

        // Клонируем объекты
        Shape clonedCircle = circle.clone();
        Shape clonedRectangle = rectangle.clone();

        // Изменяем клонированный круг
        ((Circle) clonedCircle).setRadius(15);

        // Рисуем все фигуры
        circle.draw();        // Drawing Circle [color=Red, radius=10]
        clonedCircle.draw();  // Drawing Circle [color=Red, radius=15]
        rectangle.draw();     // Drawing Rectangle [color=Blue, width=20, height=15]
        clonedRectangle.draw(); // Drawing Rectangle [color=Blue, width=20, height=15]
    }
}
```

### **Как это работает**

1. Клиент создаёт прототип (`Circle`, `Rectangle`) с начальными параметрами.
2. Вместо создания нового объекта с нуля клиент вызывает метод `clone()`,
   который возвращает копию прототипа.
3. Клонированный объект можно модифицировать независимо от оригинала (например,
   изменить радиус круга).
4. Клонирование в Java по умолчанию поверхностное (копируются только примитивы и
   ссылки), но можно реализовать глубокое копирование для сложных объектов.

### **Глубокое vs Поверхностное копирование**

- **Поверхностное копирование** (как в примере выше): Копируются примитивные
  поля и ссылки на объекты. Если прототип содержит вложенные объекты, копия и
  оригинал будут ссылаться на один и тот же вложенный объект.
- **Глубокое копирование**: Копируются все вложенные объекты, создавая полностью
  независимую копию. Это требует дополнительной логики в методе `clone()`.

Пример глубокого копирования:

```java
class Circle implements Shape {
    private int radius;
    private Color color; // Сложный объект

    public Circle(int radius, Color color) {
        this.radius = radius;
        this.color = color;
    }

    @Override
    public Shape clone() {
        try {
            Circle copy = (Circle) super.clone();
            copy.color = new Color(color.getR(), color.getG(), color.getB()); // Глубокое копирование
            return copy;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cloning failed", e);
        }
    }
}
```

### **Реальное использование в Java**

1. **Java Cloneable**:
   Интерфейс `Cloneable` и метод `Object.clone()` — встроенная поддержка
   паттерна Prototype:
   ```java
   class MyClass implements Cloneable {
       @Override
       protected Object clone() throws CloneNotSupportedException {
           return super.clone();
       }
   }
   ```
   Однако `Cloneable` имеет недостатки (например, отсутствие явного интерфейса и
   проверяемого исключения), поэтому его редко используют в современном коде.

2. **Spring Framework**:
   Spring)\"s Spring позволяет создавать прототипы через `PrototypeScope`:
   ```java
   @Component
   @Scope("prototype")
   class MyBean { /* ... */ }
   ```
   Каждый вызов `context.getBean(MyBean.class)` возвращает новый экземпляр.

3. **Java Collections**:
   Метод `clone()` в коллекциях, таких как `ArrayList`:
   ```java
   ArrayList<String> list = new ArrayList<>(Arrays.asList("A", "B"));
   ArrayList<String> clonedList = (ArrayList<String>) list.clone();
   ```

### **Преимущества**

- **Экономия ресурсов**: Клонирование быстрее, чем создание объекта с нуля.
- **Гибкость**: Позволяет создавать копии с минимальными изменениями.
- **Независимость от классов**: Клиент работает с интерфейсом прототипа, а не с
  конкретными классами.
- **Динамическое создание**: Подходит для систем, где типы объектов определяются
  во время выполнения.

### **Недостатки**

- **Сложность клонирования**: Глубокое копирование требует тщательной
  реализации, особенно для сложных объектов.
- **Ограничения Cloneable**: Встроенный механизм Java (`Cloneable`) имеет
  недостатки, такие как отсутствие типобезопасности.
- **Потенциальные ошибки**: Поверхностное копирование может привести к
  неожиданным связям между копией и оригиналом.
- **Не всегда интуитивно**: Требует понимания, какие поля нужно копировать и
  как.

### **Отличие от других паттернов**

- **Prototype vs Factory Method**:
    - **Prototype** создаёт новые объекты путём копирования существующего
      экземпляра.
    - **Factory Method** определяет создание объектов через абстрактный метод,
      реализованный в подклассах.
- **Prototype vs Abstract Factory**:
    - **Prototype** фокусируется на клонировании одного объекта.
    - **Abstract Factory** создаёт семейства связанных объектов с нуля.
- **Prototype vs Builder**:
    - **Prototype** копирует готовый объект.
    - **Builder** конструирует объект пошагово.

### **Проблемы и антипаттерны**

1. **Неправильное клонирование**: Поверхностное копирование вместо глубокого
   может привести к ошибкам, если вложенные объекты изменяются.
    - **Решение**: Реализуйте глубокое копирование для всех изменяемых вложенных
      объектов.
2. **Злоупотребление Cloneable**: Использование `Cloneable` без переопределения
   `clone()` или без обработки исключений.
    - **Решение**: Рассмотрите альтернативные подходы, такие как копирующие
      конструкторы или библиотеки (например, Apache Commons Lang).
3. **Сложность тестирования**: Тестирование клонированных объектов требует
   проверки их независимости.
    - **Решение**: Пишите тесты, проверяющие, что изменения в копии не влияют на
      оригинал.

### **Современные альтернативы в Java**

- **Копирующие конструкторы**:
  Вместо `clone()` можно использовать конструктор, который принимает объект того
  же типа:
  ```java
  class Circle {
      private int radius;

      public Circle(Circle other) {
          this.radius = other.radius;
      }
  }
  ```
- **Сериализация**:
  Глубокое копирование через сериализацию/десериализацию (например, с помощью
  `ObjectOutputStream`):
  ```java
  public <T extends Serializable> T deepCopy(T obj) {
      try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
           ObjectOutputStream oos = new ObjectOutputStream(bos)) {
          oos.write(obj);
          try (ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
               ObjectInputStream ois = new ObjectInputStream(bis)) {
              return (T) ois.readObject();
          }
      } catch (IOException | ClassNotFoundException e) {
          throw new RuntimeException("Deep copy failed", e);
      }
  }
  ```
- **Библиотеки**:
  Используйте библиотеки, такие как Apache Commons Lang (
  `SerializationUtils.clone`) или Gson для глубокого копирования.

### **Итог**

Паттерн Prototype — это эффективный способ создания объектов путём клонирования,
особенно когда создание с нуля дорого или когда нужны копии с минимальными
изменениями. В Java он часто реализуется через `Cloneable`, но требует
осторожности из-за поверхностного копирования и ограничений интерфейса. В
современных приложениях паттерн может быть заменён копирующими конструкторами,
сериализацией или DI (например, Spring с `prototype` scope). Он особенно полезен
в системах, где требуется высокая производительность или динамическое создание
объектов.

## Строитель (Builder)

Строитель — это порождающий паттерн проектирования, который позволяет создавать
сложные объекты пошагово. Строитель даёт возможность использовать один и тот же
код строительства для получения разных представлений объектов. Он особенно
полезен, когда объект имеет множество параметров, а их комбинации могут
варьироваться, или когда процесс создания требует нескольких этапов.

### **Описание паттерна**

**Цель**:

- Разделить создание сложного объекта на отдельные шаги, чтобы упростить его
  конструирование.
- Обеспечить гибкость в создании различных конфигураций объекта.
- Избежать конструкторов с большим количеством параметров (телескопический
  конструктор).

**Когда использовать**:

- Когда объект имеет много опциональных параметров или сложную логику
  инициализации.
- Когда нужно создавать разные конфигурации одного типа объекта.
- Когда процесс создания объекта должен быть независим от его структуры.
- Когда требуется обеспечить неизменяемость объекта после создания.

**Примеры использования**:

- Создание сложных объектов, таких как документы, UI-формы или конфигурации.
- Построение HTTP-запросов (например, с помощью `OkHttp` или `HttpClient`).
- Генерация объектов с множеством параметров (например, конфигурация
  автомобиля).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/builder_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Интерфейс строителя объявляет шаги конструирования продуктов, общие для всех
   видов строителей.
2. Конкретные строители реализуют строительные шаги, каждый по-своему.
   Конкретные строители могут производить разнородные объекты, не имеющие общего
   интерфейса.
3. Продукт — создаваемый объект. Продукты, сделанные разными строителями, не
   обязаны иметь общий интерфейс.
4. Директор определяет порядок вызова строительных шагов для производства той
   или иной конфигурации продуктов.
5. Обычно Клиент подаёт в конструктор директора уже готовый объект-строитель, и
   в дальнейшем данный директор использует только его. Но возможен и другой
   вариант, когда клиент передаёт строителя через параметр строительного метода
   директора. В этом случае можно каждый раз применять разных строителей для
   производства различных представлений объектов.

### **Реализация в Java**

Пример: создание объекта `Computer` с различными конфигурациями (процессор,
оперативная память, хранилище).

```java
// Продукт
class Computer {
    private final String cpu;
    private final int ram;
    private final int storage;
    private final boolean hasGraphicsCard;

    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.hasGraphicsCard = builder.hasGraphicsCard;
    }

    @Override
    public String toString() {
        return "Computer [CPU=" + cpu + ", RAM=" + ram + "GB, Storage=" + storage + "GB, GraphicsCard=" + hasGraphicsCard + "]";
    }

    // Внутренний класс Builder
    public static class Builder {
        private String cpu;
        private int ram;
        private int storage;
        private boolean hasGraphicsCard;

        public Builder setCpu(String cpu) {
            this.cpu = cpu;
            return this;
        }

        public Builder setRam(int ram) {
            this.ram = ram;
            return this;
        }

        public Builder setStorage(int storage) {
            this.storage = storage;
            return this;
        }

        public Builder setGraphicsCard(boolean hasGraphicsCard) {
            this.hasGraphicsCard = hasGraphicsCard;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }
}

// Клиентский код
public class BuilderExample {
    public static void main(String[] args) {
        // Создание базового компьютера
        Computer basicComputer = new Computer.Builder()
                .setCpu("Intel i3")
                .setRam(8)
                .setStorage(256)
                .build();
        System.out.println(basicComputer);
        // Вывод: Computer [CPU=Intel i3, RAM=8GB, Storage=256GB, GraphicsCard=false]

        // Создание игрового компьютера
        Computer gamingComputer = new Computer.Builder()
                .setCpu("Intel i9")
                .setRam(32)
                .setStorage(1000)
                .setGraphicsCard(true)
                .build();
        System.out.println(gamingComputer);
        // Вывод: Computer [CPU=Intel i9, RAM=32GB, Storage=1000GB, GraphicsCard=true]
    }
}
```

### **Как это работает**

1. Клиент использует `Builder` для пошаговой настройки параметров объекта (
   `setCpu`, `setRam` и т.д.).
2. Каждый метод строителя возвращает `this`, что позволяет использовать цепочку
   вызовов (fluent interface).
3. После настройки всех параметров клиент вызывает `build()`, который создаёт
   финальный объект `Computer`.
4. Продукт (`Computer`) является неизменяемым, так как его поля задаются только
   через конструктор и помечены как `final`.

### **Реальное использование в Java**

1. **StringBuilder**:
   Класс `StringBuilder` реализует паттерн Builder для создания строк:
   ```java
   StringBuilder builder = new StringBuilder()
           .append("Hello")
           .append(" ")
           .append("World");
   String result = builder.toString(); // Hello World
   ```

2. **Java HttpClient**:
   Класс `HttpClient` в Java 11+ использует Builder для настройки HTTP-клиента:
   ```java
   import java.net.http.HttpClient;

   HttpClient client = HttpClient.newBuilder()
           .version(HttpClient.Version.HTTP_2)
           .connectTimeout(Duration.ofSeconds(10))
           .build();
   ```

3. **Lombok**:
   Аннотация `@Builder` в Lombok автоматически генерирует реализацию паттерна
   Builder:
   ```java
   import lombok.Builder;

   @Builder
   class Computer {
       private String cpu;
       private int ram;
       private int storage;
   }

   Computer computer = Computer.builder()
           .cpu("Intel i5")
           .ram(16)
           .storage(512)
           .build();
   ```

4. **Spring Boot**:
   Конфигурация объектов, таких как `RestTemplate` или `WebClient`, часто
   использует Builder:
   ```java
   import org.springframework.web.client.RestTemplate;

   RestTemplate restTemplate = new RestTemplateBuilder()
           .setConnectTimeout(Duration.ofSeconds(5))
           .build();
   ```

### **Преимущества**

- **Гибкость**: Позволяет создавать разные конфигурации объекта.
- **Читаемость**: Код с цепочкой вызовов (`fluent interface`) легко читается.
- **Неизменяемость**: Легко создать неизменяемый объект, задавая поля через
  конструктор.
- **Избежание телескопического конструктора**: Устраняет проблему с множеством
  перегруженных конструкторов.
- **Изоляция логики**: Процесс создания отделён от структуры объекта.

### **Недостатки**

- **Увеличение кода**: Требуется отдельный класс `Builder`, что увеличивает
  количество кода.
- **Сложность для простых объектов**: Для объектов с 1-2 полями Builder может
  быть избыточным.
- **Дополнительные объекты**: Создание строителя требует выделения памяти.

### **Отличие от других паттернов**

- **Builder vs Factory Method**:
    - **Builder** фокусируется на пошаговом создании сложного объекта с
      множеством параметров.
    - **Factory Method** создаёт объект одним вызовом, определяя его тип через
      подклассы.
- **Builder vs Abstract Factory**:
    - **Builder** создаёт один объект с гибкой конфигурацией.
    - **Abstract Factory** создаёт семейства связанных объектов.
- **Builder vs Prototype**:
    - **Builder** конструирует объект с нуля, задавая параметры.
    - **Prototype** создаёт объект путём копирования существующего.

### **Проблемы и антипаттерны**

1. **Неполная инициализация**: Если клиент забудет задать обязательные
   параметры, объект может быть создан в некорректном состоянии.
    - **Решение**: Добавьте проверки в метод `build()` или сделайте обязательные
      параметры частью конструктора строителя:
      ```java
      public static class Builder {
          private final String cpu; // Обязательное поле
          private int ram;
          private int storage;
 
          public Builder(String cpu) {
              this.cpu = cpu;
          }
 
          public Computer build() {
              if (ram <= 0 || storage <= 0) {
                  throw new IllegalStateException("RAM and Storage must be set");
              }
              return new Computer(this);
          }
      }
      ```
2. **Сложность тестирования**: Тестирование объектов с множеством параметров
   может быть громоздким.
    - **Решение**: Используйте библиотеки, такие как `Test Data Builder`, или
      Lombok для упрощения.
3. **Избыточность для простых объектов**: Применение Builder к объектам с 1-2
   полями увеличивает сложность без пользы.
    - **Решение**: Используйте Builder только для сложных объектов.

### **Современные альтернативы в Java**

- **Lombok @Builder**:
  Автоматически генерирует реализацию паттерна, уменьшая шаблонный код (см.
  пример выше).
- **Java Records**:
  Для простых неизменяемых объектов можно использовать `record`, хотя они не
  поддерживают пошаговое создание:
  ```java
  record Computer(String cpu, int ram, int storage) {}
  ```
  Для сложных случаев record можно комбинировать с Builder.
- **Functional Builders**:
  В Java 8+ можно использовать функциональные интерфейсы для создания объектов:
  ```java
  Function<Consumer<Computer.Builder>, Computer> computerFactory = config -> {
      Computer.Builder builder = new Computer.Builder();
      config.accept(builder);
      return builder.build();
  };

  Computer computer = computerFactory.apply(b -> b.setCpu("Intel i7").setRam(16));
  ```

### **Итог**

Паттерн Builder — это мощный инструмент для создания сложных объектов с
множеством параметров, обеспечивающий читаемость, гибкость и неизменяемость. В
Java он широко используется в стандартной библиотеке (`StringBuilder`,
`HttpClient`) и фреймворках (Spring, Lombok). Он особенно полезен для избежания
телескопических конструкторов и упрощения работы с конфигурациями. Однако для
простых объектов Builder может быть избыточным, и в таких случаях лучше
использовать конструкторы или `record`.

---

## Фасад (Facade)

**Паттерн Facade (Фасад)** — это структурный паттерн проектирования, который
предоставляет упрощённый интерфейс к сложной подсистеме, скрывая её внутреннюю
сложность. Он действует как "единая точка входа", упрощая взаимодействие клиента
с набором классов или модулей, которые вместе решают задачу.

### **Описание паттерна**

**Цель**:

- Обеспечить простой и удобный интерфейс для работы со сложной подсистемой.
- Скрыть детали реализации подсистемы от клиента.
- Уменьшить связанность между клиентским кодом и подсистемой.

**Когда использовать**:

- Когда подсистема состоит из множества классов с сложными взаимодействиями, а
  клиенту нужен простой доступ.
- Когда требуется изолировать клиентский код от деталей реализации подсистемы.
- Когда нужно разделить подсистему на слои или предоставить точку входа для
  внешнего использования.
- Для упрощения работы с библиотеками или API с большим количеством методов.

**Примеры использования**:

- Упрощение работы с API фреймворков (например, JDBC или Hibernate).
- Управление сложными системами, такими как мультимедийные плееры или
  компиляторы.
- Обёртывание устаревших систем для интеграции с новым кодом.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/facade_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. **Фасад** предоставляет быстрый доступ к определённой функциональности
   подсистемы. Он «знает», каким классам нужно переадресовать запрос, и какие
   данные для этого нужны.
2. **Дополнительный фасад** можно ввести, чтобы не «захламлять» единственный
   фасад разнородной функциональностью. Он может использоваться как клиентом,
   так и другими фасадами.
3. **Сложная подсистема** состоит из множества разнообразных классов. Для того
   чтобы заставить их что-то делать, нужно знать подробности устройства
   подсистемы, порядок инициализации объектов и так далее.<br>
   Классы подсистемы не знают о существовании фасада и работают друг с другом
   напрямую.
4. **Клиент** использует фасад вместо прямой работы с объектами сложной
   подсистемы.

### **Реализация в Java**

Пример: фасад для упрощения работы с подсистемой домашнего кинотеатра, которая
включает DVD-плеер, проектор и аудиосистему.

```java
// Подсистема: классы с индивидуальной функциональностью
class DVDPlayer {
    public void on() {
        System.out.println("DVD Player is on");
    }

    public void play(String movie) {
        System.out.println("Playing movie: " + movie);
    }

    public void off() {
        System.out.println("DVD Player is off");
    }
}

class Projector {
    public void on() {
        System.out.println("Projector is on");
    }

    public void setInput(String input) {
        System.out.println("Projector input set to " + input);
    }

    public void off() {
        System.out.println("Projector is off");
    }
}

class AudioSystem {
    public void on() {
        System.out.println("Audio System is on");
    }

    public void setVolume(int level) {
        System.out.println("Audio volume set to " + level);
    }

    public void off() {
        System.out.println("Audio System is off");
    }
}

// Фасад
class HomeTheaterFacade {
    private final DVDPlayer dvdPlayer;
    private final Projector projector;
    private final AudioSystem audioSystem;

    public HomeTheaterFacade(DVDPlayer dvdPlayer, Projector projector, AudioSystem audioSystem) {
        this.dvdPlayer = dvdPlayer;
        this.projector = projector;
        this.audioSystem = audioSystem;
    }

    public void watchMovie(String movie) {
        System.out.println("Preparing to watch movie...");
        dvdPlayer.on();
        projector.on();
        projector.setInput("DVD");
        audioSystem.on();
        audioSystem.setVolume(5);
        dvdPlayer.play(movie);
        System.out.println("Movie started!");
    }

    public void endMovie() {
        System.out.println("Shutting down home theater...");
        dvdPlayer.off();
        projector.off();
        audioSystem.off();
        System.out.println("Home theater shut down.");
    }
}

// Клиентский код
public class FacadeExample {
    public static void main(String[] args) {
        DVDPlayer dvdPlayer = new DVDPlayer();
        Projector projector = new Projector();
        AudioSystem audioSystem = new AudioSystem();

        HomeTheaterFacade homeTheater = new HomeTheaterFacade(dvdPlayer, projector, audioSystem);

        homeTheater.watchMovie("Inception");
        // Вывод:
        // Preparing to watch movie...
        // DVD Player is on
        // Projector is on
        // Projector input set to DVD
        // Audio System is on
        // Audio volume set to 5
        // Playing movie: Inception
        // Movie started!

        homeTheater.endMovie();
        // Вывод:
        // Shutting down home theater...
        // DVD Player is off
        // Projector is off
        // Audio System is off
        // Home theater shut down.
    }
}
```

### **Как это работает**

1. Клиент создаёт экземпляры классов подсистемы (`DVDPlayer`, `Projector`,
   `AudioSystem`) и передаёт их в фасад (`HomeTheaterFacade`).
2. Фасад предоставляет высокоуровневые методы (`watchMovie`, `endMovie`),
   которые координируют работу подсистемы.
3. Клиент вызывает методы фасада, не взаимодействуя напрямую с подсистемой, что
   упрощает код и скрывает сложность.

### **Реальное использование в Java**

1. **JDBC API**:
   Класс `java.sql.DriverManager` действует как фасад, упрощая работу с
   подключением к базе данных:
   ```java
   import java.sql.Connection;
   import java.sql.DriverManager;

   Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "user", "pass");
   ```
   `DriverManager` скрывает детали загрузки драйверов и управления соединениями.

2. **SLF4J/Logging**:
   Логгеры, такие как SLF4J, предоставляют фасад для различных реализаций
   логирования (Log4j, JUL):
   ```java
   import org.slf4j.Logger;
   import org.slf4j.LoggerFactory;

   Logger logger = LoggerFactory.getLogger(MyClass.class);
   logger.info("Hello, world!");
   ```
   SLF4J скрывает выбор конкретной системы логирования.

3. **Spring Framework**:
   В Spring фасады часто используются для упрощения работы с подсистемами.
   Например, `JdbcTemplate` — это фасад для работы с JDBC:
   ```java
   import org.springframework.jdbc.core.JdbcTemplate;

   JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
   jdbcTemplate.update("INSERT INTO users (name) VALUES (?)", "Alice");
   ```
   `JdbcTemplate` скрывает сложности управления соединениями, обработки
   исключений и т.д.

### **Преимущества**

- **Упрощение интерфейса**: Клиент работает с простыми методами вместо сложной
  подсистемы.
- **Снижение связанности**: Клиентский код зависит только от фасада, а не от
  множества классов подсистемы.
- **Инкапсуляция**: Скрывает детали реализации подсистемы.
- **Гибкость**: Легко изменить или заменить подсистему, не затрагивая клиентский
  код.
- **Поддержка слоёв**: Фасад может служить точкой входа для слоя архитектуры.

### **Недостатки**

- **Ограничение функциональности**: Фасад может предоставлять только
  подмножество возможностей подсистемы.
- **Риск превращения в "божественный объект"**: Если фасад обрастает слишком
  многими методами, он может стать сложным для поддержки.
- **Дополнительный слой**: Вводит ещё один класс, что может быть избыточным для
  простых систем.

### **Отличие от других паттернов**

- **Facade vs Adapter**:
    - **Facade** упрощает интерфейс к сложной подсистеме.
    - **Adapter** преобразует интерфейс одного класса в другой, совместимый с
      клиентом.
- **Facade vs Mediator**:
    - **Facade** предоставляет упрощённый доступ к подсистеме, не координируя её
      части.
    - **Mediator** управляет взаимодействием между объектами, уменьшая их прямые
      связи.
- **Facade vs Abstract Factory**:
    - **Facade** скрывает сложность подсистемы, предоставляя высокоуровневые
      операции.
    - **Abstract Factory** создаёт семейства связанных объектов.

### **Проблемы и антипаттерны**

1. **Слишком сложный фасад**: Если фасад включает слишком много методов, он
   становится трудно поддерживаемым.
    - **Решение**: Ограничивайте фасад высокоуровневыми операциями, оставляя
      детали подсистеме.
2. **Нарушение инкапсуляции**: Если фасад предоставляет прямой доступ к объектам
   подсистемы, он теряет свою цель.
    - **Решение**: Возвращайте результаты, а не ссылки на внутренние объекты.
3. **Избыточность для простых систем**: В небольших системах фасад может быть
   ненужным усложнением.
    - **Решение**: Используйте фасад только для систем с реальной сложностью.

### **Современные альтернативы в Java**

- **Spring Service Layer**:
  В Spring сервисы часто действуют как фасады, упрощая доступ к бизнес-логике:
  ```java
  @Service
  class UserService {
      public void registerUser(String name, String email) {
          // Взаимодействие с репозиториями, валидацией и т.д.
      }
  }
  ```
- **API Gateways**:
  В микросервисной архитектуре API-шлюзы (например, Spring Cloud Gateway)
  выступают как фасады, предоставляя единый интерфейс к множеству сервисов.
- **Fluent Interfaces**:
  Для упрощения взаимодействия можно использовать цепочки вызовов вместо фасада:
  ```java
  HomeTheater theater = new HomeTheater()
          .withDVDPlayer()
          .withProjector()
          .startMovie("Inception");
  ```

### **Итог**

Паттерн Facade — это эффективный способ упростить взаимодействие со сложной
подсистемой, скрывая её детали и предоставляя удобный интерфейс. В Java он
широко используется в стандартной библиотеке (JDBC, SLF4J) и фреймворках (
Spring). Фасад снижает связанность, улучшает читаемость кода и облегчает
поддержку, но требует осторожности, чтобы не превратиться в громоздкий объект.
Он особенно полезен в системах с высокой сложностью или при интеграции с
устаревшими API.

---

## Заместитель (Proxy)

**Паттерн Proxy (Заместитель)** — это структурный паттерн проектирования,
который предоставляет объект-заместитель (прокси) для управления доступом к
другому объекту, добавляя дополнительную функциональность, такую как ленивая
инициализация, контроль доступа, логирование или кэширование, без изменения
исходного объекта. Прокси действует как посредник между клиентом и реальным
объектом.

### **Описание паттерна**

**Цель**:

- Контролировать доступ к объекту, добавляя промежуточный слой.
- Отложить создание или выполнение операций до момента, когда они действительно
  нужны.
- Предоставить дополнительную функциональность (например, проверку прав,
  кэширование).

**Когда использовать**:

- Когда нужно отложить создание дорогостоящего объекта до его фактического
  использования (ленивая инициализация).
- Когда требуется ограничить доступ к объекту (например, проверка прав).
- Когда нужно логировать операции или кэшировать результаты.
- Когда требуется управлять доступом к удалённым объектам (например, в
  распределённых системах).

**Примеры использования**:

- Ленивая загрузка данных (например, изображений в приложении).
- Проверка прав доступа перед вызовом методов сервиса.
- Прокси для удалённых объектов (например, RMI в Java).
- Кэширование результатов операций.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/proxy_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Интерфейс сервиса определяет общий интерфейс для сервиса и заместителя.
   Благодаря этому, объект заместителя можно использовать там, где ожидается
   объект сервиса.
2. Сервис содержит полезную бизнес-логику.
3. Заместитель хранит ссылку на объект сервиса. После того как заместитель
   заканчивает свою работу (например, инициализацию, логирование, защиту или
   другое), он передаёт вызовы вложенному сервису. Заместитель может сам
   отвечать за создание и удаление объекта сервиса.
4. Клиент работает с объектами через интерфейс сервиса. Благодаря этому, его
   можно «одурачить», подменив объект сервиса объектом заместителя.

### **Типы прокси**

1. **Виртуальный прокси**: Откладывает создание реального объекта до момента его
   использования (ленивая инициализация).
2. **Защитный прокси**: Контролирует доступ к объекту (например, проверяет
   права).
3. **Удалённый прокси**: Управляет доступом к объекту, расположенному в другом
   адресном пространстве (например, в распределённых системах).
4. **Кэширующий прокси**: Сохраняет результаты операций для повторного
   использования.
5. **Логирующий прокси**: Добавляет логирование вызовов методов.

### **Реализация в Java**

Пример: виртуальный прокси для ленивой загрузки изображения.

```java
// Интерфейс субъекта
interface Image {
    void display();
}

// Реальный объект
class RealImage implements Image {
    private final String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadImageFromDisk();
    }

    private void loadImageFromDisk() {
        System.out.println("Loading image: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

// Прокси
class ProxyImage implements Image {
    private RealImage realImage;
    private final String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // Ленивая инициализация
        }
        realImage.display();
    }
}

// Клиентский код
public class ProxyExample {
    public static void main(String[] args) {
        Image image = new ProxyImage("photo.jpg");

        // Изображение загружается только при первом вызове
        image.display();
        // Вывод:
        // Loading image: photo.jpg
        // Displaying image: photo.jpg

        // При повторном вызове загрузка не происходит
        image.display();
        // Вывод:
        // Displaying image: photo.jpg
    }
}
```

### **Как это работает**

1. Клиент работает с прокси (`ProxyImage`) через интерфейс `Image`, не зная, что
   это не реальный объект.
2. Прокси создаёт реальный объект (`RealImage`) только при первом вызове метода
   `display` (ленивая инициализация).
3. Последующие вызовы используют уже созданный объект, избегая повторной
   загрузки.

### **Реальное использование в Java**

1. **Java RMI (Remote Method Invocation)**:
   RMI использует удалённый прокси для доступа к объектам на другом JVM:
   ```java
   import java.rmi.Remote;
   import java.rmi.RemoteException;

   public interface MyRemote extends Remote {
       String sayHello() throws RemoteException;
   }
   ```
   Прокси-объект, созданный RMI, управляет сетевыми вызовами.

2. **Spring AOP**:
   Spring использует прокси для добавления сквозной функциональности, например,
   транзакций или логирования:
   ```java
   @Service
   class MyService {
       @Transactional
       public void doWork() { /* Логика */ }
   }
   ```
   Spring создаёт прокси, который оборачивает метод `doWork` транзакционной
   логикой.

3. **Hibernate Lazy Loading**:
   В Hibernate прокси используются для ленивой загрузки сущностей:
   ```java
   @Entity
   class User {
       @OneToMany(fetch = FetchType.LAZY)
       private List<Order> orders;
   }
   ```
   Hibernate создаёт прокси для коллекции `orders`, загружая данные только при
   обращении.

4. **Dynamic Proxy API**:
   Java предоставляет `java.lang.reflect.Proxy` для создания динамических
   прокси:
   ```java
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.Proxy;

   interface Service {
       void perform();
   }

   class RealService implements Service {
       public void perform() { System.out.println("Performing service"); }
   }

   class LoggingHandler implements InvocationHandler {
       private final Object target;

       public LoggingHandler(Object target) { this.target = target; }

       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("Before: " + method.getName());
           Object result = method.invoke(target, args);
           System.out.println("After: " + method.getName());
           return result;
       }
   }

   Service service = (Service) Proxy.newProxyInstance(
           Service.class.getClassLoader(),
           new Class[]{Service.class},
           new LoggingHandler(new RealService())
   );
   service.perform();
   // Вывод:
   // Before: perform
   // Performing service
   // After: perform
   ```

### **Преимущества**

- **Контроль доступа**: Прокси может проверять права или ограничивать операции.
- **Ленивая инициализация**: Экономит ресурсы, откладывая создание объекта.
- **Дополнительная функциональность**: Легко добавить логирование, кэширование
  или проверку.
- **Прозрачность**: Клиент работает с прокси, как с реальным объектом.
- **Изоляция**: Скрывает детали реализации подсистемы.

### **Недостатки**

- **Дополнительный слой**: Прокси добавляет сложность в архитектуру.
- **Задержки**: Ленивая инициализация может вызвать задержки при первом вызове.
- **Сложность отладки**: Прокси может затруднить отслеживание вызовов.
- **Ограничение интерфейса**: Прокси должен соответствовать интерфейсу реального
  объекта, что ограничивает добавление новых методов.

### **Отличие от других паттернов**

- **Proxy vs Decorator**:
    - **Proxy** управляет доступом или жизненным циклом объекта (например,
      ленивая инициализация).
    - **Decorator** добавляет новое поведение, сохраняя тот же интерфейс.
- **Proxy vs Adapter**:
    - **Proxy** работает с тем же интерфейсом, что и реальный объект, добавляя
      функциональность.
    - **Adapter** преобразует интерфейс одного класса в другой.
- **Proxy vs Facade**:
    - **Proxy** управляет доступом к одному объекту.
    - **Facade** упрощает интерфейс к целой подсистеме.

### **Проблемы и антипаттерны**

1. **Слишком сложный прокси**: Если прокси выполняет слишком много функций, он
   может стать трудно поддерживаемым.
    - **Решение**: Ограничивайте прокси одной задачей (например, только ленивая
      инициализация).
2. **Утечки ресурсов**: Ленивая инициализация может привести к созданию объектов
   в неподходящий момент.
    - **Решение**: Тестируйте прокси в сценариях с высокой нагрузкой.
3. **Нарушение прозрачности**: Если прокси изменяет поведение реального объекта,
   это может вызвать ошибки.
    - **Решение**: Убедитесь, что прокси строго следует интерфейсу субъекта.

### **Современные альтернативы в Java**

- **Spring AOP и Proxy**:
  Spring автоматически создаёт прокси для добавления сквозной функциональности (
  транзакции, логирование):
  ```java
  @Transactional
  public void saveData() { /* Логика */ }
  ```
- **Dynamic Proxy**:
  Использование `java.lang.reflect.Proxy` для динамического создания прокси (см.
  пример выше).
- **Bytecode Manipulation**:
  Библиотеки, такие как CGLIB, создают прокси на уровне байт-кода, что
  используется в Spring и Hibernate.
- **Functional Wrappers**:
  В Java 8+ можно использовать лямбда-выражения для обёртывания вызовов:
  ```java
  Function<String, String> loggingProxy = input -> {
      System.out.println("Processing: " + input);
      return input.toUpperCase();
  };
  ```

### **Итог**

Паттерн Proxy — это мощный инструмент для управления доступом к объектам,
добавления функциональности и оптимизации ресурсов. В Java он широко
используется в стандартной библиотеке (RMI), фреймворках (Spring, Hibernate) и
для реализации ленивой загрузки или кэширования. Прокси обеспечивает
прозрачность и гибкость, но требует осторожности, чтобы не усложнить
архитектуру. В современных приложениях динамические прокси и AOP часто заменяют
ручную реализацию.

---

## Шаблонный метод(Template Method)

**Паттерн Template Method (Шаблонный метод)** — это поведенческий паттерн
проектирования, который определяет общий алгоритм в суперклассе, позволяя
подклассам переопределять отдельные шаги этого алгоритма без изменения его общей
структуры. Он обеспечивает "скелет" алгоритма, где неизменяемая часть остаётся в
суперклассе, а изменяемые части делегируются подклассам.

### **Описание паттерна**

**Цель**:

- Определить общий алгоритм, позволяя подклассам настраивать отдельные его шаги.
- Обеспечить повторное использование кода для общей логики.
- Гарантировать, что структура алгоритма остаётся неизменной.

**Когда использовать**:

- Когда несколько классов имеют схожий алгоритм, но с различиями в отдельных
  шагах.
- Когда нужно избежать дублирования кода, вынося общую логику в суперкласс.
- Когда требуется контролировать порядок выполнения шагов алгоритма.
- Когда подклассы должны переопределять только определённые части алгоритма.

**Примеры использования**:

- Обработка данных в разных форматах (например, чтение CSV, JSON).
- Шаблоны обработки запросов в веб-приложениях (например, фильтры в Servlet
  API).
- Жизненный цикл классов в фреймворках (например, методы `onCreate` в Android).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/template_method_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Абстрактный класс определяет шаги алгоритма и содержит шаблонный метод,
   состоящий из вызовов этих шагов. Шаги могут быть как абстрактными, так и
   содержать реализацию по умолчанию.
2. Конкретный класс переопределяет некоторые (или все)шаги алгоритма. Конкретные
   классы не переопределяют сам шаблонный метод.

### **Реализация в Java**

Пример: шаблонный метод для приготовления напитков (кофе и чая), где процесс
приготовления схож, но отдельные шаги различаются.

```java
// Абстрактный класс
abstract class BeverageMaker {
    // Шаблонный метод
    public final void prepareBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    // Общие методы
    private void boilWater() {
        System.out.println("Boiling water");
    }

    private void pourInCup() {
        System.out.println("Pouring into cup");
    }

    // Абстрактные методы, которые должны реализовать подклассы
    protected abstract void brew();

    protected abstract void addCondiments();

    // Хук (hook) для необязательной настройки
    protected boolean customerWantsCondiments() {
        return true; // По умолчанию добавляем добавки
    }
}

// Конкретный класс: Кофе
class CoffeeMaker extends BeverageMaker {
    @Override
    protected void brew() {
        System.out.println("Brewing coffee grounds");
    }

    @Override
    protected void addCondiments() {
        System.out.println("Adding sugar and milk");
    }
}

// Конкретный класс: Чай
class TeaMaker extends BeverageMaker {
    @Override
    protected void brew() {
        System.out.println("Steeping tea leaves");
    }

    @Override
    protected void addCondiments() {
        System.out.println("Adding lemon");
    }

    @Override
    protected boolean customerWantsCondiments() {
        return false; // По умолчанию без добавок
    }
}

// Клиентский код
public class TemplateMethodExample {
    public static void main(String[] args) {
        System.out.println("Making Coffee:");
        BeverageMaker coffee = new CoffeeMaker();
        coffee.prepareBeverage();
        // Вывод:
        // Boiling water
        // Brewing coffee grounds
        // Pouring into cup
        // Adding sugar and milk

        System.out.println("\nMaking Tea:");
        BeverageMaker tea = new TeaMaker();
        tea.prepareBeverage();
        // Вывод:
        // Boiling water
        // Steeping tea leaves
        // Pouring into cup
    }
}
```

### **Как это работает**

1. Абстрактный класс `BeverageMaker` определяет шаблонный метод
   `prepareBeverage()`, который фиксирует порядок шагов: кипячение воды,
   заваривание, наливание в чашку и добавление добавок (если нужно).
2. Конкретные методы (`boilWater`, `pourInCup`) содержат общую логику,
   одинаковую для всех напитков.
3. Абстрактные методы (`brew`, `addCondiments`) должны быть реализованы
   подклассами (`CoffeeMaker`, `TeaMaker`).
4. Хук `customerWantsCondiments` позволяет подклассам настраивать поведение (
   например, отключить добавки для чая).
5. Клиент вызывает `prepareBeverage()` на объекте подкласса, и алгоритм
   выполняется с учётом специфичных для подкласса шагов.

### **Реальное использование в Java**

1. **Servlet API**:
   В Java Servlet API метод `service()` в `HttpServlet` действует как шаблонный
   метод:
   ```java
   import javax.servlet.http.HttpServlet;
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;

   public class MyServlet extends HttpServlet {
       @Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
           // Обработка GET-запроса
       }

       @Override
       protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
           // Обработка POST-запроса
       }
   }
   ```
   Метод `service()` в `HttpServlet` определяет общий алгоритм обработки
   HTTP-запросов, вызывая `doGet`, `doPost` и другие методы, которые
   переопределяются в подклассах.

2. **Abstract Classes в Java Collections**:
   Классы, такие как `AbstractList`, предоставляют шаблонные методы:
   ```java
   import java.util.AbstractList;

   public class MyList extends AbstractList<String> {
       private final String[] data = {"A", "B", "C"};

       @Override
       public String get(int index) {
           return data[index];
       }

       @Override
       public int size() {
           return data.length;
       }
   }
   ```
   `AbstractList` реализует общую логику списка, а подклассы переопределяют
   методы, такие как `get` и `size`.

3. **Spring Framework**:
   Spring использует Template Method в классах, таких как `JdbcTemplate`:
   ```java
   import org.springframework.jdbc.core.JdbcTemplate;

   JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
   jdbcTemplate.execute("SELECT * FROM users");
   ```
   `JdbcTemplate` определяет общий алгоритм выполнения SQL-запросов (
   подключение, выполнение, обработка ошибок), а конкретные запросы задаются
   клиентом.

### **Преимущества**

- **Повторное использование кода**: Общая логика выносится в суперкласс,
  уменьшая дублирование.
- **Контроль структуры**: Шаблонный метод гарантирует неизменность общей
  структуры алгоритма.
- **Гибкость**: Подклассы могут настраивать отдельные шаги, не затрагивая общий
  алгоритм.
- **Соответствие принципу Open/Closed**: Алгоритм открыт для расширения (новые
  подклассы), но закрыт для модификации.

### **Недостатки**

- **Ограниченность наследованием**: Подклассы должны наследовать абстрактный
  класс, что может быть неудобно в сравнении с композицией.
- **Жёсткая структура**: Изменение порядка шагов требует модификации шаблонного
  метода.
- **Сложность поддержки**: При большом числе подклассов может быть трудно
  отслеживать все переопределения.
- **Ограниченная гибкость**: Подклассы могут переопределять только те шаги,
  которые предусмотрены в суперклассе.

### **Отличие от других паттернов**

- **Template Method vs Strategy**:
    - **Template Method** использует наследование для настройки шагов алгоритма.
    - **Strategy** использует композицию, передавая алгоритм как объект.
- **Template Method vs Factory Method**:
    - **Template Method** определяет алгоритм с переопределяемыми шагами.
    - **Factory Method** фокусируется на создании объектов через абстрактный
      метод.
- **Template Method vs Builder**:
    - **Template Method** фиксирует порядок шагов для выполнения алгоритма.
    - **Builder** фокусируется на пошаговом создании объекта.

### **Проблемы и антипаттерны**

1. **Слишком жёсткий шаблон**: Если алгоритм слишком строго фиксирует шаги,
   подклассы могут быть ограничены в гибкости.
    - **Решение**: Используйте хуки или делайте больше методов защищёнными (
      `protected`), чтобы подклассы могли их переопределять.
2. **Злоупотребление наследованием**: Наследование может привести к сильной
   связанности и усложнить тестирование.
    - **Решение**: Рассмотрите Strategy или композицию для большей гибкости.
3. **Сложность тестирования**: Тестирование подклассов может быть затруднено
   из-за зависимости от суперкласса.
    - **Решение**: Используйте мок-объекты или извлекайте логику в отдельные
      классы.

### **Современные альтернативы в Java**

- **Strategy с композицией**:
  Вместо наследования можно использовать Strategy для большей гибкости:
  ```java
  interface BrewStrategy {
      void brew();
  }

  class CoffeeBrew implements BrewStrategy {
      public void brew() { System.out.println("Brewing coffee grounds"); }
  }

  class BeverageMaker {
      private final BrewStrategy brewStrategy;

      public BeverageMaker(BrewStrategy brewStrategy) {
          this.brewStrategy = brewStrategy;
      }

      public void prepareBeverage() {
          System.out.println("Boiling water");
          brewStrategy.brew();
          System.out.println("Pouring into cup");
      }
  }
  ```
- **Лямбда-выражения**:
  В Java 8+ шаги алгоритма можно передавать как лямбда-выражения:
  ```java
  class BeverageMaker {
      public void prepareBeverage(Runnable brew, Runnable addCondiments) {
          System.out.println("Boiling water");
          brew.run();
          System.out.println("Pouring into cup");
          addCondiments.run();
      }
  }

  BeverageMaker maker = new BeverageMaker();
  maker.prepareBeverage(
          () -> System.out.println("Brewing coffee grounds"),
          () -> System.out.println("Adding sugar and milk")
  );
  ```
- **Spring Template Classes**:
  Spring использует подход, похожий на Template Method, в классах, таких как
  `JdbcTemplate` или `RestTemplate`, где общая логика фиксирована, а клиент
  предоставляет детали.

### **Итог**

Паттерн Template Method — это эффективный способ определения общего алгоритма с
возможностью настройки его шагов в подклассах. Он широко используется в Java,
особенно в стандартной библиотеке (Servlet API, Collections) и фреймворках (
Spring). Паттерн обеспечивает повторное использование кода и контроль структуры,
но его зависимость от наследования может быть ограничением. В современных
приложениях Template Method иногда заменяется Strategy или лямбда-выражениями
для большей гибкости.

----

## Итератор(Iterator)

Итератор — это поведенческий паттерн проектирования, который даёт возможность
последовательно обходить элементы составных объектов, не раскрывая их
внутреннего представления. Он позволяет клиентам обходить элементы коллекции, не
зная, как они хранятся (например, в массиве, списке или хэш-таблице), и
обеспечивает единый интерфейс для работы с разными типами коллекций.

### **Описание паттерна**

**Цель**:

- Обеспечить стандартизированный способ обхода элементов коллекции.
- Скрыть детали реализации коллекции от клиента.
- Поддерживать различные способы обхода (например, прямой, обратный,
  фильтрованный).

**Когда использовать**:

- Когда нужно предоставить доступ к элементам сложной структуры данных без
  раскрытия её внутренней организации.
- Когда требуется поддерживать несколько способов обхода одной коллекции.
- Когда нужно унифицировать работу с разными типами коллекций (списки, массивы,
  деревья).
- Когда коллекция должна быть обойдена без изменения её структуры.

**Примеры использования**:

- Обход элементов коллекций в Java (`List`, `Set`, `Map`).
- Итерация по результатам базы данных (например, `ResultSet` в JDBC).
- Перебор узлов в структурах данных, таких как деревья или графы.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/iterator_structure.png" alt="factory_method" style="width: 100%; max-width: 550px">

1. Итератор описывает интерфейс для доступа и обхода элементов коллекции.
2. Конкретный итератор реализует алгоритм обхода какой-то конкретной коллекции.
   Объект итератора должен сам отслеживать текущую позицию при обходе коллекции,
   чтобы отдельные итераторы могли обходить одну и ту же коллекцию независимо.
3. Коллекция описывает интерфейс получения итератора из коллекции. Как мы уже
   говорили, коллекции не всегда являются списком. Это может быть и база данных,
   и удалённое API, и даже дерево Компоновщика. Поэтому сама коллекция может
   создавать итераторы, так как она знает, какие именно итераторы способны с ней
   работать.
4. Конкретная коллекция возвращает новый экземпляр определённого конкретного
   итератора, связав его с текущим объектом коллекции. Обратите внимание, что
   сигнатура метода возвращает интерфейс итератора. Это позволяет клиенту не
   зависеть от конкретных классов итераторов.
5. Клиент работает со всеми объектами через интерфейсы коллекции и итератора.
   Так клиентский код не зависит от конкретных классов, что позволяет применять
   различные итераторы, не изменяя существующий код программы.<br> В общем
   случае клиенты не создают объекты итераторов, а получают их из коллекций. Тем
   не менее, если клиенту требуется специальный итератор, он всегда может
   создать его самостоятельно.

### **Реализация в Java**

Пример: итератор для обхода пользовательской коллекции книг.

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс итератора
interface Iterator<T> {
    boolean hasNext();

    T next();
}

// Интерфейс агрегата
interface BookCollection {
    Iterator<Book> createIterator();
}

// Класс продукта
class Book {
    private final String title;

    public Book(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }
}

// Конкретный агрегат
class Library implements BookCollection {
    private final List<Book> books;

    public Library() {
        this.books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
    }

    @Override
    public Iterator<Book> createIterator() {
        return new LibraryIterator(books);
    }
}

// Конкретный итератор
class LibraryIterator implements Iterator<Book> {
    private final List<Book> books;
    private int index;

    public LibraryIterator(List<Book> books) {
        this.books = books;
        this.index = 0;
    }

    @Override
    public boolean hasNext() {
        return index < books.size();
    }

    @Override
    public Book next() {
        if (!hasNext()) {
            throw new IndexOutOfBoundsException("No more books");
        }
        return books.get(index++);
    }
}

// Клиентский код
public class IteratorExample {
    public static void main(String[] args) {
        Library library = new Library();
        library.addBook(new Book("The Hobbit"));
        library.addBook(new Book("1984"));
        library.addBook(new Book("Pride and Prejudice"));

        Iterator<Book> iterator = library.createIterator();
        while (iterator.hasNext()) {
            Book book = iterator.next();
            System.out.println("Book: " + book.getTitle());
        }
        // Вывод:
        // Book: The Hobbit
        // Book: 1984
        // Book: Pride and Prejudice
    }
}
```

### **Как это работает**

1. Клиент запрашивает итератор у коллекции (`Library`) через метод
   `createIterator()`.
2. Итератор (`LibraryIterator`) отслеживает текущую позицию в коллекции (с
   помощью `index`) и предоставляет методы `hasNext()` и `next()` для доступа к
   элементам.
3. Клиент использует итератор для последовательного обхода элементов, не зная,
   как они хранятся в коллекции (например, в `ArrayList`).
4. Коллекция остаётся неизменной, а итератор управляет процессом обхода.

### **Реальное использование в Java**

Java имеет встроенную поддержку паттерна Iterator через интерфейсы
`java.util.Iterator` и `java.util.Iterable`, которые используются повсеместно в
стандартной библиотеке.

1. **Collections Framework**:
   Все коллекции, реализующие `Iterable` (например, `List`, `Set`, `Map`),
   предоставляют итератор:
   ```java
   import java.util.ArrayList;
   import java.util.Iterator;

   ArrayList<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");

   Iterator<String> iterator = list.iterator();
   while (iterator.hasNext()) {
       System.out.println(iterator.next());
   }
   ```
   Или с использованием цикла `for-each`, который автоматически использует
   итератор:
   ```java
   for (String item : list) {
       System.out.println(item);
   }
   ```

2. **JDBC ResultSet**:
   `ResultSet` в JDBC реализует итератор для обхода строк результата запроса:
   ```java
   import java.sql.ResultSet;
   import java.sql.Statement;
   import java.sql.Connection;

   try (Connection conn = getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {
       while (rs.next()) {
           System.out.println(rs.getString("name"));
       }
   }
   ```

3. **Stream API**:
   В Java 8+ итераторы частично заменены Stream API, но они всё ещё используются
   под капотом:
   ```java
   import java.util.List;

   List<String> list = List.of("A", "B", "C");
   list.stream().forEach(System.out::println);
   ```

### **Преимущества**

- **Инкапсуляция**: Скрывает внутреннюю структуру коллекции от клиента.
- **Универсальность**: Предоставляет единый интерфейс для обхода разных типов
  коллекций.
- **Гибкость**: Поддерживает различные способы обхода (например, прямой,
  обратный, фильтрованный).
- **Безопасность**: Позволяет обходить коллекцию без её модификации.
- **Поддержка for-each**: В Java коллекции, реализующие `Iterable`,
  автоматически работают с циклом `for-each`.

### **Недостатки**

- **Ограниченная функциональность**: Классический итератор поддерживает только
  последовательный доступ (нет возможности вернуться назад или пропустить
  элементы).
- **Сложность для сложных структур**: Реализация итератора для деревьев или
  графов может быть нетривиальной.
- **Потенциальные проблемы с concorrency**: Итератор может выбросить
  `ConcurrentModificationException`, если коллекция изменяется во время обхода.
- **Менее мощный, чем Stream API**: В современных Java-приложениях Stream API
  часто предпочтительнее для сложных операций.

### **Отличие от других паттернов**

- **Iterator vs Composite**:
    - **Iterator** предоставляет способ обхода элементов коллекции.
    - **Composite** управляет древовидной структурой объектов, позволяя работать
      с группами как с единым объектом.
- **Iterator vs Visitor**:
    - **Iterator** фокусируется на последовательном доступе к элементам.
    - **Visitor** позволяет выполнять операции над элементами, передавая логику
      в отдельный объект.
- **Iterator vs Strategy**:
    - **Iterator** определяет способ обхода коллекции.
    - **Strategy** определяет взаимозаменяемые алгоритмы для выполнения задачи.

### **Проблемы и антипаттерны**

1. **ConcurrentModificationException**: Если коллекция изменяется во время
   итерации, итератор может выбросить исключение.
    - **Решение**: Используйте `CopyOnWriteArrayList` или синхронизируйте доступ
      к коллекции.
    - **Альтернатива**: Используйте Stream API, которая работает с неизменяемыми
      данными.
2. **Сложность реализации для нестандартных структур**: Итераторы для деревьев
   или графов требуют сложной логики.
    - **Решение**: Используйте рекурсию или библиотеки, такие как Guava, для
      упрощения.
3. **Злоупотребление итератором**: Использование итератора для простых
   коллекций, где достаточно `for-each` или Stream.
    - **Решение**: Применяйте итератор только для сложных или нестандартных
      сценариев.

### **Современные альтернативы в Java**

- **Stream API**:
  В Java 8+ Stream API предоставляет более мощный и декларативный способ
  обработки коллекций:
  ```java
  List<String> list = List.of("A", "B", "C");
  list.stream()
      .filter(s -> s.startsWith("A"))
      .forEach(System.out::println);
  ```
  Stream API поддерживает ленивые вычисления, параллелизм и сложные операции (
  фильтрация, маппинг).

- **Spliterator**:
  В Java 8 введён `Spliterator` (Splittable Iterator), который поддерживает
  параллельную обработку:
  ```java
  import java.util.Spliterator;
  import java.util.List;

  List<String> list = List.of("A", "B", "C");
  Spliterator<String> spliterator = list.spliterator();
  spliterator.forEachRemaining(System.out::println);
  ```

- **Guava Iterators**:
  Библиотека Guava предоставляет утилиты для работы с итераторами, такие как
  `Iterators.filter` или `Iterators.transform`:
  ```java
  import com.google.common.collect.Iterators;
  import java.util.Iterator;

  Iterator<String> filtered = Iterators.filter(list.iterator(), s -> s.startsWith("A"));
  ```

### **Итог**

Паттерн Iterator — это фундаментальный инструмент для последовательного доступа
к элементам коллекции, скрывающий её внутреннюю структуру. В Java он встроен в
стандартную библиотеку через `Iterator` и `Iterable`, что делает его основой для
работы с коллекциями. Хотя Stream API и Spliterator в современных приложениях
часто заменяют классический итератор для сложных операций, паттерн остаётся
актуальным для нестандартных коллекций или случаев, где требуется явный контроль
над обходом.