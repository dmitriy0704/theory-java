# Паттерны проектирования

---
Популярные:

1. Одиночка (Singleton)
2. Фабричный метод (Factory Method)
3. Абстрактная фабрика ( Abstract Factory)
4. Декоратор (Decorator)
5. Наблюдатель (Observer)
6. Стратегия (Strategy)

Дополнительно:

1. Прототип (Prototype)
2. Строитель (Builder)
3. Фасад (Facade)
4. Заместитель (Proxy)
5. Шаблонный метод(Template Method)
6. Итератор(Iterator)

---


Основные паттерны проектирования в Java делятся на три категории: порождающие,
структурные и поведенческие. Вот краткий обзор с основными примерами:

### 1. **Порождающие паттерны** (Creational Patterns)

Отвечают за создание объектов, упрощая их инициализацию и управление.

- **Фабричный метод (Factory Method)**: Определяет интерфейс для создания
  объектов, позволяя подклассам решать, какой класс создавать. Пример: создание
  разных типов документов в редакторе.
- **Абстрактная фабрика (Abstract Factory)**: Создает семейства связанных
  объектов без указания их конкретных классов. Пример: создание UI-элементов для
  разных ОС.
- **Одиночка (Singleton)**: Гарантирует, что у класса только один экземпляр, и
  предоставляет к нему глобальную точку доступа. Пример: логгер или пул
  соединений.
- **Строитель (Builder)**: Разделяет создание сложного объекта от его
  представления. Пример: создание сложных объектов, таких как HTML-документы.
- **Прототип (Prototype)**: Создает новые объекты путем копирования
  существующего. Пример: клонирование объектов в графическом редакторе.

### 2. **Структурные паттерны** (Structural Patterns)

Определяют, как объекты и классы объединяются в более крупные структуры.

- **Адаптер (Adapter)**: Преобразует интерфейс одного класса в интерфейс,
  ожидаемый клиентом. Пример: адаптация старого API к новому.
- **Мост (Bridge)**: Разделяет абстракцию и реализацию, позволяя изменять их
  независимо. Пример: разделение логики рисования фигур и их рендеринга.
- **Компоновщик (Composite)**: Объединяет объекты в древовидные структуры для
  работы с ними как с единым объектом. Пример: структура GUI-компонентов.
- **Декоратор (Decorator)**: Динамически добавляет обязанности объекту. Пример:
  добавление функционала к потоку ввода-вывода.
- **Фасад (Facade)**: Предоставляет упрощенный интерфейс к сложной подсистеме.
  Пример: упрощение работы с библиотекой.
- **Легковес (Flyweight)**: Экономит память, разделяя состояние объектов.
  Пример: повторное использование символов в текстовом редакторе.
- **Заместитель (Proxy)**: Контролирует доступ к объекту, добавляя
  дополнительную логику. Пример: ленивая загрузка изображений.

### 3. **Поведенческие паттерны** (Behavioral Patterns)

Регулируют взаимодействие и распределение обязанностей между объектами.

- **Цепочка обязанностей (Chain of Responsibility)**: Передает запрос по цепочке
  обработчиков. Пример: обработка событий в GUI.
- **Команда (Command)**: Инкапсулирует запрос как объект, позволяя передавать
  его как параметр. Пример: реализация операций "отмена/повтор".
- **Итератор (Iterator)**: Предоставляет способ последовательного доступа к
  элементам коллекции. Пример: обход списка или массива.
- **Посредник (Mediator)**: Упрощает взаимодействие между объектами, централизуя
  управление. Пример: чат между пользователями.
- **Снимок (Memento)**: Сохраняет состояние объекта для последующего
  восстановления. Пример: сохранение состояния игры.
- **Наблюдатель (Observer)**: Определяет зависимость "один ко многим", уведомляя
  объекты об изменениях. Пример: подписка на события.
- **Состояние (State)**: Позволяет объекту изменять поведение в зависимости от
  состояния. Пример: автомат с напитками.
- **Стратегия (Strategy)**: Определяет семейство алгоритмов и позволяет их
  взаимозаменяемость. Пример: сортировка разными алгоритмами.
- **Шаблонный метод (Template Method)**: Определяет скелет алгоритма, позволяя
  подклассам переопределять шаги. Пример: процесс обработки данных.
- **Посетитель (Visitor)**: Разделяет алгоритм от структуры данных, позволяя
  добавлять новые операции. Пример: обход дерева объектов.

### Примечания:

- Эти паттерны описаны в книге "Design Patterns" (Gang of Four) и широко
  применяются в Java.
- В Java некоторые паттерны реализуются проще благодаря встроенным механизмам (
  например, `Iterator` в коллекциях или `Observer` в `java.util.Observable`).
- Выбор паттерна зависит от задачи: изучайте контекст и проблему, чтобы избежать
  избыточной сложности.

---

# ПОДРОБНО

Паттерны проектирования GoF (Gang of Four) из книги *Design Patterns: Elements
of Reusable Object-Oriented Software* широко используются в программировании,
включая Java. Некоторые из них более популярны, чем другие, благодаря их
универсальности, простоте применения и частоте встречающихся задач, которые они
решают. Популярность паттернов зависит от контекста, но на основе опыта
разработки, анализа Stack Overflow, GitHub и обсуждений в сообществе Java можно
выделить наиболее часто используемые паттерны GoF.

Ниже приведены **самые популярные паттерны GoF**, их описание, примеры
применения в Java и причины их популярности.

---

## 1. **Singleton (Одиночка)**

**Паттерн Singleton (Одиночка)** — это порождающий паттерн проектирования,
который гарантирует, что у класса есть только один экземпляр, и предоставляет
глобальную точку доступа к этому экземпляру. Он часто используется в ситуациях,
когда требуется единый доступ к ресурсу или состоянию, например, для логгеров,
конфигураций или пулов соединений.

### **Описание паттерна**

**Цель**:

- Обеспечить существование только одного экземпляра класса.
- Предоставить глобальную точку доступа к этому экземпляру.

**Когда использовать**:

- Необходим ровно один экземпляр класса (например, для управления доступом к
  общему ресурсу).
- Требуется глобальная точка доступа (например, для логгера или конфигурации).
- Создание нескольких экземпляров дорого или нежелательно.

**Примеры использования**:

- Логгер (`java.util.logging.Logger` или `SLF4J`).
- Пул соединений с базой данных.
- Кэш или конфигурация приложения.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/singleton_structure.png" alt="singleton" width="75%" style="max-width: 550px">

1. **Приватный конструктор**: Предотвращает создание экземпляров извне.
2. **Статическая переменная**: Хранит единственный экземпляр класса.
3. **Статический метод**: Предоставляет доступ к экземпляру (обычно называется
   `getInstance()`).

### **Реализация в Java**

Существует несколько способов реализации Singleton в Java, каждый с учётом
потокобезопасности и производительности. Рассмотрим основные варианты.

#### **1. Простой Singleton (не потокобезопасный)**

```java
public class Singleton {
    // Хранит единственный экземпляр класса.
    private static Singleton instance;

    // Предотвращает создание экземпляров извне.
    private Singleton() {
    } // Приватный конструктор

    // Предоставляет доступ к экземпляру (обычно называется `getInstance()`)
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**Проблема**: Не подходит для многопоточных приложений, так как несколько
потоков могут одновременно создать разные экземпляры.

#### **2. Двойная проверка блокировки (Double-Checked Locking)**

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**Плюсы**: Потокобезопасен, минимизирует накладные расходы синхронизации.  
**Особенности**: Ключевое слово `volatile` предотвращает проблемы с частичной
инициализацией объекта в многопоточной среде.

### **Пример реального использования**

Допустим, нам нужен логгер, который используется во всём приложении:

```java
public class Logger {
    private static final Logger instance = new Logger();

    private Logger() {
    }

    public static Logger getInstance() {
        return instance;
    }

    public void log(String message) {
        System.out.println("Log: " + message);
    }
}

public class Application {
    public static void main(String[] args) {
        Logger logger = Logger.getInstance();
        logger.log("Application started");
    }
}
```

### **Проблемы и антипаттерны**

**_Проблема:_**

Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности
класса.

1. Гарантирует наличие единственного экземпляра класса. Чаще всего это полезно
   для доступа к какому-то общему ресурсу, например, базе данных.
2. Предоставляет глобальную точку доступа. Это не просто глобальная переменная,
   через которую можно достучаться к определённому объекту. Глобальные
   переменные не защищены от записи, поэтому любой код может подменять их
   значения без вашего ведома. Но есть и другой нюанс. Неплохо бы хранить в
   одном месте и код, который решает проблему №1, а также иметь к нему простой и
   доступный интерфейс.

**_Решение:_**

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и
создать публичный статический метод, который и будет контролировать жизненный
цикл объекта-одиночки.
Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому
статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет
отдавать один и тот же объект.

Singleton, несмотря на популярность, может стать антипаттерном, если
используется неправильно:

1. **Скрытые зависимости**: Классы, использующие Singleton, напрямую зависят от
   его реализации, что затрудняет тестирование.

- **Решение**: Используйте Dependency Injection (например, Spring), чтобы
  передавать зависимости явно.

2. **Проблемы с тестированием**: Статическое состояние Singleton сохраняется
   между тестами.

- **Решение**: Добавьте метод для сброса состояния в тестах или используйте
  мок-объекты.

3. **Потокобезопасность**: Неправильная реализация может привести к созданию
   нескольких экземпляров.

- **Решение**: Используйте варианты с двойной проверкой или Holder.

4. **Глобальное состояние**: Может привести к трудно отслеживаемым побочным
   эффектам.

- **Решение**: Минимизируйте использование Singleton для объектов с изменяемым
  состоянием.

### **Современные альтернативы в Java**

В современных Java-приложениях Singleton часто заменяется другими подходами:

- **Dependency Injection**: Фреймворки, такие как Spring, создают и управляют
  единственным экземпляром объекта (например, `@Bean` с областью `singleton`).
  ```java
  @Component
  public class Logger {
      public void log(String message) {
          System.out.println("Log: " + message);
      }
  }
  ```
  Spring гарантирует, что `Logger` будет единственным экземпляром.
- **Enum Singleton**: Использование перечислений для реализации Singleton (по
  Джошуа Блоху).
  ```java
  public enum Singleton {
      INSTANCE;

      public void doSomething() {
          System.out.println("Doing something");
      }
  }
  ```
  **Плюсы**: Простота, потокобезопасность, защита от рефлексии и сериализации.

### **Преимущества Singleton**

- Гарантирует единственный экземпляр.
- Упрощает доступ к общему ресурсу.
- Ленивая инициализация (в некоторых реализациях) экономит ресурсы.

### **Недостатки Singleton**

- Может привести к скрытым зависимостям.
- Усложняет модульное тестирование.
- Потенциальные проблемы в многопоточной среде.
- Нарушение принципа единственной ответственности, если Singleton выполняет
  слишком много функций.

### **Когда НЕ использовать Singleton**

- Если класс имеет изменяемое состояние, которое должно быть независимым для
  разных контекстов.
- Когда требуется несколько экземпляров в будущем (Singleton трудно
  переработать).
- В тестах, где нужно подменять реализацию (лучше использовать DI).

### **Итог**

Singleton — это мощный и популярный паттерн, особенно в Java, благодаря своей
простоте и встроенной поддержке в языке (например, статические поля). Однако его
следует использовать с осторожностью, чтобы избежать антипаттернов. В
современных приложениях часто предпочтительнее использовать Dependency Injection
через фреймворки, такие как Spring, или enum-реализацию для простых случаев.

---

## 2.1 Фабричный метод

**Паттерн Factory Method (Фабричный метод)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания объектов в
суперклассе, позволяя подклассам определять, какой конкретный класс создавать.
Он помогает делегировать процесс создания объектов подклассам, обеспечивая
гибкость и расширяемость.

Фабричный метод — это порождающий паттерн проектирования, который определяет
общий интерфейс для создания объектов в суперклассе, позволяя подклассам
изменять тип создаваемых объектов.

### **Описание паттерна**

**Цель**:

- Определить интерфейс для создания объектов, позволяя подклассам решать, какой
  класс создавать.
- Изолировать процесс создания объектов от их использования.

**Когда использовать**:

- Когда заранее неизвестно, какие именно объекты нужно создавать.
- Когда вы хотите предоставить подклассам возможность определять создаваемые
  объекты.
- Когда нужно обеспечить расширяемость системы для добавления новых типов
  объектов.

**Примеры использования**:

- Создание различных реализаций соединений с базой данных
  (`java.sql.DriverManager`).
- Генерация документов разных форматов (PDF, Word).
- Создание UI-компонентов, зависящих от платформы (Windows, macOS).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/factory_method_structure.png" alt="factory_method" width="75%" style="max-width: 550px">

1. **Продукт (Product)**: общий интерфейс объектов, которые может произвести
   создатель и его подклассы.
2. **Конкретный продукт (Concrete Product)**: содержит код различных продуктов.
   Продукты будут отличаться реализацией, но интерфейс у них будет общий.
3. **Создатель (Creator)**: Абстрактный класс или интерфейс, содержащий
   фабричный метод (обычно абстрактный). <br>
   Создатель объявляет фабричный метод, который должен возвращать новые объекты
   продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом
   продуктов.<br>
   Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы
   реализовать его по-своему. Но он может возвращать и некий стандартный
   продукт.<br>
   Несмотря на название, важно понимать, что создание продуктов не является
   единственной функцией создателя. Обычно он содержит и другой полезный код
   работы с продуктом. Аналогия: большая софтверная компания может иметь центр
   подготовки программистов, но основная задача компании — создавать программные
   продукты, а не готовить программистов.
4. **Конкретный создатель (Concrete Creator)**: Подклассы, реализующие фабричный
   метод для создания конкретных продуктов.

### **Реализация в Java**

Ниже приведён пример реализации паттерна Factory Method для создания
транспортных средств (например, автомобилей и мотоциклов).

```java
// Интерфейс продукта
interface Vehicle {
    void drive();
}

// Конкретные продукты
class Car implements Vehicle {
    public void drive() {
        System.out.println("Driving a car");
    }
}

class Motorcycle implements Vehicle {
    public void drive() {
        System.out.println("Riding a motorcycle");
    }
}

// Абстрактный создатель
abstract class VehicleFactory {
    // Фабричный метод переопределяется в подклассах, 
    // чтобы изменить тип создаваемого продукта
    public abstract Vehicle createVehicle();

    // Метод, использующий фабричный метод
    public void deliverVehicle() {
        Vehicle vehicle = createVehicle();
        vehicle.drive();
    }
}

// Конкретные создатели
class CarFactory extends VehicleFactory {
    public Vehicle createVehicle() {
        return new Car();
    }
}

class MotorcycleFactory extends VehicleFactory {
    public Vehicle createVehicle() {
        return new Motorcycle();
    }
}

// Клиентский код
public class FactoryMethodExample {
    public static void main(String[] args) {
        VehicleFactory carFactory = new CarFactory();
        carFactory.deliverVehicle(); // Вывод: Driving a car

        VehicleFactory motorcycleFactory = new MotorcycleFactory();
        motorcycleFactory.deliverVehicle(); // Вывод: Riding a motorcycle
    }
}
```

### **Как это работает**

1. Клиент работает с абстрактным классом `VehicleFactory` и вызывает метод
   `deliverVehicle()`.
2. Конкретные фабрики (`CarFactory`, `MotorcycleFactory`) реализуют
   `createVehicle()`, возвращая нужный объект (`Car` или `Motorcycle`).
3. Клиент не знает, какой конкретный класс создаётся, что делает код гибким и
   независимым от конкретных реализаций.

### **Преимущества**

- **Гибкость**: Легко добавить новый тип продукта, создав новый подкласс фабрики
  и продукта.
- **Соответствие принципу Open/Closed**: Система открыта для расширения (новые
  продукты), но закрыта для модификации.
- **Изоляция**: Клиентский код работает с абстракциями, а не с конкретными
  классами.
- **Упрощение тестирования**: Можно подменять реализации продуктов в тестах.

### **Недостатки**

- **Усложнение кода**: Для каждого нового продукта нужно создавать новый класс
  фабрики.
- **Дополнительные классы**: Может увеличить количество классов в проекте.

### **Пример реального использования в Java**

В стандартной библиотеке Java паттерн Factory Method встречается, например, в
`java.util.Calendar`:

```java
Calendar calendar = Calendar.getInstance(); // Фабричный метод
```

- `getInstance()` возвращает конкретную реализацию `Calendar` (например,
  `GregorianCalendar`) в зависимости от локали и конфигурации.
- Клиент не знает, какой конкретный класс возвращается, но может работать с
  абстрактным интерфейсом.

Другой пример — Spring Framework:

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
MyBean bean = context.getBean(MyBean.class);
```

`ApplicationContext` действует как фабрика, создавая объекты (beans) на основе
конфигурации.

### **Отличие от других паттернов**

- **Factory Method vs Abstract Factory**:
    - Factory Method создаёт один тип продукта через один фабричный метод.
    - Abstract Factory создаёт семейство связанных продуктов (например,
      UI-компоненты для разных платформ).
- **Factory Method vs Simple Factory**:
    - Simple Factory — это не паттерн GoF, а упрощённый подход, где один класс
      содержит логику создания объектов (обычно с использованием `switch` или
      `if`).
    - Factory Method использует наследование и делегирует создание подклассам.
- **Factory Method vs Builder**:
    - Factory Method фокусируется на создании одного объекта с минимальной
      настройкой.
    - Builder используется для пошагового конструирования сложных объектов.

### **Проблемы и антипаттерны**

1. **Слишком много фабрик**: Если для каждого продукта создаётся отдельная
   фабрика, код может стать громоздким.

- **Решение**: Рассмотрите Abstract Factory или Simple Factory для простых
  случаев.

2. **Жёсткая привязка к иерархии**: Требует создания подклассов для каждого
   нового продукта.

- **Решение**: Используйте параметризованные фабрики или Dependency Injection (
  например, в Spring).

3. **Сложность тестирования**: Если фабрика возвращает сложные объекты, может
   быть трудно подменять их в тестах.

- **Решение**: Используйте интерфейсы и мок-объекты (например, с Mockito).

### **Современные альтернативы в Java**

- **Dependency Injection**: Фреймворки, такие как Spring или Guice, часто
  заменяют Factory Method, управляя созданием объектов через контейнер.
  ```java
  @Component
  class Car implements Vehicle {
      public void drive() { System.out.println("Driving a car"); }
  }

  @Autowired
  private Vehicle vehicle; // Spring создаёт объект
  ```
- **Лямбда-выражения**: В Java 8+ можно использовать функциональные интерфейсы
  для создания объектов:
  ```java
  Supplier<Vehicle> carFactory = Car::new;
  Vehicle vehicle = carFactory.get();
  ```

### **Итог**

Factory Method — это мощный паттерн, который помогает создавать объекты,
сохраняя гибкость и расширяемость системы. Он особенно полезен, когда тип
создаваемого объекта зависит от контекста или конфигурации. В Java он часто
встречается в стандартной библиотеке и фреймворках, таких как Spring. Однако для
простых случаев можно использовать более лёгкие альтернативы, такие как Simple
Factory или DI.

---

## 2.2 Абстрактная фабрика

Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет
создавать семейства связанных объектов, не привязываясь к конкретным классам
создаваемых объектов.

**Паттерн Abstract Factory (Абстрактная фабрика)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания семейств связанных
или взаимозависимых объектов без указания их конкретных классов. Он позволяет
создавать группы объектов, которые работают вместе, обеспечивая совместимость
между ними.

### **Описание паттерна**

**Цель**:

- Создавать семейства связанных объектов, не привязываясь к их конкретным
  классам.
- Гарантировать, что создаваемые объекты совместимы друг с другом.

**Когда использовать**:

- Когда система должна поддерживать несколько семейств объектов (например,
  UI-компоненты для разных платформ: Windows, macOS).
- Когда нужно гарантировать совместимость создаваемых объектов.
- Когда требуется изолировать клиентский код от конкретных реализаций.

**Примеры использования**:

- Создание UI-компонентов (кнопки, текстовые поля) для разных операционных
  систем.
- Генерация объектов для разных баз данных (например, драйверы и соединения для
  MySQL, PostgreSQL).
- Поддержка различных тем оформления в приложении (светлая, тёмная).

### Структура паттерна

<img src="/img/design_pattern/design_patterns/abstract_factory_structure.png" alt="factory_method" style="max-width: 550px">

1. Абстрактные продукты объявляют интерфейсы продуктов, которые связаны друг с
   другом по смыслу, но выполняют разные функции.
2. Конкретные продукты — большой набор классов, которые относятся к различным
   абстрактным продуктам (кресло/столик), но имеют одни и те же вариации (
   Викторианский/Модерн).
3. Абстрактная фабрика объявляет методы создания различных абстрактных
   продуктов (кресло/столик).
4. Конкретные фабрики относятся каждая к своей вариации продуктов (
   Викторианский/Модерн) и реализуют методы абстрактной фабрики, позволяя
   создавать все продукты определённой вариации.
5. Несмотря на то, что конкретные фабрики порождают конкретные продукты,
   сигнатуры их методов должны возвращать соответствующие абстрактные продукты.
   Это позволит клиентскому коду, использующему фабрику, не привязываться к
   конкретным классам продуктов. Клиент сможет работать с любыми вариациями
   продуктов через абстрактные интерфейсы.

### **Реализация в Java**

Пример: создание UI-компонентов (кнопок и текстовых полей) для разных
операционных систем (Windows и macOS).

```java
// Абстрактные продукты
interface Button {
    void render();
}

interface TextField {
    void input();
}

// Конкретные продукты для Windows
class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering Windows Button");
    }
}

class WindowsTextField implements TextField {
    public void input() {
        System.out.println("Input in Windows TextField");
    }
}

// Конкретные продукты для macOS
class MacOSButton implements Button {
    public void render() {
        System.out.println("Rendering macOS Button");
    }
}

class MacOSTextField implements TextField {
    public void input() {
        System.out.println("Input in macOS TextField");
    }
}

// Абстрактная фабрика
interface UIFactory {
    Button createButton();

    TextField createTextField();
}

// Конкретные фабрики
class WindowsUIFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public TextField createTextField() {
        return new WindowsTextField();
    }
}

class MacOSUIFactory implements UIFactory {
    public Button createButton() {
        return new MacOSButton();
    }

    public TextField createTextField() {
        return new MacOSTextField();
    }
}

// Клиентский код
public class Application {
    private final Button button;
    private final TextField textField;

    public Application(UIFactory factory) {
        this.button = factory.createButton();
        this.textField = factory.createTextField();
    }

    public void renderUI() {
        button.render();
        textField.input();
    }

    public static void main(String[] args) {
        UIFactory windowsFactory = new WindowsUIFactory();
        Application windowsApp = new Application(windowsFactory);
        windowsApp.renderUI(); // Вывод: Rendering Windows Button, Input in Windows TextField

        UIFactory macOSFactory = new MacOSUIFactory();
        Application macOSApp = new Application(macOSFactory);
        macOSApp.renderUI(); // Вывод: Rendering macOS Button, Input in macOS TextField
    }
}
```

### **Как это работает**

1. Клиентский код работает с абстрактной фабрикой (`UIFactory`) и абстрактными
   продуктами (`Button`, `TextField`).
2. Конкретная фабрика (`WindowsUIFactory` или `MacOSUIFactory`) создаёт
   семейство совместимых продуктов (например, только Windows-компоненты).
3. Клиент не знает, какие конкретные классы создаются, что делает систему гибкой
   и независимой от реализаций.

### **Преимущества**

- **Совместимость продуктов**: Гарантирует, что создаваемые объекты принадлежат
  одному семейству (например, Windows-кнопка не смешивается с macOS-полем).
- **Гибкость**: Легко добавить новое семейство продуктов, создав новую фабрику.
- **Соответствие принципу Open/Closed**: Система открыта для расширения (новые
  фабрики), но закрыта для модификации.
- **Изоляция**: Клиентский код работает с абстракциями, а не с конкретными
  классами.

### **Недостатки**

- **Усложнение кода**: Требует создания множества классов (фабрики, продукты).
- **Дополнительная абстракция**: Может быть избыточной для простых систем.
- **Сложность поддержки**: При добавлении нового продукта нужно обновлять все
  фабрики.

### **Пример реального использования в Java**

1. **Java AWT/Swing**:
   В Java библиотеки для создания UI (AWT и Swing) используют паттерн, похожий
   на Abstract Factory, для создания компонентов, специфичных для платформы.
   Например, `Toolkit` действует как фабрика, создающая платформозависимые
   компоненты:
   ```java
   import java.awt.*;
   Button button = Toolkit.getDefaultToolkit().createButton("Click me");
   ```
   `Toolkit` возвращает компоненты, соответствующие текущей ОС.

2. **JDBC** В JDBC разные драйверы (MySQL, PostgreSQL) предоставляют семейства
   объектов (соединения, подготовленные запросы), что можно рассматривать как
   реализацию Abstract Factory.

3. **Spring Framework**:
   Spring `ApplicationContext` может создавать семейства связанных beans, что
   напоминает Abstract Factory:
   ```java
   ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
   ```

### **Отличие от других паттернов**

- **Abstract Factory vs Factory Method**:
    - **Abstract Factory** создаёт семейство связанных продуктов (например,
      кнопка и текстовое поле).
    - **Factory Method** создаёт один продукт, а подклассы определяют его тип.
- **Abstract Factory vs Builder**:
    - **Abstract Factory** фокусируется на создании семейства объектов сразу.
    - **Builder** используется для пошагового конструирования одного сложного
      объекта.
- **Abstract Factory vs Simple Factory**:
    - **Simple Factory** — упрощённый подход, где один класс создаёт объекты на
      основе параметра.
    - **Abstract Factory** работает с семействами объектов и использует иерархию
      фабрик.

### **Проблемы и антипаттерны**

1. **Слишком много классов**: Большое количество продуктов и фабрик может
   усложнить проект.
   **Решение**: Используйте Abstract Factory только для сложных систем с
   несколькими семействами объектов.
2. **Жёсткая структура**: Добавление нового продукта требует изменения всех
   фабрик.
   **Решение**: Рассмотрите параметризованные фабрики или DI для большей
   гибкости.
3. **Сложность тестирования**: Тестирование может быть затруднено из-за
   множества зависимостей.
   **Решение**: Используйте мок-объекты (например, с Mockito) для подмены
   фабрик.

### **Современные альтернативы в Java**

- **Dependency Injection**: Фреймворки, такие как Spring или Guice, могут
  заменить Abstract Factory, управляя созданием семейств объектов:
  ```java
  @Component
  class WindowsButton implements Button { /* ... */ }

  @Component
  class WindowsTextField implements TextField { /* ... */ }

  @Autowired
  private UIFactory uiFactory; // Spring предоставляет нужную фабрику
  ```
- **Функциональные интерфейсы**: В Java 8+ можно использовать `Supplier` для
  создания объектов:
  ```java
  Supplier<Button> buttonFactory = WindowsButton::new;
  Button button = buttonFactory.get();
  ```

### **Итог**

Abstract Factory — мощный паттерн для создания семейств совместимых объектов,
особенно в системах, где требуется поддержка нескольких вариантов реализации
(например, платформ, тем, баз данных). Он обеспечивает гибкость и изоляцию
клиентского кода от конкретных классов, но может усложнить архитектуру из-за
большого количества классов. В современных Java-приложениях его часто заменяют
или дополняют DI-фреймворки, такие, как Spring.


---

## 3. **Observer (Наблюдатель)**

Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм
подписки, позволяющий одним объектам следить и реагировать на события,
происходящие в других объектах.

**Паттерн Observer (Наблюдатель)** — это поведенческий паттерн проектирования,
который устанавливает зависимость "один ко многим" между объектами, чтобы при
изменении состояния одного объекта (субъекта) все зависимые объекты (
наблюдатели) автоматически уведомлялись и обновлялись. Этот паттерн широко
используется в событийно-ориентированных системах, где изменения в одном
компоненте должны отражаться в других.

### **Описание паттерна**

**Цель**:

- Обеспечить механизм уведомления нескольких объектов об изменениях состояния
  другого объекта.
- Поддерживать слабую связанность между субъектом и наблюдателями.

**Когда использовать**:

- Когда изменение состояния одного объекта должно автоматически обновлять другие
  объекты (например, обновление UI при изменении данных).
- В системах, основанных на событиях (например, GUI, обработка кликов мыши).
- Для реализации моделей "паблишер-субскрайбер" (publisher-subscriber).
- Когда нужно динамически добавлять или удалять наблюдателей.

**Примеры использования**:

- Обновление пользовательского интерфейса при изменении модели (паттерн MVC).
- Слушатели событий в Java (например, `ActionListener` в Swing).
- Реактивные системы (например, RxJava, Project Reactor).
- Уведомления в мессенджерах или новостных лентах.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/observer_structure.png" alt="factory_method" style="max-width: 550px">

1. Издатель владеет внутренним состоянием, изменение которого интересно
   отслеживать подписчикам. Издатель содержит механизм подписки: список
   подписчиков и методы подписки/отписки.
2. Когда внутреннее состояние издателя меняется, он оповещает своих подписчиков.
   Для этого издатель проходит по списку подписчиков и вызывает их метод
   оповещения, заданный в общем интерфейсе подписчиков.
3. Подписчик определяет интерфейс, которым пользуется издатель для отправки
   оповещения. В большинстве случаев для этого достаточно единственного метода.
4. Конкретные подписчики выполняют что-то в ответ на оповещение, пришедшее от
   издателя. Эти классы должны следовать общему интерфейсу подписчиков, чтобы
   издатель не зависел от конкретных классов подписчиков.
5. По приходу оповещения подписчику нужно получить обновлённое состояние
   издателя. Издатель может передать это состояние через параметры метода
   оповещения. Более гибкий вариант — передавать через параметры весь объект
   издателя, чтобы подписчик мог сам получить требуемые данные. Как вариант,
   подписчик может постоянно хранить ссылку на объект издателя, переданный ему в
   конструкторе.
6. Клиент создаёт объекты издателей и подписчиков, а затем регистрирует
   подписчиков на обновления в издателях.

### **Реализация в Java**

Пример: новостное агентство (субъект) рассылает новости подписчикам 
(наблюдателям).

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс наблюдателя
interface Observer {
    void update(String message);
}

// Интерфейс субъекта
interface Subject {
    void addObserver(Observer observer);

    void removeObserver(Observer observer);

    void notifyObservers();
}

// Конкретный субъект
class NewsAgency implements Subject {
    private final List<Observer> observers = new ArrayList<>();
    private String news;

    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }

    @Override
    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
}

// Конкретный наблюдатель
class NewsChannel implements Observer {
    private final String channelName;

    public NewsChannel(String channelName) {
        this.channelName = channelName;
    }

    @Override
    public void update(String message) {
        System.out.println(channelName + " received news: " + message);
    }
}

// Клиентский код
public class ObserverExample {
    public static void main(String[] args) {
        NewsAgency agency = new NewsAgency();
        NewsChannel channel1 = new NewsChannel("Channel 1");
        NewsChannel channel2 = new NewsChannel("Channel 2");

        agency.addObserver(channel1);
        agency.addObserver(channel2);

        agency.setNews("Breaking News!"); // Вывод:
        // Channel 1 received news: Breaking News!
        // Channel 2 received news: Breaking News!

        agency.removeObserver(channel2);
        agency.setNews("Update!");       // Вывод:
        // Channel 1 received news: Update!
    }
}
```

### **Как это работает**

1. Субъект (`NewsAgency`) хранит список наблюдателей и состояние (например,
   `news`).
2. При изменении состояния (`setNews`) субъект вызывает `notifyObservers`,
   который уведомляет всех наблюдателей.
3. Каждый наблюдатель (`NewsChannel`) реализует метод `update`, определяющий,
   как реагировать на изменения.
4. Клиентский код управляет регистрацией и удалением наблюдателей.

### **Реальное использование в Java**

1. **Swing/JavaFX**:
   В GUI-фреймворках Java события (например, клик по кнопке) обрабатываются
   через наблюдателей:
   ```java
   import javax.swing.*;
   import java.awt.event.ActionListener;

   public class ButtonExample {
       public static void main(String[] args) {
           JButton button = new JButton("Click me");
           button.addActionListener(e -> System.out.println("Button clicked!"));
           JFrame frame = new JFrame();
           frame.add(button);
           frame.setSize(200, 200);
           frame.setVisible(true);
       }
   }
   ```
   Здесь `ActionListener` — это наблюдатель, а кнопка — субъект.

2. **Java Observable (устаревший)**:
   До Java 9 стандартная библиотека предоставляла класс `java.util.Observable` и
   интерфейс `java.util.Observer`:
   ```java
   import java.util.Observable;
   import java.util.Observer;

   class MyObservable extends Observable {
       void changeState(String data) {
           setChanged();
           notifyObservers(data);
       }
   }

   class MyObserver implements Observer {
       public void update(Observable o, Object arg) {
           System.out.println("Received: " + arg);
       }
   }
   ```
   Этот подход устарел, так как был слишком ограниченным и не поддерживал
   современные практики.

3. **PropertyChangeListener**:
   Более современный подход в Java — использование
   `java.beans.PropertyChangeSupport`:
   ```java
   import java.beans.PropertyChangeListener;
   import java.beans.PropertyChangeSupport;

   public class NewsAgency {
       private final PropertyChangeSupport support = new PropertyChangeSupport(this);
       private String news;

       public void addObserver(PropertyChangeListener listener) {
           support.addPropertyChangeListener(listener);
       }

       public void setNews(String news) {
           String oldNews = this.news;
           this.news = news;
           support.firePropertyChange("news", oldNews, news);
       }
   }
   ```

4. **Реактивные библиотеки**:
   В современных Java-приложениях паттерн Observer часто реализуется через
   библиотеки, такие как RxJava или Project Reactor:
   ```java
   import io.reactivex.rxjava3.core.Observable;

   public class RxJavaExample {
       public static void main(String[] args) {
           Observable.just("Breaking News!")
                     .subscribe(news -> System.out.println("Received: " + news));
       }
   }
   ```

### **Преимущества**

- **Слабая связанность**: Субъект и наблюдатели не зависят друг от друга
  напрямую, взаимодействуя через интерфейсы.
- **Гибкость**: Наблюдатели можно добавлять или удалять динамически.
- **Поддержка событий**: Идеально подходит для асинхронных и
  событийно-ориентированных систем.
- **Широкое применение**: Используется в GUI, реактивном программировании и
  архитектурах, таких как MVC.

### **Недостатки**

- **Утечки памяти**: Если наблюдатели не удаляются, они могут оставаться в
  памяти, удерживая ссылки на субъект.
    - **Решение**: Используйте `WeakReference` или явно удаляйте наблюдателей.
- **Производительность**: Уведомление большого числа наблюдателей может быть
  затратным.
    - **Решение**: Оптимизируйте уведомления, например, используя фильтры или
      асинхронные вызовы.
- **Сложность отладки**: Поток уведомлений может быть трудно отследить в больших
  системах.
    - **Решение**: Используйте логирование или реактивные библиотеки с
      встроенной диагностикой.

### **Отличие от других паттернов**

- **Observer vs Mediator**:
    - **Observer** рассылает уведомления напрямую от субъекта к наблюдателям.
    - **Mediator** централизует взаимодействие через посредника, уменьшая прямые
      связи.
- **Observer vs Publish-Subscribe**:
    - **Observer** предполагает, что субъект знает своих наблюдателей.
    - **Publish-Subscribe** использует брокер сообщений (например, Kafka), где
      издатель и подписчик не знают друг о друге.
- **Observer vs Chain of Responsibility**:
    - **Observer** уведомляет всех наблюдателей одновременно.
    - **Chain of Responsibility** передаёт запрос по цепочке, пока он не будет
      обработан.

### **Проблемы и антипаттерны**

1. **Забытые наблюдатели**: Незарегистрированные наблюдатели могут вызывать
   утечки памяти.
    - **Решение**: Используйте `removeObserver` или слабые ссылки (
      `WeakReference`).
2. **Слишком много уведомлений**: Частые или ненужные уведомления снижают
   производительность.
    - **Решение**: Вводите фильтры или условия для уведомлений.
3. **Сложная логика в наблюдателях**: Если наблюдатели выполняют тяжёлые
   операции, система может замедлиться.
    - **Решение**: Выполняйте сложные задачи асинхронно (например, с помощью
      `ExecutorService`).

### **Современные альтернативы в Java**

- **Реактивное программирование**: Библиотеки, такие как RxJava, Project Reactor
  или Flow API (Java 9+), предоставляют мощные инструменты для реализации
  Observer:
  ```java
  import java.util.concurrent.Flow;

  class NewsPublisher implements Flow.Publisher<String> {
      // Реализация паблишер-субскрайбер
  }
  ```
- **Spring Events**: В Spring можно использовать `@EventListener` для обработки
  событий:
  ```java
  @Component
  class NewsListener {
      @EventListener
      public void handleNews(NewsEvent event) {
          System.out.println("Received: " + event.getNews());
      }
  }
  ```
- **Лямбда-выражения**: В Java 8+ наблюдатели можно реализовать через
  функциональные интерфейсы:
  ```java
  List<Consumer<String>> observers = new ArrayList<>();
  observers.add(message -> System.out.println("Received: " + message));
  ```

### **Итог**

Паттерн Observer — это мощный инструмент для реализации
событийно-ориентированных систем, особенно в GUI, реактивных приложениях и
архитектурах, таких как MVC. Он обеспечивает слабую связанность и гибкость, но
требует осторожности, чтобы избежать утечек памяти и проблем с
производительностью. В современных Java-приложениях паттерн часто реализуется
через встроенные механизмы (Swing, PropertyChangeListener) или библиотеки (
RxJava, Spring).

---

### 4. **Strategy (Стратегия)**

**Паттерн Strategy (Стратегия)** — это поведенческий паттерн проектирования,
который позволяет определять семейство алгоритмов, инкапсулировать каждый из них
и делать их взаимозаменяемыми. Этот паттерн даёт возможность выбирать алгоритм
во время выполнения программы, не изменяя код, который его использует. Он
особенно полезен, когда нужно поддерживать разные варианты поведения или
алгоритмов для одной задачи.

### **Описание паттерна**

**Цель**:

- Определить семейство алгоритмов и сделать их взаимозаменяемыми.
- Позволить клиентскому коду выбирать алгоритм во время выполнения.
- Изолировать логику алгоритма от контекста, который его использует.

**Когда использовать**:

- Когда нужно использовать разные варианты одного алгоритма (например, разные
  способы оплаты, сортировки, сжатия данных).
- Когда в коде много условных операторов (`if-else`), зависящих от типа
  поведения, которые можно вынести в отдельные классы.
- Когда нужно заменять алгоритм без изменения клиентского кода.
- Когда требуется изолировать реализацию алгоритма от его использования.

**Примеры использования**:

- Различные способы оплаты в интернет-магазине (PayPal, кредитная карта,
  криптовалюта).
- Алгоритмы сортировки (`Comparator` в Java).
- Разные стратегии рендеринга графики (2D, 3D).

### **Структура паттерна**

1. **Стратегия (Strategy)**: Интерфейс или абстрактный класс, определяющий метод
   для выполнения алгоритма.
2. **Конкретная стратегия (Concrete Strategy)**: Классы, реализующие интерфейс
   стратегии, каждый с собственной реализацией алгоритма.
3. **Контекст (Context)**: Класс, который использует стратегию и содержит ссылку
   на объект стратегии. Контекст делегирует выполнение алгоритма выбранной
   стратегии.
4. **Клиент (Client)**: Код, который создаёт контекст и задаёт конкретную
   стратегию.

### **Реализация в Java**

Пример: реализация разных способов оплаты в интернет-магазине.

```java
import java.util.*;

// Интерфейс стратегии
interface PaymentStrategy {
    void pay(double amount);
}

// Конкретные стратегии
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Credit Card ending in " + cardNumber.substring(cardNumber.length() - 4));
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;

    public PayPalPayment(String email) {
        this.email = email;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using PayPal account " + email);
    }
}

// Контекст
class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    private List<Double> items;

    public ShoppingCart() {
        this.items = new ArrayList<>();
    }

    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void addItem(double price) {
        items.add(price);
    }

    public void checkout() {
        double total = items.stream().mapToDouble(Double::doubleValue).sum();
        if (paymentStrategy == null) {
            throw new IllegalStateException("Payment strategy not set");
        }
        paymentStrategy.pay(total);
    }
}

// Клиентский код
public class StrategyExample {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        cart.addItem(100.0);
        cart.addItem(50.0);

        // Оплата кредитной картой
        cart.setPaymentStrategy(new CreditCardPayment("1234-5678-9012-3456"));
        cart.checkout(); // Вывод: Paid 150.0 using Credit Card ending in 3456

        // Оплата через PayPal
        cart.setPaymentStrategy(new PayPalPayment("user@example.com"));
        cart.checkout(); // Вывод: Paid 150.0 using PayPal account user@example.com
    }
}
```

### **Как это работает**

1. Клиент создаёт контекст (`ShoppingCart`) и задаёт конкретную стратегию (
   `CreditCardPayment` или `PayPalPayment`) через метод `setPaymentStrategy`.
2. Контекст использует стратегию для выполнения действия (`pay`) без знания её
   внутренней реализации.
3. Клиент может менять стратегию во время выполнения, не изменяя код контекста.

### **Реальное использование в Java**

1. **Java Collections (Comparator)**:
   `Collections.sort` использует паттерн Strategy через интерфейс `Comparator`:
   ```java
   List<String> names = Arrays.asList("Bob", "Alice", "Charlie");
   Collections.sort(names, String::compareToIgnoreCase); // Стратегия сортировки
   System.out.println(names); // [Alice, Bob, Charlie]
   ```
   Здесь `Comparator` — это стратегия, определяющая порядок сортировки.

2. **Spring Framework**:
   В Spring разные реализации сервисов (например, для обработки запросов) могут
   быть инкапсулированы как стратегии:
   ```java
   @Service
   interface PaymentService {
       void pay(double amount);
   }

   @Service
   class CreditCardService implements PaymentService {
       public void pay(double amount) { /* Логика */ }
   }

   @Autowired
   private PaymentService paymentService; // Инъекция стратегии
   ```

3. **Stream API**:
   Функции, передаваемые в методы `map`, `filter` или `reduce`, действуют как
   стратегии:
   ```java
   List<Integer> numbers = Arrays.asList(1, 2, 3);
   numbers.stream().map(n -> n * 2).forEach(System.out::println); // Стратегия: умножение на 2
   ```

### **Преимущества**

- **Гибкость**: Легко добавлять новые алгоритмы, создавая новые классы
  стратегий.
- **Соответствие принципу Open/Closed**: Контекст открыт для расширения (новые
  стратегии), но закрыт для модификации.
- **Изоляция**: Логика алгоритма отделена от контекста, что упрощает
  тестирование.
- **Устранение условных операторов**: Вместо `if-else` для выбора поведения
  используется полиморфизм.
- **Динамическая смена поведения**: Стратегию можно менять во время выполнения.

### **Недостатки**

- **Увеличение числа классов**: Каждая новая стратегия требует отдельного
  класса.
- **Дополнительная сложность**: Для простых случаев паттерн может быть
  избыточным.
- **Необходимость настройки**: Клиент должен знать, какую стратегию выбрать, и
  передать её в контекст.

### **Отличие от других паттернов**

- **Strategy vs State**:
    - **Strategy** определяет взаимозаменяемые алгоритмы, которые не зависят от
      состояния контекста.
    - **State** управляет поведением, зависящим от внутреннего состояния
      объекта, и может изменять состояние контекста.
- **Strategy vs Command**:
    - **Strategy** фокусируется на выборе алгоритма для одной задачи.
    - **Command** инкапсулирует запрос как объект, часто для выполнения действий
      позже (например, undo/redo).
- **Strategy vs Template Method**:
    - **Strategy** использует композицию (стратегия передаётся в контекст).
    - **Template Method** использует наследование (подклассы переопределяют шаги
      алгоритма).

### **Проблемы и антипаттерны**

1. **Слишком много стратегий**: Если стратегий становится слишком много, код
   может стать громоздким.
    - **Решение**: Рассмотрите использование функциональных интерфейсов или
      лямбда-выражений для простых случаев.
2. **Жёсткая привязка клиента**: Клиент должен знать о всех стратегиях и
   выбирать подходящую.
    - **Решение**: Используйте Factory или DI (например, Spring) для создания
      стратегий.
3. **Избыточность для простых случаев**: Если есть только один алгоритм, паттерн
   может быть лишним.
    - **Решение**: Используйте Strategy только для задач с несколькими
      вариантами поведения.

### **Современные альтернативы в Java**

- **Лямбда-выражения и функциональные интерфейсы**:
  В Java 8+ Strategy часто заменяется лямбда-выражениями, что уменьшает
  необходимость в отдельных классах:
  ```java
  interface PaymentStrategy {
      void pay(double amount);
  }

  PaymentStrategy creditCard = amount -> System.out.println("Paid " + amount + " via Credit Card");
  PaymentStrategy payPal = amount -> System.out.println("Paid " + amount + " via PayPal");

  cart.setPaymentStrategy(creditCard);
  cart.checkout();
  ```
- **Spring Dependency Injection**:
  Spring позволяет внедрять стратегии как зависимости, упрощая их выбор:
  ```java
  @Service("creditCard")
  class CreditCardPayment implements PaymentStrategy { /* ... */ }

  @Autowired
  @Qualifier("creditCard")
  private PaymentStrategy paymentStrategy;
  ```
- **Map с перечислениями**:
  Для простых случаев можно использовать `Enum` и `Map` для выбора стратегии:
  ```java
  enum PaymentType {
      CREDIT_CARD(amount -> System.out.println("Paid " + amount + " via Credit Card")),
      PAYPAL(amount -> System.out.println("Paid " + amount + " via PayPal"));

      private final Consumer<Double> paymentAction;

      PaymentType(Consumer<Double> paymentAction) {
          this.paymentAction = paymentAction;
      }

      void pay(double amount) {
          paymentAction.accept(amount);
      }
  }
  ```

### **Итог**

Паттерн Strategy — это мощный инструмент для управления различными алгоритмами
или поведениями, обеспечивающий гибкость и изоляцию кода. Он широко используется
в Java, особенно в стандартной библиотеке (`Comparator`, Stream API) и
фреймворках (Spring). В современных приложениях Strategy часто упрощается с
помощью лямбда-выражений или DI, что делает код компактнее. Однако для сложных
систем с множеством алгоритмов классическая реализация Strategy остаётся
предпочтительной.

Если вам нужен более сложный пример, помощь с интеграцией в ваш проект,
сравнение с другими паттернами (например, State или Command) или разбор
конкретной задачи, напишите!


---

### 5. **Decorator (Декоратор)**

**Паттерн Decorator (Декоратор)** — это структурный паттерн проектирования,
который позволяет динамически добавлять новые обязанности или поведение объекту,
оборачивая его в другой объект. Он предоставляет гибкую альтернативу
наследованию для расширения функциональности, сохраняя интерфейс исходного
объекта.

### **Описание паттерна**

**Цель**:

- Динамически добавлять новые обязанности объекту без изменения его кода.
- Обеспечить гибкое расширение функциональности через композицию вместо
  наследования.

**Когда использовать**:

- Когда нужно добавлять функциональность объектам на лету (например, добавление
  логирования, кэширования, шифрования).
- Когда наследование нецелесообразно из-за большого числа комбинаций поведения.
- Когда требуется сохранить интерфейс исходного объекта, но расширить его
  поведение.
- Для реализации принципа единственной ответственности (SRP), разделяя основную
  логику и дополнительные функции.

**Примеры использования**:

- Потоки ввода-вывода в Java (`BufferedInputStream`, `DataInputStream`).
- Добавление функциональности в UI-компоненты (например, прокрутка или рамка в
  Swing).
- Декорирование сервисов (логирование, проверка прав доступа).

### **Структура паттерна**

1. **Компонент (Component)**: Абстрактный класс или интерфейс, определяющий
   методы, которые будут реализованы объектами и декораторами.
2. **Конкретный компонент (Concrete Component)**: Класс, реализующий
   компонент, — это объект, который будет декорироваться.
3. **Декоратор (Decorator)**: Абстрактный класс, реализующий интерфейс
   компонента и содержащий ссылку на декорируемый объект.
4. **Конкретный декоратор (Concrete Decorator)**: Класс, добавляющий новое
   поведение, вызывая методы исходного объекта и добавляя свои действия.

### **Реализация в Java**

Пример: декорирование напитков в кофейне, где к базовому напитку (например,
кофе) можно добавлять ингредиенты (молоко, сироп).

```java
// Компонент
interface Beverage {
    String getDescription();

    double getCost();
}

// Конкретный компонент
class Espresso implements Beverage {
    @Override
    public String getDescription() {
        return "Espresso";
    }

    @Override
    public double getCost() {
        return 2.0;
    }
}

// Абстрактный декоратор
abstract class BeverageDecorator implements Beverage {
    protected Beverage beverage;

    public BeverageDecorator(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription();
    }

    @Override
    public double getCost() {
        return beverage.getCost();
    }
}

// Конкретные декораторы
class Milk extends BeverageDecorator {
    public Milk(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Milk";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.5;
    }
}

class Syrup extends BeverageDecorator {
    public Syrup(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Syrup";
    }

    @Override
    public double getCost() {
        return beverage.getCost() + 0.7;
    }
}

// Клиентский код
public class DecoratorExample {
    public static void main(String[] args) {
        Beverage espresso = new Espresso();
        System.out.println(espresso.getDescription() + " $" + espresso.getCost());
        // Вывод: Espresso $2.0

        Beverage latte = new Milk(espresso);
        System.out.println(latte.getDescription() + " $" + latte.getCost());
        // Вывод: Espresso, Milk $2.5

        Beverage fancyLatte = new Syrup(new Milk(espresso));
        System.out.println(fancyLatte.getDescription() + " $" + fancyLatte.getCost());
        // Вывод: Espresso, Milk, Syrup $3.2
    }
}
```

### **Как это работает**

1. Клиент создаёт базовый объект (`Espresso`) и передаёт его в декоратор (
   `Milk`, `Syrup`).
2. Каждый декоратор реализует интерфейс `Beverage`, вызывая методы исходного
   объекта и добавляя своё поведение (например, увеличивая стоимость или изменяя
   описание).
3. Декораторы можно комбинировать в цепочку, добавляя несколько уровней
   функциональности (`Syrup` оборачивает `Milk`, который оборачивает
   `Espresso`).
4. Клиент работает с декорированным объектом через тот же интерфейс `Beverage`.

### **Реальное использование в Java**

1. **Java I/O**:
   Потоки ввода-вывода в Java — классический пример паттерна Decorator:
   ```java
   import java.io.*;

   public class IOExample {
       public static void main(String[] args) throws IOException {
           FileInputStream fis = new FileInputStream("test.txt");
           BufferedInputStream bis = new BufferedInputStream(fis); // Декоратор
           int data = bis.read();
           bis.close();
       }
   }
   ```
    - `BufferedInputStream` декорирует `FileInputStream`, добавляя буферизацию.
    - `DataInputStream` может добавить методы для чтения примитивных типов.

2. **Swing UI**:
   В Swing декораторы используются для добавления функциональности компонентам,
   например, рамок или полос прокрутки:
   ```java
   import javax.swing.*;

   JScrollPane scrollPane = new JScrollPane(new JTextArea()); // Декоратор
   ```

3. **Spring Framework**:
   В Spring декораторы часто используются для добавления функциональности,
   например, кэширования или логирования:
   ```java
   @Cacheable("results")
   public Result computeExpensiveResult() { /* Логика */ }
   ```
   Здесь `@Cacheable` действует как декоратор, добавляя кэширование к методу.

### **Преимущества**

- **Гибкость**: Можно комбинировать декораторы в любом порядке и количестве.
- **Соответствие принципу Open/Closed**: Функциональность расширяется без
  изменения исходного класса.
- **Альтернатива наследованию**: Избегает создания множества подклассов для
  комбинаций поведения.
- **Переиспользуемость**: Декораторы можно применять к разным объектам одного
  интерфейса.

### **Недостатки**

- **Увеличение числа классов**: Каждый декоратор — это отдельный класс.
- **Сложность отладки**: Цепочка декораторов может затруднить отслеживание
  выполнения.
- **Не всегда интуитивно**: Многослойное декорирование может быть трудно понять
  новичкам.
- **Ограничение интерфейса**: Декораторы должны строго следовать интерфейсу
  компонента, что ограничивает добавление новых методов.

### **Отличие от других паттернов**

- **Decorator vs Adapter**:
    - **Decorator** добавляет поведение, сохраняя тот же интерфейс.
    - **Adapter** преобразует интерфейс одного класса в другой.
- **Decorator vs Proxy**:
    - **Decorator** фокусируется на добавлении функциональности.
    - **Proxy** управляет доступом или жизненным циклом объекта (например,
      ленивая инициализация).
- **Decorator vs Composite**:
    - **Decorator** оборачивает один объект, добавляя поведение.
    - **Composite** управляет группой объектов как единым целым (древовидная
      структура).

### **Проблемы и антипаттерны**

1. **Слишком длинные цепочки декораторов**: Многослойное декорирование может
   снизить читаемость и производительность.
    - **Решение**: Ограничивайте количество декораторов или используйте другие
      паттерны (например, Strategy) для сложных случаев.
2. **Нарушение инкапсуляции**: Если декоратор изменяет внутреннее состояние
   объекта, это может привести к ошибкам.
    - **Решение**: Декораторы должны быть прозрачными и работать только с
      публичным интерфейсом.
3. **Сложность тестирования**: Тестирование цепочек декораторов может быть
   затруднительным.
    - **Решение**: Используйте мок-объекты (например, с Mockito) для изоляции
      компонентов.

### **Современные альтернативы в Java**

- **Лямбда-выражения**:
  В Java 8+ декораторы иногда заменяются функциональными композициями:
  ```java
  Function<Beverage, Beverage> addMilk = bev -> new Beverage() {
      public String getDescription() { return bev.getDescription() + ", Milk"; }
      public double getCost() { return bev.getCost() + 0.5; }
  };

  Beverage espresso = new Espresso();
  Beverage latte = addMilk.apply(espresso);
  ```
- **Spring AOP**:
  В Spring аспекты могут действовать как декораторы, добавляя сквозную
  функциональность (логирование, транзакции):
  ```java
  @Transactional
  public void saveOrder(Order order) { /* Логика */ }
  ```
- **Аннотации**:
  Аннотации, такие как `@Log` в SLF4J или `@Cacheable` в Spring, часто заменяют
  явные декораторы для простых случаев.

### **Итог**

Паттерн Decorator — это мощный инструмент для динамического расширения
функциональности объектов, особенно в системах, где требуется множество
комбинаций поведения. В Java он широко используется в стандартной библиотеке (
I/O, Swing) и фреймворках (Spring). Его гибкость делает его идеальным для
случаев, где наследование неудобно, но он может усложнить код при чрезмерном
использовании. В современных Java-приложениях декораторы часто упрощаются с
помощью лямбда-выражений, AOP или аннотаций.

Если вам нужен более сложный пример, помощь с интеграцией в ваш проект,
сравнение с другими паттернами (например, Proxy или Adapter) или разбор
конкретной задачи, напишите!

### Почему именно эти паттерны популярны?

1. **Универсальность**: Эти паттерны решают типичные задачи (создание объектов,
   управление поведением, реакция на события).
2. **Поддержка в Java**: Многие встроены в стандартную библиотеку (например, I/O
   для Decorator, `Comparator` для Strategy).
3. **Фреймворки**: Spring, Hibernate и другие активно используют Factory,
   Singleton, Observer.
4. **Сообщество**: На Stack Overflow и GitHub эти паттерны часто упоминаются в
   решениях (например, Singleton и Factory — лидеры по вопросам).

### Менее популярные паттерны GoF

Некоторые паттерны, такие как **Memento**, **Interpreter** или **Flyweight**,
менее популярны, так как применяются в специфических сценариях (например,
реализация undo, парсинг языков, оптимизация памяти). Они реже встречаются в
типичных Java-приложениях.

### Замечания

- **Контекст имеет значение**: Популярность зависит от домена. Например, в
  веб-разработке (Spring) чаще встречаются Factory и Singleton, а в GUI —
  Observer и Decorator.
- **Современные альтернативы**: В Java многие паттерны упрощаются с помощью
  функционального программирования (например, лямбда-выражения заменяют Strategy
  в некоторых случаях).
- **Антипаттерны**: Неправильное использование популярных паттернов (например,
  Singleton) может привести к проблемам, как обсуждалось ранее.

# ===== ДОПОЛНИТЕЛЬНО =====

## Прототип (Prototype)

**Паттерн Prototype (Прототип)** — это порождающий паттерн проектирования,
который позволяет создавать новые объекты путём копирования существующего
объекта, называемого прототипом, без привязки к их конкретным классам. Этот
паттерн полезен, когда создание объекта с нуля дорогостоящее или когда нужно
создать объект с похожими характеристиками, но с небольшими изменениями.

---

### **Описание паттерна**

**Цель**:

- Создавать новые объекты путём клонирования существующего экземпляра (
  прототипа).
- Избегать затрат на создание объектов с нуля.
- Обеспечить независимость от конкретных классов создаваемых объектов.

**Когда использовать**:

- Когда создание объекта с нуля требует значительных ресурсов (например,
  загрузка данных из базы данных или сложные вычисления).
- Когда нужно создать копию объекта с минимальными изменениями.
- Когда классы объектов определяются динамически, и создание через конструкторы
  затруднено.
- Когда система должна быть независимой от процесса создания объектов.

**Примеры использования**:

- Клонирование графических объектов в редакторах (например, копирование фигур в
  графическом редакторе).
- Создание шаблонных объектов в играх (например, копирование врагов с
  одинаковыми характеристиками).
- Кэширование объектов для повторного использования.

---

### **Структура паттерна**

1. **Прототип (Prototype)**: Интерфейс или абстрактный класс, объявляющий метод
   клонирования (обычно `clone()`).
2. **Конкретный прототип (Concrete Prototype)**: Класс, реализующий метод
   клонирования, создающий копию самого себя.
3. **Клиент (Client)**: Код, который использует прототип для создания новых
   объектов путём клонирования.

---

### **Реализация в Java**

В Java паттерн Prototype часто использует встроенный интерфейс `Cloneable` и
метод `clone()` из класса `Object`. Пример: клонирование графических фигур.

```java
// Интерфейс прототипа
interface Shape extends Cloneable {
    Shape clone();

    void draw();
}

// Конкретный прототип
class Circle implements Shape {
    private int radius;
    private String color;

    public Circle(int radius, String color) {
        this.radius = radius;
        this.color = color;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override
    public Shape clone() {
        try {
            return (Shape) super.clone(); // Поверхностное копирование
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cloning failed", e);
        }
    }

    @Override
    public void draw() {
        System.out.println("Drawing Circle [color=" + color + ", radius=" + radius + "]");
    }
}

// Конкретный прототип
class Rectangle implements Shape {
    private int width;
    private int height;
    private String color;

    public Rectangle(int width, int height, String color) {
        this.width = width;
        this.height = height;
        this.color = color;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    @Override
    public Shape clone() {
        try {
            return (Shape) super.clone(); // Поверхностное копирование
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cloning failed", e);
        }
    }

    @Override
    public void draw() {
        System.out.println("Drawing Rectangle [color=" + color + ", width=" + width + ", height=" + height + "]");
    }
}

// Клиентский код
public class PrototypeExample {
    public static void main(String[] args) {
        // Создаём прототипы
        Shape circle = new Circle(10, "Red");
        Shape rectangle = new Rectangle(20, 15, "Blue");

        // Клонируем объекты
        Shape clonedCircle = circle.clone();
        Shape clonedRectangle = rectangle.clone();

        // Изменяем клонированный круг
        ((Circle) clonedCircle).setRadius(15);

        // Рисуем все фигуры
        circle.draw();        // Drawing Circle [color=Red, radius=10]
        clonedCircle.draw();  // Drawing Circle [color=Red, radius=15]
        rectangle.draw();     // Drawing Rectangle [color=Blue, width=20, height=15]
        clonedRectangle.draw(); // Drawing Rectangle [color=Blue, width=20, height=15]
    }
}
```

---

### **Как это работает**

1. Клиент создаёт прототип (`Circle`, `Rectangle`) с начальными параметрами.
2. Вместо создания нового объекта с нуля клиент вызывает метод `clone()`,
   который возвращает копию прототипа.
3. Клонированный объект можно модифицировать независимо от оригинала (например,
   изменить радиус круга).
4. Клонирование в Java по умолчанию поверхностное (копируются только примитивы и
   ссылки), но можно реализовать глубокое копирование для сложных объектов.

---

### **Глубокое vs Поверхностное копирование**

- **Поверхностное копирование** (как в примере выше): Копируются примитивные
  поля и ссылки на объекты. Если прототип содержит вложенные объекты, копия и
  оригинал будут ссылаться на один и тот же вложенный объект.
- **Глубокое копирование**: Копируются все вложенные объекты, создавая полностью
  независимую копию. Это требует дополнительной логики в методе `clone()`.

Пример глубокого копирования:

```java
class Circle implements Shape {
    private int radius;
    private Color color; // Сложный объект

    public Circle(int radius, Color color) {
        this.radius = radius;
        this.color = color;
    }

    @Override
    public Shape clone() {
        try {
            Circle copy = (Circle) super.clone();
            copy.color = new Color(color.getR(), color.getG(), color.getB()); // Глубокое копирование
            return copy;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cloning failed", e);
        }
    }
}
```

---

### **Реальное использование в Java**

1. **Java Cloneable**:
   Интерфейс `Cloneable` и метод `Object.clone()` — встроенная поддержка
   паттерна Prototype:
   ```java
   class MyClass implements Cloneable {
       @Override
       protected Object clone() throws CloneNotSupportedException {
           return super.clone();
       }
   }
   ```
   Однако `Cloneable` имеет недостатки (например, отсутствие явного интерфейса и
   проверяемого исключения), поэтому его редко используют в современном коде.

2. **Spring Framework**:
   Spring)\"s Spring позволяет создавать прототипы через `PrototypeScope`:
   ```java
   @Component
   @Scope("prototype")
   class MyBean { /* ... */ }
   ```
   Каждый вызов `context.getBean(MyBean.class)` возвращает новый экземпляр.

3. **Java Collections**:
   Метод `clone()` в коллекциях, таких как `ArrayList`:
   ```java
   ArrayList<String> list = new ArrayList<>(Arrays.asList("A", "B"));
   ArrayList<String> clonedList = (ArrayList<String>) list.clone();
   ```

---

### **Преимущества**

- **Экономия ресурсов**: Клонирование быстрее, чем создание объекта с нуля.
- **Гибкость**: Позволяет создавать копии с минимальными изменениями.
- **Независимость от классов**: Клиент работает с интерфейсом прототипа, а не с
  конкретными классами.
- **Динамическое создание**: Подходит для систем, где типы объектов определяются
  во время выполнения.

---

### **Недостатки**

- **Сложность клонирования**: Глубокое копирование требует тщательной
  реализации, особенно для сложных объектов.
- **Ограничения Cloneable**: Встроенный механизм Java (`Cloneable`) имеет
  недостатки, такие как отсутствие типобезопасности.
- **Потенциальные ошибки**: Поверхностное копирование может привести к
  неожиданным связям между копией и оригиналом.
- **Не всегда интуитивно**: Требует понимания, какие поля нужно копировать и
  как.

---

### **Отличие от других паттернов**

- **Prototype vs Factory Method**:
    - **Prototype** создаёт новые объекты путём копирования существующего
      экземпляра.
    - **Factory Method** определяет создание объектов через абстрактный метод,
      реализованный в подклассах.
- **Prototype vs Abstract Factory**:
    - **Prototype** фокусируется на клонировании одного объекта.
    - **Abstract Factory** создаёт семейства связанных объектов с нуля.
- **Prototype vs Builder**:
    - **Prototype** копирует готовый объект.
    - **Builder** конструирует объект пошагово.

---

### **Проблемы и антипаттерны**

1. **Неправильное клонирование**: Поверхностное копирование вместо глубокого
   может привести к ошибкам, если вложенные объекты изменяются.
    - **Решение**: Реализуйте глубокое копирование для всех изменяемых вложенных
      объектов.
2. **Злоупотребление Cloneable**: Использование `Cloneable` без переопределения
   `clone()` или без обработки исключений.
    - **Решение**: Рассмотрите альтернативные подходы, такие как копирующие
      конструкторы или библиотеки (например, Apache Commons Lang).
3. **Сложность тестирования**: Тестирование клонированных объектов требует
   проверки их независимости.
    - **Решение**: Пишите тесты, проверяющие, что изменения в копии не влияют на
      оригинал.

---

### **Современные альтернативы в Java**

- **Копирующие конструкторы**:
  Вместо `clone()` можно использовать конструктор, который принимает объект того
  же типа:
  ```java
  class Circle {
      private int radius;

      public Circle(Circle other) {
          this.radius = other.radius;
      }
  }
  ```
- **Сериализация**:
  Глубокое копирование через сериализацию/десериализацию (например, с помощью
  `ObjectOutputStream`):
  ```java
  public <T extends Serializable> T deepCopy(T obj) {
      try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
           ObjectOutputStream oos = new ObjectOutputStream(bos)) {
          oos.write(obj);
          try (ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
               ObjectInputStream ois = new ObjectInputStream(bis)) {
              return (T) ois.readObject();
          }
      } catch (IOException | ClassNotFoundException e) {
          throw new RuntimeException("Deep copy failed", e);
      }
  }
  ```
- **Библиотеки**:
  Используйте библиотеки, такие как Apache Commons Lang (
  `SerializationUtils.clone`) или Gson для глубокого копирования.

---

### **Итог**

Паттерн Prototype — это эффективный способ создания объектов путём клонирования,
особенно когда создание с нуля дорого или когда нужны копии с минимальными
изменениями. В Java он часто реализуется через `Cloneable`, но требует
осторожности из-за поверхностного копирования и ограничений интерфейса. В
современных приложениях паттерн может быть заменён копирующими конструкторами,
сериализацией или DI (например, Spring с `prototype` scope). Он особенно полезен
в системах, где требуется высокая производительность или динамическое создание
объектов.

Если вам нужен более сложный пример, помощь с реализацией в вашем проекте,
сравнение с другими паттернами (например, Factory Method или Builder) или разбор
конкретной задачи, напишите!

---

## Строитель (Builder)

**Паттерн Builder (Строитель)** — это порождающий паттерн проектирования,
который позволяет пошагово конструировать сложные объекты, отделяя процесс
создания от их структуры. Он особенно полезен, когда объект имеет множество
параметров, а их комбинации могут варьироваться, или когда процесс создания
требует нескольких этапов.

---

### **Описание паттерна**

**Цель**:

- Разделить создание сложного объекта на отдельные шаги, чтобы упростить его
  конструирование.
- Обеспечить гибкость в создании различных конфигураций объекта.
- Избежать конструкторов с большим количеством параметров (телескопический
  конструктор).

**Когда использовать**:

- Когда объект имеет много опциональных параметров или сложную логику
  инициализации.
- Когда нужно создавать разные конфигурации одного типа объекта.
- Когда процесс создания объекта должен быть независим от его структуры.
- Когда требуется обеспечить неизменяемость объекта после создания.

**Примеры использования**:

- Создание сложных объектов, таких как документы, UI-формы или конфигурации.
- Построение HTTP-запросов (например, с помощью `OkHttp` или `HttpClient`).
- Генерация объектов с множеством параметров (например, конфигурация
  автомобиля).

---

### **Структура паттерна**

1. **Продукт (Product)**: Класс, представляющий сложный объект, который
   создаётся строителем.
2. **Строитель (Builder)**: Абстрактный интерфейс или класс, определяющий методы
   для пошагового создания продукта.
3. **Конкретный строитель (Concrete Builder)**: Реализация строителя, создающая
   конкретный продукт.
4. **Директор (Director)** (опционально): Класс, управляющий процессом
   строительства, вызывая методы строителя в нужном порядке.
5. **Клиент (Client)**: Код, который использует строителя для создания объекта.

---

### **Реализация в Java**

Пример: создание объекта `Computer` с различными конфигурациями (процессор,
оперативная память, хранилище).

```java
// Продукт
class Computer {
    private final String cpu;
    private final int ram;
    private final int storage;
    private final boolean hasGraphicsCard;

    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.hasGraphicsCard = builder.hasGraphicsCard;
    }

    @Override
    public String toString() {
        return "Computer [CPU=" + cpu + ", RAM=" + ram + "GB, Storage=" + storage + "GB, GraphicsCard=" + hasGraphicsCard + "]";
    }

    // Внутренний класс Builder
    public static class Builder {
        private String cpu;
        private int ram;
        private int storage;
        private boolean hasGraphicsCard;

        public Builder setCpu(String cpu) {
            this.cpu = cpu;
            return this;
        }

        public Builder setRam(int ram) {
            this.ram = ram;
            return this;
        }

        public Builder setStorage(int storage) {
            this.storage = storage;
            return this;
        }

        public Builder setGraphicsCard(boolean hasGraphicsCard) {
            this.hasGraphicsCard = hasGraphicsCard;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }
}

// Клиентский код
public class BuilderExample {
    public static void main(String[] args) {
        // Создание базового компьютера
        Computer basicComputer = new Computer.Builder()
                .setCpu("Intel i3")
                .setRam(8)
                .setStorage(256)
                .build();
        System.out.println(basicComputer);
        // Вывод: Computer [CPU=Intel i3, RAM=8GB, Storage=256GB, GraphicsCard=false]

        // Создание игрового компьютера
        Computer gamingComputer = new Computer.Builder()
                .setCpu("Intel i9")
                .setRam(32)
                .setStorage(1000)
                .setGraphicsCard(true)
                .build();
        System.out.println(gamingComputer);
        // Вывод: Computer [CPU=Intel i9, RAM=32GB, Storage=1000GB, GraphicsCard=true]
    }
}
```

---

### **Как это работает**

1. Клиент использует `Builder` для пошаговой настройки параметров объекта (
   `setCpu`, `setRam` и т.д.).
2. Каждый метод строителя возвращает `this`, что позволяет использовать цепочку
   вызовов (fluent interface).
3. После настройки всех параметров клиент вызывает `build()`, который создаёт
   финальный объект `Computer`.
4. Продукт (`Computer`) является неизменяемым, так как его поля задаются только
   через конструктор и помечены как `final`.

---

### **Реальное использование в Java**

1. **StringBuilder**:
   Класс `StringBuilder` реализует паттерн Builder для создания строк:
   ```java
   StringBuilder builder = new StringBuilder()
           .append("Hello")
           .append(" ")
           .append("World");
   String result = builder.toString(); // Hello World
   ```

2. **Java HttpClient**:
   Класс `HttpClient` в Java 11+ использует Builder для настройки HTTP-клиента:
   ```java
   import java.net.http.HttpClient;

   HttpClient client = HttpClient.newBuilder()
           .version(HttpClient.Version.HTTP_2)
           .connectTimeout(Duration.ofSeconds(10))
           .build();
   ```

3. **Lombok**:
   Аннотация `@Builder` в Lombok автоматически генерирует реализацию паттерна
   Builder:
   ```java
   import lombok.Builder;

   @Builder
   class Computer {
       private String cpu;
       private int ram;
       private int storage;
   }

   Computer computer = Computer.builder()
           .cpu("Intel i5")
           .ram(16)
           .storage(512)
           .build();
   ```

4. **Spring Boot**:
   Конфигурация объектов, таких как `RestTemplate` или `WebClient`, часто
   использует Builder:
   ```java
   import org.springframework.web.client.RestTemplate;

   RestTemplate restTemplate = new RestTemplateBuilder()
           .setConnectTimeout(Duration.ofSeconds(5))
           .build();
   ```

---

### **Преимущества**

- **Гибкость**: Позволяет создавать разные конфигурации объекта.
- **Читаемость**: Код с цепочкой вызовов (`fluent interface`) легко читается.
- **Неизменяемость**: Легко создать неизменяемый объект, задавая поля через
  конструктор.
- **Избежание телескопического конструктора**: Устраняет проблему с множеством
  перегруженных конструкторов.
- **Изоляция логики**: Процесс создания отделён от структуры объекта.

---

### **Недостатки**

- **Увеличение кода**: Требуется отдельный класс `Builder`, что увеличивает
  количество кода.
- **Сложность для простых объектов**: Для объектов с 1-2 полями Builder может
  быть избыточным.
- **Дополнительные объекты**: Создание строителя требует выделения памяти.

---

### **Отличие от других паттернов**

- **Builder vs Factory Method**:
    - **Builder** фокусируется на пошаговом создании сложного объекта с
      множеством параметров.
    - **Factory Method** создаёт объект одним вызовом, определяя его тип через
      подклассы.
- **Builder vs Abstract Factory**:
    - **Builder** создаёт один объект с гибкой конфигурацией.
    - **Abstract Factory** создаёт семейства связанных объектов.
- **Builder vs Prototype**:
    - **Builder** конструирует объект с нуля, задавая параметры.
    - **Prototype** создаёт объект путём копирования существующего.

---

### **Проблемы и антипаттерны**

1. **Неполная инициализация**: Если клиент забудет задать обязательные
   параметры, объект может быть создан в некорректном состояния.
    - **Решение**: Добавьте проверки в метод `build()` или сделайте обязательные
      параметры частью конструктора строителя:
      ```java
      public static class Builder {
          private final String cpu; // Обязательное поле
          private int ram;
          private int storage;
 
          public Builder(String cpu) {
              this.cpu = cpu;
          }
 
          public Computer build() {
              if (ram <= 0 || storage <= 0) {
                  throw new IllegalStateException("RAM and Storage must be set");
              }
              return new Computer(this);
          }
      }
      ```
2. **Сложность тестирования**: Тестирование объектов с множеством параметров
   может быть громоздким.
    - **Решение**: Используйте библиотеки, такие как `Test Data Builder`, или
      Lombok для упрощения.
3. **Избыточность для простых объектов**: Применение Builder к объектам с 1-2
   полями увеличивает сложность без пользы.
    - **Решение**: Используйте Builder только для сложных объектов.

---

### **Современные альтернативы в Java**

- **Lombok @Builder**:
  Автоматически генерирует реализацию паттерна, уменьшая шаблонный код (см.
  пример выше).
- **Java Records**:
  Для простых неизменяемых объектов можно использовать `record`, хотя они не
  поддерживают пошаговое создание:
  ```java
  record Computer(String cpu, int ram, int storage) {}
  ```
  Для сложных случаев record можно комбинировать с Builder.
- **Functional Builders**:
  В Java 8+ можно использовать функциональные интерфейсы для создания объектов:
  ```java
  Function<Consumer<Computer.Builder>, Computer> computerFactory = config -> {
      Computer.Builder builder = new Computer.Builder();
      config.accept(builder);
      return builder.build();
  };

  Computer computer = computerFactory.apply(b -> b.setCpu("Intel i7").setRam(16));
  ```

---

### **Итог**

Паттерн Builder — это мощный инструмент для создания сложных объектов с
множеством параметров, обеспечивающий читаемость, гибкость и неизменяемость. В
Java он широко используется в стандартной библиотеке (`StringBuilder`,
`HttpClient`) и фреймворках (Spring, Lombok). Он особенно полезен для избежания
телескопических конструкторов и упрощения работы с конфигурациями. Однако для
простых объектов Builder может быть избыточным, и в таких случаях лучше
использовать конструкторы или `record`.

Если вам нужен более сложный пример, помощь с реализацией в вашем проекте,
сравнение с другими паттернами (например, Factory Method или Prototype) или
разбор конкретной задачи, напишите!

---

## Фасад (Facade)

**Паттерн Facade (Фасад)** — это структурный паттерн проектирования, который
предоставляет упрощённый интерфейс к сложной подсистеме, скрывая её внутреннюю
сложность. Он действует как "единая точка входа", упрощая взаимодействие клиента
с набором классов или модулей, которые вместе решают задачу.

---

### **Описание паттерна**

**Цель**:

- Обеспечить простой и удобный интерфейс для работы со сложной подсистемой.
- Скрыть детали реализации подсистемы от клиента.
- Уменьшить связанность между клиентским кодом и подсистемой.

**Когда использовать**:

- Когда подсистема состоит из множества классов с сложными взаимодействиями, а
  клиенту нужен простой доступ.
- Когда требуется изолировать клиентский код от деталей реализации подсистемы.
- Когда нужно разделить подсистему на слои или предоставить точку входа для
  внешнего использования.
- Для упрощения работы с библиотеками или API с большим количеством методов.

**Примеры использования**:

- Упрощение работы с API фреймворков (например, JDBC или Hibernate).
- Управление сложными системами, такими как мультимедийные плееры или
  компиляторы.
- Обёртывание устаревших систем для интеграции с новым кодом.

---

### **Структура паттерна**

1. **Фасад (Facade)**: Класс, предоставляющий упрощённый интерфейс с методами,
   которые вызывают функции подсистемы.
2. **Подсистема (Subsystem)**: Набор классов, выполняющих сложные операции. Эти
   классы могут быть независимыми или взаимодействовать друг с другом.
3. **Клиент (Client)**: Код, который использует фасад для взаимодействия с
   подсистемой.

---

### **Реализация в Java**

Пример: фасад для упрощения работы с подсистемой домашнего кинотеатра, которая
включает DVD-плеер, проектор и аудиосистему.

```java
// Подсистема: классы с индивидуальной функциональностью
class DVDPlayer {
    public void on() {
        System.out.println("DVD Player is on");
    }

    public void play(String movie) {
        System.out.println("Playing movie: " + movie);
    }

    public void off() {
        System.out.println("DVD Player is off");
    }
}

class Projector {
    public void on() {
        System.out.println("Projector is on");
    }

    public void setInput(String input) {
        System.out.println("Projector input set to " + input);
    }

    public void off() {
        System.out.println("Projector is off");
    }
}

class AudioSystem {
    public void on() {
        System.out.println("Audio System is on");
    }

    public void setVolume(int level) {
        System.out.println("Audio volume set to " + level);
    }

    public void off() {
        System.out.println("Audio System is off");
    }
}

// Фасад
class HomeTheaterFacade {
    private final DVDPlayer dvdPlayer;
    private final Projector projector;
    private final AudioSystem audioSystem;

    public HomeTheaterFacade(DVDPlayer dvdPlayer, Projector projector, AudioSystem audioSystem) {
        this.dvdPlayer = dvdPlayer;
        this.projector = projector;
        this.audioSystem = audioSystem;
    }

    public void watchMovie(String movie) {
        System.out.println("Preparing to watch movie...");
        dvdPlayer.on();
        projector.on();
        projector.setInput("DVD");
        audioSystem.on();
        audioSystem.setVolume(5);
        dvdPlayer.play(movie);
        System.out.println("Movie started!");
    }

    public void endMovie() {
        System.out.println("Shutting down home theater...");
        dvdPlayer.off();
        projector.off();
        audioSystem.off();
        System.out.println("Home theater shut down.");
    }
}

// Клиентский код
public class FacadeExample {
    public static void main(String[] args) {
        DVDPlayer dvdPlayer = new DVDPlayer();
        Projector projector = new Projector();
        AudioSystem audioSystem = new AudioSystem();

        HomeTheaterFacade homeTheater = new HomeTheaterFacade(dvdPlayer, projector, audioSystem);

        homeTheater.watchMovie("Inception");
        // Вывод:
        // Preparing to watch movie...
        // DVD Player is on
        // Projector is on
        // Projector input set to DVD
        // Audio System is on
        // Audio volume set to 5
        // Playing movie: Inception
        // Movie started!

        homeTheater.endMovie();
        // Вывод:
        // Shutting down home theater...
        // DVD Player is off
        // Projector is off
        // Audio System is off
        // Home theater shut down.
    }
}
```

---

### **Как это работает**

1. Клиент создаёт экземпляры классов подсистемы (`DVDPlayer`, `Projector`,
   `AudioSystem`) и передаёт их в фасад (`HomeTheaterFacade`).
2. Фасад предоставляет высокоуровневые методы (`watchMovie`, `endMovie`),
   которые координируют работу подсистемы.
3. Клиент вызывает методы фасада, не взаимодействуя напрямую с подсистемой, что
   упрощает код и скрывает сложность.

---

### **Реальное использование в Java**

1. **JDBC API**:
   Класс `java.sql.DriverManager` действует как фасад, упрощая работу с
   подключением к базе данных:
   ```java
   import java.sql.Connection;
   import java.sql.DriverManager;

   Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "user", "pass");
   ```
   `DriverManager` скрывает детали загрузки драйверов и управления соединениями.

2. **SLF4J/Logging**:
   Логгеры, такие как SLF4J, предоставляют фасад для различных реализаций
   логирования (Log4j, JUL):
   ```java
   import org.slf4j.Logger;
   import org.slf4j.LoggerFactory;

   Logger logger = LoggerFactory.getLogger(MyClass.class);
   logger.info("Hello, world!");
   ```
   SLF4J скрывает выбор конкретной системы логирования.

3. **Spring Framework**:
   В Spring фасады часто используются для упрощения работы с подсистемами.
   Например, `JdbcTemplate` — это фасад для работы с JDBC:
   ```java
   import org.springframework.jdbc.core.JdbcTemplate;

   JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
   jdbcTemplate.update("INSERT INTO users (name) VALUES (?)", "Alice");
   ```
   `JdbcTemplate` скрывает сложности управления соединениями, обработки
   исключений и т.д.

---

### **Преимущества**

- **Упрощение интерфейса**: Клиент работает с простыми методами вместо сложной
  подсистемы.
- **Снижение связанности**: Клиентский код зависит только от фасада, а не от
  множества классов подсистемы.
- **Инкапсуляция**: Скрывает детали реализации подсистемы.
- **Гибкость**: Легко изменить или заменить подсистему, не затрагивая клиентский
  код.
- **Поддержка слоёв**: Фасад может служить точкой входа для слоя архитектуры.

---

### **Недостатки**

- **Ограничение функциональности**: Фасад может предоставлять только
  подмножество возможностей подсистемы.
- **Риск превращения в "божественный объект"**: Если фасад обрастает слишком
  многими методами, он может стать сложным для поддержки.
- **Дополнительный слой**: Вводит ещё один класс, что может быть избыточным для
  простых систем.

---

### **Отличие от других паттернов**

- **Facade vs Adapter**:
    - **Facade** упрощает интерфейс к сложной подсистеме.
    - **Adapter** преобразует интерфейс одного класса в другой, совместимый с
      клиентом.
- **Facade vs Mediator**:
    - **Facade** предоставляет упрощённый доступ к подсистеме, не координируя её
      части.
    - **Mediator** управляет взаимодействием между объектами, уменьшая их прямые
      связи.
- **Facade vs Abstract Factory**:
    - **Facade** скрывает сложность подсистемы, предоставляя высокоуровневые
      операции.
    - **Abstract Factory** создаёт семейства связанных объектов.

---

### **Проблемы и антипаттерны**

1. **Слишком сложный фасад**: Если фасад включает слишком много методов, он
   становится трудно поддерживаемым.
    - **Решение**: Ограничивайте фасад высокоуровневыми операциями, оставляя
      детали подсистеме.
2. **Нарушение инкапсуляции**: Если фасад предоставляет прямой доступ к объектам
   подсистемы, он теряет свою цель.
    - **Решение**: Возвращайте результаты, а не ссылки на внутренние объекты.
3. **Избыточность для простых систем**: В небольших системах фасад может быть
   ненужным усложнением.
    - **Решение**: Используйте фасад только для систем с реальной сложностью.

---

### **Современные альтернативы в Java**

- **Spring Service Layer**:
  В Spring сервисы часто действуют как фасады, упрощая доступ к бизнес-логике:
  ```java
  @Service
  class UserService {
      public void registerUser(String name, String email) {
          // Взаимодействие с репозиториями, валидацией и т.д.
      }
  }
  ```
- **API Gateways**:
  В микросервисной архитектуре API-шлюзы (например, Spring Cloud Gateway)
  выступают как фасады, предоставляя единый интерфейс к множеству сервисов.
- **Fluent Interfaces**:
  Для упрощения взаимодействия можно использовать цепочки вызовов вместо фасада:
  ```java
  HomeTheater theater = new HomeTheater()
          .withDVDPlayer()
          .withProjector()
          .startMovie("Inception");
  ```

---

### **Итог**

Паттерн Facade — это эффективный способ упростить взаимодействие со сложной
подсистемой, скрывая её детали и предоставляя удобный интерфейс. В Java он
широко используется в стандартной библиотеке (JDBC, SLF4J) и фреймворках (
Spring). Фасад снижает связанность, улучшает читаемость кода и облегчает
поддержку, но требует осторожности, чтобы не превратиться в громоздкий объект.
Он особенно полезен в системах с высокой сложностью или при интеграции с
устаревшими API.

Если вам нужен более сложный пример, помощь с реализацией в вашем проекте,
сравнение с другими паттернами (например, Adapter или Mediator) или разбор
конкретной задачи, напишите!

---

## Заместитель (Proxy)

**Паттерн Proxy (Заместитель)** — это структурный паттерн проектирования,
который предоставляет объект-заместитель (прокси) для управления доступом к
другому объекту, добавляя дополнительную функциональность, такую как ленивая
инициализация, контроль доступа, логирование или кэширование, без изменения
исходного объекта. Прокси действует как посредник между клиентом и реальным
объектом.

---

### **Описание паттерна**

**Цель**:

- Контролировать доступ к объекту, добавляя промежуточный слой.
- Отложить создание или выполнение операций до момента, когда они действительно
  нужны.
- Предоставить дополнительную функциональность (например, проверку прав,
  кэширование).

**Когда использовать**:

- Когда нужно отложить создание дорогостоящего объекта до его фактического
  использования (ленивая инициализация).
- Когда требуется ограничить доступ к объекту (например, проверка прав).
- Когда нужно логировать операции или кэшировать результаты.
- Когда требуется управлять доступом к удалённым объектам (например, в
  распределённых системах).

**Примеры использования**:

- Ленивая загрузка данных (например, изображений в приложении).
- Проверка прав доступа перед вызовом методов сервиса.
- Прокси для удалённых объектов (например, RMI в Java).
- Кэширование результатов операций.

---

### **Структура паттерна**

1. **Субъект (Subject)**: Интерфейс, который определяет общие методы для
   реального объекта и прокси.
2. **Реальный объект (Real Subject)**: Класс, выполняющий основную работу, к
   которому прокси управляет доступом.
3. **Прокси (Proxy)**: Класс, реализующий тот же интерфейс, что и реальный
   объект, и содержащий ссылку на него. Прокси добавляет дополнительную логику
   перед или после вызова методов реального объекта.
4. **Клиент (Client)**: Код, который работает с прокси, как с реальным объектом.

---

### **Типы прокси**

1. **Виртуальный прокси**: Откладывает создание реального объекта до момента его
   использования (ленивая инициализация).
2. **Защитный прокси**: Контролирует доступ к объекту (например, проверяет
   права).
3. **Удалённый прокси**: Управляет доступом к объекту, расположенному в другом
   адресном пространстве (например, в распределённых системах).
4. **Кэширующий прокси**: Сохраняет результаты операций для повторного
   использования.
5. **Логирующий прокси**: Добавляет логирование вызовов методов.

---

### **Реализация в Java**

Пример: виртуальный прокси для ленивой загрузки изображения.

```java
// Интерфейс субъекта
interface Image {
    void display();
}

// Реальный объект
class RealImage implements Image {
    private final String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadImageFromDisk();
    }

    private void loadImageFromDisk() {
        System.out.println("Loading image: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

// Прокси
class ProxyImage implements Image {
    private RealImage realImage;
    private final String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // Ленивая инициализация
        }
        realImage.display();
    }
}

// Клиентский код
public class ProxyExample {
    public static void main(String[] args) {
        Image image = new ProxyImage("photo.jpg");

        // Изображение загружается только при первом вызове
        image.display();
        // Вывод:
        // Loading image: photo.jpg
        // Displaying image: photo.jpg

        // При повторном вызове загрузка не происходит
        image.display();
        // Вывод:
        // Displaying image: photo.jpg
    }
}
```

---

### **Как это работает**

1. Клиент работает с прокси (`ProxyImage`) через интерфейс `Image`, не зная, что
   это не реальный объект.
2. Прокси создаёт реальный объект (`RealImage`) только при первом вызове метода
   `display` (ленивая инициализация).
3. Последующие вызовы используют уже созданный объект, избегая повторной
   загрузки.

---

### **Реальное использование в Java**

1. **Java RMI (Remote Method Invocation)**:
   RMI использует удалённый прокси для доступа к объектам на другом JVM:
   ```java
   import java.rmi.Remote;
   import java.rmi.RemoteException;

   public interface MyRemote extends Remote {
       String sayHello() throws RemoteException;
   }
   ```
   Прокси-объект, созданный RMI, управляет сетевыми вызовами.

2. **Spring AOP**:
   Spring использует прокси для добавления сквозной функциональности, например,
   транзакций или логирования:
   ```java
   @Service
   class MyService {
       @Transactional
       public void doWork() { /* Логика */ }
   }
   ```
   Spring создаёт прокси, который оборачивает метод `doWork` транзакционной
   логикой.

3. **Hibernate Lazy Loading**:
   В Hibernate прокси используются для ленивой загрузки сущностей:
   ```java
   @Entity
   class User {
       @OneToMany(fetch = FetchType.LAZY)
       private List<Order> orders;
   }
   ```
   Hibernate создаёт прокси для коллекции `orders`, загружая данные только при
   обращении.

4. **Dynamic Proxy API**:
   Java предоставляет `java.lang.reflect.Proxy` для создания динамических
   прокси:
   ```java
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.Proxy;

   interface Service {
       void perform();
   }

   class RealService implements Service {
       public void perform() { System.out.println("Performing service"); }
   }

   class LoggingHandler implements InvocationHandler {
       private final Object target;

       public LoggingHandler(Object target) { this.target = target; }

       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("Before: " + method.getName());
           Object result = method.invoke(target, args);
           System.out.println("After: " + method.getName());
           return result;
       }
   }

   Service service = (Service) Proxy.newProxyInstance(
           Service.class.getClassLoader(),
           new Class[]{Service.class},
           new LoggingHandler(new RealService())
   );
   service.perform();
   // Вывод:
   // Before: perform
   // Performing service
   // After: perform
   ```

---

### **Преимущества**

- **Контроль доступа**: Прокси может проверять права или ограничивать операции.
- **Ленивая инициализация**: Экономит ресурсы, откладывая создание объекта.
- **Дополнительная функциональность**: Легко добавить логирование, кэширование
  или проверку.
- **Прозрачность**: Клиент работает с прокси, как с реальным объектом.
- **Изоляция**: Скрывает детали реализации подсистемы.

---

### **Недостатки**

- **Дополнительный слой**: Прокси добавляет сложность в архитектуру.
- **Задержки**: Ленивая инициализация может вызвать задержки при первом вызове.
- **Сложность отладки**: Прокси может затруднить отслеживание вызовов.
- **Ограничение интерфейса**: Прокси должен соответствовать интерфейсу реального
  объекта, что ограничивает добавление новых методов.

---

### **Отличие от других паттернов**

- **Proxy vs Decorator**:
    - **Proxy** управляет доступом или жизненным циклом объекта (например,
      ленивая инициализация).
    - **Decorator** добавляет новое поведение, сохраняя тот же интерфейс.
- **Proxy vs Adapter**:
    - **Proxy** работает с тем же интерфейсом, что и реальный объект, добавляя
      функциональность.
    - **Adapter** преобразует интерфейс одного класса в другой.
- **Proxy vs Facade**:
    - **Proxy** управляет доступом к одному объекту.
    - **Facade** упрощает интерфейс к целой подсистеме.

---

### **Проблемы и антипаттерны**

1. **Слишком сложный прокси**: Если прокси выполняет слишком много функций, он
   может стать трудно поддерживаемым.
    - **Решение**: Ограничивайте прокси одной задачей (например, только ленивая
      инициализация).
2. **Утечки ресурсов**: Ленивая инициализация может привести к созданию объектов
   в неподходящий момент.
    - **Решение**: Тестируйте прокси в сценариях с высокой нагрузкой.
3. **Нарушение прозрачности**: Если прокси изменяет поведение реального объекта,
   это может вызвать ошибки.
    - **Решение**: Убедитесь, что прокси строго следует интерфейсу субъекта.

---

### **Современные альтернативы в Java**

- **Spring AOP и Proxy**:
  Spring автоматически создаёт прокси для добавления сквозной функциональности (
  транзакции, логирование):
  ```java
  @Transactional
  public void saveData() { /* Логика */ }
  ```
- **Dynamic Proxy**:
  Использование `java.lang.reflect.Proxy` для динамического создания прокси (см.
  пример выше).
- **Bytecode Manipulation**:
  Библиотеки, такие как CGLIB, создают прокси на уровне байт-кода, что
  используется в Spring и Hibernate.
- **Functional Wrappers**:
  В Java 8+ можно использовать лямбда-выражения для обёртывания вызовов:
  ```java
  Function<String, String> loggingProxy = input -> {
      System.out.println("Processing: " + input);
      return input.toUpperCase();
  };
  ```

---

### **Итог**

Паттерн Proxy — это мощный инструмент для управления доступом к объектам,
добавления функциональности и оптимизации ресурсов. В Java он широко
используется в стандартной библиотеке (RMI), фреймворках (Spring, Hibernate) и
для реализации ленивой загрузки или кэширования. Прокси обеспечивает
прозрачность и гибкость, но требует осторожности, чтобы не усложнить
архитектуру. В современных приложениях динамические прокси и AOP часто заменяют
ручную реализацию.

Если вам нужен более сложный пример, помощь с реализацией в вашем проекте,
сравнение с другими паттернами (например, Decorator или Facade) или разбор
конкретной задачи, напишите!


---

## Шаблонный метод(Template Method)

**Паттерн Template Method (Шаблонный метод)** — это поведенческий паттерн
проектирования, который определяет общий алгоритм в суперклассе, позволяя
подклассам переопределять отдельные шаги этого алгоритма без изменения его общей
структуры. Он обеспечивает "скелет" алгоритма, где неизменяемая часть остаётся в
суперклассе, а изменяемые части делегируются подклассам.

---

### **Описание паттерна**

**Цель**:

- Определить общий алгоритм, позволяя подклассам настраивать отдельные его шаги.
- Обеспечить повторное использование кода для общей логики.
- Гарантировать, что структура алгоритма остаётся неизменной.

**Когда использовать**:

- Когда несколько классов имеют схожий алгоритм, но с различиями в отдельных
  шагах.
- Когда нужно избежать дублирования кода, вынося общую логику в суперкласс.
- Когда требуется контролировать порядок выполнения шагов алгоритма.
- Когда подклассы должны переопределять только определённые части алгоритма.

**Примеры использования**:

- Обработка данных в разных форматах (например, чтение CSV, JSON).
- Шаблоны обработки запросов в веб-приложениях (например, фильтры в Servlet
  API).
- Жизненный цикл классов в фреймворках (например, методы `onCreate` в Android).

---

### **Структура паттерна**

1. **Абстрактный класс (Abstract Class)**: Определяет шаблонный метод,
   содержащий алгоритм, и абстрактные методы для шагов, которые должны
   реализовать подклассы. Может также содержать конкретные методы или хуки (
   hooks) для необязательной настройки.
2. **Конкретный класс (Concrete Class)**: Подкласс, реализующий абстрактные
   методы и, при необходимости, переопределяющий хуки.
3. **Клиент (Client)**: Использует абстрактный класс или его подклассы, вызывая
   шаблонный метод.

---

### **Реализация в Java**

Пример: шаблонный метод для приготовления напитков (кофе и чая), где процесс
приготовления схож, но отдельные шаги различаются.

```java
// Абстрактный класс
abstract class BeverageMaker {
    // Шаблонный метод
    public final void prepareBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    // Общие методы
    private void boilWater() {
        System.out.println("Boiling water");
    }

    private void pourInCup() {
        System.out.println("Pouring into cup");
    }

    // Абстрактные методы, которые должны реализовать подклассы
    protected abstract void brew();

    protected abstract void addCondiments();

    // Хук (hook) для необязательной настройки
    protected boolean customerWantsCondiments() {
        return true; // По умолчанию добавляем добавки
    }
}

// Конкретный класс: Кофе
class CoffeeMaker extends BeverageMaker {
    @Override
    protected void brew() {
        System.out.println("Brewing coffee grounds");
    }

    @Override
    protected void addCondiments() {
        System.out.println("Adding sugar and milk");
    }
}

// Конкретный класс: Чай
class TeaMaker extends BeverageMaker {
    @Override
    protected void brew() {
        System.out.println("Steeping tea leaves");
    }

    @Override
    protected void addCondiments() {
        System.out.println("Adding lemon");
    }

    @Override
    protected boolean customerWantsCondiments() {
        return false; // По умолчанию без добавок
    }
}

// Клиентский код
public class TemplateMethodExample {
    public static void main(String[] args) {
        System.out.println("Making Coffee:");
        BeverageMaker coffee = new CoffeeMaker();
        coffee.prepareBeverage();
        // Вывод:
        // Boiling water
        // Brewing coffee grounds
        // Pouring into cup
        // Adding sugar and milk

        System.out.println("\nMaking Tea:");
        BeverageMaker tea = new TeaMaker();
        tea.prepareBeverage();
        // Вывод:
        // Boiling water
        // Steeping tea leaves
        // Pouring into cup
    }
}
```

---

### **Как это работает**

1. Абстрактный класс `BeverageMaker` определяет шаблонный метод
   `prepareBeverage()`, который фиксирует порядок шагов: кипячение воды,
   заваривание, наливание в чашку и добавление добавок (если нужно).
2. Конкретные методы (`boilWater`, `pourInCup`) содержат общую логику,
   одинаковую для всех напитков.
3. Абстрактные методы (`brew`, `addCondiments`) должны быть реализованы
   подклассами (`CoffeeMaker`, `TeaMaker`).
4. Хук `customerWantsCondiments` позволяет подклассам настраивать поведение (
   например, отключить добавки для чая).
5. Клиент вызывает `prepareBeverage()` на объекте подкласса, и алгоритм
   выполняется с учётом специфичных для подкласса шагов.

---

### **Реальное использование в Java**

1. **Servlet API**:
   В Java Servlet API метод `service()` в `HttpServlet` действует как шаблонный
   метод:
   ```java
   import javax.servlet.http.HttpServlet;
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;

   public class MyServlet extends HttpServlet {
       @Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
           // Обработка GET-запроса
       }

       @Override
       protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
           // Обработка POST-запроса
       }
   }
   ```
   Метод `service()` в `HttpServlet` определяет общий алгоритм обработки
   HTTP-запросов, вызывая `doGet`, `doPost` и другие методы, которые
   переопределяются в подклассах.

2. **Abstract Classes в Java Collections**:
   Классы, такие как `AbstractList`, предоставляют шаблонные методы:
   ```java
   import java.util.AbstractList;

   public class MyList extends AbstractList<String> {
       private final String[] data = {"A", "B", "C"};

       @Override
       public String get(int index) {
           return data[index];
       }

       @Override
       public int size() {
           return data.length;
       }
   }
   ```
   `AbstractList` реализует общую логику списка, а подклассы переопределяют
   методы, такие как `get` и `size`.

3. **Spring Framework**:
   Spring использует Template Method в классах, таких как `JdbcTemplate`:
   ```java
   import org.springframework.jdbc.core.JdbcTemplate;

   JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
   jdbcTemplate.execute("SELECT * FROM users");
   ```
   `JdbcTemplate` определяет общий алгоритм выполнения SQL-запросов (
   подключение, выполнение, обработка ошибок), а конкретные запросы задаются
   клиентом.

---

### **Преимущества**

- **Повторное использование кода**: Общая логика выносится в суперкласс,
  уменьшая дублирование.
- **Контроль структуры**: Шаблонный метод гарантирует неизменность общей
  структуры алгоритма.
- **Гибкость**: Подклассы могут настраивать отдельные шаги, не затрагивая общий
  алгоритм.
- **Соответствие принципу Open/Closed**: Алгоритм открыт для расширения (новые
  подклассы), но закрыт для модификации.

---

### **Недостатки**

- **Ограниченность наследованием**: Подклассы должны наследовать абстрактный
  класс, что может быть неудобно в сравнении с композицией.
- **Жёсткая структура**: Изменение порядка шагов требует модификации шаблонного
  метода.
- **Сложность поддержки**: При большом числе подклассов может быть трудно
  отслеживать все переопределения.
- **Ограниченная гибкость**: Подклассы могут переопределять только те шаги,
  которые предусмотрены в суперклассе.

---

### **Отличие от других паттернов**

- **Template Method vs Strategy**:
    - **Template Method** использует наследование для настройки шагов алгоритма.
    - **Strategy** использует композицию, передавая алгоритм как объект.
- **Template Method vs Factory Method**:
    - **Template Method** определяет алгоритм с переопределяемыми шагами.
    - **Factory Method** фокусируется на создании объектов через абстрактный
      метод.
- **Template Method vs Builder**:
    - **Template Method** фиксирует порядок шагов для выполнения алгоритма.
    - **Builder** фокусируется на пошаговом создании объекта.

---

### **Проблемы и антипаттерны**

1. **Слишком жёсткий шаблон**: Если алгоритм слишком строго фиксирует шаги,
   подклассы могут быть ограничены в гибкости.
    - **Решение**: Используйте хуки или делайте больше методов защищёнными (
      `protected`), чтобы подклассы могли их переопределять.
2. **Злоупотребление наследованием**: Наследование может привести к сильной
   связанности и усложнить тестирование.
    - **Решение**: Рассмотрите Strategy или композицию для большей гибкости.
3. **Сложность тестирования**: Тестирование подклассов может быть затруднено
   из-за зависимости от суперкласса.
    - **Решение**: Используйте мок-объекты или извлекайте логику в отдельные
      классы.

---

### **Современные альтернативы в Java**

- **Strategy с композицией**:
  Вместо наследования можно использовать Strategy для большей гибкости:
  ```java
  interface BrewStrategy {
      void brew();
  }

  class CoffeeBrew implements BrewStrategy {
      public void brew() { System.out.println("Brewing coffee grounds"); }
  }

  class BeverageMaker {
      private final BrewStrategy brewStrategy;

      public BeverageMaker(BrewStrategy brewStrategy) {
          this.brewStrategy = brewStrategy;
      }

      public void prepareBeverage() {
          System.out.println("Boiling water");
          brewStrategy.brew();
          System.out.println("Pouring into cup");
      }
  }
  ```
- **Лямбда-выражения**:
  В Java 8+ шаги алгоритма можно передавать как лямбда-выражения:
  ```java
  class BeverageMaker {
      public void prepareBeverage(Runnable brew, Runnable addCondiments) {
          System.out.println("Boiling water");
          brew.run();
          System.out.println("Pouring into cup");
          addCondiments.run();
      }
  }

  BeverageMaker maker = new BeverageMaker();
  maker.prepareBeverage(
          () -> System.out.println("Brewing coffee grounds"),
          () -> System.out.println("Adding sugar and milk")
  );
  ```
- **Spring Template Classes**:
  Spring использует подход, похожий на Template Method, в классах, таких как
  `JdbcTemplate` или `RestTemplate`, где общая логика фиксирована, а клиент
  предоставляет детали.

---

### **Итог**

Паттерн Template Method — это эффективный способ определения общего алгоритма с
возможностью настройки его шагов в подклассах. Он широко используется в Java,
особенно в стандартной библиотеке (Servlet API, Collections) и фреймворках (
Spring). Паттерн обеспечивает повторное использование кода и контроль структуры,
но его зависимость от наследования может быть ограничением. В современных
приложениях Template Method иногда заменяется Strategy или лямбда-выражениями
для большей гибкости.

Если вам нужен более сложный пример, помощь с реализацией в вашем проекте,
сравнение с другими паттернами (например, Strategy или Builder) или разбор
конкретной задачи, напишите!

----

## Итератор(Iterator)

**Паттерн Iterator (Итератор)** — это поведенческий паттерн проектирования,
который предоставляет способ последовательного доступа к элементам коллекции (
например, списка, массива, дерева) без раскрытия её внутренней структуры. Он
позволяет клиентам обходить элементы коллекции, не зная, как они хранятся (
например, в массиве, списке или хэш-таблице), и обеспечивает единый интерфейс
для работы с разными типами коллекций.

---

### **Описание паттерна**

**Цель**:

- Обеспечить стандартизированный способ обхода элементов коллекции.
- Скрыть детали реализации коллекции от клиента.
- Поддерживать различные способы обхода (например, прямой, обратный,
  фильтрованный).

**Когда использовать**:

- Когда нужно предоставить доступ к элементам сложной структуры данных без
  раскрытия её внутренней организации.
- Когда требуется поддерживать несколько способов обхода одной коллекции.
- Когда нужно унифицировать работу с разными типами коллекций (списки, массивы,
  деревья).
- Когда коллекция должна быть обойдена без изменения её структуры.

**Примеры использования**:

- Обход элементов коллекций в Java (`List`, `Set`, `Map`).
- Итерация по результатам базы данных (например, `ResultSet` в JDBC).
- Перебор узлов в структурах данных, таких как деревья или графы.

---

### **Структура паттерна**

1. **Итератор (Iterator)**: Интерфейс, определяющий методы для доступа к
   элементам коллекции, такие как `hasNext()` (есть ли следующий элемент) и
   `next()` (получить следующий элемент).
2. **Конкретный итератор (Concrete Iterator)**: Класс, реализующий интерфейс
   итератора, который отслеживает текущую позицию и логику обхода.
3. **Агрегат (Aggregate)**: Интерфейс или абстрактный класс, представляющий
   коллекцию и предоставляющий метод для создания итератора.
4. **Конкретный агрегат (Concrete Aggregate)**: Класс, реализующий коллекцию и
   возвращающий соответствующий итератор.
5. **Клиент (Client)**: Код, использующий итератор для обхода элементов
   коллекции.

---

### **Реализация в Java**

Пример: итератор для обхода пользовательской коллекции книг.

```java
import java.util.ArrayList;
import java.util.List;

// Интерфейс итератора
interface Iterator<T> {
    boolean hasNext();

    T next();
}

// Интерфейс агрегата
interface BookCollection {
    Iterator<Book> createIterator();
}

// Класс продукта
class Book {
    private final String title;

    public Book(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }
}

// Конкретный агрегат
class Library implements BookCollection {
    private final List<Book> books;

    public Library() {
        this.books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
    }

    @Override
    public Iterator<Book> createIterator() {
        return new LibraryIterator(books);
    }
}

// Конкретный итератор
class LibraryIterator implements Iterator<Book> {
    private final List<Book> books;
    private int index;

    public LibraryIterator(List<Book> books) {
        this.books = books;
        this.index = 0;
    }

    @Override
    public boolean hasNext() {
        return index < books.size();
    }

    @Override
    public Book next() {
        if (!hasNext()) {
            throw new IndexOutOfBoundsException("No more books");
        }
        return books.get(index++);
    }
}

// Клиентский код
public class IteratorExample {
    public static void main(String[] args) {
        Library library = new Library();
        library.addBook(new Book("The Hobbit"));
        library.addBook(new Book("1984"));
        library.addBook(new Book("Pride and Prejudice"));

        Iterator<Book> iterator = library.createIterator();
        while (iterator.hasNext()) {
            Book book = iterator.next();
            System.out.println("Book: " + book.getTitle());
        }
        // Вывод:
        // Book: The Hobbit
        // Book: 1984
        // Book: Pride and Prejudice
    }
}
```

---

### **Как это работает**

1. Клиент запрашивает итератор у коллекции (`Library`) через метод
   `createIterator()`.
2. Итератор (`LibraryIterator`) отслеживает текущую позицию в коллекции (с
   помощью `index`) и предоставляет методы `hasNext()` и `next()` для доступа к
   элементам.
3. Клиент использует итератор для последовательного обхода элементов, не зная,
   как они хранятся в коллекции (например, в `ArrayList`).
4. Коллекция остаётся неизменной, а итератор управляет процессом обхода.

---

### **Реальное использование в Java**

Java имеет встроенную поддержку паттерна Iterator через интерфейсы
`java.util.Iterator` и `java.util.Iterable`, которые используются повсеместно в
стандартной библиотеке.

1. **Collections Framework**:
   Все коллекции, реализующие `Iterable` (например, `List`, `Set`, `Map`),
   предоставляют итератор:
   ```java
   import java.util.ArrayList;
   import java.util.Iterator;

   ArrayList<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");

   Iterator<String> iterator = list.iterator();
   while (iterator.hasNext()) {
       System.out.println(iterator.next());
   }
   ```
   Или с использованием цикла `for-each`, который автоматически использует
   итератор:
   ```java
   for (String item : list) {
       System.out.println(item);
   }
   ```

2. **JDBC ResultSet**:
   `ResultSet` в JDBC реализует итератор для обхода строк результата запроса:
   ```java
   import java.sql.ResultSet;
   import java.sql.Statement;
   import java.sql.Connection;

   try (Connection conn = getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {
       while (rs.next()) {
           System.out.println(rs.getString("name"));
       }
   }
   ```

3. **Stream API**:
   В Java 8+ итераторы частично заменены Stream API, но они всё ещё используются
   под капотом:
   ```java
   import java.util.List;

   List<String> list = List.of("A", "B", "C");
   list.stream().forEach(System.out::println);
   ```

---

### **Преимущества**

- **Инкапсуляция**: Скрывает внутреннюю структуру коллекции от клиента.
- **Универсальность**: Предоставляет единый интерфейс для обхода разных типов
  коллекций.
- **Гибкость**: Поддерживает различные способы обхода (например, прямой,
  обратный, фильтрованный).
- **Безопасность**: Позволяет обходить коллекцию без её модификации.
- **Поддержка for-each**: В Java коллекции, реализующие `Iterable`,
  автоматически работают с циклом `for-each`.

---

### **Недостатки**

- **Ограниченная функциональность**: Классический итератор поддерживает только
  последовательный доступ (нет возможности вернуться назад или пропустить
  элементы).
- **Сложность для сложных структур**: Реализация итератора для деревьев или
  графов может быть нетривиальной.
- **Потенциальные проблемы с concorrency**: Итератор может выбросить
  `ConcurrentModificationException`, если коллекция изменяется во время обхода.
- **Менее мощный, чем Stream API**: В современных Java-приложениях Stream API
  часто предпочтительнее для сложных операций.

---

### **Отличие от других паттернов**

- **Iterator vs Composite**:
    - **Iterator** предоставляет способ обхода элементов коллекции.
    - **Composite** управляет древовидной структурой объектов, позволяя работать
      с группами как с единым объектом.
- **Iterator vs Visitor**:
    - **Iterator** фокусируется на последовательном доступе к элементам.
    - **Visitor** позволяет выполнять операции над элементами, передавая логику
      в отдельный объект.
- **Iterator vs Strategy**:
    - **Iterator** определяет способ обхода коллекции.
    - **Strategy** определяет взаимозаменяемые алгоритмы для выполнения задачи.

---

### **Проблемы и антипаттерны**

1. **ConcurrentModificationException**: Если коллекция изменяется во время
   итерации, итератор может выбросить исключение.
    - **Решение**: Используйте `CopyOnWriteArrayList` или синхронизируйте доступ
      к коллекции.
    - **Альтернатива**: Используйте Stream API, которая работает с неизменяемыми
      данными.
2. **Сложность реализации для нестандартных структур**: Итераторы для деревьев
   или графов требуют сложной логики.
    - **Решение**: Используйте рекурсию или библиотеки, такие как Guava, для
      упрощения.
3. **Злоупотребление итератором**: Использование итератора для простых
   коллекций, где достаточно `for-each` или Stream.
    - **Решение**: Применяйте итератор только для сложных или нестандартных
      сценариев.

---

### **Современные альтернативы в Java**

- **Stream API**:
  В Java 8+ Stream API предоставляет более мощный и декларативный способ
  обработки коллекций:
  ```java
  List<String> list = List.of("A", "B", "C");
  list.stream()
      .filter(s -> s.startsWith("A"))
      .forEach(System.out::println);
  ```
  Stream API поддерживает ленивые вычисления, параллелизм и сложные операции (
  фильтрация, маппинг).

- **Spliterator**:
  В Java 8 введён `Spliterator` (Splittable Iterator), который поддерживает
  параллельную обработку:
  ```java
  import java.util.Spliterator;
  import java.util.List;

  List<String> list = List.of("A", "B", "C");
  Spliterator<String> spliterator = list.spliterator();
  spliterator.forEachRemaining(System.out::println);
  ```

- **Guava Iterators**:
  Библиотека Guava предоставляет утилиты для работы с итераторами, такие как
  `Iterators.filter` или `Iterators.transform`:
  ```java
  import com.google.common.collect.Iterators;
  import java.util.Iterator;

  Iterator<String> filtered = Iterators.filter(list.iterator(), s -> s.startsWith("A"));
  ```

---

### **Итог**

Паттерн Iterator — это фундаментальный инструмент для последовательного доступа
к элементам коллекции, скрывающий её внутреннюю структуру. В Java он встроен в
стандартную библиотеку через `Iterator` и `Iterable`, что делает его основой для
работы с коллекциями. Хотя Stream API и Spliterator в современных приложениях
часто заменяют классический итератор для сложных операций, паттерн остаётся
актуальным для нестандартных коллекций или случаев, где требуется явный контроль
над обходом.

Если вам нужен более сложный пример (например, итератор для дерева), помощь с
реализацией в вашем проекте, сравнение с другими паттернами (например, Visitor
или Composite) или разбор конкретной задачи, напишите!