# **Singleton (Одиночка)**

**Паттерн Singleton (Одиночка)** — это порождающий паттерн проектирования,
который гарантирует, что у класса есть только один экземпляр, и предоставляет
глобальную точку доступа к этому экземпляру. Он часто используется в ситуациях,
когда требуется единый доступ к ресурсу или состоянию, например, для логгеров,
конфигураций или пулов соединений.

### **Описание паттерна**

**Когда использовать**:

- Необходим ровно один экземпляр класса (например, для управления доступом к
  общему ресурсу).
- Требуется глобальная точка доступа (например, для логгера или конфигурации).
- Создание нескольких экземпляров дорого или нежелательно.
- Логгер (`java.util.logging.Logger` или `SLF4J`).
- Пул соединений с базой данных.
- Кэш или конфигурация приложения.

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/singleton_structure.png" alt="singleton" style="width:100%; max-width: 550px">

1. Одиночка определяет статический метод getInstance,
   который возвращает единственный экземпляр своего
   класса.<br>
   Конструктор одиночки должен быть скрыт от клиентов.
   Вызов метода getInstance должен стать единственным
   способом получить объект этого класса.

### **Реализация в Java**

Существует несколько способов реализации Singleton в Java, каждый с учётом
потокобезопасности и производительности. Рассмотрим основные варианты.

#### Двойная проверка блокировки (Double-Checked Locking)

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**Плюсы**: Потокобезопасен, минимизирует накладные расходы синхронизации.  
**Особенности**: Ключевое слово `volatile` предотвращает проблемы с частичной
инициализацией объекта в многопоточной среде.

### **Пример реального использования**

Допустим, нам нужен логгер, который используется во всём приложении:

```java
public class Logger {
    private static final Logger instance = new Logger();

    private Logger() {
    }

    public static Logger getInstance() {
        return instance;
    }

    public void log(String message) {
        System.out.println("Log: " + message);
    }
}

public class Application {
    public static void main(String[] args) {
        Logger logger = Logger.getInstance();
        logger.log("Application started");
    }
}
```

### **Проблемы решаемы паттерном**

Паттерн **Singleton (Одиночка)** решает ряд проблем, связанных с управлением
ресурсами и доступом к объектам в приложении. Он обеспечивает наличие только
одного экземпляра класса и предоставляет глобальную точку доступа к нему. Вот
основные проблемы, которые решает этот паттерн:

### 1. **Гарантия единственного экземпляра объекта**

- **Проблема**: В некоторых случаях требуется, чтобы в приложении существовал
  только один экземпляр определённого объекта, например, для управления общим
  ресурсом (конфигурация, логгер, пул соединений). Множественные экземпляры
  могут привести к конфликтам, неэффективному использованию ресурсов или
  непредсказуемому поведению.
- **Решение**: Singleton гарантирует, что создаётся и используется только один
  экземпляр класса. Это достигается через приватный конструктор и статический
  метод доступа (`getInstance()`).
- **Пример**: Логгер приложения (`SLF4J` или `java.util.logging.Logger`) должен
  быть единым, чтобы все записи логов писались в один файл или поток.

### 2. **Глобальная точка доступа**

- **Проблема**: Некоторые объекты должны быть доступны из разных частей
  приложения без необходимости передавать их экземпляры через параметры или
  зависимости. Без единой точки доступа это может привести к сложностям в
  управлении или дублированию кода.
- **Решение**: Singleton предоставляет статический метод (`getInstance()`),
  через который любой компонент приложения может получить доступ к единственному
  экземпляру.
- **Пример**: Конфигурация приложения (например, настройки базы данных) может
  быть доступна через Singleton, чтобы любой модуль мог её использовать.

### 3. **Экономия ресурсов**

- **Проблема**: Создание нескольких экземпляров объекта, особенно если он
  требует значительных ресурсов (например, подключение к базе данных или
  загрузка большого файла конфигурации), может быть дорогостоящим по памяти и
  времени.
- **Решение**: Singleton позволяет создать объект один раз и переиспользовать
  его, минимизируя затраты ресурсов. Ленивая инициализация (lazy initialization)
  дополнительно откладывает создание до первого обращения.
- **Пример**: Пул соединений с базой данных создаётся один раз и используется
  всеми частями приложения.

### 4. **Управление общим состоянием**

- **Проблема**: Некоторые объекты должны хранить общее состояние, доступное всем
  компонентам приложения, например, счётчик запросов или кэш данных.
  Множественные экземпляры могут привести к рассинхронизации состояния.
- **Решение**: Singleton обеспечивает единое место для хранения и управления
  общим состоянием, гарантируя, что все компоненты работают с одними и теми же
  данными.
- **Пример**: Кэш данных, где все запросы к внешнему API сохраняются в одном
  месте для повторного использования.

### 5. **Упрощение взаимодействия с подсистемами**

- **Проблема**: Взаимодействие с подсистемами, которые требуют единой точки
  управления (например, диспетчер событий или менеджер ресурсов), может быть
  сложным, если каждый компонент создаёт свои экземпляры.
- **Решение**: Singleton предоставляет централизованную точку управления,
  упрощая координацию и взаимодействие.
- **Пример**: Менеджер событий в GUI-приложении, который распределяет события
  между компонентами, должен быть единым.

### **Конкретные примеры в Java**

- **Логгеры**: Классы, такие как `java.util.logging.Logger` или
  `org.slf4j.Logger`, часто реализуются как Singleton (или с аналогичным
  поведением), чтобы все логи писались в один поток.
- **Пулы соединений**: Объекты, управляющие соединениями с базой данных (
  например, `DataSource` в JDBC), используют Singleton для управления единым
  пулом.
- **Конфигурации**: Классы, хранящие настройки приложения (например,
  `Properties` или пользовательские конфигурации), часто делают Singleton, чтобы
  избежать дублирования.

### **Дополнительные аспекты**

- **Потокобезопасность**: В многопоточных приложениях Singleton решает проблему
  создания нескольких экземпляров, используя механизмы синхронизации или ленивую
  инициализацию (например, `double-checked locking` или
  `Initialization-on-demand Holder`).
    - **Пример**:
      ```java
      public class Singleton {
          private static volatile Singleton instance;
  
          private Singleton() {}
  
          public static Singleton getInstance() {
              if (instance == null) {
                  synchronized (Singleton.class) {
                      if (instance == null) {
                          instance = new Singleton();
                      }
                  }
              }
              return instance;
          }
      }
      ```

- **Сериализация и рефлексия**: Singleton решает проблемы, связанные с
  сохранением единственности экземпляра при сериализации или использовании
  рефлексии, через специальные методы (например, `readResolve`) или
  enum-реализацию.
    - **Пример с enum**:
      ```java
      public enum Singleton {
          INSTANCE;
          public void doSomething() { /* Логика */ }
      }
      ```

### **Проблемы, которые НЕ решает Singleton**

- **Тестирование**: Singleton может усложнить тестирование, так как его
  глобальное состояние сохраняется между тестами.
- **Гибкость**: Singleton фиксирует единственный экземпляр, что может быть
  ограничивающим, если в будущем потребуется несколько экземпляров.
- **Антипаттерны**: Неправильное использование (например, для хранения
  изменяемого состояния) может привести к проблемам, таким как скрытые
  зависимости или трудно отслеживаемые ошибки.

### **Проблемы и антипаттерны**

**_Проблема:_**

Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности
класса.

1. Гарантирует наличие единственного экземпляра класса. Чаще всего это полезно
   для доступа к какому-то общему ресурсу, например, базе данных.
2. Предоставляет глобальную точку доступа. Это не просто глобальная переменная,
   через которую можно достучаться к определённому объекту. Глобальные
   переменные не защищены от записи, поэтому любой код может подменять их
   значения без вашего ведома. Но есть и другой нюанс. Неплохо бы хранить в
   одном месте и код, который решает проблему №1, а также иметь к нему простой и
   доступный интерфейс.

**_Решение:_**

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и
создать публичный статический метод, который и будет контролировать жизненный
цикл объекта-одиночки.
Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому
статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет
отдавать один и тот же объект.

Singleton, несмотря на популярность, может стать антипаттерном, если
используется неправильно:

1. **Скрытые зависимости**: Классы, использующие Singleton, напрямую зависят от
   его реализации, что затрудняет тестирование.

- **Решение**: Используйте Dependency Injection (например, Spring), чтобы
  передавать зависимости явно.

2. **Проблемы с тестированием**: Статическое состояние Singleton сохраняется
   между тестами.

- **Решение**: Добавьте метод для сброса состояния в тестах или используйте
  мок-объекты.

3. **Потокобезопасность**: Неправильная реализация может привести к созданию
   нескольких экземпляров.

- **Решение**: Используйте варианты с двойной проверкой или Holder.

4. **Глобальное состояние**: Может привести к трудно отслеживаемым побочным
   эффектам.

- **Решение**: Минимизируйте использование Singleton для объектов с изменяемым
  состоянием.

### **Современные альтернативы**

В современных Java-приложениях Singleton часто заменяется другими подходами,
которые решают те же проблемы, но с большей гибкостью:

- **Dependency Injection (DI)**: Фреймворки, такие как Spring, создают и
  управляют единственным экземпляром объекта (scope `singleton`), передавая его
  через зависимости.
    - **Пример**:
      ```java
      @Component
      class Logger {
          public void log(String message) { /* Логика */ }
      }
  
      @Autowired
      private Logger logger; // Spring обеспечивает единственный экземпляр
      ```
- **Статические утилитные классы**: Для простых случаев, где не требуется
  состояние, можно использовать статические методы вместо Singleton.
- **Фабрики**: Для управления ресурсами можно использовать Factory Method или
  Abstract Factory, предоставляя больше контроля над созданием объектов.

### **Преимущества Singleton**

- Гарантирует единственный экземпляр.
- Упрощает доступ к общему ресурсу.
- Ленивая инициализация (в некоторых реализациях) экономит ресурсы.

### **Недостатки Singleton**

- Может привести к скрытым зависимостям.
- Усложняет модульное тестирование.
- Потенциальные проблемы в многопоточной среде.
- Нарушение принципа единственной ответственности, если Singleton выполняет
  слишком много функций.

### **Когда НЕ использовать Singleton**

- Если класс имеет изменяемое состояние, которое должно быть независимым для
  разных контекстов.
- Когда требуется несколько экземпляров в будущем (Singleton трудно
  переработать).
- В тестах, где нужно подменять реализацию (лучше использовать DI).

### **Итог**

Паттерн Singleton решает проблемы, связанные с необходимостью единственного
экземпляра объекта, глобального доступа, экономии ресурсов и управления общим
состоянием. Он особенно полезен для логгеров, пулов соединений, кэшей и
конфигураций. Однако его следует использовать с осторожностью, чтобы избежать
антипаттернов, таких как скрытые зависимости или сложности с тестированием. В
современных приложениях Dependency Injection часто является более гибкой
альтернативой.


