# Абстрактная фабрика

Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет
создавать семейства связанных объектов, не привязываясь к конкретным классам
создаваемых объектов.

**Паттерн Abstract Factory (Абстрактная фабрика)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания семейств связанных
или взаимозависимых объектов без указания их конкретных классов. Он позволяет
создавать группы объектов, которые работают вместе, обеспечивая совместимость
между ними.

### **Описание паттерна**

**Цель**:

- Создавать семейства связанных объектов, не привязываясь к их конкретным
  классам.
- Гарантировать, что создаваемые объекты совместимы друг с другом.

**Когда использовать**:

- Когда система должна поддерживать несколько семейств объектов (например,
  UI-компоненты для разных платформ: Windows, macOS).
- Когда нужно гарантировать совместимость создаваемых объектов.
- Когда требуется изолировать клиентский код от конкретных реализаций.

**Примеры использования**:

- Создание UI-компонентов (кнопки, текстовые поля) для разных операционных
  систем.
- Генерация объектов для разных баз данных (например, драйверы и соединения для
  MySQL, PostgreSQL).
- Поддержка различных тем оформления в приложении (светлая, тёмная).

### Структура паттерна

<img src="/img/design_pattern/design_patterns/abstract_factory_structure.png" alt="factory_method" style="max-width: 550px">

1. Абстрактные продукты объявляют интерфейсы продуктов, которые связаны друг с
   другом по смыслу, но выполняют разные функции.
2. Конкретные продукты — большой набор классов, которые относятся к различным
   абстрактным продуктам (кресло/столик), но имеют одни и те же вариации (
   Викторианский/Модерн).
3. Абстрактная фабрика объявляет методы создания различных абстрактных
   продуктов (кресло/столик).
4. Конкретные фабрики относятся каждая к своей вариации продуктов (
   Викторианский/Модерн) и реализуют методы абстрактной фабрики, позволяя
   создавать все продукты определённой вариации.
5. Несмотря на то, что конкретные фабрики порождают конкретные продукты,
   сигнатуры их методов должны возвращать соответствующие абстрактные продукты.
   Это позволит клиентскому коду, использующему фабрику, не привязываться к
   конкретным классам продуктов. Клиент сможет работать с любыми вариациями
   продуктов через абстрактные интерфейсы.

### **Реализация в Java**

Пример: создание UI-компонентов (кнопок и текстовых полей) для разных
операционных систем (Windows и macOS).

```java
// Абстрактные продукты
interface Button {
    void render();
}

interface TextField {
    void input();
}

// Конкретные продукты для Windows
class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering Windows Button");
    }
}

class WindowsTextField implements TextField {
    public void input() {
        System.out.println("Input in Windows TextField");
    }
}

// Конкретные продукты для macOS
class MacOSButton implements Button {
    public void render() {
        System.out.println("Rendering macOS Button");
    }
}

class MacOSTextField implements TextField {
    public void input() {
        System.out.println("Input in macOS TextField");
    }
}

// Абстрактная фабрика
interface UIFactory {
    Button createButton();

    TextField createTextField();
}

// Конкретные фабрики
class WindowsUIFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public TextField createTextField() {
        return new WindowsTextField();
    }
}

class MacOSUIFactory implements UIFactory {
    public Button createButton() {
        return new MacOSButton();
    }

    public TextField createTextField() {
        return new MacOSTextField();
    }
}

// Клиентский код
public class Application {
    private final Button button;
    private final TextField textField;

    public Application(UIFactory factory) {
        this.button = factory.createButton();
        this.textField = factory.createTextField();
    }

    public void renderUI() {
        button.render();
        textField.input();
    }

    public static void main(String[] args) {
        UIFactory windowsFactory = new WindowsUIFactory();
        Application windowsApp = new Application(windowsFactory);
        windowsApp.renderUI(); // Вывод: Rendering Windows Button, Input in Windows TextField

        UIFactory macOSFactory = new MacOSUIFactory();
        Application macOSApp = new Application(macOSFactory);
        macOSApp.renderUI(); // Вывод: Rendering macOS Button, Input in macOS TextField
    }
}
```

### **Как это работает**

1. Клиентский код работает с абстрактной фабрикой (`UIFactory`) и абстрактными
   продуктами (`Button`, `TextField`).
2. Конкретная фабрика (`WindowsUIFactory` или `MacOSUIFactory`) создаёт
   семейство совместимых продуктов (например, только Windows-компоненты).
3. Клиент не знает, какие конкретные классы создаются, что делает систему гибкой
   и независимой от реализаций.

### **Преимущества**

- **Совместимость продуктов**: Гарантирует, что создаваемые объекты принадлежат
  одному семейству (например, Windows-кнопка не смешивается с macOS-полем).
- **Гибкость**: Легко добавить новое семейство продуктов, создав новую фабрику.
- **Соответствие принципу Open/Closed**: Система открыта для расширения (новые
  фабрики), но закрыта для модификации.
- **Изоляция**: Клиентский код работает с абстракциями, а не с конкретными
  классами.

### **Недостатки**

- **Усложнение кода**: Требует создания множества классов (фабрики, продукты).
- **Дополнительная абстракция**: Может быть избыточной для простых систем.
- **Сложность поддержки**: При добавлении нового продукта нужно обновлять все
  фабрики.

### **Пример реального использования в Java**

1. **Java AWT/Swing**:
   В Java библиотеки для создания UI (AWT и Swing) используют паттерн, похожий
   на Abstract Factory, для создания компонентов, специфичных для платформы.
   Например, `Toolkit` действует как фабрика, создающая платформозависимые
   компоненты:
   ```java
   import java.awt.*;
   Button button = Toolkit.getDefaultToolkit().createButton("Click me");
   ```
   `Toolkit` возвращает компоненты, соответствующие текущей ОС.

2. **JDBC** В JDBC разные драйверы (MySQL, PostgreSQL) предоставляют семейства
   объектов (соединения, подготовленные запросы), что можно рассматривать как
   реализацию Abstract Factory.

3. **Spring Framework**:
   Spring `ApplicationContext` может создавать семейства связанных beans, что
   напоминает Abstract Factory:
   ```java
   ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
   ```

### **Проблемы решаемые паттерном**

Паттерн **Abstract Factory (Абстрактная фабрика)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания семейств связанных
или взаимозависимых объектов без указания их конкретных классов. Он решает ряд
проблем, связанных с созданием групп объектов, которые должны быть совместимыми
и работать вместе. Вот основные проблемы, которые решает этот паттерн:

### 1. **Создание семейств связанных объектов**

- **Проблема**: В системе может потребоваться создавать группы объектов, которые
  связаны между собой и должны быть совместимыми (например, UI-компоненты для
  разных платформ, такие как кнопки и текстовые поля для Windows или macOS).
  Создание таких объектов напрямую в клиентском коде приводит к жёсткой привязке
  к конкретным классам и усложняет поддержку.
- **Решение**: Abstract Factory предоставляет интерфейс для создания семейств
  объектов, гарантируя, что все созданные объекты принадлежат одному семейству (
  например, только Windows-компоненты). Клиент работает с абстрактным
  интерфейсом фабрики, не зная конкретных классов.
- **Пример**: В UI-фреймворке фабрика создаёт кнопки и текстовые поля,
  совместимые с конкретной платформой:
  ```java
  interface UIFactory {
      Button createButton();
      TextField createTextField();
  }

  class WindowsUIFactory implements UIFactory {
      public Button createButton() { return new WindowsButton(); }
      public TextField createTextField() { return new WindowsTextField(); }
  }
  ```

### 2. **Гарантия совместимости создаваемых объектов**

- **Проблема**: Если клиентский код создаёт объекты напрямую, есть риск
  смешивания объектов из разных семейств (например, Windows-кнопка с
  macOS-полем), что может привести к несовместимости или некорректному
  поведению.
- **Решение**: Abstract Factory обеспечивает, что все объекты, созданные одной
  фабрикой, принадлежат одному семейству и совместимы друг с другом. Это
  особенно важно для систем, где объекты должны работать в связке.
- **Пример**: В игре фабрика создаёт оружие и броню для разных фракций (
  например, эльфы или орки), гарантируя, что экипировка соответствует фракции.

### 3. **Упрощение добавления новых семейств объектов**

- **Проблема**: Добавление нового семейства объектов (например, поддержка новой
  платформы или темы оформления) требует значительных изменений в коде, если
  создание объектов не структурировано. Это нарушает принцип Open/Closed (
  открытость для расширения, закрытость для модификации).
- **Решение**: Abstract Factory позволяет добавить новое семейство объектов,
  просто создав новый класс фабрики, реализующий абстрактный интерфейс.
  Клиентский код остаётся неизменным, так как работает с абстракцией.
- **Пример**: Для добавления поддержки Linux в UI-фреймворк достаточно создать
  `LinuxUIFactory`, не меняя клиентский код.

### 4. **Изоляция клиентского кода от конкретных реализаций**

- **Проблема**: Клиентский код, создающий объекты напрямую через `new`,
  становится зависимым от конкретных классов, что усложняет замену реализаций и
  увеличивает связанность.
- **Решение**: Abstract Factory скрывает детали создания объектов, предоставляя
  клиенту только абстрактный интерфейс фабрики и продуктов. Это уменьшает
  связанность и упрощает поддержку.
- **Пример**: Клиентский код работает с `UIFactory`, не зная, создаются ли
  `WindowsButton` или `MacOSButton`.

### 5. **Поддержка принципа Open/Closed**

- **Проблема**: Без структурированного подхода к созданию объектов добавление
  новых типов или семейств требует изменения существующего кода, что делает
  систему хрупкой.
- **Решение**: Abstract Factory делает систему открытой для расширения (новые
  фабрики и продукты добавляются легко) и закрытой для модификации (клиентский
  код не меняется).
- **Пример**: В системе рендеринга графики можно добавить новую фабрику для
  Vulkan, не трогая код, работающий с OpenGL.

### 6. **Упрощение работы с подсистемами**

- **Проблема**: Если подсистема состоит из множества взаимосвязанных объектов,
  клиентский код должен знать, как их создавать и комбинировать, что увеличивает
  сложность.
- **Решение**: Abstract Factory предоставляет единый интерфейс для создания всех
  объектов подсистемы, упрощая их интеграцию и использование.
- **Пример**: В JDBC фабрика может создавать объекты для соединения, запросов и
  транзакций, специфичных для базы данных (MySQL, PostgreSQL).

### 7. **Упрощение тестирования**

- **Проблема**: Жёсткая привязка к конкретным классам затрудняет подмену
  объектов в тестах (например, для создания мок-объектов).
- **Решение**: Abstract Factory позволяет подменять фабрику в тестах, возвращая
  заглушки или моки вместо реальных объектов, что упрощает тестирование.
- **Пример**: В тестах можно использовать `MockUIFactory`, которая возвращает
  `MockButton` и `MockTextField`.

### **Проблемы, которые НЕ решает Abstract Factory**

- **Добавление новых продуктов**: Если нужно добавить новый тип продукта (
  например, `Checkbox` к `Button` и `TextField`), требуется изменить интерфейс
  фабрики и все её реализации, что нарушает принцип Open/Closed.
- **Сложность для простых систем**: Для систем с одним типом объекта или без
  семейств Abstract Factory может быть избыточной.
- **Увеличение числа классов**: Требует создания множества классов (фабрики,
  продукты), что может усложнить архитектуру.

### **Проблемы и антипаттерны**

1. **Слишком много классов**: Большое количество продуктов и фабрик может
   усложнить проект.
   **Решение**: Используйте Abstract Factory только для сложных систем с
   несколькими семействами объектов.
2. **Жёсткая структура**: Добавление нового продукта требует изменения всех
   фабрик.
   **Решение**: Рассмотрите параметризованные фабрики или DI для большей
   гибкости.
3. **Сложность тестирования**: Тестирование может быть затруднено из-за
   множества зависимостей.
   **Решение**: Используйте мок-объекты (например, с Mockito) для подмены
   фабрик.

### **Современные альтернативы**

- **Dependency Injection (DI)**: Фреймворки, такие как Spring, управляют
  созданием семейств объектов, внедряя зависимости:
  ```java
  @Component
  class WindowsButton implements Button { /* ... */ }

  @Autowired
  private Button button; // Spring создаёт нужный объект
  ```
- **Лямбда-выражения и Supplier**: В Java 8+ можно использовать функциональные
  интерфейсы для создания объектов:
  ```java
  Supplier<Button> buttonFactory = WindowsButton::new;
  Button button = buttonFactory.get();
  ```
- **Factory Method**: Если требуется создавать только один тип объекта, Factory
  Method может быть проще, чем Abstract Factory.

### **Итог**

Паттерн Abstract Factory решает проблемы, связанные с созданием семейств
связанных объектов, обеспечением их совместимости, изоляцией клиентского кода от
реализаций и поддержкой расширяемости. Он особенно полезен в системах, где
требуется поддержка нескольких платформ, тем или подсистем (например, UI, базы
данных). Однако он может быть сложным для поддержки при добавлении новых
продуктов и избыточным для простых случаев. В Java паттерн используется в
стандартной библиотеке (AWT, JDBC) и фреймворках (Spring), а в современных
приложениях его часто дополняют DI или функциональные подходы.
