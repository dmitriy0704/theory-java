# Фабричный метод

Фабричный метод — это порождающий паттерн проектирования, который определяет
общий интерфейс для создания объектов в суперклассе, позволяя подклассам
изменять тип создаваемых объектов.

**Паттерн Factory Method (Фабричный метод)** — это порождающий паттерн
проектирования, который предоставляет интерфейс для создания объектов в
суперклассе, позволяя подклассам определять, какой конкретный класс создавать.
Он помогает делегировать процесс создания объектов подклассам, обеспечивая
гибкость и расширяемость.

### **Описание паттерна**

**Цель**:

- Определить интерфейс для создания объектов, позволяя подклассам решать, какой
  класс создавать.
- Изолировать процесс создания объектов от их использования.

**Когда использовать**:

- Когда заранее неизвестно, какие именно объекты нужно создавать.
- Когда вы хотите предоставить подклассам возможность определять создаваемые
  объекты.
- Когда нужно обеспечить расширяемость системы для добавления новых типов
  объектов.

**Примеры использования**:

- Создание различных реализаций соединений с базой данных
  (`java.sql.DriverManager`).
- Генерация документов разных форматов (PDF, Word).
- Создание UI-компонентов, зависящих от платформы (Windows, macOS).

### **Структура паттерна**

<img src="/img/design_pattern/design_patterns/factory_method_structure.png" alt="factory_method" width="100%" style="max-width: 550px">

1. **Продукт (Product)**: общий интерфейс объектов, которые может произвести
   создатель и его подклассы.
2. **Конкретный продукт (Concrete Product)**: содержит код различных продуктов.
   Продукты будут отличаться реализацией, но интерфейс у них будет общий.
3. **Создатель (Creator)**: Абстрактный класс или интерфейс, содержащий
   фабричный метод (обычно абстрактный). <br>
   Создатель объявляет фабричный метод, который должен возвращать новые объекты
   продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом
   продуктов.<br>
   Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы
   реализовать его по-своему. Но он может возвращать и некий стандартный
   продукт.<br>
   Несмотря на название, важно понимать, что создание продуктов не является
   единственной функцией создателя. Обычно он содержит и другой полезный код
   работы с продуктом. Аналогия: большая софтверная компания может иметь центр
   подготовки программистов, но основная задача компании — создавать программные
   продукты, а не готовить программистов.
4. **Конкретный создатель (Concrete Creator)**: Подклассы, реализующие фабричный
   метод для создания конкретных продуктов.

### **Реализация в Java**

Ниже приведён пример реализации паттерна Factory Method для создания
транспортных средств (например, автомобилей и мотоциклов).

```java
// Интерфейс продукта
interface Vehicle {
    void drive();
}

// Конкретные продукты
class Car implements Vehicle {
    public void drive() {
        System.out.println("Driving a car");
    }
}

class Motorcycle implements Vehicle {
    public void drive() {
        System.out.println("Riding a motorcycle");
    }
}

// Абстрактный создатель
abstract class VehicleFactory {
    // Фабричный метод переопределяется в подклассах, 
    // чтобы изменить тип создаваемого продукта
    public abstract Vehicle createVehicle();

    // Метод, использующий фабричный метод
    public void deliverVehicle() {
        Vehicle vehicle = createVehicle();
        vehicle.drive();
    }
}

// Конкретные создатели
class CarFactory extends VehicleFactory {
    public Vehicle createVehicle() {
        return new Car();
    }
}

class MotorcycleFactory extends VehicleFactory {
    public Vehicle createVehicle() {
        return new Motorcycle();
    }
}

// Клиентский код
public class FactoryMethodExample {
    public static void main(String[] args) {
        VehicleFactory carFactory = new CarFactory();
        carFactory.deliverVehicle(); // Вывод: Driving a car

        VehicleFactory motorcycleFactory = new MotorcycleFactory();
        motorcycleFactory.deliverVehicle(); // Вывод: Riding a motorcycle
    }
}
```

### **Как это работает**

1. Клиент работает с абстрактным классом `VehicleFactory` и вызывает метод
   `deliverVehicle()`.
2. Конкретные фабрики (`CarFactory`, `MotorcycleFactory`) реализуют
   `createVehicle()`, возвращая нужный объект (`Car` или `Motorcycle`).
3. Клиент не знает, какой конкретный класс создаётся, что делает код гибким и
   независимым от конкретных реализаций.

### **Преимущества**

- **Гибкость**: Легко добавить новый тип продукта, создав новый подкласс фабрики
  и продукта.
- **Соответствие принципу Open/Closed**: Система открыта для расширения (новые
  продукты), но закрыта для модификации.
- **Изоляция**: Клиентский код работает с абстракциями, а не с конкретными
  классами.
- **Упрощение тестирования**: Можно подменять реализации продуктов в тестах.

### **Недостатки**

- **Усложнение кода**: Для каждого нового продукта нужно создавать новый класс
  фабрики.
- **Дополнительные классы**: Может увеличить количество классов в проекте.

### **Пример реального использования в Java**

В стандартной библиотеке Java паттерн Factory Method встречается, например, в
`java.util.Calendar`:

```java
Calendar calendar = Calendar.getInstance(); // Фабричный метод
```

- `getInstance()` возвращает конкретную реализацию `Calendar` (например,
  `GregorianCalendar`) в зависимости от локали и конфигурации.
- Клиент не знает, какой конкретный класс возвращается, но может работать с
  абстрактным интерфейсом.

Другой пример — Spring Framework:

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
MyBean bean = context.getBean(MyBean.class);
```

`ApplicationContext` действует как фабрика, создавая объекты (beans) на основе
конфигурации.

### **Проблемы решаемые паттерном*

Паттерн **Factory Method (Фабричный метод)** — это порождающий паттерн
проектирования, который решает ряд проблем, связанных с созданием объектов,
предоставляя гибкий и расширяемый способ их instantiation. Он позволяет
делегировать создание объектов подклассам, обеспечивая независимость клиентского
кода от конкретных классов. Вот основные проблемы, которые решает этот паттерн:

### 1. **Создание объектов без привязки к конкретным классам**

- **Проблема**: Клиентский код, создающий объекты напрямую с помощью `new`,
  становится зависимым от их конкретных классов. Это усложняет замену или
  добавление новых типов объектов без изменения кода.
- **Решение**: Factory Method определяет абстрактный метод для создания объектов
  в суперклассе, а подклассы решают, какой конкретный класс создавать. Клиент
  работает с абстрактным интерфейсом, а не с конкретными классами.
- **Пример**: В приложении для обработки документов клиентский код может
  создавать документы (`PDFDocument`, `WordDocument`) через фабричный метод, не
  зная их конкретных реализаций.
  ```java
  abstract class DocumentFactory {
      public abstract Document createDocument();
  }

  class PdfFactory extends DocumentFactory {
      @Override
      public Document createDocument() {
          return new PdfDocument();
      }
  }
  ```

### 2. **Упрощение добавления новых типов объектов**

- **Проблема**: Если система должна поддерживать новые типы объектов, добавление
  их требует изменения существующего кода (например, добавления новых условий в
  `if-else` или `switch` для создания объектов), что нарушает принцип
  Open/Closed (открытость для расширения, закрытость для модификации).
- **Решение**: Factory Method позволяет добавлять новые типы объектов, просто
  создавая новый подкласс фабрики, реализующий абстрактный метод создания.
  Клиентский код остаётся неизменным.
- **Пример**: В игре для создания разных типов врагов (например, `Soldier`,
  `Wizard`) достаточно добавить новый подкласс фабрики (`WizardFactory`), не
  меняя логику игры.

### 3. **Изоляция логики создания объектов**

- **Проблема**: Логика создания объектов, особенно если она сложная (например,
  включает инициализацию, настройку зависимостей или выбор типа), может
  загромождать клиентский код, делая его менее читаемым и трудным для поддержки.
- **Решение**: Factory Method выносит логику создания объектов в отдельные
  классы (фабрики), отделяя её от бизнес-логики клиента. Это улучшает читаемость
  и поддерживаемость кода.
- **Пример**: Создание соединений с базой данных (`MySQLConnection`,
  `PostgreSQLConnection`) может быть инкапсулировано в фабриках, чтобы
  клиентский код вызывал только `createConnection()`.

### 4. **Поддержка полиморфизма при создании объектов**

- **Проблема**: В системах, где требуется создавать объекты с общим интерфейсом,
  но разной реализацией, клиентский код должен вручную определять, какой класс
  создавать, что усложняет поддержку.
- **Решение**: Factory Method использует полиморфизм, позволяя подклассам
  фабрики возвращать объекты, соответствующие общему интерфейсу. Клиент работает
  с абстракцией, а конкретная реализация определяется подклассом.
- **Пример**: В UI-фреймворке фабричный метод может создавать кнопки (
  `WindowsButton`, `MacOSButton`), реализующие интерфейс `Button`.

### 5. **Управление зависимостями при создании объектов**

- **Проблема**: Создание объектов может включать сложные зависимости или
  конфигурации (например, установка параметров, внедрение зависимостей), что
  усложняет процесс instantiation.
- **Решение**: Factory Method позволяет фабрикам управлять зависимостями и
  конфигурацией объектов, скрывая эти детали от клиента.
- **Пример**: Фабрика для создания HTTP-клиентов может настраивать тайм-ауты,
  заголовки или прокси, возвращая готовый объект:
  ```java
  class HttpClientFactory extends ClientFactory {
      @Override
      public HttpClient createClient() {
          return HttpClient.newBuilder()
                  .connectTimeout(Duration.ofSeconds(10))
                  .build();
      }
  }
  ```

### 6. **Упрощение тестирования**

- **Проблема**: Жёсткая привязка к конкретным классам через `new` затрудняет
  подмену объектов в тестах (например, для создания мок-объектов).
- **Решение**: Factory Method позволяет легко подменять фабрики в тестах,
  возвращая заглушки (stubs) или моки вместо реальных объектов, что упрощает
  тестирование.
- **Пример**: В тестах можно создать `MockDocumentFactory`, которая возвращает
  `MockDocument` для проверки поведения без реальных файлов.

### 7. **Поддержка расширяемости в системах**

- **Проблема**: Системы, которые должны быть легко расширяемыми для новых
  сценариев (например, добавление новых платформ, форматов или устройств),
  требуют гибкого механизма создания объектов.
- **Решение**: Factory Method делает систему расширяемой, так как новые типы
  объектов можно интегрировать, добавив новый подкласс фабрики, не трогая
  существующий код.
- **Пример**: В платформе для рендеринга графики фабричный метод может
  поддерживать новые рендеры (`OpenGLRenderer`, `VulkanRenderer`) через новые
  фабрики.

### **Проблемы, которые НЕ решает Factory Method**

- **Сложность для простых случаев**: Если система имеет только один тип объекта
  или создание объектов тривиально, Factory Method может добавить ненужную
  сложность.
- **Множество фабрик**: Для большого числа типов объектов требуется создавать
  много подклассов фабрик, что увеличивает количество кода.
- **Ограниченная гибкость параметров**: Factory Method не так удобен для
  создания объектов с множеством параметров (в таких случаях лучше использовать
  Builder).

### **Проблемы и антипаттерны**

1. **Слишком много фабрик**: Если для каждого продукта создаётся отдельная
   фабрика, код может стать громоздким.

- **Решение**: Рассмотрите Abstract Factory или Simple Factory для простых
  случаев.

2. **Жёсткая привязка к иерархии**: Требует создания подклассов для каждого
   нового продукта.

- **Решение**: Используйте параметризованные фабрики или Dependency Injection (
  например, в Spring).

3. **Сложность тестирования**: Если фабрика возвращает сложные объекты, может
   быть трудно подменять их в тестах.

- **Решение**: Используйте интерфейсы и мок-объекты (например, с Mockito).

### **Современные альтернативы**

- **Dependency Injection (DI)**: Фреймворки, такие как Spring, управляют
  созданием объектов, внедряя зависимости, что часто заменяет Factory Method:
  ```java
  @Component
  class PdfDocument implements Document { /* ... */ }

  @Autowired
  private Document document; // Spring создаёт нужный объект
  ```
- **Лямбда-выражения**: В Java 8+ можно использовать `Supplier` для создания
  объектов:
  ```java
  Supplier<Document> pdfFactory = PdfDocument::new;
  Document doc = pdfFactory.get();
  ```
- **Abstract Factory**: Для создания семейств связанных объектов может
  использоваться Abstract Factory вместо Factory Method.

### **Итог**

Паттерн Factory Method решает проблемы, связанные с жёсткой привязкой к
конкретным классам, сложностью добавления новых типов объектов, изоляцией логики
создания и поддержкой полиморфизма. Он делает код более гибким, расширяемым и
тестируемым, особенно в системах, где требуется создавать разные реализации
одного интерфейса. Однако для сложных объектов с множеством параметров или
простых случаев могут быть более подходящими другие паттерны (Builder, DI). В
Java Factory Method широко используется в стандартной библиотеке и фреймворках,
таких, как Spring.

