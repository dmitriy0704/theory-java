
> HIBERNATE. Проблема n+1

Проблема N+1 в Hibernate (и в других ORM, таких как JPA) — это распространенная
проблема производительности, которая возникает при выполнении запросов к базе
данных. Она связана с тем, как ORM загружает связанные сущности.

## ЧТО ТАКОЕ ПРОБЛЕМА N+1?

Проблема N+1 возникает, когда для загрузки коллекции связанных сущностей
выполняется один запрос для основной сущности и затем отдельный запрос для
каждой из связанных сущностей. Это может привести к значительному увеличению
количества запросов к базе данных, что негативно сказывается на
производительности приложения.

### Пример

Предположим, у вас есть две сущности: `Author` и `Book`, где один автор может
иметь много книг. Если вы хотите получить список всех авторов и их книг, вы
можете написать следующий код:

```java
class Demo {
    public void demo() {
        List<Author> authors = session
                .createQuery("FROM Author", Author.class)
                .getResultList();
        for (Author author : authors) {
            System.out.println(author.getName());
            for (Book book : author.getBooks()) {
                System.out.println(book.getTitle());
            }
        }
    }
}

```

В этом примере происходит следующее:

1. Выполняется один запрос для получения всех авторов (это 1 запрос).
2. Для каждого автора выполняется отдельный запрос для получения его книг (это N
   запросов, где N — количество авторов).

Таким образом, общее количество запросов к базе данных составляет 1 + N, что и
приводит к проблеме N+1.

## ПОЧЕМУ ЭТО ПРОБЛЕМА?

Проблема N+1 может значительно ухудшить производительность приложения по
следующим причинам:

- **Увеличение времени выполнения**: Каждый дополнительный запрос требует
  времени на выполнение и обработку.
- **Нагрузка на базу данных**: Большое количество запросов может привести к
  увеличению нагрузки на базу данных и ухудшению ее производительности.
- **Сложность отладки**: Увеличение количества запросов может затруднить отладку
  и анализ производительности приложения.

## ПРИЧИНЫ ВОЗНИКНОВЕНИЯ

1. **Ленивая загрузка (Lazy Loading) по умолчанию**  
   По умолчанию многие ассоциации в Hibernate (например, `@OneToMany`,
   `@ManyToOne`) настроены на ленивую загрузку (`FetchType.LAZY`). Это значит,
   что связанные объекты не загружаются сразу вместе с основным объектом, а
   подгружаются при первом обращении к ним. Если в коде происходит итерация по
   коллекции связанных объектов, то для каждого из них Hibernate выполнит
   отдельный SQL-запрос.

2. **Отсутствие явного указания жадной загрузки (Eager Fetching)**  
   Если не использовать `FetchType.EAGER` или не применять `JOIN FETCH` в
   JPQL/HQL-запросах, Hibernate не будет загружать связанные сущности одним
   запросом с использованием JOIN.

3. **Использование коллекций с ленивой загрузкой без оптимизации**  
   При работе с коллекциями (`List`, `Set`) связанных сущностей без применения
   специальных техник (например, batch fetching или fetch join) каждый элемент
   коллекции может быть загружен отдельным запросом.

4. **Отсутствие batch fetching**  
   Batch fetching — это механизм Hibernate, который позволяет загружать
   несколько связанных сущностей одним запросом с помощью IN-подобных
   конструкций. Если он не настроен или не используется, то для каждой связанной
   сущности будет отдельный запрос.

5. **Неправильное использование ORM-запросов**  
   Например, если в цикле выполняется обращение к связанным объектам без
   предварительной выборки через JOIN FETCH, то каждый вызов приведёт к
   отдельному SQL-запросу.

### Кратко:

| Причина                          | Описание                                                                                 |
|----------------------------------|------------------------------------------------------------------------------------------|
| Ленивый fetch (`FetchType.LAZY`) | Связанные объекты загружаются по требованию, что приводит к множеству отдельных запросов |
| Отсутствие `JOIN FETCH`          | Запросы без join fetch не объединяют выборку связанных сущностей                         |
| Отсутствие batch fetching        | Нет групповой подгрузки связанных объектов                                               |
| Итерация по ленивым коллекциям   | При обходе коллекций происходит множество отдельных запросов                             |


## Как исправить проблемы N+1?

Проблему **N+1** в Hibernate можно исправить несколькими способами, в
зависимости от конкретного сценария и требований к производительности. Ниже
перечислены основные подходы с примерами.

1. Использовать `JOIN FETCH` в JPQL/HQL-запросах

Это самый распространённый способ загрузить связанные сущности одним запросом с
помощью SQL JOIN.

**Пример:**

```java

class Demo() {
    void demo() {
        // Без JOIN FETCH — возникнет N+1
        List<Author> authors = entityManager.createQuery("SELECT a FROM Author a", Author.class).getResultList();

        for (
                Author author : authors) {
            // При обращении к author.getBooks() будет отдельный запрос для каждой книги
            System.out.

                    println(author.getBooks().

                            size());
        }

// С JOIN FETCH — все книги загружаются вместе с авторами одним запросом
        List<Author> authors = entityManager.createQuery(
                "SELECT a FROM Author a JOIN FETCH a.books", Author.class).getResultList();
    }
}

```

2. Настроить batch fetching (пакетную загрузку)

Batch fetching позволяет Hibernate загружать связанные сущности пакетами, а не
по одной.

**Настройка в `hibernate.cfg.xml` или `application.properties`:**

```properties
hibernate.default_batch_fetch_size=16
```

**Аннотация на коллекции или связях:**

```java

@OneToMany(fetch = FetchType.LAZY)
@BatchSize(size = 16)
private Set<Book> books;
```

Hibernate при обращении к коллекции загрузит сразу 16 связанных объектов одним
запросом с `IN (...)`.

3. Использовать жадную загрузку (`FetchType.EAGER`)

Можно указать, что связанные сущности должны загружаться сразу вместе с основной
сущностью.

```java

@OneToMany(fetch = FetchType.EAGER)
private Set<Book> books;
```

**Однако:**  
Жадная загрузка может привести к избыточной выборке данных и ухудшению
производительности, если связи большие или не всегда нужны.

4. Использовать Entity Graphs (JPA 2.1+)

Entity Graph позволяет динамически указывать, какие связи нужно подгружать.

```java
EntityGraph<Author> graph = entityManager.createEntityGraph(Author.class);
graph.

addAttributeNodes("books");

Map<String, Object> props = new HashMap<>();
props.

put("javax.persistence.fetchgraph",graph);

Author author = entityManager.find(Author.class, authorId, props);
```

5. Оптимизировать структуру запросов и логику приложения

- Избегать обращения к ленивым коллекциям в циклах без предварительной выборки.
- Загружать данные пакетами.
- Использовать DTO и проекции для выборки только нужных данных.

Итог

| Способ                    | Когда использовать                                  | Преимущества                  | Недостатки                          |
|---------------------------|-----------------------------------------------------|-------------------------------|-------------------------------------|
| `JOIN FETCH`              | При необходимости загрузить связанные объекты сразу | Один запрос вместо N+1        | Может привести к дублированию строк |
| Batch fetching            | При работе с большими коллекциями                   | Уменьшает количество запросов | Требует настройки и понимания       |
| Жадная загрузка (`EAGER`) | Когда всегда нужны связанные данные                 | Простота использования        | Может грузить лишние данные         |
| Entity Graphs             | Для динамического управления загрузкой              | Гибкость                      | Сложнее в настройке                 |

> HIBERNATE. ENTITY GRAPHS

Entity Graphs (графы сущностей) — это механизм в JPA (Java Persistence API),
который позволяет разработчикам управлять загрузкой связанных сущностей более
гибко и эффективно. С помощью графов сущностей можно указать, какие связанные
объекты должны быть загружены вместе с основной сущностью, что помогает избежать
проблемы N+1 и оптимизировать производительность запросов.

### Основные характеристики Entity Graphs:

1. **Определение графа:** Граф сущностей определяет, какие атрибуты (сущности)
   должны быть загружены при выполнении запроса. Это позволяет вам
   контролировать стратегию выборки данных.

2. **Динамическое создание:** Графы могут быть созданы динамически в коде или
   определены статически с помощью аннотаций.

3. **Поддержка различных стратегий загрузки:** Вы можете использовать графы для
   указания, какие связанные сущности должны быть загружены с использованием
   `FetchType.EAGER` или `FetchType.LAZY`, в зависимости от ваших потребностей.

## ПРИМЕР

Есть две сущности: `Author` и `Book`. У автора может быть много книг.

```java

@Entity
public class Author {
    @Id
    private Long id;

    private String name;

    @OneToMany(mappedBy = "author", fetch = FetchType.LAZY)
    private List<Book> books;

    // геттеры и сеттеры
}

@Entity
public class Book {
    @Id
    private Long id;

    private String title;

    @ManyToOne(fetch = FetchType.LAZY)
    private Author author;

    // геттеры и сеттеры
}
```

### Проблема N+1

Если вы просто сделаете:

```java
class Demo {
    void demo() {
        List<Author> authors = entityManager
                .createQuery("SELECT a FROM Author a", Author.class)
                .getResultList();
        for (Author author : authors) {
            System.out.println(
                    author.getBooks()
                            .size()
            );  // тут будет отдельный запрос на каждую коллекцию books!
        }
    }
}

```

Hibernate выполнит 1 запрос на авторов + N запросов на книги каждого автора —
это и есть проблема N+1.

### Решение с Entity Graph

Создадим Entity Graph, который укажет JPA подгрузить книги вместе с авторами:

```java
class Demo {
    void demo() {
        EntityGraph<Author> graph = entityManager.createEntityGraph(Author.class);
        graph.addAttributeNodes("books");
    }
}
```

Теперь используем этот граф при выполнении запроса:

```java
class Demo {
    void demo() {
        List<Author> authors = entityManager
                .createQuery("SELECT a FROM Author a", Author.class)
                .setHint("javax.persistence.fetchgraph", graph)
                .getResultList();
        for (Author author : authors) {
            System.out
                    .println(author.getBooks()
                            .size());  // книги уже загружены одним запросом!
        }
    }
}
```

### Что происходит?

- JPA подставляет в SQL `JOIN` для связи `books`.
- Все данные загружаются одним запросом.
- При обращении к `author.getBooks()` дополнительных запросов не будет.


1. Определение графа с помощью аннотаций

Вы можете определить граф сущностей с помощью аннотации `@EntityGraph` на уровне
класса или метода репозитория:

```java

@Entity
@NamedEntityGraph(name = "Author.books",
        attributePaths = {"books"})
public class Author {
    @Id
    private Long id;

    @OneToMany(mappedBy = "author")
    private Set<Book> books;
}
```

2. Использование графа в запросе

Затем вы можете использовать этот граф при выполнении запроса:

```java
class Demo{
  void demo(){
    EntityGraph entityGraph = entityManager.getEntityGraph("Author.books");
    Map<String, Object> properties = new HashMap<>();
    properties.put("javax.persistence.fetchgraph",entityGraph);
    Author author = entityManager.find(Author.class, authorId, properties);
  }
}
```

3. Динамическое создание графа

Вы также можете создавать графы динамически в коде:

```java

class Demo{
  void demo(){
    EntityGraph graph = entityManager.createEntityGraph(Author.class);
    graph.addAttributeNodes("books");
    Map<String, Object> hints = new HashMap<>();
    hints.put("javax.persistence.fetchgraph",graph);
    List<Author> authors = entityManager
          .createQuery("SELECT a FROM Author a", Author.class)
          .setHint("javax.persistence.fetchgraph", graph)
          .getResultList();
  }
}
```

### Преимущества использования Entity Graphs

- **Гибкость:** Позволяют динамически управлять тем, какие данные загружаются.
- **Улучшение производительности:** Помогают избежать проблемы N+1 и избыточных
  запросов к базе данных.
- **Читаемость кода:** Упрощают понимание того, какие данные будут загружены при
  выполнении запроса.

Использование Entity Graphs — это мощный инструмент для оптимизации работы с JPA
и управления загрузкой связанных данных в приложениях на Java.



> ## Жадная загрузка

**Жадная загрузка (Eager Loading)** — это стратегия загрузки связанных данных,
при которой связанные сущности загружаются **сразу вместе с основной сущностью**
в момент выполнения запроса к базе данных.


### Что это значит?

Если у вас есть, например, сущность `Author` и связанная с ней коллекция
`books`, то при жадной загрузке:

- Когда вы загружаете автора из базы, сразу же подгружаются и все его книги.
- Это обычно реализуется через SQL JOIN или дополнительные запросы, которые
  выполняются сразу.
  
  

### Пример

```java

@Entity
public class Author {
    @OneToMany(fetch = FetchType.EAGER)
    private List<Book> books;
}
```

При таком объявлении, когда вы получите автора из базы, Hibernate сразу же
загрузит и все связанные книги.


### Плюсы жадной загрузки

- Избегает проблему N+1 запросов, если вам точно нужны связанные данные.
- Удобно, когда вы всегда используете связанные объекты вместе с основной
  сущностью.


### Минусы жадной загрузки

- Может привести к избыточной нагрузке на базу и сети, если связанные данные не
  нужны.
- При большом количестве связанных объектов может сильно замедлить запрос.

### В противоположность — **ленивая загрузка (Lazy Loading)**

- Связанные данные загружаются только при первом обращении к ним.
- Позволяет экономить ресурсы, но может вызвать проблему N+1 запросов.

### Итог

**Жадная загрузка** — это когда связанные объекты подгружаются сразу вместе с
основной сущностью, чтобы избежать дополнительных запросов позже. Это удобно для
часто используемых связей, но может быть неэффективно при больших объемах
данных.


> ## Criteria api

**Criteria API** — это часть спецификации JPA (Java Persistence API), которая предоставляет типобезопасный, объектно-ориентированный способ построения динамических запросов к базе данных.


### Основные особенности Criteria API:

- **Типобезопасность**  
  Запросы строятся с помощью Java-кода, а не строк JPQL, что позволяет избежать ошибок в синтаксисе и типах на этапе компиляции.

- **Динамическое построение запросов**  
  Удобно создавать запросы с условиями, которые зависят от логики приложения (например, если параметры фильтрации могут меняться).

- **Объектно-ориентированный подход**  
  Запросы строятся через объекты `CriteriaBuilder`, `CriteriaQuery`, `Root` и т.д., что облегчает чтение и поддержку кода.



### Пример использования Criteria API

```java
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<Author> cq = cb.createQuery(Author.class);
Root<Author> author = cq.from(Author.class);

cq.select(author)
  .where(cb.like(author.get("name"), "Иван%"));

List<Author> authors = entityManager.createQuery(cq).getResultList();
```

### Когда использовать Criteria API?

- Когда нужно строить сложные или динамические запросы.
- Когда важна типобезопасность и удобство поддержки кода.
- В случаях, когда использование строковых JPQL-запросов неудобно или рискованно.

### Кратко

**Criteria API** — это инструмент для программного построения запросов к базе данных в JPA, который помогает создавать гибкие, безопасные и удобочитаемые запросы без использования строковых выражений.

### Пример кода с Criteria API

Допустим, у нас есть сущность `Author` с полями `id`, `name` и связью `books` (
список книг). Мы хотим получить всех авторов с именем, начинающимся на "Иван".


```java
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import javax.persistence.EntityManager;
import java.util.List;

public List<Author> findAuthorsByNamePrefix(EntityManager entityManager, String prefix) {
    // Получаем объект CriteriaBuilder из EntityManager
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();

    // Создаем запрос для сущности Author
    CriteriaQuery<Author> cq = cb.createQuery(Author.class);

    // Определяем корень запроса (FROM Author a)
    Root<Author> authorRoot = cq.from(Author.class);

    // Добавляем условие WHERE a.name LIKE 'prefix%'
    cq.select(authorRoot)
            .where(cb.like(authorRoot.get("name"), prefix + "%"));

    // Выполняем запрос и получаем результат
    List<Author> authors = entityManager.createQuery(cq).getResultList();

    return authors;
}
```

### Объяснение:

- `CriteriaBuilder` — фабрика для создания частей запроса.
- `CriteriaQuery<T>` — сам запрос, где `T` — тип результата.
- `Root<T>` — корень запроса, указывает на основную сущность.
- Метод `cb.like()` создаёт условие LIKE.
- В итоге мы получаем список авторов, чьё имя начинается с заданного префикса.


### Как использовать вместе с Entity Graph?

Можно комбинировать Criteria API и Entity Graph:

```java
EntityGraph<Author> graph = entityManager.createEntityGraph(Author.class);
graph.addAttributeNodes("books");

List<Author> authors = entityManager.createQuery(cq)
        .setHint("javax.persistence.fetchgraph", graph)
        .getResultList();
```

Так вы получите авторов с подгруженными книгами в одном запросе.


> ## EntityManager

**EntityManager** — это основной интерфейс в JPA (Java Persistence API), который
отвечает за взаимодействие с базой данных и управляет жизненным циклом
сущностей.

### Основные функции EntityManager:

- **Создание, чтение, обновление и удаление (CRUD) сущностей**  
  Например, сохранение нового объекта в базу или получение объекта по его
  идентификатору.

- **Управление состоянием сущностей**  
  Сущности могут быть в разных состояниях: новые, управляемые (attached),
  отсоединённые (detached), удалённые. EntityManager следит за этими
  состояниями.

- **Выполнение запросов к базе данных**  
  Через JPQL (Java Persistence Query Language) или Criteria API.

- **Транзакционное управление**  
  Обычно EntityManager работает внутри транзакций, обеспечивая атомарность
  операций.


### Пример использования EntityManager:

```java

class Demo{
  void demo(){
    // Получение сущности по ID
    Author author = entityManager.find(Author.class, 1L);

    // Создание новой сущности
    Author newAuthor = new Author();
    newAuthor.setName("Иван Иванов").entityManager.persist(newAuthor);

    // Обновление сущности
    author.setName("Пётр Петров");
    entityManager.merge(author);

    // Удаление сущности
    entityManager.remove(author);
  }
}
```

### Где берётся EntityManager?

- В Java EE / Jakarta EE контейнере его обычно внедряют через
  `@PersistenceContext`.
- В Spring Boot можно получить через `@Autowired` или использовать
  `EntityManagerFactory`.

### Кратко

EntityManager — это объект, который позволяет работать с базой данных на уровне
объектов (сущностей), управлять их состояниями и выполнять запросы. Это основной
инструмент для работы с JPA.

> ## Уровни кеширования в Hibernate

Hibernate предоставляет несколько уровней кеширования, которые помогают
оптимизировать производительность приложения, уменьшая количество обращений к
базе данных.


### 1. Первичный кеш (First-Level Cache)

- **Описание:** Это кэш, который связан с сессией Hibernate. Он хранит объекты,
  загруженные в рамках текущей сессии.
- **Область видимости:** Действует только в пределах одной сессии. Когда сессия
  закрывается, все данные в первичном кэше теряются.
- **Применение:** Если вы запрашиваете одну и ту же сущность несколько раз в
  рамках одной сессии, Hibernate будет возвращать объект из первичного кэша
  вместо выполнения нового запроса к базе данных.

- **Описание**: Первичный кеш является неотъемлемой частью сессии Hibernate. Он
  хранит объекты, загруженные в текущей сессии, и обеспечивает их повторное
  использование без необходимости повторного запроса к базе данных.
- **Область видимости**: Первичный кеш существует только в пределах одной
  сессии. Как только сессия закрывается, все объекты в первичном кеше становятся
  недоступными.
- **Поведение**: Если вы запрашиваете один и тот же объект несколько раз в
  рамках одной сессии, Hibernate будет возвращать его из первичного кеша вместо
  того, чтобы выполнять новый запрос к базе данных.
- **Пример**:
  ```java
  Session session = sessionFactory.openSession();
  Author author1 = session.get(Author.class, 1); // Запрос к БД
  Author author2 = session.get(Author.class, 1); // Возвращается из первичного кеша
  ```

### 2. Вторичный кеш (Second-Level Cache)

- **Описание:** Это опциональный кэш, который может быть настроен для хранения
  объектов между сессиями. Он позволяет делиться данными между разными сессиями.
- **Область видимости:** Действует на уровне сессии-фабрики (SessionFactory).
  Данные остаются в этом кэше даже после закрытия сессий.
- **Применение:** Вторичный кэш может быть использован для хранения часто
  запрашиваемых сущностей или коллекций, что позволяет уменьшить количество
  запросов к базе данных.
- **Описание**: Вторичный кеш является опциональным и может быть настроен для
  хранения объектов между сессиями. Он позволяет кэшировать данные на уровне
  всей сессии фабрики (SessionFactory), что позволяет использовать одни и те же
  данные в разных сессиях.
- **Область видимости**: Вторичный кеш доступен для всех сессий, использующих
  одну и ту же фабрику сессий.
- **Настройка**: Для использования второго уровня кеша необходимо включить его в
  конфигурации Hibernate и выбрать провайдер кеша (например, Ehcache, Infinispan
  и т.д.).
- **Пример настройки**:
  ```xml
  <property name="hibernate.cache.use_second_level_cache">true</property>
  <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
  ```

#### Конфигурация вторичного кэша:

Для использования вторичного кэша необходимо:

1. Включить его в конфигурации Hibernate.
2. Настроить провайдер кеша (например, Ehcache, Infinispan и т.д.).
3. Аннотировать сущности или коллекции, которые должны использовать вторичный
   кэш.

Пример аннотации для включения вторичного кэша:

```java

@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Author {
    @Id
    private Long id;

    // другие поля и методы
}
```

#### Кеширование коллекций

Вторичный кеш также может использоваться для кэширования коллекций. Вы можете
настроить стратегию кэширования для отдельных сущностей или коллекций через
аннотации или XML-конфигурацию.

#### Пример аннотации для вторичного кеша:

```java

@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Author {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "author")
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private Set<Book> books;
}
```

### Стратегии кэширования

Hibernate поддерживает несколько стратегий кэширования для второго уровня:

1. **READ_ONLY**: Используется для объектов, которые не изменяются после их
   создания. Это наиболее эффективная стратегия.
2. **READ_WRITE**: Используется для объектов, которые могут изменяться.
   Hibernate управляет блокировками при записи.
3. **NONSTRICT_READ_WRITE**: Позволяет более высокую производительность за счет
   менее строгого контроля за изменениями.
4. **TRANSACTIONAL**: Поддерживает транзакционное поведение.

### 3. **Кэш запросов (Query Cache)**

- **Описание:** Это дополнительный уровень кеширования, который позволяет
  кешировать результаты запросов.
- **Область видимости:** Работает совместно со вторичным кэшем и может
  использоваться для кеширования результатов HQL или Criteria запросов.
- **Применение:** Если вы выполняете один и тот же запрос несколько раз,
  результаты могут быть извлечены из кеша вместо выполнения запроса к базе
  данных.

#### Конфигурация кеша запросов:

Чтобы использовать кеш запросов, необходимо:

1. Включить его в конфигурации Hibernate.
2. Аннотировать запросы или использовать методы API для указания использования
   кеша.

Пример использования кеша запросов:

```java
List<Author> authors = session.createQuery("FROM Author")
        .setHint("org.hibernate.cacheable", true)
        .getResultList();
```

### Заключение

Кеширование в Hibernate — это мощный инструмент для повышения производительности
приложений за счет уменьшения количества обращений к базе данных. Понимание
уровней кеширования и их правильная настройка могут значительно улучшить время
отклика вашего приложения и снизить нагрузку на базу данных.

> ## Сессия Hibernate

Сессия в Hibernate — это основной интерфейс для взаимодействия с базой данных.
Она представляет собой единицу работы с данными и обеспечивает механизм для
выполнения операций с сущностями, таких как создание, чтение, обновление и
удаление (CRUD). Сессия управляет состоянием объектов и их жизненным циклом, а
также обеспечивает кэширование на уровне первого уровня.

### Основные характеристики сессии Hibernate:

1. **Управление состоянием объектов:**
    - Сессия отслеживает изменения в сущностях, которые она загружает. Когда вы
      загружаете сущность из базы данных, она становится "управляемой" (managed)
      и находится в состоянии "приложения" (persistent).
    - Если вы изменяете управляемую сущность, Hibernate автоматически
      отслеживает эти изменения и может синхронизировать их с базой данных при
      вызове метода `session.flush()` или при закрытии сессии.

2. **Первичный кэш:**
    - Сессия имеет свой собственный первичный кэш (first-level cache), который
      хранит загруженные объекты. Если вы запрашиваете одну и ту же сущность
      несколько раз в рамках одной сессии, Hibernate будет возвращать объект из
      этого кэша вместо выполнения нового запроса к базе данных.

3. **Жизненный цикл:**
    - Сессия создается через `SessionFactory` и должна быть закрыта после
      завершения работы. Это можно сделать вручную или с помощью блока
      `try-with-resources`, чтобы гарантировать закрытие.
    - Сессия может быть открыта в начале транзакции и закрыта после завершения
      всех операций.

4. **Транзакции:**
    - Сессия обычно используется в контексте транзакций. Вы можете начать
      транзакцию, выполнять операции с сущностями и затем зафиксировать или
      откатить изменения.
    - Пример использования транзакций:

```java
      Session session = sessionFactory.openSession();
      Transaction transaction = null;
 
      try {
          transaction = session.beginTransaction();
          // операции с сущностями
          transaction.commit();
      } catch (Exception e) {
          if (transaction != null) {
              transaction.rollback();
          }
          e.printStackTrace();
      } finally {
          session.close();
      }
```

5. **Потокобезопасность:**
    - Сессии не являются потокобезопасными. Каждая сессия должна использоваться
      только одним потоком одновременно. Для многопоточных приложений
      рекомендуется использовать `SessionFactory` для создания новых экземпляров
      `Session`.

### Заключение

Сессия в Hibernate является ключевым компонентом для работы с базой данных,
обеспечивая управление состоянием объектов, кэширование и поддержку транзакций.
Правильное использование сессий позволяет эффективно взаимодействовать с базой
данных и оптимизировать производительность приложения.

### Фабрика сессий

Фабрика сессий (SessionFactory) в Hibernate — это интерфейс, который отвечает за
создание и управление сессиями (Session). Она является основным компонентом,
который настраивается один раз при запуске приложения и используется для
получения экземпляров сессий. В контексте второго уровня кэширования (Second
Level Cache) фабрика сессий играет важную роль в управлении кэшированием данных
между различными сессиями.

### Основные аспекты фабрики сессий в контексте второго уровня кэширования:

1. **Управление вторичным кэшем:**
    - Фабрика сессий отвечает за настройку и управление вторичным кэшем. Она
      может быть сконфигурирована для использования различных провайдеров кэша,
      таких как Ehcache, Infinispan, Hazelcast и другие.
    - Вторичный кэш позволяет хранить данные между сессиями, что уменьшает
      количество обращений к базе данных и повышает производительность
      приложения.

2. **Конфигурация:**
    - При создании `SessionFactory` вы можете указать параметры конфигурации для
      включения второго уровня кэширования. Это включает в себя указание
      провайдера кэша, настройки его параметров и определение того, какие
      сущности или коллекции должны использовать второй уровень кэша.
    - Пример конфигурации в `hibernate.cfg.xml`:

      ```xml
      <property name="hibernate.cache.use_second_level_cache">true</property>
      <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
      ```

3. **Кэширование сущностей и коллекций:**
    - Вы можете аннотировать ваши сущности или коллекции для использования
      второго уровня кэша. Это позволяет Hibernate сохранять их состояние в
      кэше, что ускоряет доступ к данным.
    - Пример аннотации для включения второго уровня кэша:

```java
      @Entity
      @Cacheable
      @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
      public class Author {
          @Id
          private Long id;
          // другие поля и методы
      }
```

4. **Производительность:**
    - Использование второго уровня кэширования может значительно улучшить
      производительность приложения, особенно если у вас есть часто
      запрашиваемые данные или данные, которые редко изменяются.
    - Однако важно правильно настроить стратегию кеширования (например,
      `READ_ONLY`, `READ_WRITE`, `NONSTRICT_READ_WRITE`, `TRANSACTIONAL`) в
      зависимости от требований вашего приложения.

5. **Создание и закрытие:**
    - Фабрика сессий создается один раз при запуске приложения и обычно
      закрывается при завершении работы приложения. Это позволяет избежать
      накладных расходов на создание новых экземпляров фабрики при каждом
      запросе.

### Заключение

Фабрика сессий в Hibernate является ключевым компонентом для управления сессиями
и вторичным кэшированием. Она обеспечивает возможность настройки и использования
различных стратегий кеширования, что позволяет оптимизировать производительность
приложений за счет уменьшения количества обращений к базе данных. Правильная
конфигурация фабрики сессий и использование второго уровня кэширования могут
существенно повысить эффективность работы вашего приложения.

> ## HQL, native, JPQL, Criteria запросы

### HQL

HQL (Hibernate Query Language) и native SQL (нативные SQL-запросы) — это два
способа выполнения запросов к базе данных в контексте Hibernate, ORM (
Object-Relational Mapping) фреймворка для Java. Оба подхода имеют свои
особенности, преимущества и недостатки. Давайте рассмотрим основные отличия
между ними.

#### 1. Уровень абстракции

- **HQL**:
    - HQL является объектно-ориентированным языком запросов, который работает с
      сущностями и их свойствами, а не с таблицами и столбцами базы данных.
    - Запросы в HQL пишутся с использованием имен классов и их полей, что делает
      код более читаемым и понятным для разработчиков, знакомых с
      объектно-ориентированным программированием.

- **Native SQL**:
    - Native SQL использует стандартный SQL-синтаксис, который напрямую
      взаимодействует с базой данных.
    - Запросы пишутся с использованием имен таблиц и столбцов, что может быть
      менее удобно при работе с объектами.

#### 2. Портируемость

- **HQL**:
    - HQL более портативен между различными СУБД (системами управления базами
      данных), так как он абстрагирует детали реализации конкретной базы данных.
    - Это позволяет легко менять СУБД без необходимости переписывать запросы.

- **Native SQL**:
    - Native SQL зависит от конкретной СУБД и ее диалекта. Это может привести к
      проблемам при переносе приложения на другую СУБД, так как могут
      потребоваться изменения в запросах.

#### 3. Поддержка функций

- **HQL**:
    - HQL поддерживает большинство стандартных операций SQL, но может не
      поддерживать специфические функции или операторы некоторых СУБД.
    - Некоторые сложные запросы могут быть труднее реализовать в HQL.

- **Native SQL**:
    - Native SQL позволяет использовать все возможности конкретной СУБД, включая
      специфические функции и оптимизации.
    - Это может быть полезно для выполнения сложных запросов или оптимизации
      производительности.

#### 4. Производительность

- **HQL**:
    - HQL может иметь накладные расходы из-за дополнительного уровня абстракции,
      но в большинстве случаев это незначительно.

- **Native SQL**:
    - Native SQL может быть более производительным для сложных запросов или
      операций, так как он напрямую взаимодействует с базой данных без
      дополнительных преобразований.

#### Примеры

##### Пример HQL:

```java
    String hql = "FROM Author WHERE name = :authorName";
    Query query = session.createQuery(hql);
    query.setParameter("authorName","John Doe");
    List<Author> authors = query.list();
```

##### Пример Native SQL:

```java
    String sql = "SELECT * FROM authors WHERE name = :authorName";
    Query query = session.createSQLQuery(sql).addEntity(Author.class);
    query.setParameter("authorName","John Doe");
    List<Author> authors = query.list();
```

### Заключение

Выбор между HQL и native SQL зависит от конкретных требований вашего приложения.
Если вам нужна высокая портируемость и удобство работы с объектами, лучше
использовать HQL. Если же вам нужны специфические функции базы данных или вы
работаете с очень сложными запросами, то native SQL может быть более подходящим
выбором.

### JPQL

JPQL (Java Persistence Query Language) — это объектно-ориентированный язык
запросов, используемый в Java Persistence API (JPA) для выполнения запросов к
базе данных. JPQL позволяет разработчикам писать запросы, которые работают с
объектами и их свойствами, а не с таблицами и столбцами базы данных. Это делает
JPQL более удобным и интуитивно понятным для работы с объектно-ориентированными
приложениями.

#### Основные характеристики JPQL:

1. **Объектно-ориентированный подход:**
    - JPQL работает с сущностями (объектами), а не с таблицами. Запросы
      формулируются на основе классов сущностей и их атрибутов.
    - Например, вместо того чтобы писать SQL-запрос к таблице `Author`, вы
      пишете запрос к сущности `Author`.

2. **Синтаксис:**
    - Синтаксис JPQL похож на SQL, но он ориентирован на объекты. Например,
      вместо `SELECT * FROM Author` вы пишете `SELECT a FROM Author a`.
    - Вы можете использовать такие конструкции, как `WHERE`, `ORDER BY`,
      `GROUP BY` и другие.

3. **Поддержка наследования:**
    - JPQL поддерживает концепции наследования, что позволяет выполнять запросы
      к родительским и дочерним сущностям.

4. **Динамические запросы:**
    - JPQL позволяет создавать динамические запросы с использованием параметров,
      что делает его гибким для различных сценариев.

5. **Портативность:**
    - Запросы на JPQL являются независимыми от конкретной базы данных, что
      делает код более переносимым между различными СУБД.

### Пример использования JPQL:

Вот пример того, как можно использовать JPQL для выполнения запроса к базе
данных:

```java
class Demo {
    void demo() {
        // Получение EntityManager
        EntityManager entityManager = entityManagerFactory.createEntityManager();

        // Начало транзакции
        entityManager.getTransaction().begin();

        // Пример JPQL запроса
        String jpql = "SELECT a FROM Author a WHERE a.name = :name";
        TypedQuery<Author> query = entityManager.createQuery(jpql, Author.class);
        query.setParameter("name", "John Doe");

        // Выполнение запроса
        List<Author> authors = query.getResultList();

        // Завершение транзакции
        entityManager.getTransaction().commit();

        // Закрытие EntityManager
        entityManager.close();
    }

```

### Основные компоненты JPQL:

1. **Сущности:**
    - Запросы формулируются на основе классов-сущностей, которые соответствуют
      таблицам в базе данных.

2. **Атрибуты:**
    - Вы обращаетесь к атрибутам сущностей так же, как вы обращаетесь к полям
      объекта в Java.

3. **Параметры:**
    - Вы можете использовать именованные или позиционные параметры для передачи
      значений в запрос.

4. **Типизированные запросы:**
    - Использование `TypedQuery` позволяет получить результаты определенного
      типа, что обеспечивает безопасность типов во время компиляции.

### Заключение

JPQL является мощным инструментом для работы с базами данных в Java-приложениях,
позволяя разработчикам писать понятные и поддерживаемые запросы на основе
объектов и их свойств. Он сочетает в себе простоту SQL с преимуществами
объектно-ориентированного программирования, что делает его идеальным выбором для
работы с JPA и Hibernate.


### Отличия HQL от JPQL

#### Что такое HQL и JPQL?

- **HQL (Hibernate Query Language)** — это собственный язык запросов, разработанный командой Hibernate. Он похож на SQL, но работает с объектами и их свойствами, а не с таблицами и столбцами.

- **JPQL (Java Persistence Query Language)** — это стандартный язык запросов, определённый спецификацией JPA. Он тоже похож на SQL и работает с сущностями и их полями.

---

### Основные отличия

| Характеристика          | HQL                                      | JPQL                                     |
|------------------------|------------------------------------------|------------------------------------------|
| **Стандарт**           | Собственный язык Hibernate                | Стандарт JPA (часть спецификации JPA)    |
| **Совместимость**      | Работает только с Hibernate                | Работает с любыми JPA-провайдерами       |
| **Функциональность**   | Может содержать расширения Hibernate      | Более ограниченный набор возможностей     |
| **Поддержка специфичных функций БД** | Может поддерживать специфичные функции Hibernate и диалекты БД | Стандартизирован, без расширений         |
| **Использование**      | Используется в проектах с Hibernate напрямую | Используется в любых JPA-проектах         |

---

### Пример запроса

**HQL:**

```hql
from Author a where a.name like 'Иван%'
```

**JPQL:**

```jpql
SELECT a FROM Author a WHERE a.name LIKE 'Иван%'
```

---

### Итог

- **JPQL** — это стандартный, переносимый язык запросов для JPA.
- **HQL** — расширенный язык запросов Hibernate, который включает все возможности JPQL плюс дополнительные функции.

Если вы используете только JPA без Hibernate, то работаете с JPQL. Если же используете Hibernate напрямую, то можете использовать HQL и его расширения.

## Criteria запросы

Criteria запросы в Hibernate — это способ создания запросов к базе данных с
использованием объектно-ориентированного подхода. Они позволяют строить запросы
программно, используя API, вместо написания SQL или HQL (Hibernate Query
Language). Это особенно полезно для динамического построения запросов, когда
условия могут изменяться в зависимости от логики приложения.

### Основные характеристики Criteria запросов:

1. **Объектно-ориентированный подход:**
    - Criteria API позволяет работать с сущностями и их свойствами как с
      объектами, что делает код более читаемым и поддерживаемым.
    - Вместо написания строкового запроса вы создаете объекты и связываете их.

2. **Динамическое построение запросов:**
    - Criteria API позволяет добавлять условия, сортировку и другие параметры
      запроса динамически, что удобно для создания сложных фильтров.
    - Например, вы можете добавлять условия на основе пользовательского ввода
      или других факторов.

3. **Типобезопасность:**
    - Использование Criteria API обеспечивает типобезопасность, так как
      компилятор может проверять правильность типов на этапе компиляции.

4. **Поддержка различных операций:**
    - Criteria API поддерживает различные операции, такие как выборка (select),
      фильтрация (where), сортировка (order by) и группировка (group by).

### Пример использования Criteria API:

Вот пример того, как можно использовать Criteria API для выполнения запроса к
базе данных:

```java

class Demo {
    void demo() {

        // Получение сессии
        Session session = sessionFactory.openSession();

        // Создание CriteriaBuilder
        CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();

        // Создание CriteriaQuery
        CriteriaQuery<Author> criteriaQuery = criteriaBuilder
        .createQuery(Author.class);

        // Определение корня запроса (из какой сущности мы выбираем)
        Root<Author> root = criteriaQuery.from(Author.class);

        // Добавление условий (например, выбор авторов с определенным именем)
        criteriaQuery.
                select(root).
                where(criteriaBuilder.equal(root.get("name"), "John Doe"));

        // Выполнение запроса
        List<Author> authors = session.createQuery(criteriaQuery).getResultList();

        // Закрытие сессии
        session.close();
    }
}

```

### Основные компоненты Criteria API:

1. **CriteriaBuilder:**
    - Интерфейс для создания объектов `CriteriaQuery`, `Predicate` и других
      компонентов запроса.

2. **CriteriaQuery:**
    - Представляет сам запрос. Вы можете указать, какие сущности вы хотите
      выбрать и какие условия применить.

3. **Root:**
    - Корень запроса, который представляет сущность, из которой вы выбираете
      данные.

4. **Predicate:**
    - Условия фильтрации данных. Вы можете комбинировать несколько предикатов с
      помощью логических операторов (AND, OR).

5. **TypedQuery:**
    - Позволяет выполнять запрос и получать результаты в виде списка объектов
      определенного типа.

### Заключение

Criteria API в Hibernate предоставляет мощный инструмент для построения
динамических и типобезопасных запросов к базе данных. Он упрощает работу с
данными и делает код более чистым и понятным по сравнению с использованием
строковых SQL-запросов или HQL.
