# Stream Api

## Stateless и Stateful операции

Операции в Stream API делятся на два типа: stateless (без состояния) и
stateful (с состоянием), в зависимости от того, как они обрабатывают элементы
потока.

Операции без состояния, такие как map() и filter(), обрабатывают каждый элемент
потока независимо от других. Они не требуют информации о предыдущих или
последующих элементах для своей работы, что делает их идеально подходящими для
параллельной обработки. Например, в методе filter() каждый элемент проверяется
по заданному условию отдельно, и его результат не зависит от других элементов.

Операции с состоянием, такие как sorted(), distinct() или limit(), требуют
информации о других элементах потока. Эти операции не могут начать возвращать
результаты, пока не обработают часть или весь поток. Например, sorted() должна
сначала собрать все элементы, чтобы их отсортировать, а затем уже передать их на
последующие этапы.

Если в пайплайне используются только операции без состояния, то поток может быть
обработан “в один проход”, что делает выполнение быстрым и эффективным. Однако
при добавлении операций с состоянием поток делится на секции, и каждая секция
должна завершить свою обработку перед началом следующей.

```java
public static void main(String[] args) {
    final List<String> list = List.of("one", "two", "three");

    list.stream()
            .filter(s -> {
                System.out.println("filter: " + s);
                return s.length() <= 3;
            })
            .map(s1 -> {
                System.out.println("map: " + s1);
                return s1.toUpperCase();
            })
            .sorted()
            .forEach(x -> {
                System.out.println("forEach: " + x);
            });
}
```

В отличие от предыдущего примера, добавление sorted() меняет порядок выполнения:

1. Для каждого элемента сначала выполняется filter, затем map.
2. sorted() необходимо увидеть все элементы, чтобы выполнить сортировку.
3. Порядок вывода в forEach() соответствует результату сортировки.

Таким образом, операция sorted() создает “точку синхронизации”, когда необходимо
сначала обработать все элементы до завершения пайплайна. Это может быть полезно
в некоторых случаях, но может и замедлить обработку, особенно для больших
наборов данных.

## Терминальные операции

Промежуточные операции не выполняются немедленно — они откладываются до тех пор,
пока не будет вызвана терминальная операция.  
Именно терминальная операция запускает выполнение потока. После ее вызова
происходит анализ операций в пайплайне, и определяется эффективная стратегия его
выполнения.

## .parallel(), Проблемы parallel в Stream API, fork-join-poll, commonPool()

Для параллельного выполнения потоков в Stream Api collection.stream()
можно заменить на` collection.parallelStream().operation()`  
либо в общем случае для произвольного stream:
`Source.stream().parallel().operation()`.

Параллельные операции в Stream API в Java позволяют обрабатывать данные в
многопоточном режиме, используя преимущества многоядерных процессоров. Они
основаны на концепции разделения задачи на подзадачи, которые выполняются
параллельно, а затем результаты объединяются. Вот подробное объяснение:

### Основы параллельных стримов

1. **Создание параллельного стрима**:
    - Параллельный стрим можно создать из обычного стрима, вызвав метод
      `parallel()`:
      ```java
      List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
      numbers.stream().parallel()
             .forEach(System.out::println);
      ```
    - Или сразу получить параллельный стрим из коллекции:
      ```java
      numbers.parallelStream()
             .forEach(System.out::println);
      ```

2. **Fork/Join Framework**:
    - Параллельные стримы используют пул потоков Fork/Join, введённый в Java 7 (
      `ForkJoinPool.commonPool()`). Этот пул автоматически распределяет задачи
      между доступными процессорными ядрами.
    - Разделение задач происходит рекурсивно: стрим делится на меньшие части,
      каждая из которых обрабатывается отдельным потоком.

3. **Порядок обработки**:
    - В параллельных стримах порядок обработки элементов не гарантируется, в
      отличие от последовательных стримов. Например, в примере выше числа могут
      выводиться в любом порядке.

### Когда использовать параллельные стримы

Параллельные стримы полезны для:

- **Тяжёлых вычислений**: Например, обработка больших коллекций, сложные
  математические операции, фильтрация или преобразование данных.
- **Независимых операций**: Когда элементы стрима можно обрабатывать независимо
  друг от друга (без необходимости синхронизации).
- **Больших объёмов данных**: Параллелизм даёт прирост производительности при
  работе с большими наборами данных.

Однако параллельные стримы **не подходят** для:

- Маленьких коллекций: Накладные расходы на создание потоков и их синхронизацию
  могут превысить выгоду.
- Операций с побочными эффектами: Например, изменение общей переменной в
  `forEach` может привести к состоянию гонки.
- Зависимых операций: Если обработка одного элемента зависит от другого,
  параллелизм может вызвать ошибки.

### Примеры операций

1. **Фильтрация и маппинг**:
   ```java
   List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
   List<Integer> evenSquares = numbers.parallelStream()
                                     .filter(n -> n % 2 == 0)
                                     .map(n -> n * n)
                                     .collect(Collectors.toList());
   System.out.println(evenSquares); // [4, 16, 36, 64, 100]
   ```
   Здесь фильтрация и возведение в квадрат выполняются параллельно.

2. **Суммирование**:
   ```java
   int sum = numbers.parallelStream()
                    .reduce(0, Integer::sum);
   System.out.println(sum); // 55
   ```
   Метод `reduce` безопасно объединяет результаты из разных потоков.

3. **Группировка**:
   ```java
   Map<Boolean, List<Integer>> oddEvenMap = numbers.parallelStream()
                                                   .collect(Collectors.groupingBy(n -> n % 2 == 0));
   System.out.println(oddEvenMap);
   // {false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8, 10]}
   ```

### Особенности и подводные камни

1. **Потокобезопасность**:
    - Операции в параллельных стримах должны быть **без состояния** (stateless)
      и **без побочных эффектов** (non-interfering). Например:
      ```java
      List<Integer> sharedList = new ArrayList<>();
      numbers.parallelStream().forEach(n -> sharedList.add(n)); // ОПАСНО!
      ```
      Это может привести к непредсказуемым результатам из-за состояния гонки.
      Вместо этого используйте потокобезопасные коллекторы:
      ```java
      List<Integer> safeList = numbers.parallelStream()
                                      .collect(Collectors.toList());
      ```

2. **Производительность**:
    - Параллельные стримы не всегда быстрее. Например, для операций с
      интенсивным вводом-выводом (чтение файлов, сетевые запросы) параллелизм
      может быть неэффективным.
    - Размер данных и тип операции влияют на производительность. Для маленьких
      коллекций последовательный стрим часто быстрее.

3. **Управление пулами потоков**:
    - По умолчанию используется общий `ForkJoinPool.commonPool()`. Если нужно
      использовать собственный пул, можно выполнить стрим в пределах
      `ForkJoinPool`:
      ```java
      ForkJoinPool customPool = new ForkJoinPool(4);
      customPool.submit(() -> 
          numbers.parallelStream().forEach(System.out::println)
      ).join();
      ```

4. **Порядок элементов**:
    - Если порядок важен, используйте `forEachOrdered` вместо `forEach`:
      ```java
      numbers.parallelStream()
             .forEachOrdered(System.out::println); // Вывод в порядке коллекции
      ```
      Но это может снизить производительность, так как накладывает ограничения
      на параллелизм.

### Рекомендации

- **Измеряйте производительность**: Перед использованием параллельных стримов
  протестируйте их на реальных данных, чтобы убедиться в приросте скорости.
- **Избегайте побочных эффектов**: Используйте чистые функции и коллекторы для
  безопасной работы.
- **Учитывайте тип данных**: Параллельные стримы лучше работают с массивами и
  `ArrayList`, чем с `LinkedList`, из-за более эффективного разделения данных.
- **Логируйте и отлаживайте**: Параллельные стримы сложнее отлаживать, поэтому
  используйте логирование для отслеживания проблем.

### Итог

Параллельные стримы в Stream API — мощный инструмент для обработки данных в
многопоточном режиме. Они упрощают написание параллельного кода, но требуют
осторожности из-за возможных проблем с потокобезопасностью и
производительностью. Используйте их для тяжёлых вычислений на больших данных,
избегая побочных эффектов и учитывая специфику задачи.

## Проблемы параллельных стримов

Параллельные стримы в Java Stream API, несмотря на их мощь, имеют ряд проблем и
ограничений, которые могут усложнить их использование. Вот основные проблемы:

1. **Потокобезопасность и побочные эффекты**:
    - Параллельные стримы не гарантируют безопасность при работе с общими
      изменяемыми ресурсами. Если в операциях (например, `forEach`)
      модифицируется общий объект, это может привести к **состоянию гонки** или
      непредсказуемым результатам:
      ```java
      List<Integer> sharedList = new ArrayList<>();
      numbers.parallelStream().forEach(n -> sharedList.add(n)); // ОПАСНО!
      ```
    - Решение: Используйте потокобезопасные коллекторы (`Collectors.toList()`)
      или синхронизированные структуры данных, но это снижает
      производительность.

2. **Накладные расходы**:
    - Параллельные стримы используют `ForkJoinPool`, который требует затрат на
      создание потоков, разделение задач и их объединение. Для **маленьких
      коллекций** или простых операций накладные расходы могут превысить выгоду,
      делая параллельный стрим медленнее последовательного.
    - Пример: Для коллекции из 10 элементов последовательный стрим почти всегда
      быстрее.

3. **Негарантированный порядок обработки**:
    - В параллельных стримах элементы обрабатываются в произвольном порядке, что
      может быть проблемой, если порядок важен. Использование `forEachOrdered`
      решает проблему, но снижает производительность, так как ограничивает
      параллелизм:
      ```java
      numbers.parallelStream().forEach(System.out::println); // Порядок не гарантирован
      numbers.parallelStream().forEachOrdered(System.out::println); // Порядок сохранён, но медленнее
      ```

4. **Сложность отладки**:
    - Параллельные стримы сложнее отлаживать из-за многопоточной природы.
      Ошибки, такие как состояние гонки или неправильное объединение
      результатов, трудно воспроизвести и диагностировать.
    - Логирование в параллельных стримах также может запутывать, так как
      сообщения из разных потоков перемешиваются.

5. **Ограниченная применимость**:
    - Параллельные стримы эффективны только для **вычислительных задач** (
      CPU-bound), где данные независимы. Для задач с интенсивным
      вводом-выводом (I/O-bound), таких как чтение файлов или сетевые запросы,
      они не дают прироста производительности, так как потоки простаивают в
      ожидании данных.

6. **Неравномерное распределение задач**:
    - `ForkJoinPool` делит стрим на части, но если данные неоднородны (например,
      некоторые элементы требуют больше времени на обработку), это может
      привести к **дисбалансу нагрузки** между потоками. Один поток может
      закончить работу раньше, а другой — задерживать выполнение.

7. **Зависимость от типа данных**:
    - Эффективность параллельных стримов зависит от структуры данных. Например,
      `ArrayList` или массивы делятся на части быстрее, чем `LinkedList`, из-за
      более сложного доступа к элементам в последнем.
    - Для некоторых коллекций (например, `TreeSet`) разделение может быть
      неэффективным, что снижает выгоду от параллелизма.

8. **Ограничения ForkJoinPool**:
    - По умолчанию используется общий `ForkJoinPool.commonPool()`, размер
      которого зависит от количества процессорных ядер (
      `Runtime.getRuntime().availableProcessors()`). Если пул занят другими
      задачами, производительность параллельных стримов может упасть.
    - Использование кастомного пула (`ForkJoinPool`) усложняет код и требует
      ручного управления.

9. **Сложности с состоянием операций**:
    - Некоторые операции, такие как `reduce` или `collect`, требуют *
      *ассоциативных** и **без состояния** функций. Если операция зависит от
      порядка элементов или имеет состояние, параллельный стрим может дать
      неверные результаты.
    - Пример: Неправильное использование `reduce` с неассоциативной операцией
      может привести к ошибкам.

10. **Риск чрезмерного параллелизма**:
    - Если в приложении одновременно используется несколько параллельных стримов
      или других многопоточных механизмов, это может привести к *
      *перегруженности пула потоков**, конкуренции за ресурсы и снижению общей
      производительности.

### Рекомендации по минимизации проблем

- **Тестируйте производительность**: Сравнивайте параллельные и последовательные
  стримы на реальных данных, чтобы убедиться в целесообразности.
- **Избегайте побочных эффектов**: Используйте чистые функции и коллекторы для
  безопасной работы.
- **Используйте подходящие структуры данных**: Предпочитайте `ArrayList` или
  массивы для параллельных стримов.
- **Ограничивайте параллелизм**: При необходимости используйте кастомный
  `ForkJoinPool` с заданным числом потоков.
- **Проверяйте порядок**: Если порядок важен, используйте `forEachOrdered` или
  последовательный стрим.
- **Профилируйте приложение**: Используйте инструменты (например, VisualVM) для
  анализа узких мест и проблем с потоками.

### Итог

Параллельные стримы — мощный инструмент, но их использование требует
осторожности. Основные проблемы связаны с потокобезопасностью, накладными
расходами, порядком обработки и сложностью отладки. Они лучше всего подходят для
больших независимых вычислительных задач, но могут быть неэффективны или опасны
в других сценариях. Всегда тестируйте и анализируйте их поведение в конкретном
контексте.


## ForkJoinPool

**ForkJoinPool** — это специализированный пул потоков в Java, введённый в Java 7
как часть фреймворка **Fork/Join**. Он предназначен для эффективного выполнения
задач, которые можно рекурсивно разделять на подзадачи (divide-and-conquer).
ForkJoinPool используется в параллельных стримах Stream API и других сценариях,
где требуется параллельная обработка. Вот подробное объяснение:

### Основы ForkJoinPool

1. **Назначение**:
    - ForkJoinPool оптимизирован для задач, которые можно разбить на меньшие
      подзадачи, выполняемые параллельно, с последующим объединением
      результатов. Примеры: рекурсивные алгоритмы (например, сортировка
      слиянием, обработка деревьев) и параллельные стримы.
    - Он эффективно использует многоядерные процессоры, минимизируя накладные
      расходы на управление потоками.

2. **Ключевые концепции**:
    - **Fork (разделение)**: Задача делится на подзадачи, которые распределяются
      между потоками.
    - **Join (объединение)**: После выполнения подзадач их результаты
      объединяются.
    - **Work-stealing (кража работы)**: Если поток завершает свои задачи, он
      может "украсть" задачи из очереди другого потока, что повышает
      эффективность и балансирует нагрузку.

3. **Основной класс**:
    - Основной класс для задач — `ForkJoinTask`, с двумя основными подклассами:
        - `RecursiveAction`: Для задач, не возвращающих результат (например,
          обновление массива).
        - `RecursiveTask<V>`: Для задач, возвращающих результат (например,
          вычисление суммы).
    - Задачи отправляются в пул через методы `submit`, `invoke` или `execute`.

### Как работает ForkJoinPool

1. **Пул потоков**:
    - ForkJoinPool создаёт пул потоков, обычно равный количеству процессорных
      ядер (`Runtime.getRuntime().availableProcessors()`).
    - Каждый поток имеет собственную очередь задач (двусторонняя очередь,
      Deque), куда помещаются подзадачи.

2. **Алгоритм work-stealing**:
    - Если поток завершает свои задачи, он берёт задачу из конца очереди другого
      потока. Это снижает конкуренцию за ресурсы и улучшает использование
      процессора.
    - Work-stealing особенно полезен для задач с неравномерной нагрузкой, где
      некоторые подзадачи выполняются быстрее.

3. **Рекурсивное разделение**:
    - Задачи делятся до тех пор, пока не достигается пороговое значение (
      например, маленький размер данных), после чего они выполняются
      последовательно.
    - Пример: Для обработки массива задача может делить массив пополам, пока
      подмассивы не станут достаточно малыми.

### Использование ForkJoinPool

1. **Создание пула**:
   ```java
   ForkJoinPool pool = new ForkJoinPool(4); // Пул с 4 потоками
   ```
    - По умолчанию используется `ForkJoinPool.commonPool()` (общий пул), который
      создаётся автоматически и используется параллельными стримами.

2. **Пример с RecursiveAction** (без возвращаемого результата):
   ```java
   import java.util.concurrent.RecursiveAction;
   import java.util.concurrent.ForkJoinPool;

   class IncrementTask extends RecursiveAction {
       private final int[] array;
       private final int start, end;
       private static final int THRESHOLD = 10;

       IncrementTask(int[] array, int start, int end) {
           this.array = array;
           this.start = start;
           this.end = end;
       }

       @Override
       protected void compute() {
           if (end - start <= THRESHOLD) {
               // Прямое выполнение для маленького массива
               for (int i = start; i < end; i++) {
                   array[i]++;
               }
           } else {
               // Разделение задачи
               int mid = (start + end) / 2;
               IncrementTask left = new IncrementTask(array, start, mid);
               IncrementTask right = new IncrementTask(array, mid, end);
               left.fork(); // Асинхронно запустить левую задачу
               right.compute(); // Выполнить правую задачу в текущем потоке
               left.join(); // Дождаться завершения левой задачи
           }
       }
   }

   public class Main {
       public static void main(String[] args) {
           int[] array = new int[100];
           ForkJoinPool pool = new ForkJoinPool();
           pool.invoke(new IncrementTask(array, 0, array.length));
           System.out.println(array[0]); // 1
       }
   }
   ```

3. **Пример с RecursiveTask** (с возвращаемым результатом):
   ```java
   import java.util.concurrent.RecursiveTask;
   import java.util.concurrent.ForkJoinPool;

   class SumTask extends RecursiveTask<Long> {
       private final int[] array;
       private final int start, end;
       private static final int THRESHOLD = 10;

       SumTask(int[] array, int start, int end) {
           this.array = array;
           this.start = start;
           this.end = end;
       }

       @Override
       protected Long compute() {
           if (end - start <= THRESHOLD) {
               long sum = 0;
               for (int i = start; i < end; i++) {
                   sum += array[i];
               }
               return sum;
           } else {
               int mid = (start + end) / 2;
               SumTask left = new SumTask(array, start, mid);
               SumTask right = new SumTask(array, mid, end);
               left.fork();
               long rightResult = right.compute();
               long leftResult = left.join();
               return leftResult + rightResult;
           }
       }
   }

   public class Main {
       public static void main(String[] args) {
           int[] array = new int[100];
           for (int i = 0; i < array.length; i++) array[i] = i + 1;
           ForkJoinPool pool = new ForkJoinPool();
           long sum = pool.invoke(new SumTask(array, 0, array.length));
           System.out.println(sum); // 5050
       }
   }
   ```

4. **Использование в параллельных стримах**:
    - Параллельные стримы автоматически используют `ForkJoinPool.commonPool()`:
      ```java
      List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
      int sum = numbers.parallelStream().reduce(0, Integer::sum);
      ```

### Преимущества ForkJoinPool

- **Эффективность**: Алгоритм work-stealing минимизирует простои потоков.
- **Автоматическое управление потоками**: Нет необходимости вручную создавать и
  управлять потоками.
- **Подходит для рекурсивных задач**: Идеально для задач, которые естественно
  делятся на подзадачи.
- **Интеграция с Stream API**: Упрощает параллельную обработку коллекций.

### Проблемы и ограничения

1. **Накладные расходы**:
    - Разделение задач и управление потоками создают накладные расходы, что
      делает ForkJoinPool неэффективным для маленьких задач.
2. **Сложность кода**:
    - Написание задач для ForkJoinPool (особенно с правильным разделением)
      сложнее, чем использование обычных потоков или стримов.
3. **Ограниченная применимость**:
    - Подходит только для CPU-bound задач. Для I/O-bound задач (чтение файлов,
      сетевые запросы) лучше использовать другие пулы, например,
      `ThreadPoolExecutor`.
4. **Риск перегрузки пула**:
    - Общий пул (`commonPool`) может быть перегружен, если множество
      параллельных стримов или задач выполняются одновременно.
5. **Потокобезопасность**:
    - Как и в параллельных стримах, задачи должны быть без состояния и без
      побочных эффектов, чтобы избежать состояний гонки.
6. **Сложности с отладкой**:
    - Многопоточная природа и work-stealing усложняют диагностику ошибок.

### Рекомендации

- **Используйте для больших задач**: ForkJoinPool эффективен для обработки
  больших данных или сложных рекурсивных алгоритмов.
- **Задавайте порог разделения**: Убедитесь, что задачи делятся до разумного
  размера, чтобы избежать избыточных накладных расходов.
- **Избегайте побочных эффектов**: Убедитесь, что задачи не изменяют общие
  ресурсы без синхронизации.
- **Тестируйте производительность**: Сравнивайте ForkJoinPool с последовательным
  выполнением или другими пулами потоков.
- **Используйте кастомный пул при необходимости**:
   ```java
   ForkJoinPool customPool = new ForkJoinPool(4);
   customPool.submit(() -> numbers.parallelStream().forEach(System.out::println)).join();
   ```

### Итог

ForkJoinPool — мощный инструмент для параллельного выполнения рекурсивных задач,
особенно в контексте Stream API. Его алгоритм work-stealing и автоматическое
управление потоками делают его эффективным для вычислительных задач на
многоядерных системах. Однако он требует осторожного использования из-за
накладных расходов, сложности кода и ограничений по типам задач. Если вы
работаете с параллельными стримами или рекурсивными алгоритмами, ForkJoinPool —
стандартный выбор, но всегда тестируйте его на реальных данных.

## ForkJoinPoll.commonPool()

**ForkJoinPool.commonPool()** — это статический метод в классе `ForkJoinPool` в
Java, который возвращает общий (shared) пул потоков Fork/Join, используемый по
умолчанию для выполнения параллельных задач, таких как параллельные стримы в
Stream API. Этот пул создаётся автоматически JVM и является глобальным для всего
приложения.

### Основные характеристики

1. **Назначение**:
    - `commonPool()` предоставляет готовый пул потоков для выполнения задач
      Fork/Join, таких как рекурсивные задачи (`RecursiveTask`,
      `RecursiveAction`) или параллельные стримы, без необходимости создавать
      собственный пул.
    - Он используется автоматически в параллельных стримах:
      ```java
      List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
      numbers.parallelStream().forEach(System.out::println); // Использует commonPool
      ```

2. **Размер пула**:
    - Количество потоков в `commonPool` обычно равно количеству процессорных
      ядер минус один (`Runtime.getRuntime().availableProcessors() - 1`), чтобы
      оставить один поток для других задач JVM.
    - Размер можно настроить через системное свойство:
      ```bash
      -Djava.util.concurrent.ForkJoinPool.common.parallelism=4
      ```

3. **Work-stealing**:
    - Как и любой `ForkJoinPool`, `commonPool` использует алгоритм *
      *work-stealing**: потоки, завершившие свои задачи, могут "украсть" задачи
      из очередей других потоков, что повышает эффективность.

4. **Создание и доступ**:
    - Пул создаётся лениво (lazy initialization) при первом вызове
      `commonPool()` или при запуске параллельного стрима.
    - Доступ к пулу:
      ```java
      ForkJoinPool commonPool = ForkJoinPool.commonPool();
      ```

### Когда используется

- **Параллельные стримы**: Все операции `parallelStream()` по умолчанию
  выполняются в `commonPool`.
- **Ручное использование**: Можно отправлять задачи в `commonPool` через
  `submit`, `invoke` или `execute`:
  ```java
  ForkJoinPool.commonPool().submit(() -> System.out.println("Task in common pool"));
  ```

### Преимущества

- **Удобство**: Не нужно создавать и управлять собственным пулом.
- **Эффективность**: Оптимизирован для многопоточных задач с рекурсивным
  разделением.
- **Глобальная доступность**: Доступен из любой части приложения.

### Проблемы и ограничения

1. **Общий ресурс**:
    - Так как `commonPool` используется всеми параллельными стримами и задачами
      в приложении, он может стать перегруженным, если одновременно выполняется
      много задач.
    - Это может привести к конкуренции за потоки и снижению производительности.

2. **Ограниченный контроль**:
    - Нельзя напрямую настроить параметры пула (например,
      минимальное/максимальное количество потоков) без системных свойств.
    - Для тонкой настройки лучше создать собственный `ForkJoinPool`.

3. **Не подходит для I/O-bound задач**:
    - `commonPool` оптимизирован для вычислительных (CPU-bound) задач. Для задач
      с интенсивным вводом-выводом (I/O-bound), таких как чтение файлов или
      сетевые запросы, он может быть неэффективен, так как потоки простаивают.

4. **Накладные расходы**:
    - Для маленьких задач накладные расходы на управление потоками в
      `commonPool` могут превысить выгоду от параллелизма.

5. **Потокобезопасность**:
    - Задачи, выполняемые в `commonPool`, должны быть без состояния и без
      побочных эффектов, чтобы избежать состояний гонки, особенно в параллельных
      стримах.

### Пример использования

```java
import java.util.concurrent.ForkJoinPool;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        ForkJoinPool commonPool = ForkJoinPool.commonPool();
        System.out.println("Parallelism: " + commonPool.getParallelism()); // Количество потоков

        // Параллельный стрим, использующий commonPool
        Arrays.asList(1, 2, 3, 4, 5)
                .parallelStream()
                .forEach(n -> System.out.println(n + " processed by " + Thread.currentThread().getName()));

        // Ручная отправка задачи в commonPool
        commonPool.submit(() -> System.out.println("Custom task in commonPool"));
    }
}
```

### Рекомендации

- **Используйте для вычислительных задач**: `commonPool` идеален для
  параллельных стримов и рекурсивных алгоритмов на больших данных.
- **Избегайте перегрузки**: Если в приложении много параллельных операций,
  рассмотрите создание кастомного `ForkJoinPool`:
  ```java
  ForkJoinPool customPool = new ForkJoinPool(4);
  customPool.submit(() -> numbers.parallelStream().forEach(System.out::println)).join();
  ```
- **Проверяйте производительность**: Для маленьких коллекций последовательные
  стримы могут быть быстрее.
- **Настройка при необходимости**: Используйте системное свойство
  `-Djava.util.concurrent.ForkJoinPool.common.parallelism` для управления
  количеством потоков, если требуется.

### Итог

`ForkJoinPool.commonPool()` — это удобный и эффективный общий пул потоков для
параллельных задач, особенно в Stream API. Он упрощает параллельную обработку,
но имеет ограничения, связанные с общим доступом, отсутствием гибкой настройки и
применимостью только к вычислительным задачам. Для сложных сценариев или высокой
нагрузки лучше использовать кастомный `ForkJoinPool`.

Если нужны дополнительные примеры или разъяснения, уточните!