# Многопоточность

# ExecutorService

**ExecutorService** в Java — это высокоуровневый интерфейс из пакета
`java.util.concurrent`, предназначенный для управления потоками выполнения задач
в многопоточных приложениях. Он упрощает работу с потоками, предоставляя пул
потоков и механизмы для асинхронного выполнения задач. Вот основные аспекты:

### Основные характеристики

1. **Абстракция над потоками**: ExecutorService позволяет выполнять задачи (
   `Runnable` или `Callable`) без необходимости вручную создавать и управлять
   потоками.
2. **Пул потоков**: Вместо создания нового потока для каждой задачи,
   ExecutorService использует пул потоков, что снижает накладные расходы на
   создание и уничтожение потоков.
3. **Гибкость**: Поддерживает выполнение задач асинхронно, с возможностью
   получения результатов (через `Future`) и управления временем выполнения.
4. **Управление жизненным циклом**: Предоставляет методы для корректного
   завершения работы пула потоков.

### Основные особенности `ExecutorService`:

1. **Управление потоками**: `ExecutorService` позволяет вам управлять пулом
   потоков, что означает, что вы можете повторно использовать потоки для
   выполнения нескольких задач, вместо создания нового потока для каждой задачи.
   Это значительно снижает накладные расходы на создание и уничтожение потоков.
2. **Асинхронное выполнение**: Вы можете отправлять задачи на выполнение и
   продолжать выполнять другие операции, не дожидаясь завершения этих задач.
3. **Планирование задач**: `ExecutorService` поддерживает планирование задач с
   использованием методов, таких как `schedule()` (в классе
   `ScheduledExecutorService`), что позволяет выполнять задачи через
   определенные интервалы времени или с задержкой.
4. **Разные типы задач**: Вы можете отправлять как `Runnable`, так и `Callable`
   задачи. `Callable` позволяет возвращать результат и обрабатывать исключения.
5. **Управление жизненным циклом**: `ExecutorService` предоставляет методы для
   управления жизненным циклом пула потоков, такие как `shutdown()` и
   `shutdownNow()`, которые позволяют корректно завершить выполнение задач.
6. **Фабрики для создания экземпляров**: Для создания экземпляров
   `ExecutorService` обычно используются статические методы класса `Executors`,
   такие как:
    - `Executors.newFixedThreadPool(int nThreads)`: создает пул фиксированного
      размера.
    - `Executors.newCachedThreadPool()`: создает пул, который создает новые
      потоки по мере необходимости, но повторно использует ранее созданные
      потоки.
    - `Executors.newSingleThreadExecutor()`: создает пул с одним потоком.

### Основные интерфейсы и классы

- **Executor**: Базовый интерфейс с методом `execute(Runnable)`.
- **ExecutorService**: Расширяет `Executor`, добавляя методы для управления
  задачами и завершением работы.
- **ScheduledExecutorService**: Подинтерфейс для планирования задач с задержкой
  или периодическим выполнением.
- Реализации:
    - `ThreadPoolExecutor`: Настраиваемый пул потоков.
    - `ScheduledThreadPoolExecutor`: Для планирования задач.
    - `ForkJoinPool`: Для задач, разбиваемых на подзадачи (рекурсивные
      вычисления).

### Создание ExecutorService

Создать `ExecutorService` можно с помощью фабричных методов класса `Executors`:

```java
import java.util.concurrent.*;

// Фиксированный пул потоков (например, 5 потоков)
ExecutorService executor = Executors.newFixedThreadPool(5);

        // Кэширующий пул (создает потоки по необходимости)
        ExecutorService executor = Executors.newCachedThreadPool();

        // Одиночный поток
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // Планировщик задач
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
```

### Основные методы

1. **Отправка задач**:
    - `execute(Runnable)`: Выполняет задачу без возврата результата.
    - `submit(Runnable)`: Возвращает `Future<?>` для отслеживания завершения.
    - `submit(Callable<T>)`: Выполняет задачу, возвращающую результат (тип `T`).
    - `invokeAll(Collection<Callable<T>>)`: Выполняет все задачи и возвращает
      список `Future`.
    - `invokeAny(Collection<Callable<T>>)`: Выполняет задачи и возвращает
      результат первой успешно завершенной.

2. **Управление завершением**:
    - `shutdown()`: Завершает прием новых задач, но выполняет уже отправленные.
    - `shutdownNow()`: Пытается прервать все задачи и завершить работу.
    - `awaitTermination(long timeout, TimeUnit unit)`: Ждет завершения всех
      задач в течение указанного времени.

3. **Планирование (для ScheduledExecutorService)**:
    - `schedule(Runnable/Callable, long delay, TimeUnit unit)`: Выполняет задачу
      после задержки.
    -
   `scheduleAtFixedRate(Runnable, long initialDelay, long period, TimeUnit unit)`:
   Периодическое выполнение с фиксированным интервалом.
    -
   `scheduleWithFixedDelay(Runnable, long initialDelay, long delay, TimeUnit unit)`:
   Периодическое выполнение с фиксированной задержкой между задачами.

### Пример использования

```java
import java.util.concurrent.*;

public class ExecutorServiceExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Задача Runnable
        executor.submit(() -> System.out.println("Задача Runnable выполнена в " + Thread.currentThread().getName()));

        // Задача Callable с результатом
        Future<Integer> future = executor.submit(() -> {
            Thread.sleep(1000);
            return 42;
        });

        // Получение результата
        System.out.println("Результат Callable: " + future.get());

        // Завершение пула
        executor.shutdown();
        if (executor.awaitTermination(5, TimeUnit.SECONDS)) {
            System.out.println("Пул завершен");
        } else {
            executor.shutdownNow();
            System.out.println("Пул принудительно остановлен");
        }
    }
}
```

### Преимущества

- Упрощает управление потоками.
- Повышает производительность за счет повторного использования потоков.
- Поддерживает асинхронное выполнение и обработку результатов.
- Гибкость в настройке пула (размер, стратегия обработки очереди).

### Рекомендации

1. **Всегда завершайте пул**: Используйте `shutdown()` или `shutdownNow()`,
   чтобы избежать утечек ресурсов.
2. **Обрабатывайте исключения**: Проверяйте исключения в `Future.get()` или
   используйте `try-catch` при выполнении задач.
3. **Выбирайте подходящий тип пула**:
    - `newFixedThreadPool`: Для ограниченного числа потоков.
    - `newCachedThreadPool`: Для множества короткоживущих задач.
    - `newSingleThreadExecutor`: Для последовательного выполнения.
4. **Избегайте перегрузки**: Слишком большое количество задач может привести к
   исчерпанию ресурсов.

### Ограничения

- Неуправляемый `newCachedThreadPool` может создавать слишком много потоков, что
  приведет к снижению производительности.
- Неправильное завершение пула может вызвать утечки памяти.
- Очереди задач (например, в `ThreadPoolExecutor`) могут переполниться при
  большом количестве задач.

### Когда использовать

`ExecutorService` идеально подходит для:

- Параллельной обработки задач (например, обработка запросов в веб-сервере).
- Выполнения длительных операций в фоновом режиме.
- Планирования периодических задач (например, очистка кэша).
- Разбиения задач на подзадачи (с `ForkJoinPool`).

Для более сложных сценариев можно настроить `ThreadPoolExecutor` напрямую,
задавая параметры пула (размер, очередь, политика отклонения задач).

## В чем отличие ExecutorService от ForkJoinPool?

`ExecutorService` и `ForkJoinPool` в Java оба используются для управления
потоками и выполнения задач в многопоточной среде, но они имеют разные цели,
архитектуру и подходы к обработке задач. Вот основные отличия:

### 1. **Назначение и область применения**

- **ExecutorService**:
    - Универсальный интерфейс из пакета `java.util.concurrent` для выполнения
      асинхронных задач.
    - Подходит для общего управления потоками и выполнения независимых задач,
      таких как обработка запросов в веб-сервере, выполнение фоновых операций
      или параллельная обработка данных.
    - Не оптимизирован для рекурсивных или иерархических задач.
- **ForkJoinPool**:
    - Специализированная реализация `ExecutorService`, предназначенная для
      задач, которые можно рекурсивно разделять на подзадачи (подход "разделяй и
      властвуй").
    - Оптимизирован для задач с интенсивным разбиением (например, обработка
      больших массивов, рекурсивные алгоритмы типа сортировки или вычислений).
    - Основное использование: задачи, где большая работа разбивается на меньшие
      подзадачи, которые затем объединяются (например, параллельная обработка в
      `parallelStream` в Java).

### 2. **Архитектура и механизм работы**

- **ExecutorService**:
    - Использует пул потоков фиксированного или динамического размера (например,
      `FixedThreadPool`, `CachedThreadPool`).
    - Задачи распределяются по потокам из пула, и каждый поток выполняет задачу
      независимо.
    - Не имеет встроенной поддержки для рекурсивного разбиения задач.
    - Очередь задач (например, `LinkedBlockingQueue`) управляет порядком
      выполнения.
- **ForkJoinPool**:
    - Использует механизм **work-stealing** (кража работы): каждый поток имеет
      свою очередь задач, и если поток простаивает, он может "украсть" задачи из
      очереди другого потока, что повышает эффективность.
    - Оптимизирован для задач, где создаются подзадачи (через `ForkJoinTask`,
      такие, как `RecursiveTask` или `RecursiveAction`).
    - Поддерживает рекурсивное разбиение задач: задача делится на подзадачи (
      `fork`), которые выполняются параллельно, а затем результаты
      объединяются (`join`).

### 3. **Типы задач**

- **ExecutorService**:
    - Подходит для независимых задач, которые не требуют взаимодействия или
      координации между собой.
    - Примеры: обработка HTTP-запросов, выполнение независимых вычислений,
      запуск фоновых операций.
    - Задачи обычно представляют собой `Runnable` или `Callable`.
- **ForkJoinPool**:
    - Идеален для задач, которые можно разделить на меньшие части, выполняемые
      параллельно, с последующим объединением результатов.
    - Примеры: рекурсивная сортировка (QuickSort, MergeSort), обработка больших
      массивов, вычисления на графах.
    - Задачи обычно представляют собой `ForkJoinTask` (подклассы `RecursiveTask`
      для задач с возвращаемым результатом или `RecursiveAction` для задач без
      результата).

### 4. **Производительность**

- **ExecutorService**:
    - Эффективен для задач с предсказуемой нагрузкой и независимыми операциями.
    - Может быть менее эффективен для задач с большим количеством подзадач, так
      как не оптимизирован для динамического разбиения.
    - Накладные расходы зависят от типа пула (например, `CachedThreadPool` может
      создавать много потоков, что снижает производительность при высокой
      нагрузке).
- **ForkJoinPool**:
    - Высокая производительность для рекурсивных задач благодаря механизму
      work-stealing, который минимизирует простои потоков.
    - Оптимизирован для задач с высокой степенью параллелизма, где подзадачи
      имеют схожую вычислительную сложность.
    - Может быть менее эффективен для задач, которые не подразумевают
      рекурсивное разбиение, из-за дополнительных накладных расходов на
      управление подзадачами.

### 5. **API и использование**

- **ExecutorService**:
    - Простое API: `execute`, `submit`, `invokeAll`, `invokeAny`.
    - Управление жизненным циклом через `shutdown`, `shutdownNow`,
      `awaitTermination`.
    - Пример:
      ```java
      ExecutorService executor = Executors.newFixedThreadPool(4);
      executor.submit(() -> System.out.println("Задача выполнена"));
      executor.shutdown();
      ```
- **ForkJoinPool**:
    - Более сложное API, ориентированное на рекурсию: задачи делятся с помощью
      `fork()` и объединяются с помощью `join()`.
    - Используется с `ForkJoinTask` или его подклассами.
    - Пример:
      ```java
      import java.util.concurrent.*;
  
      public class ForkJoinExample extends RecursiveTask<Integer> {
          private final int[] array;
          private final int start, end;
  
          public ForkJoinExample(int[] array, int start, int end) {
              this.array = array;
              this.start = start;
              this.end = end;
          }
  
          @Override
          protected Integer compute() {
              if (end - start <= 10) {
                  int sum = 0;
                  for (int i = start; i < end; i++) sum += array[i];
                  return sum;
              } else {
                  int mid = (start + end) / 2;
                  ForkJoinExample left = new ForkJoinExample(array, start, mid);
                  ForkJoinExample right = new ForkJoinExample(array, mid, end);
                  left.fork(); // Разделяем задачу
                  return right.compute() + left.join(); // Объединяем результаты
              }
          }
  
          public static void main(String[] args) {
              ForkJoinPool pool = ForkJoinPool.commonPool();
              int[] array = new int[100]; // Заполнить массив
              ForkJoinExample task = new ForkJoinExample(array, 0, array.length);
              int result = pool.invoke(task);
              System.out.println("Сумма: " + result);
              pool.shutdown();
          }
      }
      ```

### 6. **Интеграция с Java**

- **ExecutorService**:
    - Используется в широком спектре приложений, например, в веб-серверах (
      Tomcat, Jetty), пулах соединений, обработке событий.
    - Подходит для любых асинхронных задач.
- **ForkJoinPool**:
    - Интегрирован с Java Streams API (начиная с Java 8): `parallelStream`
      использует `ForkJoinPool.commonPool()` для параллельной обработки.
    - Пример: `Arrays.stream(array).parallel().sum()` использует `ForkJoinPool`.

### 7. **Общий пул (Common Pool)**

- **ExecutorService**:
    - Не имеет общего пула по умолчанию; вы создаете собственный экземпляр с
      помощью `Executors`.
- **ForkJoinPool**:
    - Имеет общий пул (`ForkJoinPool.commonPool()`), который используется для
      `parallelStream` и других задач, если не указан конкретный пул.
    - Размер пула по умолчанию равен количеству доступных процессоров (
      `Runtime.getRuntime().availableProcessors()`).

### Когда использовать что

- **ExecutorService**:
    - Для независимых задач, где не требуется рекурсивное разбиение.
    - Когда нужна простая модель пула потоков (фиксированный, кэширующий или
      одиночный).
    - Примеры: обработка запросов, выполнение фоновых задач, запуск таймеров.
- **ForkJoinPool**:
    - Для рекурсивных задач, которые можно эффективно разделить на подзадачи.
    - Когда вы хотите использовать механизм work-stealing для повышения
      производительности.
    - Примеры: обработка больших массивов, рекурсивные алгоритмы, задачи в
      `parallelStream`.

### Краткое сравнение

| Характеристика         | ExecutorService                   | ForkJoinPool                            |
|------------------------|-----------------------------------|-----------------------------------------|
| **Назначение**         | Универсальное выполнение задач    | Рекурсивные задачи с разделением        |
| **Механизм**           | Пул потоков, очередь задач        | Work-stealing, рекурсивное разбиение    |
| **Тип задач**          | Независимые `Runnable`/`Callable` | `ForkJoinTask` (`RecursiveTask/Action`) |
| **Производительность** | Хорошая для независимых задач     | Оптимизирована для рекурсивных задач    |
| **API**                | Простое (`submit`, `execute`)     | Сложнее (`fork`, `join`)                |
| **Использование**      | Веб-серверы, фоновые задачи       | `parallelStream`, рекурсивные алгоритмы |
| **Общий пул**          | Отсутствует                       | `commonPool()`                          |

### Итог

- Если ваши задачи независимы и не требуют рекурсивного разбиения, используйте
  `ExecutorService` (например, `FixedThreadPool` или `CachedThreadPool`).
- Если задачи можно разделить на подзадачи (например, обработка больших данных
  или рекурсивные вычисления), используйте `ForkJoinPool` для повышения
  эффективности за счет work-stealing.

## ThreadPoolExecutor

**ThreadPoolExecutor** в Java — это мощная и гибкая реализация интерфейса
`ExecutorService` из пакета `java.util.concurrent`, предназначенная для
управления пулом потоков. Она позволяет настраивать параметры пула потоков,
такие как размер пула, политика обработки очереди задач и поведение при
перегрузке. Это более низкоуровневый инструмент по сравнению с фабричными
методами `Executors`, предоставляя детальный контроль над выполнением задач.

### Основные характеристики

- **Пул потоков**: `ThreadPoolExecutor` создает пул потоков, которые повторно
  используются для выполнения задач, что снижает накладные расходы на создание и
  уничтожение потоков.
- **Гибкость настройки**: Позволяет задавать минимальное и максимальное
  количество потоков, тип очереди задач и стратегию обработки отклоненных задач.
- **Управление задачами**: Поддерживает асинхронное выполнение задач (`Runnable`
  или `Callable`) с возможностью получения результатов через `Future`.
- **Жизненный цикл**: Обеспечивает методы для управления завершением пула (
  `shutdown`, `shutdownNow`, `awaitTermination`).

### Конструкторы

`ThreadPoolExecutor` имеет несколько конструкторов, самый полный из которых:

```java
ThreadPoolExecutor(int corePoolSize,
                   int maximumPoolSize,
                   long keepAliveTime,
                   TimeUnit unit,
                   BlockingQueue<Runnable> workQueue,
                   ThreadFactory threadFactory,
                   RejectedExecutionHandler handler)
```

- **corePoolSize**: Количество потоков, которые постоянно поддерживаются в
  пуле (даже если простаивают).
- **maximumPoolSize**: Максимальное количество потоков, которое может быть
  создано при переполнении очереди.
- **keepAliveTime**: Время, в течение которого лишние потоки (сверх
  `corePoolSize`) будут простаивать перед завершением.
- **unit**: Единица измерения времени для `keepAliveTime` (например,
  `TimeUnit.SECONDS`).
- **workQueue**: Очередь для хранения задач, ожидающих выполнения (например,
  `LinkedBlockingQueue`, `ArrayBlockingQueue`, `SynchronousQueue`).
- **threadFactory**: Фабрика для создания новых потоков (обычно
  `Executors.defaultThreadFactory()`).
- **handler**: Политика обработки задач, которые не могут быть выполнены из-за
  переполнения пула или очереди (например, `AbortPolicy`, `CallerRunsPolicy`).

### Основные параметры и их влияние

1. **corePoolSize и maximumPoolSize**:
    - Пул начинает с `corePoolSize` потоков. Если очередь задач переполняется,
      создаются дополнительные потоки до `maximumPoolSize`.
    - Если `corePoolSize` равно `maximumPoolSize`, пул имеет фиксированный
      размер (аналог `Executors.newFixedThreadPool`).
2. **workQueue**:
    - `LinkedBlockingQueue`: Неограниченная очередь (по умолчанию). Может
      привести к переполнению памяти при большом количестве задач.
    - `ArrayBlockingQueue`: Ограниченная очередь с фиксированным размером.
    - `SynchronousQueue`: Очередь без буфера — задачи передаются напрямую потоку
      или отклоняются.
    - `PriorityBlockingQueue`: Очередь с приоритетами для задач.
3. **keepAliveTime**:
    - Если количество потоков превышает `corePoolSize`, избыточные потоки
      завершаются после простоя в течение `keepAliveTime`.
    - Если `allowCoreThreadTimeOut(true)`, даже основные потоки (`corePoolSize`)
      могут завершаться при простое.
4. **RejectedExecutionHandler**:
    - Определяет, что делать, если задача не может быть добавлена в очередь или
      выполнена:
        - `AbortPolicy` (по умолчанию): выбрасывает
          `RejectedExecutionException`.
        - `CallerRunsPolicy`: Выполняет задачу в вызывающем потоке.
        - `DiscardPolicy`: Тихо отбрасывает задачу.
        - `DiscardOldestPolicy`: Отбрасывает самую старую задачу в очереди и
          пытается добавить новую.

### Создание ThreadPoolExecutor

Пример создания:

```java
import java.util.concurrent.*;

ThreadPoolExecutor executor = new ThreadPoolExecutor(
        2, // corePoolSize
        4, // maximumPoolSize
        60, // keepAliveTime
        TimeUnit.SECONDS, // единица времени
        new ArrayBlockingQueue<>(10), // очередь на 10 задач
        Executors.defaultThreadFactory(), // фабрика потоков
        new ThreadPoolExecutor.AbortPolicy() // политика отклонения
);
```

### Основные методы

`ThreadPoolExecutor` наследует методы от `ExecutorService`:

- `execute(Runnable)`: Выполняет задачу без возврата результата.
- `submit(Runnable/Callable)`: Выполняет задачу и возвращает `Future`.
- `invokeAll/invokeAny`: Выполняет коллекцию задач.
- `shutdown()`: Завершает прием новых задач, но выполняет существующие.
- `shutdownNow()`: Пытается прервать все задачи.
- `awaitTermination`: Ждет завершения всех задач в течение заданного времени.

Дополнительные методы:

- `getPoolSize()`: Возвращает текущий размер пула.
- `getActiveCount()`: Количество активных потоков.
- `getQueue()`: Возвращает очередь задач.
- `setCorePoolSize(int)`: Динамически изменяет размер пула.

### Пример использования

```java
import java.util.concurrent.*;

public class ThreadPoolExecutorExample {
    public static void main(String[] args) throws Exception {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, 4, 60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(10),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );

        // Отправка задач
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Задача " + taskId + " выполняется в " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                }
            });
        }

        // Мониторинг
        System.out.println("Активных потоков: " + executor.getActiveCount());
        System.out.println("Задач в очереди: " + executor.getQueue().size());

        // Завершение
        executor.shutdown();
        if (executor.awaitTermination(10, TimeUnit.SECONDS)) {
            System.out.println("Пул завершен");
        } else {
            executor.shutdownNow();
            System.out.println("Пул принудительно остановлен");
        }
    }
}
```

### Преимущества

- **Гибкость**: Тонкая настройка пула (размер, очередь, политика отклонения).
- **Эффективность**: Повторное использование потоков снижает накладные расходы.
- **Мониторинг**: Возможность отслеживать состояние пула (активные потоки,
  очередь).
- **Управление перегрузкой**: Настраиваемые политики обработки отклоненных
  задач.

### Ограничения

- **Сложность настройки**: Требует понимания параметров (`corePoolSize`,
  `maximumPoolSize`, `workQueue`) для оптимальной работы.
- **Риск переполнения**: Неограниченные очереди (например,
  `LinkedBlockingQueue`) могут привести к исчерпанию памяти.
- **Ручное управление**: В отличие от `Executors.newFixedThreadPool` или
  `ForkJoinPool`, требует явной настройки.

### Сравнение с другими пулами

- **По сравнению с `Executors.newFixedThreadPool`**:
    - `FixedThreadPool` — это `ThreadPoolExecutor` с `corePoolSize` =
      `maximumPoolSize` и неограниченной очередью (`LinkedBlockingQueue`).
    - `ThreadPoolExecutor` позволяет настраивать поведение (например,
      ограниченная очередь, время жизни потоков).
- **По сравнению с `Executors.newCachedThreadPool`**:
    - `CachedThreadPool` — это `ThreadPoolExecutor` с `corePoolSize = 0`,
      `maximumPoolSize = Integer.MAX_VALUE` и `SynchronousQueue`.
    - `ThreadPoolExecutor` дает больше контроля над количеством потоков и
      очередью.
- **По сравнению с `ForkJoinPool`**:
    - `ForkJoinPool` оптимизирован для рекурсивных задач с механизмом
      work-stealing.
    - `ThreadPoolExecutor` лучше подходит для независимых задач и не
      поддерживает рекурсивное разбиение.

### Когда использовать

- Когда нужна тонкая настройка пула потоков (например, ограниченная очередь или
  специфическая политика отклонения).
- Для задач, где требуется управление количеством одновременно выполняемых
  потоков.
- Для приложений с предсказуемой нагрузкой, таких как веб-серверы, обработка
  запросов или фоновые задачи.

### Рекомендации

1. **Выбирайте подходящую очередь**:
    - Используйте `ArrayBlockingQueue` для ограничения памяти.
    - Избегайте `LinkedBlockingQueue` без ограничений, чтобы предотвратить
      переполнение.
2. **Настройте политику отклонения**:
    - `CallerRunsPolicy` помогает избежать перегрузки, выполняя задачи в
      вызывающем потоке.
    - `AbortPolicy` подходит, если нужно явно обрабатывать отказы.
3. **Мониторьте пул**:
    - Используйте методы `getActiveCount()`, `getQueue().size()` для
      отслеживания нагрузки.
4. **Завершайте пул корректно**:
    - Всегда вызывайте `shutdown()` или `shutdownNow()` для освобождения
      ресурсов.
5. **Тестируйте параметры**:
    - Подберите `corePoolSize` и `maximumPoolSize` в зависимости от нагрузки и
      доступных процессоров.

___

## Задачи

В контексте `ExecutorService` (и вообще многопоточности в
Java), **"задача"** — это **единица работы**, которую мы хотим выполнить в
отдельном потоке.

В Java задача — это объект, реализующий один из интерфейсов:

- `Runnable` — если задача **не возвращает результат**
- `Callable<T>` — если задача **возвращает результат** и может выбрасывать
  исключения

Можно представить задачу как команду: "Сделай что-то". И `ExecutorService` —
это менеджер, который принимает такие команды и раздаёт их доступным
работникам (потокам из пула).

**Пример задачи с `Runnable`:**

```java
Runnable task = () -> System.out.println("Печать отчета...");
```

Эта задача просто что-то делает — побочный эффект, но **ничего не возвращает**.

**Пример задачи с `Callable`:**

```java
Callable<Integer> task = () -> {
    int result = 2 + 2;
    return result;
};
```

Эта задача **возвращает значение** — можно получить результат через
`Future<Integer>`.

Ты кидаешь задачи в корзину (`submit()`), сотрудники их берут, делают и отдают
результат на бумажке (`Future.get()`).

_**Реальный пример с задачей, которая:**_

1. Делает какое-то вычисление (например, считает сумму чисел от 1 до N)
2. Возвращает результат
3. Используется через `Callable`
4. Обрабатывается через `Future`

Код:

```java
import java.util.concurrent.*;

public class TaskExample {
    public static void main(String[] args) {
        // 1. Создаём пул потоков
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // 2. Создаём задачу
        Callable<Integer> task = () -> {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
                Thread.sleep(10); // имитируем задержку
            }
            return sum;
        };

        // 3. Отправляем задачу в ExecutorService
        Future<Integer> future = executor.submit(task);

        // 4. Делаем что-то параллельно (для примера)
        System.out.println("Задача запущена. Выполняем другие действия...");

        try {
            // 5. Получаем результат (блокирует поток, пока не готово)
            Integer result = future.get();
            System.out.println("Результат вычислений: " + result);
        } catch (InterruptedException | ExecutionException e) {
            System.out.println("Произошла ошибка при выполнении задачи: " + e.getMessage());
        }

        // 6. Завершаем работу ExecutorService
        executor.shutdown();
    }
}
```

Что происходит шаг за шагом:

1. Мы создаём пул из одного потока (можно больше).
2. Описываем задачу — простое сложение чисел с задержкой.
3. Передаём задачу на выполнение.
4. Пока задача выполняется — основной поток может делать что-то ещё.
5. Получаем результат с помощью `future.get()`.
6. Завершаем работу пула.

### Основные характеристики задач:

1. **Единица работы**: Задача — это конкретная работа или операция, которую
   нужно выполнить. Это может быть что угодно: от простого вычисления до сложной
   обработки данных.

2. **Асинхронность**: Задачи могут выполняться асинхронно, что позволяет
   основному потоку продолжать выполнение других операций, не дожидаясь
   завершения задачи.

3. **Возврат результата**:
    - **Runnable**: Задачи, реализующие интерфейс `Runnable`, не возвращают
      результат. Метод `run()` этого интерфейса имеет тип `void`.
    - **Callable**: Задачи, реализующие интерфейс `Callable`, могут возвращать
      результат и могут выбрасывать проверяемые исключения. Метод `call()` этого
      интерфейса возвращает значение.

4. **Управление состоянием**: Каждая задача может находиться в одном из
   нескольких состояний (например, ожидает выполнения, выполняется или
   завершена). Это состояние можно отслеживать с помощью объекта типа `Future`,
   который возвращается при отправке задачи на выполнение.

### Параллельный запуск нескольких задач

_**InvokeAll():**_

Пример:

Запускаем **несколько задач параллельно**<br>
Каждая считает сумму от 1 до своего числа N<br>
Собираем **все результаты**<br>
Используем `ExecutorService` и `List<Future>`

_**Пример: несколько задач параллельно**_

```java
import java.util.concurrent.*;
import java.util.*;

public class MultiTaskExample {
    public static void main(String[] args) throws InterruptedException {
        // 1. Пул из 3 потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // 2. Список задач (Callable)
        List<Callable<Integer>> tasks = new ArrayList<>();
        for (int n : List.of(100, 200, 300)) {
            tasks.add(() -> {
                int sum = 0;
                for (int i = 1; i <= n; i++) {
                    sum += i;
                    Thread.sleep(5); // имитируем задержку
                }
                System.out.println("Задача для " + n + " завершена");
                return sum;
            });
        }

        // 3. Отправляем все задачи и получаем список Future
        List<Future<Integer>> results = executor.invokeAll(tasks);

        // 4. Обрабатываем результаты
        for (Future<Integer> future : results) {
            try {
                Integer result = future.get();
                System.out.println("Результат: " + result);
            } catch (ExecutionException e) {
                System.out.println("Ошибка в задаче: " + e.getMessage());
            }
        }

        // 5. Завершаем Executor
        executor.shutdown();


        // -> Задача для 100 завершена
        // Задача для 200 завершена
        // Задача для 300 завершена
        // Результат: 5050
        // Результат: 20100
        // Результат: 45150
    }
}
```

_**Что делает `invokeAll()`?**_

- Принимает список задач (`List<Callable<T>>`)
- Запускает их параллельно
- Возвращает список `Future<T>` — по одному на каждую задачу

`invokeAll()` **ждёт**, пока все задачи завершатся — это удобно для пакетной
обработки.

invokeAny();

`invokeAny()` — это почти как `invokeAll()`, **но он ждёт только первую
успешно завершённую задачу**, и:

- Возвращает **только один результат**
- Остальные задачи **отменяются**
- Это удобно, когда нужно просто получить **первый доступный ответ**, а не все

**Пример: `invokeAny()` в действии**

```java
import java.util.concurrent.*;
import java.util.*;

public class InvokeAnyExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Список задач с разной задержкой
        List<Callable<String>> tasks = List.of(
                () -> {
                    Thread.sleep(3000);
                    return "Результат из задачи 1 (3 сек)";
                },
                () -> {
                    Thread.sleep(1000);
                    return "Результат из задачи 2 (1 сек)";
                },
                () -> {
                    Thread.sleep(2000);
                    return "Результат из задачи 3 (2 сек)";
                }
        );

        try {
            // invokeAny ждёт первую выполненную и возвращает её результат
            String fastestResult = executor.invokeAny(tasks);
            System.out.println("Самая быстрая задача вернула: " + fastestResult);
        } catch (ExecutionException e) {
            System.out.println("Ошибка при выполнении одной из задач: " + e.getMessage());
        }

        executor.shutdown();
    }
}
```

**Что произойдёт:**

- Все 3 задачи стартуют одновременно.
- Первая, которая закончится — это вторая (через 1 сек).
- `invokeAny()` сразу возвращает её результат.
- Остальные 2 задачи отменяются автоматически.

Если все задачи упадут с ошибкой — `invokeAny()` выбросит `ExecutionException`.

Вывод:

```
Самая быстрая задача вернула: Результат из задачи 2 (1 сек)
```

Такой подход полезен, например, при:

- Обращении к нескольким серверам — взять ответ того, кто быстрее
- Поиске в разных источниках
- Параллельных попытках — "кто первый, тот и молодец"

## Асинхронные задачи

**Асинхронные задачи** — это задачи, которые выполняются независимо от основного
потока выполнения программы. Это означает, что основной поток может продолжать
свою работу, не дожидаясь завершения асинхронной задачи. Асинхронное выполнение
позволяет улучшить отзывчивость приложений, особенно в тех случаях, когда
требуется выполнение длительных операций, таких как сетевые запросы, операции
ввода-вывода или сложные вычисления. Асинхронные задачи могут выполняться в
фоновом режиме, позволяя основному потоку продолжать выполнение других операций.
После завершения асинхронной задачи можно обработать результаты выполнения. В
Java для этого часто используются объекты`Future` и `Callable`, которые
позволяют получить результат выполнения задачи или обработать исключения.
Асинхронные задачи могут быть настроены на выполнение с тайм-аутами или отменой,
что позволяет избежать зависания приложения при выполнении долгих операций.

### Callable

`Callable` — это функциональный интерфейс в Java, представляющий собой
задачу, которая может быть выполнена асинхронно и возвращает результат. Он
является частью пакета `java.util.concurrent` и часто используется в сочетании с
`ExecutorService` для выполнения задач в фоновом режиме.

В отличие от интерфейса `Runnable`, который не
возвращает результат (метод `run()` имеет тип `void`), метод `call()`
интерфейса `Callable` возвращает значение. Это позволяет получать результат
выполнения задачи.

Метод `call()` может выбрасывать проверяемые
исключения (checked exceptions), что позволяет обрабатывать ошибки,
возникающие во время выполнения задачи. В случае с `Runnable`, все исключения
должны обрабатываться внутри метода `run()`.

Когда задача, реализующая интерфейс `Callable`,
отправляется на выполнение через `ExecutorService`, она возвращает объект
типа `Future`. Этот объект позволяет проверять статус выполнения задачи и
получать результат после ее завершения.

## Задачи и потоки

Задачи и потоки в контексте многопоточности в Java тесно связаны между собой,
поскольку задачи представляют собой единицы работы, которые выполняются в
потоках.

### 1. **Определение потоков и задач**

- **Поток**: Поток — это отдельная последовательность выполнения в программе.
  Каждый поток имеет свой собственный стек вызовов и может выполняться
  параллельно с другими потоками. В Java потоки создаются с помощью класса
  `Thread` или через интерфейсы, такие как `Runnable` и `Callable`.

- **Задача**: Задача — это конкретная работа или операция, которую нужно
  выполнить. В Java задачи могут быть реализованы через интерфейсы `Runnable` (
  для задач без результата) и `Callable` (для задач с результатом).

### 2. **Выполнение задач в потоках**

Когда вы отправляете задачу на выполнение в `ExecutorService`, она будет
выполнена в одном из потоков пула потоков. Вот как это работает:

- **Создание пула потоков**: При создании экземпляра `ExecutorService`, вы
  определяете пул потоков, который будет использоваться для выполнения задач.
  Например, с помощью метода `Executors.newFixedThreadPool(n)` создается пул из
  `n` потоков.

- **Отправка задач**: Когда вы отправляете задачу на выполнение (например, через
  метод `submit()`), `ExecutorService` выбирает один из доступных потоков из
  пула для выполнения этой задачи.

- **Асинхронное выполнение**: Задачи могут выполняться асинхронно, что означает,
  что основной поток программы может продолжать выполнение других операций, не
  дожидаясь завершения задачи.

### 3. **Параллелизм и многопоточность**

Использование задач и потоков позволяет реализовать параллелизм:

- **Параллельное выполнение**: Если у вас есть несколько задач, которые могут
  выполняться одновременно (например, обработка данных или выполнение сетевых
  запросов), вы можете отправить их на выполнение в пул потоков. Пул будет
  распределять задачи между доступными потоками, что позволяет выполнять их
  параллельно.

- **Управление ресурсами**: Пулы потоков помогают управлять ресурсами более
  эффективно. Вместо создания нового потока для каждой задачи (что может быть
  затратным по времени и ресурсам), вы можете повторно использовать существующие
  потоки для выполнения новых задач.

## Future

`Future<V>` — это объект, который представляет результат асинхронной операции. С
его помощью можно:

- Получить результат задачи.
- Проверить, завершена ли она.
- Отменить её выполнение.

### Пример работы с `Future`:

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        Callable<String> task = () -> {
            Thread.sleep(2000);
            return "Готово!";
        };

        Future<String> future = executor.submit(task);
        // Можно делать что-то другое пока задача выполняется...

        if (!future.isDone()) {
            System.out.println("Задача еще выполняется...");
        }

        String result = future.get(); // блокирует поток до завершения 
        // блокирует вызывающий поток, пока результат не будет готов.
        System.out.println("Результат: " + result);
    }
}

```

### Почему `ExecutorService` лучше, чем `Thread`?

| Функция / Особенность      | `Thread` вручную        | `ExecutorService`                         |
|----------------------------|-------------------------|-------------------------------------------|
| Масштабируемость           | ручное управление       | пулы потоков, динамическое распределение  |
| Повторное использование    | каждый поток — новый    | потоки переиспользуются                   |
| Управление задачами        | нет возврата результата | через `Future`, отмена задач              |
| Исключения                 | сложно обрабатывать     | логируются/обрабатываются через `Future`  |
| Контроль завершения работы | нет                     | `shutdown()`, `awaitTermination()` и т.д. |



Объект `Future`, возвращаемый интерфейсом `Callable` в Java, представляет собой
результат асинхронной операции. Он предоставляет методы для проверки состояния
выполнения задачи, получения результата и обработки возможных исключений,
которые могут возникнуть во время выполнения задачи. Давайте рассмотрим основные
аспекты объекта `Future` более подробно.

#### Основные характеристики объекта `Future`

1. **Асинхронный результат**: Объект `Future` позволяет вам получить результат
   выполнения задачи, которая была отправлена на выполнение в пул потоков или
   другой механизм многопоточности. Поскольку задача выполняется асинхронно, вы
   можете продолжать выполнение других операций в основном потоке, не дожидаясь
   завершения задачи.

2. **Методы для управления состоянием**:
    - `isDone()`: Возвращает `true`, если задача завершена (независимо от того,
      была ли она выполнена успешно или завершилась с ошибкой).
    - `isCancelled()`: Возвращает `true`, если задача была отменена до ее
      завершения.
    - `cancel(boolean mayInterruptIfRunning)`: Пытается отменить выполнение
      задачи. Если задача уже выполняется и параметр `mayInterruptIfRunning`
      равен `true`, то выполнение задачи может быть прервано.

3. **Получение результата**:
    - `get()`: Блокирует текущий поток до тех пор, пока задача не завершится, и
      возвращает результат выполнения задачи. Если задача завершилась с
      исключением, метод `get()` выбросит это исключение.
    - `get(long timeout, TimeUnit unit)`: Блокирует текущий поток до тех пор,
      пока задача не завершится или не истечет указанный таймаут.

#### Пример использования объекта Future

Вот пример кода, который демонстрирует использование интерфейса `Callable` и
объекта `Future`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Определяем задачу Callable
        Callable<Integer> task = () -> {
            // Имитация длительной операции
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует текущий поток до получения результата
            System.out.println("Результат: " + result);
        } catch (InterruptedException e) {
            System.err.println("Задача была прервана");
        } catch (ExecutionException e) {
            System.err.println("Ошибка при выполнении задачи: " + e.getCause());
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу типа `Callable`, которая
   имитирует длительную операцию (например, задержку на 2 секунды) и возвращает
   значение 42.

3. **Отправка задачи**: Мы отправляем задачу на выполнение через метод
   `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы вызываем метод `get()` у объекта `Future`, чтобы
   получить результат выполнения задачи. Этот вызов блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения:
    - `InterruptedException`: Выбрасывается, если текущий поток был прерван во
      время ожидания результата.
    - `ExecutionException`: Выбрасывается, если задача завершилась с ошибкой; в
      этом случае мы можем получить причину ошибки через метод `getCause()`.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

### Заключение

Объект `Future` является важным компонентом многопоточного программирования в
Java, позволяя управлять асинхронными задачами и получать результаты их
выполнения. Он предоставляет удобные методы для проверки состояния задач и
обработки результатов или ошибок, что делает его полезным инструментом для
работы с параллельными вычислениями.

## Реализации ExecutorService

ThreadPoolExecutor
ScheduledThreadPoolExecutor
CachedThreadPoolExecutor
ForkJoinPool

#### **ThreadPoolExecutor**

ThreadPoolExecutor – это реализация интерфейса ExecutorService в Java, который
предоставляет пул потоков исполнения для выполнения задач в фоновом режиме.

ThreadPoolExecutor позволяет создать и настроить пул потоков исполнения с
определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения задач в фоновом режиме, что может улучшить
производительность и реактивность вашего приложения.

#### **ScheduledThreadPoolExecutor**

ScheduledThreadPoolExecutor – это реализация интерфейса ScheduledExecutorService
в Java, который предоставляет пул потоков исполнения для выполнения задач в
определенный момент времени или с определенной периодичностью.

ScheduledThreadPoolExecutor позволяет создать и настроить пул потоков исполнения
с определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения регулярных задач в фоновом режиме, что может
улучшить производительность и реактивность вашего приложения.

#### **CachedThreadPoolExecutor**

CachedThreadPoolExecutor – это реализация интерфейса ExecutorService в Java,
который предоставляет пул потоков исполнения для выполнения задач в фоновом
режиме.

CachedThreadPoolExecutor автоматически масштабирует количество потоков
исполнения в зависимости от количества задач, которые нужно выполнить. Если
задачи поступают слишком быстро и текущее количество потоков исполнения не может
справиться с ними, CachedThreadPoolExecutor создает новый поток исполнения,
чтобы обеспечить выполнение задачи. Если задачи не поступают достаточно быстро и
текущее количество потоков исполнения избыточно, CachedThreadPoolExecutor
автоматически удаляет потоки исполнения, чтобы уменьшить нагрузку на систему.

#### **ForkJoinPool**

ForkJoinPool – это реализация ExecutorService в Java, которая используется для
параллельного выполнения задач. Эти задачи могут быть разбиты на более мелкие
подзадачи. Она позволяет использовать принцип “разделяй и властвуй” для более
эффективного использования многопроцессорных и многопоточных систем.

_**Основные компоненты ForkJoinPool:**_

**Пул потоков исполнения**

ForkJoinPool управляет пулом потоков исполнения, которые используются для
выполнения задач. Количество потоков исполнения в пуле задается при создании
экземпляра ForkJoinPool. Каждый поток в пуле имеет свой собственный стек
вызовов, что позволяет ForkJoinPool улучшить производительность в случае, когда
задачи могут быть разбиты на более мелкие подзадачи.

**Разбиение и объединение задач:**

ForkJoinPool поддерживает работу с задачами типа RecursiveAction и
RecursiveTask, которые представляют собой рекурсивно делимые задачи без
возвращаемого значения и с возвращаемым значением соответственно. Когда
ForkJoinPool получает задачу типа RecursiveTask, он разбивает ее на более мелкие
подзадачи, выполняет их параллельно в разных потоках и объединяет результаты
выполнения в единую итоговую задачу.


