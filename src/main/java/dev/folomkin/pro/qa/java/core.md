# Управление памятью в JAVA.

# Устройство памяти

В Java память управляется автоматически с помощью **сборщика мусора** (Garbage
Collector), что отличает её от языков, где требуется ручное управление памятью (
например, C++). Устройство памяти в Java делится на несколько основных областей,
которые используются JVM (Java Virtual Machine) для выполнения программы.
Рассмотрим их подробно:

### 1. **Общая структура памяти JVM**

JVM делит память на несколько областей:

- **Heap (Куча)**: Хранит объекты и их данные.
- **Stack (Стек)**: Используется для хранения локальных переменных и стеков
  вызовов методов.
- **Method Area (Область методов)**: Хранит метаданные классов, статические
  переменные и код методов.
- **PC Register (Регистр программного счётчика)**: Содержит адрес текущей
  инструкции для каждого потока.
- **Native Method Stack (Стек нативных методов)**: Используется для выполнения
  нативного кода (например, через JNI).

### 2. **Heap (Куча)**

- **Основное назначение**: Хранит все объекты, созданные с помощью `new`,
  включая экземпляры классов и массивы.
- **Структура кучи**:
    - **Young Generation (Молодое поколение)**:
        - **Eden**: Сюда изначально помещаются новые объекты.
        - **Survivor Spaces (S0 и S1)**: Объекты, пережившие сборку мусора,
          перемещаются сюда.
    - **Old Generation (Старое поколение)**: Хранит долгоживущие объекты.
    - **Permanent Generation (до Java 8) / Metaspace (с Java 8)**: Хранит
      метаданные классов и строки из строкового пула (в Java 7+ строки
      перемещены в кучу).
- **Сборка мусора**:
    - Молодое поколение очищается чаще (Minor GC), так как многие объекты "
      живут" недолго.
    - Старое поколение очищается реже (Major GC или Full GC), так как там
      находятся долгоживущие объекты.
    - Алгоритмы сборки мусора: Mark-and-Sweep, G1, ZGC, Shenandoah (в
      зависимости от версии JVM).

### 3. **Stack (Стек)**

- **Назначение**: Хранит локальные переменные, ссылки на объекты и информацию о
  вызовах методов (каждый поток имеет свой стек).
- **Структура**:
    - Каждый вызов метода создаёт **фрейм** (frame) в стеке.
    - Фрейм содержит:
        - Локальные переменные метода.
        - Операндовый стек для промежуточных вычислений.
        - Ссылку на текущий метод и класс.
- **Особенности**:
    - Стек работает по принципу LIFO (Last In, First Out).
    - Если стек переполняется (например, при глубокой рекурсии), возникает
      `StackOverflowError`.
    - Локальные переменные примитивных типов (`int`, `double` и т.д.) хранятся
      непосредственно в стеке, а ссылки на объекты указывают на кучу.

### 4. **Method Area (Область методов)**

- **Назначение**: Хранит:
    - Метаданные классов (структура, поля, методы).
    - Статические переменные.
    - Константный пул (константы, используемые классом).
- **Особенности**:
    - До Java 8 эта область была частью кучи и называлась Permanent Generation.
    - С Java 8 используется **Metaspace**, который выделяется в нативной памяти
      и может динамически расширяться.
    - Если Metaspace переполняется, возникает `OutOfMemoryError: Metaspace`.

### 5. **PC Register (Регистр программного счётчика)**

- **Назначение**: Хранит адрес текущей инструкции, выполняемой потоком.
- **Особенности**:
    - Каждый поток имеет свой регистр.
    - Используется JVM для управления выполнением байт-кода.

### 6. **Native Method Stack (Стек нативных методов)**

- **Назначение**: Хранит информацию о вызовах нативных методов (например,
  написанных на C/C++ через JNI).
- **Особенности**: Размер стека ограничен, переполнение вызывает
  `StackOverflowError`.

### 7. **Управление памятью**

- **Сборщик мусора**:
    - Отслеживает объекты, на которые больше нет ссылок, и освобождает память.
    - Основные алгоритмы: Serial GC, Parallel GC, G1 (по умолчанию с Java 9),
      ZGC, Shenandoah.
- **Ключевые особенности**:
    - Java не позволяет вручную освобождать память (нет аналога `free` или
      `delete`).
    - Вы можете лишь "предложить" сборку мусора через `System.gc()`, но JVM не
      гарантирует её выполнение.
    - Для оптимизации работы с памятью используются пулы объектов, кэширование и
      другие техники.

### 8. **Типичные ошибки, связанные с памятью**

- **OutOfMemoryError**:
    - `Java heap space`: Недостаточно памяти в куче.
    - `Metaspace`: Переполнение области метаданных.
- **StackOverflowError**: Переполнение стека, обычно из-за глубокой рекурсии.
- **Memory Leak**: Утечки памяти из-за удержания ссылок на ненужные объекты (
  например, в коллекциях).

### 9. **Оптимизация памяти**

- Используйте правильные коллекции (например, `ArrayList` вместо `LinkedList`
  для быстрого доступа).
- Избегайте хранения ненужных ссылок в статических полях.
- Настраивайте параметры JVM (например, `-Xms`, `-Xmx` для кучи,
  `-XX:MaxMetaspaceSize` для Metaspace).
- Используйте инструменты профилирования (VisualVM, JProfiler) для анализа
  использования памяти.

### Пример

```java
public class MemoryExample {
    public static void main(String[] args) {
        // Объект создаётся в куче (Eden), ссылка myObj в стеке
        MyClass myObj = new MyClass();
        // Локальная переменная i хранится в стеке
        int i = 10;
        // Статическая переменная хранится в Metaspace
        MyClass.staticField = 20;
    }
}

class MyClass {
    static int staticField; // В Metaspace
    int instanceField; // В куче
}
```

### Заключение

Устройство памяти в Java организовано так, чтобы разработчик мог сосредоточиться
на логике программы, а JVM автоматически управляет памятью. Куча и стек —
основные области, где хранятся данные, а сборщик мусора минимизирует утечки
памяти. Понимание структуры памяти помогает оптимизировать производительность и
избегать ошибок вроде `OutOfMemoryError`.


--------------

## Heap. Young Generation (Молодое поколение). Old Generation (Старое поколение)

В Java **Heap (Куча)** делится на несколько областей, из которых **Young
Generation** (Молодое поколение) и **Old Generation** (Старое поколение) играют
ключевую роль в управлении памятью и работе сборщика мусора (Garbage Collector,
GC). Рассмотрим их подробнее.

### 1. **Young Generation (Молодое поколение)**

Молодое поколение — это область кучи, где создаются новые объекты и происходит
их начальная обработка сборщиком мусора. Оно оптимизировано для работы с
объектами, которые обычно имеют короткий жизненный цикл (быстро создаются и
уничтожаются).

#### Структура Young Generation

Молодое поколение делится на три подобласти:

- **Eden**:
    - Все новые объекты, созданные с помощью `new`, изначально размещаются
      здесь.
    - Это самая большая часть Young Generation.
    - Большинство объектов в Eden "живут" недолго и быстро становятся
      недостижимыми (например, временные объекты в методах).
- **Survivor Spaces (S0 и S1)**:
    - Два небольших пространства, называемые **From** и **To**, используются для
      хранения объектов, переживших хотя бы одну сборку мусора.
    - После сборки мусора в Eden живые объекты перемещаются в один из Survivor
      Spaces (например, S0).
    - При следующей сборке мусора объекты из S0 (если они всё ещё живы)
      перемещаются в S1, и наоборот.
    - Объекты, которые переживают несколько циклов сборки мусора (обычно 15, в
      зависимости от настройки JVM), перемещаются в **Old Generation**.

#### Работа сборщика мусора в Young Generation

- **Minor GC**: Процесс сборки мусора в Young Generation.
    - Быстрый, так как область относительно небольшая.
    - Удаляет недостижимые объекты из Eden и Survivor Spaces.
    - Живые объекты перемещаются между Survivor Spaces или в Old Generation (
      если они "достаточно старые").
- Алгоритмы: Обычно используется **Copying Collector** (копирующий сборщик
  мусора), который копирует живые объекты из Eden и одного Survivor Space в
  другой Survivor Space, минимизируя фрагментацию.

#### Особенности

- Размер Young Generation обычно меньше, чем Old Generation, но сборка мусора
  здесь происходит чаще.
- Параметры JVM, такие как `-Xmn`, позволяют настраивать размер Young
  Generation.
- Оптимизировано для объектов с коротким жизненным циклом, что соответствует
  принципу "большинство объектов умирают молодыми".

### 2. **Old Generation (Старое поколение)**

Старое поколение — это область кучи, предназначенная для хранения долгоживущих
объектов, которые пережили несколько циклов сборки мусора в Young Generation.

#### Характеристики

- **Назначение**: Хранит объекты, которые используются в течение длительного
  времени (например, объекты конфигурации, кэши, пулы соединений).
- **Размер**: Обычно значительно больше, чем Young Generation, так как
  долгоживущие объекты накапливаются.
- **Сборка мусора**:
    - Процесс называется **Major GC** или **Full GC** (если затрагивает всю
      кучу).
    - Выполняется реже, чем Minor GC, но занимает больше времени, так как
      область больше и алгоритмы сложнее.
    - Используются алгоритмы, такие как **Mark-and-Sweep-Compact** (в старых
      версиях JVM) или более современные, например **G1** или **ZGC**, которые
      минимизируют паузы.
- **Проблемы**:
    - Переполнение Old Generation вызывает `OutOfMemoryError: Java heap space`.
    - Утечки памяти (например, из-за неправильно управляемых коллекций) часто
      проявляются в Old Generation.

#### Перемещение объектов

- Объекты попадают в Old Generation, если они пережили заданное количество
  циклов Minor GC (параметр `-XX:MaxTenuringThreshold`, по умолчанию 15).
- Некоторые объекты (например, очень большие) могут создаваться сразу в Old
  Generation, минуя Young Generation, если их размер превышает определённый
  порог.

### 3. **Ключевые различия**

| **Характеристика**   | **Young Generation**                    | **Old Generation**                      |
|----------------------|-----------------------------------------|-----------------------------------------|
| **Назначение**       | Хранение новых и краткоживущих объектов | Хранение долгоживущих объектов          |
| **Подобласти**       | Eden, Survivor Spaces (S0, S1)          | Единая область                          |
| **Сборка мусора**    | Minor GC (быстрая)                      | Major/Full GC (медленная)               |
| **Алгоритмы**        | Copying Collector                       | Mark-and-Sweep, G1, ZGC и др.           |
| **Размер**           | Меньше, настраивается через `-Xmn`      | Больше, зависит от `-Xmx`               |
| **Частота GC**       | Часто                                   | Редко                                   |
| **Типичные объекты** | Временные объекты, локальные переменные | Кэши, пулы, глобальные структуры данных |

### 4. **Пример работы**

```java
public class Example {
    public static void main(String[] args) {
        // Создаётся в Eden
        Object temp = new Object();
        // Локальная переменная temp перестанет существовать после выхода из метода
        // и будет удалена при Minor GC

        // Объект, который может попасть в Old Generation
        static List<Object> cache = new ArrayList<>();
        cache.add(new Object()); // Этот объект может пережить несколько GC и попасть в Old Generation
    }
}
```

- Объект `temp` создаётся в Eden и, скорее всего, будет удалён при следующем
  Minor GC.
- Объект в `cache` может переместиться в Survivor Space, а затем в Old
  Generation, если останется достижимым.

### 5. **Оптимизация**

- **Young Generation**:
    - Увеличение размера Eden (`-XX:NewSize`, `-XX:MaxNewSize`) может уменьшить
      частоту Minor GC, но увеличивает паузы.
    - Настройка соотношения Eden и Survivor Spaces (`-XX:SurvivorRatio`)
      помогает балансировать производительность.
- **Old Generation**:
    - Используйте современные сборщики мусора (G1, ZGC) для минимизации пауз.
    - Избегайте утечек памяти, очищая коллекции и слабые ссылки (
      `WeakReference`, `SoftReference`).
    - Настройте максимальный размер кучи (`-Xmx`) для поддержки долгоживущих
      объектов.

### 6. **Заключение**

Young Generation и Old Generation — это ключевые области кучи, которые разделяют
объекты по их "возрасту" и жизненному циклу. Young Generation оптимизирован для
быстрого создания и удаления объектов, а Old Generation — для хранения
долгоживущих данных. Понимание их работы помогает оптимизировать
производительность Java-приложений и эффективно управлять памятью.

Если нужно углубиться в конкретный аспект (например, алгоритмы GC или настройка
параметров JVM), дайте знать!


==========================================================
---------------------------------------------------------

# Сборка мусора. CG Root

Сборка мусора (Garbage Collection, GC) в Java — это автоматический процесс
управления памятью, который освобождает память, занятую объектами, на которые
больше нет ссылок. JVM (Java Virtual Machine) использует сборщик мусора для
предотвращения утечек памяти и упрощения работы разработчика. В этом ответе я
расскажу о сборке мусора в Java, её механизмах, а также подробно объясню, что
такое **Garbage Collector Roots** (корни сборщика мусора).

---

### 1. **Сборка мусора в Java: Основы**

Сборка мусора в Java основана на принципе: если объект недостижим (на него нет
активных ссылок из программы), он считается "мусором" и может быть удалён.
Основные задачи сборщика мусора:

- Определение недостижимых объектов.
- Освобождение памяти, занятой этими объектами.
- Устранение фрагментации памяти (в некоторых алгоритмах).

#### Процесс сборки мусора

1. **Mark (Пометка)**: Сборщик мусора идентифицирует, какие объекты всё ещё
   достижимы, начиная с корней (Garbage Collector Roots).
2. **Sweep (Очистка)**: Удаляет недостижимые объекты, освобождая память.
3. **Compact (Уплотнение, опционально)**: Перемещает оставшиеся объекты, чтобы
   уменьшить фрагментацию (используется в некоторых алгоритмах, например,
   Mark-and-Sweep-Compact).
4. **Copy (Копирование, в Young Generation)**: В Молодом поколении живые объекты
   копируются из одной области (например, Eden) в другую (Survivor Space),
   минимизируя фрагментацию.

#### Области памяти, где работает GC

Сборка мусора происходит в основном в **Heap (Куче)**, которая делится на:

- **Young Generation** (Eden + Survivor Spaces): Для краткоживущих объектов,
  очищается с помощью **Minor GC**.
- **Old Generation**: Для долгоживущих объектов, очищается с помощью **Major GC
  ** или **Full GC** (затрагивает всю кучу).
- **Metaspace** (с Java 8): Хранит метаданные классов, очищается отдельно.

#### Типы сборщиков мусора

JVM предоставляет несколько реализаций сборщика мусора, каждая из которых
подходит для разных сценариев:

1. **Serial GC**: Однопоточный, для небольших приложений.
2. **Parallel GC**: Многопоточный, для высокой пропускной способности.
3. **CMS (Concurrent Mark-Sweep)**: Минимизирует паузы, но устарел с Java 9.
4. **G1 (Garbage-First)**: Баланс между паузами и пропускной способностью,
   используется по умолчанию с Java 9.
5. **ZGC** и **Shenandoah**: Современные сборщики с низкими паузами для больших
   объёмов памяти (доступны с Java 11+).

---

### 2. **Garbage Collector Roots (Корни сборщика мусора)**

**Garbage Collector Roots** — это отправные точки, с которых сборщик мусора
начинает поиск достижимых объектов. Корни представляют собой ссылки, от которых
можно "добраться" до объектов в памяти. Если объект не связан с корнем ни одной
цепочкой ссылок, он считается недостижимым и подлежит удалению.

#### Что является GC Root?

GC Roots — это объекты или ссылки, которые гарантированно "живы" в контексте
программы. Основные типы корней:

1. **Локальные переменные в стеке**:
    - Переменные, находящиеся в стеке текущего метода (например, параметры
      метода или локальные переменные).
    - Пример: `Object obj = new Object();` — `obj` в стеке является GC Root.
2. **Статические переменные**:
    - Статические поля классов, хранящиеся в Metaspace.
    - Пример: `static List<Object> cache = new ArrayList<>();` — `cache`
      является GC Root.
3. **Активные потоки (Threads)**:
    - Все запущенные потоки (объекты `Thread`) считаются корнями, так как они
      активны.
    - Ссылки из стека вызовов потока также являются корнями.
4. **Классы, загруженные ClassLoader'ом**:
    - Объекты классов, загруженные активным загрузчиком классов (например,
      системным ClassLoader'ом).
    - Это включает метаданные классов и их статические поля.
5. **Ссылки из нативного кода (JNI)**:
    - Объекты, на которые ссылаются из нативного кода через Java Native
      Interface (JNI).
6. **Синхронизационные мониторы**:
    - Объекты, используемые в блоках `synchronized`, пока они заблокированы.
7. **Ссылки JVM**:
    - Специальные объекты, которые JVM удерживает для своих внутренних нужд (
      например, строки в строковом пуле до Java 7 или системные объекты).

#### Как GC использует корни?

1. **Поиск достижимых объектов**:
    - Сборщик мусора начинает с GC Roots и рекурсивно обходит все ссылки (граф
      объектов).
    - Объекты, до которых можно добраться от корней, помечаются как "живые".
    - Объекты, не связанные с корнями, считаются "мусором".
2. **Пример**:
   ```java
   public class GCRootExample {
       static Object staticObj = new Object(); // GC Root (статическая переменная)
       public static void main(String[] args) {
           Object localObj = new Object(); // GC Root (локальная переменная в стеке)
           List<Object> list = new ArrayList<>(); // list — GC Root
           list.add(new Object()); // Объект в списке достижим через list
           localObj = null; // Объект, на который указывал localObj, теперь недостижим
       }
   }
   ```
    - `staticObj` — GC Root, объект, на который он ссылается, останется живым.
    - `localObj` — GC Root, пока метод `main` выполняется. После присваивания
      `null` объект становится недостижимым и может быть удалён.
    - Объект в `list` остаётся достижимым, так как `list` — GC Root.

#### Роль GC Roots в сборке мусора

- GC Roots определяют, какие объекты "живы". Без корней сборщик мусора не смог
  бы понять, что можно удалить.
- Неправильное управление корнями (например, хранение ссылок в статических
  полях) может привести к утечкам памяти, так как объекты остаются достижимыми.

---

### 3. **Ключевые особенности сборки мусора**

- **Автоматичность**: Разработчик не управляет памятью вручную (нет `free` или
  `delete`).
- **Паузы (Stop-the-World)**: Во время сборки мусора (особенно Major GC)
  выполнение программы может приостанавливаться. Современные сборщики (ZGC,
  Shenandoah) минимизируют такие паузы.
- **Типы сборок**:
    - **Minor GC**: Очистка Young Generation, быстрая.
    - **Major/Full GC**: Очистка Old Generation или всей кучи, более
      ресурсоёмкая.
- **Настройка**:
    - Параметры JVM, такие как `-Xms`, `-Xmx`, `-XX:NewRatio`,
      `-XX:MaxTenuringThreshold`, позволяют настраивать поведение GC.
    - Выбор сборщика: `-XX:+UseG1GC`, `-XX:+UseZGC` и т.д.

---

### 4. **Проблемы и оптимизация**

- **Утечки памяти**:
    - Возникают, если объекты остаются достижимыми через GC Roots (например,
      статические коллекции).
    - Решение: Используйте слабые ссылки (`WeakReference`, `SoftReference`) или
      очищайте коллекции.
- **Долгие паузы**:
    - Major GC может вызывать заметные задержки. Современные сборщики (G1, ZGC)
      решают эту проблему.
- **Мониторинг**:
    - Используйте инструменты вроде VisualVM, JProfiler или параметры JVM (
      `-Xlog:gc`) для анализа работы GC.
- **Оптимизация**:
    - Уменьшайте создание ненужных объектов.
    - Настраивайте размеры Young и Old Generation.
    - Выбирайте подходящий сборщик мусора для вашего приложения.

---

### 5. **Заключение**

Сборка мусора в Java — это мощный механизм, который автоматизирует управление
памятью, освобождая разработчика от ручной работы. **GC Roots** играют
центральную роль, определяя, какие объекты остаются в памяти. Понимание корней и
их влияния на достижимость объектов помогает избегать утечек памяти и
оптимизировать производительность. Различные сборщики мусора (G1, ZGC и др.)
предоставляют гибкость для разных сценариев использования, от небольших
приложений до высоконагруженных серверов.

Если хотите углубиться в конкретный алгоритм (например, G1 или ZGC) или примеры
утечек памяти, дайте знать!

---------- 

## Алгоритмы сборки мусора G1 и ZGC

В Java сборка мусора (Garbage Collection, GC) — ключевой механизм управления
памятью, а **G1 (Garbage-First)** и **ZGC (Z Garbage Collector)** — два
современных сборщика мусора, разработанных для повышения производительности и
минимизации пауз. Они подходят для разных сценариев: G1 балансирует пропускную
способность и паузы, а ZGC ориентирован на сверхнизкие задержки для больших
объёмов памяти. Рассмотрим их подробнее.

---

### 1. **G1 (Garbage-First)**

G1 — это сборщик мусора, представленный в Java 7 и ставший сборщиком по
умолчанию в Java 9. Он разработан для приложений с большими объемами памяти (от
нескольких ГБ) и ориентирован на баланс между пропускной способностью и
предсказуемыми паузами.

#### Основные особенности G1

- **Региональная структура кучи**:
    - G1 делит кучу на множество небольших регионов (обычно 1–32 МБ), которые
      могут быть частью Young Generation (Eden, Survivor) или Old Generation.
    - Регионы не обязаны быть смежными, что позволяет гибко управлять памятью.
- **Приоритетная очистка**:
    - G1 фокусируется на регионах с наибольшим количеством "мусора" (отсюда
      название Garbage-First), что повышает эффективность очистки.
- **Смешанная сборка (Mixed GC)**:
    - G1 выполняет как **Minor GC** (очистка Young Generation), так и **Mixed GC
      ** (очистка Young и части Old Generation).
    - Mixed GC позволяет постепенно очищать Old Generation, избегая длительных
      Full GC.
- **Параллельность и конкурентность**:
    - G1 использует несколько потоков для ускорения фазы пометки (Mark) и
      очистки (Sweep).
    - Некоторые этапы (например, пометка живых объектов) выполняются конкурентно
      с приложением, минимизируя паузы.
- **Stop-the-World (STW)**:
    - G1 использует STW-паузы для определённых операций, но они короче, чем у
      старых сборщиков (например, CMS).
    - Целевое время пауз можно настроить с помощью параметра
      `-XX:MaxGCPauseMillis` (по умолчанию 200 мс).

#### Как работает G1

1. **Инициализация**:
    - Куча делится на регионы, каждый из которых может быть Eden, Survivor, Old
      или свободным.
    - Новые объекты создаются в регионах Eden.
2. **Minor GC**:
    - Очищает Young Generation (Eden и Survivor).
    - Живые объекты копируются в новые регионы Survivor или перемещаются в Old
      Generation, если они достаточно "старые".
3. **Concurrent Marking**:
    - G1 конкурентно помечает достижимые объекты, начиная с GC Roots.
    - Определяет регионы с наибольшим количеством мусора.
4. **Mixed GC**:
    - Очищает как Young Generation, так и выбранные регионы Old Generation.
    - Выбираются регионы, где очистка даст наибольшую выгоду (много мусора, мало
      живых объектов).
5. **Full GC**:
    - Происходит редко, если G1 не успевает очищать Old Generation или куча
      переполняется.
    - Это STW-событие, которое G1 старается избегать.

#### Преимущества G1

- Эффективное управление большими кучами (от 4 ГБ и выше).
- Предсказуемые паузы за счёт настройки целевого времени пауз.
- Постепенная очистка Old Generation, что снижает вероятность Full GC.
- Автоматическая адаптация под нагрузку приложения.

#### Недостатки G1

- Более высокая нагрузка на процессор из-за конкурентных операций.
- Меньшая пропускная способность по сравнению с Parallel GC в некоторых
  сценариях.
- Full GC всё ещё возможен при высоких нагрузках или неправильной настройке.

#### Настройка G1

- `-XX:+UseG1GC`: Включение G1.
- `-XX:MaxGCPauseMillis`: Установка целевого времени паузы (например,
  `-XX:MaxGCPauseMillis=100`).
- `-XX:G1HeapRegionSize`: Размер региона кучи (по умолчанию выбирается
  автоматически).
- `-XX:InitiatingHeapOccupancyPercent`: Порог заполнения Old Generation для
  начала Concurrent Marking (по умолчанию 45%).

#### Когда использовать G1

- Приложения, требующие низких и предсказуемых пауз (например, веб-серверы).
- Большие кучи (4 ГБ и выше).
- Если требуется баланс между паузами и производительностью.

---

### 2. **ZGC (Z Garbage Collector)**

ZGC — это современный сборщик мусора, представленный в Java 11 (
экспериментально) и ставший полностью стабильным в Java 15. Он разработан для
приложений с очень большими кучами (до терабайт) и минимальными паузами (обычно
менее 10 мс), что делает его идеальным для высоконагруженных систем, где
задержки критичны.

#### Основные особенности ZGC

- **Низкие паузы**:
    - ZGC обеспечивает паузы менее 10 мс, независимо от размера кучи.
    - Большинство операций (пометка, перемещение объектов) выполняются
      конкурентно с приложением.
- **Colored Pointers**:
    - ZGC использует "цветные указатели" (colored pointers), где метаданные о
      состоянии объекта хранятся в самом указателе (в битах адреса).
    - Это позволяет отслеживать состояние объектов без дополнительных затрат
      памяти.
- **Load Barriers**:
    - ZGC использует барьеры чтения (load barriers) при доступе к объектам,
      чтобы обновлять ссылки в случае перемещения объектов.
- **Однопроходная сборка**:
    - В отличие от G1, ZGC не разделяет Young и Old Generation. Все объекты
      обрабатываются единообразно.
    - Это упрощает структуру кучи, но требует больше ресурсов для конкурентной
      работы.
- **Поддержка больших куч**:
    - ZGC эффективен для куч от нескольких ГБ до терабайт.
- **Уплотнение памяти**:
    - ZGC автоматически перемещает живые объекты, устраняя фрагментацию, причём
      делает это конкурентно.

#### Как работает ZGC

1. **Инициализация**:
    - Куча делится на регионы, как в G1, но без явного разделения на Young и Old
      Generation.
    - Новые объекты распределяются по регионам.
2. **Concurrent Marking**:
    - ZGC конкурентно помечает достижимые объекты, начиная с GC Roots, используя
      цветные указатели.
3. **Concurrent Relocation**:
    - ZGC перемещает живые объекты в новые регионы, устраняя фрагментацию.
    - Барьеры чтения обновляют ссылки на перемещённые объекты.
4. **Stop-the-World (STW)**:
    - Паузы минимальны и происходят только для синхронизации корней (GC Roots)
      или завершения некоторых операций.
    - Длительность пауз не зависит от размера кучи или количества объектов.

#### Преимущества ZGC

- Сверхнизкие паузы (<10 мс), подходящие для приложений с жёсткими требованиями
  к задержкам.
- Эффективная работа с большими кучами (до терабайт).
- Автоматическое устранение фрагментации без длительных STW-пауз.
- Простота настройки (ZGC требует минимальной конфигурации).

#### Недостатки ZGC

- Высокая нагрузка на процессор из-за конкурентных операций и барьеров чтения.
- Меньшая пропускная способность по сравнению с Parallel GC или G1 в некоторых
  сценариях.
- Требует 64-битной JVM и больше памяти для метаданных (цветные указатели).

#### Настройка ZGC

- `-XX:+UseZGC`: Включение ZGC.
- `-Xmx`: Установка максимального размера кучи (например, `-Xmx16g`).
- `-XX:ConcGCThreads`: Количество потоков для конкурентной работы (по умолчанию
  выбирается автоматически).
- `-XX:ZCollectionInterval`: Интервал между сборками (по умолчанию адаптивный).

#### Когда использовать ZGC

- Приложения с жёсткими требованиями к задержкам (например, финансовые системы,
  реал-тайм приложения).
- Очень большие кучи (десятки ГБ или терабайты).
- Системы, где важна стабильность времени отклика.

---

### 3. **Сравнение G1 и ZGC**

| **Характеристика**         | **G1**                                | **ZGC**                                        |
|----------------------------|---------------------------------------|------------------------------------------------|
| **Введён**                 | Java 7, по умолчанию с Java 9         | Java 11 (экспериментально), стабилен с Java 15 |
| **Паузы**                  | До 200 мс (настраиваемо)              | <10 мс, независимо от размера кучи             |
| **Структура кучи**         | Регионы, Young + Old Generation       | Регионы, без разделения на поколения           |
| **Сборка мусора**          | Minor GC, Mixed GC, Full GC           | Конкурентная сборка, минимальные STW           |
| **Фрагментация**           | Решается Mixed GC и Full GC           | Конкурентное уплотнение                        |
| **Пропускная способность** | Высокая, но ниже, чем у Parallel GC   | Ниже из-за барьеров чтения                     |
| **Подходит для**           | Средние/большие кучи, баланс пауз     | Большие кучи, минимальные задержки             |
| **Настройка**              | Много параметров для тонкой настройки | Минимальная настройка                          |

---

### 4. **Пример настройки**

Для приложения с кучей 16 ГБ и требованием пауз <100 мс:

- **G1**:
  ```bash
  java -XX:+UseG1GC -Xmx16g -XX:MaxGCPauseMillis=100 -jar app.jar
  ```
- **ZGC**:
  ```bash
  java -XX:+UseZGC -Xmx16g -jar app.jar
  ```

---

### 5. **Заключение**

- **G1** — универсальный выбор для большинства приложений с большими кучами, где
  требуется баланс между паузами и производительностью. Подходит для серверных
  приложений с умеренными требованиями к задержкам.
- **ZGC** — идеален для высоконагруженных систем с большими кучами, где
  критически важны минимальные паузы (например, реал-тайм системы или
  микросервисы).

Если нужно углубиться в конкретный сценарий использования, примеры настройки или
сравнение производительности, дайте знать!


==========================================================
---------------------------------------------------------

# String pool

**String Pool** (или **пул строк**) в Java — это специальная область памяти в
куче (Heap), предназначенная для хранения строковых литералов и интернированных
строк. Этот механизм оптимизирует использование памяти и повышает
производительность, так как строки являются одними из самых часто используемых
объектов в Java-программах. Давайте разберём, как работает String Pool, его
особенности и место в структуре памяти Java.

---

### 1. **Что такое String Pool?**

String Pool — это кэш строк, который хранит уникальные экземпляры строковых
объектов (`String`) в памяти. Основная цель:

- **Экономия памяти**: Повторно использует одинаковые строки вместо создания
  новых объектов.
- **Ускорение работы**: Сравнение строк с помощью `==` (на идентичность) для
  строк из пула быстрее, чем сравнение содержимого через `equals()`.

В Java строки неизменяемы (immutable), поэтому безопасно хранить их в пуле для
повторного использования.

---

### 2. **Где находится String Pool?**

- **До Java 7**:
    - String Pool находился в **Permanent Generation** (часть кучи, где хранятся
      метаданные классов и статические данные).
    - Это приводило к проблемам, так как Permanent Generation имела
      фиксированный размер, и переполнение пула строк могло вызвать
      `OutOfMemoryError: PermGen space`.
- **С Java 7 и выше**:
    - String Pool был перенесён в основную часть **Heap** (обычно в Young или
      Old Generation, в зависимости от "возраста" строк).
    - Это позволило лучше управлять памятью, так как куча динамически
      масштабируется (настраивается через `-Xmx`).
    - После Java 8 Permanent Generation заменён на **Metaspace**, который теперь
      хранит только метаданные классов, а не строки.

---

### 3. **Как работает String Pool?**

String Pool управляется JVM и содержит строки, созданные двумя основными
способами:

1. **Строковые литералы**:
    - Строки, заданные в коде напрямую, например: `String s = "Hello";`.
    - Такие строки автоматически помещаются в String Pool при загрузке класса.
    - Если строка с таким же содержимым уже есть в пуле, JVM возвращает ссылку
      на существующий объект вместо создания нового.
2. **Интернирование строк**:
    - Метод `String.intern()` позволяет вручную добавить строку в String Pool.
    - Если строка уже есть в пуле, возвращается ссылка на неё; если нет — строка
      добавляется в пул.

#### Пример:

```java
String s1 = "Hello"; // Создаётся в String Pool
String s2 = "Hello"; // Ссылается на тот же объект в String Pool
String s3 = new String("Hello"); // Создаётся новый объект в куче, НЕ в String Pool
String s4 = s3.intern(); // Помещает "Hello" в String Pool (или возвращает ссылку на существующий объект)

System.out.

println(s1 ==s2); // true (один и тот же объект в String Pool)
System.out.

println(s1 ==s3); // false (s3 — новый объект в куче)
System.out.

println(s1 ==s4); // true (s4 ссылается на объект в String Pool)
```

---

### 4. **Как строки попадают в String Pool?**

- **Литералы**: Все строковые литералы, объявленные в коде (например,
  `"Hello"`), автоматически добавляются в String Pool при загрузке класса.
- **Метод `intern()`**: Вызов `String.intern()` проверяет, есть ли строка в
  пуле. Если строка отсутствует, она добавляется; если есть — возвращается
  ссылка на неё.
- **Конкатенация констант**: Если строка создаётся путём конкатенации строковых
  литералов на этапе компиляции, она также помещается в String Pool. Например:
  ```java
  String s = "Hel" + "lo"; // "Hello" будет в String Pool
  ```
  Но если конкатенация происходит во время выполнения (например, с переменными),
  результат создаётся в куче, а не в пуле:
  ```java
  String prefix = "Hel";
  String s = prefix + "lo"; // Создаётся в куче, НЕ в String Pool
  ```

---

### 5. **Сборка мусора и String Pool**

- Строки в String Pool подлежат сборке мусора, если на них больше нет ссылок.
- **До Java 7**: Строки в Permanent Generation редко очищались, так как эта
  область нечасто подвергалась сборке мусора. Это могло привести к переполнению
  PermGen.
- **С Java 7**: Поскольку String Pool находится в куче, строки удаляются
  сборщиком мусора, как и другие объекты, если они становятся недостижимыми.
    - Строки, созданные как литералы, обычно остаются достижимыми через
      метаданные классов (ClassLoader), пока класс загружен.
    - Строки, добавленные через `intern()`, могут быть удалены, если на них нет
      ссылок.

---

### 6. **Особенности и ограничения**

- **Уникальность**: String Pool гарантирует, что для каждого уникального
  строкового значения существует только один объект в пуле.
- **Производительность**:
    - Использование String Pool снижает потребление памяти, так как одинаковые
      строки не дублируются.
    - Сравнение строк из пула с помощью `==` быстрее, чем `equals()`, но следует
      использовать `equals()` для сравнения содержимого, чтобы избежать ошибок.
- **Ограничения**:
    - Чрезмерное использование `intern()` может привести к переполнению кучи,
      особенно если создаётся много уникальных строк.
    - В старых версиях Java (до 7) переполнение String Pool вызывало
      `OutOfMemoryError: PermGen space`.

---

### 7. **Практические рекомендации**

- **Используйте литералы для констант**:
  ```java
  String s = "Hello"; // Эффективно, строка в String Pool
  ```
  Избегайте создания строк через `new String("Hello")`, так как это создаёт
  лишний объект в куче.
- **Осторожно с `intern()`**:
    - Используйте `intern()` только для строк, которые будут часто повторяться и
      использоваться долгое время.
    - Например, для обработки больших объёмов данных (парсинг, конфигурации).
- **Мониторинг памяти**:
    - Используйте инструменты (VisualVM, JProfiler) для анализа использования
      String Pool.
    - Настраивайте размер кучи (`-Xmx`) для больших приложений с интенсивным
      использованием строк.
- **Конкатенация**:
    - Для динамической конкатенации используйте `StringBuilder` или
      `StringBuffer`, чтобы избежать создания временных объектов в куче:
      ```java
      StringBuilder sb = new StringBuilder();
      sb.append("Hel").append("lo"); // Эффективно
      String result = sb.toString();
      ```

---

### 8. **Пример кода**

```java
public class StringPoolExample {
    public static void main(String[] args) {
        String literal1 = "Test"; // В String Pool
        String literal2 = "Test"; // Ссылается на тот же объект в String Pool
        String newString = new String("Test"); // В куче, вне String Pool
        String interned = newString.intern(); // Ссылается на объект в String Pool

        System.out.println(literal1 == literal2); // true (одинаковые объекты в String Pool)
        System.out.println(literal1 == newString); // false (newString в куче)
        System.out.println(literal1 == interned); // true (interned ссылается на String Pool)
        System.out.println(literal1.equals(newString)); // true (сравнение содержимого)
    }
}
```

---

### 9. **Заключение**

String Pool — это эффективный механизм в Java для оптимизации хранения строк,
который использует неизменяемость строк для повторного использования объектов. С
Java 7 он находится в куче, что упрощает управление памятью и делает его более
устойчивым к переполнению. Понимание работы String Pool помогает писать более
эффективный код, избегать лишнего потребления памяти и правильно использовать
методы вроде `intern()`.

Если нужно углубиться в конкретный аспект (например, производительность
`intern()` или анализ памяти), дайте знать!
======================================================
======================================================
======================================================
======================================================
======================================================
======================================================
======================================================

# Устройство памяти и сборка мусора

==============
---------------------------

### Основные области памяти в Java

Когда ты запускаешь Java-программу, память делится на несколько важных частей:

| Область           | Что хранится                                    |
|-------------------|-------------------------------------------------|
| **Heap (Куча)**   | Все объекты и данные, созданные с помощью `new` |
| **Stack (Стек)**  | Локальные переменные и вызовы методов           |
| **Метаспейс**     | Информация о классах (метаданные)               |
| **Code Cache**    | Скомпилированный код JIT-компилятора            |
| **Direct Memory** | Память вне куч (используется, например, NIO)    |

#### Heap (Куча)

- Самая большая область памяти.
- Управляется сборщиком мусора (**GC** — Garbage Collector).
- все **объекты** (`new` объекты, массивы),
- связанные с ними данные.

**Heap** — это общая память для всех потоков.  
Если переменная — это ссылка на объект, то сама ссылка хранится в стеке, а
объект — в куче.

_Как устроена куча?_

Heap делится на несколько областей:

```
Heap Memory
├── Young Generation
│    ├── Eden (сад новых объектов)
│    ├── Survivor 0 (выжившие объекты)
│    └── Survivor 1
├── Old Generation (старые объекты)
└── (иногда) Metaspace (для классов)
```

_Как работает память в куче?_

1. **Создание нового объекта** (`new MyClass()`) ➔ память выделяется в Eden.
2. **Minor GC** очищает Eden от мусора.
    - Выжившие объекты переносятся в Survivor области.
3. **Старение объектов**: после нескольких Minor GC выжившие объекты
   перемещаются в **Old Generation**.
4. **Major GC** убирает мусор из Old Generation.

_Что хранится в куче?_

| Элемент             | Описание                                         |
|:--------------------|:-------------------------------------------------|
| Экземпляры классов  | Все `new` объекты                                |
| Массивы             | Массивы любого типа (`int[]`, `String[]` и т.д.) |
| Строки (`String`)   | Если создаются явно через `new`, а не через пул  |
| Кэшированные данные | Например, коллекции, кэш                         |

_Жизненный цикл объекта в куче_

| Стадия      | Что происходит                                                             |
|:------------|:---------------------------------------------------------------------------|
| Создание    | Объект создается в Eden.                                                   |
| Перемещение | Если выжил после нескольких GC ➔ попадает в Survivor, потом в Old Gen.     |
| Уничтожение | Когда больше нет сильных ссылок ➔ объект собирается сборщиком мусора (GC). |

**Сравнение: Стек против Кучи**

| Параметр   | Стек                         | Куча                                    |
|:-----------|:-----------------------------|:----------------------------------------|
| Содержимое | Локальные переменные, ссылки | Объекты                                 |
| Жизнь      | До завершения метода         | До того, как объект станет недостижимым |
| Размер     | Маленький                    | Большой                                 |
| Управление | Автоматическое               | Сборщик мусора                          |

**Итого:**

- **Куча** — для хранения всех объектов приложения.
- **Управляется автоматически** через сборку мусора (GC).
- **Одна куча** на все потоки.
- **Heap перегружен ➔ OutOfMemoryError**.

_**Куча делится на поколения:**_

| Поколение            | Описание                                         |
|----------------------|--------------------------------------------------|
| **Young Generation** | Новые объекты; быстро умирают — быстро убираются |
| **Old Generation**   | "Долго живущие" объекты                          |
| **Survivor Spaces**  | Промежуточные буферы между Young и Old           |

##### **Молодое поколение (Young Gen)**

- Делится на **Eden** + **Survivor S0/S1**.
- Новые объекты сначала появляются в **Eden**.
- После одной или нескольких сборок мусора могут перейти в **Survivor** или
  **Old**.

**Что такое молодые объекты в Java Heap?**

Когда программа создаёт новые объекты, они сначала **попадают в специальную
часть кучи**, которая называется **Young Generation** или просто Young Gen.  
**Это место для "молодых" объектов** — то есть недавно созданных.

**Основная идея:**

- Большинство объектов в приложениях живут очень **короткое время** (например,
  какие-то временные строки, коллекции и т.д.).
- Чтобы эффективно их быстро убирать, Java делит кучу на поколения:  
  **молодые** (Young) и **старые** (Old).

**Структура кучи памяти в Java**

Грубо делится на две большие части:

```
Heap Memory
├── Young Generation
│    ├── Eden Space
│    ├── Survivor Space 1 (S0)
│    └── Survivor Space 2 (S1)
└── Old Generation (Tenured Space)
```

_Состоит из трёх частей:_

1. **Eden Space** — место, где появляются все новые объекты.
2. **Survivor Space 0 (S0)** — "пережившие" объекты после первой сборки мусора.
3. **Survivor Space 1 (S1)** — вторая зона для дальнейшего перемещения выживших
   объектов.

_Как это работает?_

1. **Создание объекта** ➔ он попадает в **Eden**.
2. Когда **Eden** заполняется ➔ происходит **Minor GC** (маленькая сборка
   мусора).
    - Все **неиспользуемые** объекты в Eden удаляются.
    - **Выжившие** перемещаются в один из **Survivor**-спейсов.
3. После нескольких сборок (переходов между S0 и S1):
    - Если объект всё ещё жив ➔ он **перемещается в Old Generation**.

_Цикл жизни молодого объекта:_

```
[Создание] → Eden → Minor GC → Survivor 0 → Survivor 1 → ... → Old Generation
```

Немного подробнее про сборки:

- **Minor GC** — быстрая сборка, только Young Gen.
- **Major GC (или Full GC)** — затрагивает и Young, и Old Gen. Долгая операция!

_Визуальная схема (упрощённо):_

```
Создание новых объектов → Eden  
Eden заполнился → Minor GC  
Выжившие → Survivor 0  
Выжившие → Survivor 1  
Много выжили? → Old Generation
```

_Итог:_

| Термин               | Что значит                            |
|:---------------------|:--------------------------------------|
| **Young Generation** | Память для недавно созданных объектов |
| **Eden Space**       | Место создания новых объектов         |
| **Survivor Spaces**  | Переходная зона для выживших          |
| **Minor GC**         | Быстрая очистка молодых объектов      |
| **Promotion**        | Перемещение объекта в Old Gen         |

##### **Старое поколение (Old Gen)**

- Здесь хранятся объекты, которые "пережили" много циклов сборки мусора.
- Старые объекты редко убираются => сборка мусора здесь медленнее.

**Старое поколение** в Java Heap — это область памяти, где находятся
долгоживущие объекты.<br>
Туда попадают те объекты, которые:

- **Пережили несколько сборок мусора** в молодом поколении (Young Gen),
- **Их возраст (`age`) превысил порог** (`MaxTenuringThreshold`).

**Идея:**  
Если объект живёт достаточно долго, скорее всего, он ещё долго будет нужен ➔ его
перемещают в Old Gen, чтобы не трогать часто.

_Структура памяти:_

```
Heap Memory
├── Young Generation
│    ├── Eden
│    ├── Survivor 0 (S0)
│    └── Survivor 1 (S1)
└── Old Generation (Tenured Space)   ← старые объекты здесь!
```

_Как объекты попадают в Old Gen?_

1. Новый объект создаётся ➔ попадает в Eden.
2. После Minor GC:
    - Если объект **выжил**, переходит в Survivor.
    - При каждом следующем Minor GC его возраст увеличивается.
3. Когда возраст объекта >= MaxTenuringThreshold ➔
    - **Объект перемещается в Old Generation** (promotion).

_Что хранится в Old Gen?_

- Сессии пользователей (`HttpSession`).
- Долгоживущие коллекции (`Map`, `List`), например, кэш.
- Данные уровня приложения (например, постоянные конфигурационные объекты).

_Особенности работы со Старым поколением:_

| Характеристика | Детали                                                                          |
|:---------------|:--------------------------------------------------------------------------------|
| Размер         | Обычно больше, чем Young Gen.                                                   |
| Частота GC     | Реже, чем в Young Gen.                                                          |
| Тип GC         | **Major GC** или **Full GC** (медленные, могут приостанавливать приложение).    |
| Алгоритмы      | Обычно используется **маркировка и сжатие** (`Mark-Compact`), а не копирование. |

_Как происходит сборка мусора в Old Gen?_

- Когда **Old Gen заполняется**, запускается **Major GC**.
- В отличие от Minor GC (работающего в Young Gen), Major GC:
    - Проходит по всей памяти.
    - Находит живые объекты.
    - **Компактирует** живые объекты в одну часть кучи (убирает "дыры" памяти).
    - Может **заморозить все потоки** (`Stop The World`).

Это более тяжёлая операция, чем обычный Minor GC, поэтому старое поколение
стараются заполнять как можно реже.

#### Stack (Стек)

- Каждый поток имеет **свой стек**.
- При вызове метода создается **Stack Frame**:
    - Локальные переменные
    - Параметры метода
    - Адрес возврата
- После завершения метода его стек-фрейм **удаляется**.

**Важно**: объекты в стеке не хранятся — только **ссылки** на них, если есть.

**Стек памяти** — это **область оперативной памяти**, которая выделяется для:

- хранения **вызовов методов**,
- хранения **локальных переменных**,
- хранения **контекста выполнения** (например, параметры методов, ссылки на
  объекты).

Каждый поток (`Thread`) в Java имеет **свой собственный стек**.  
То есть у каждого потока — **отдельная** изолированная память под вызовы своих
методов.

_Как устроен стек?_

Работает по принципу **"последним пришёл — первым ушёл"** (LIFO: Last In — First
Out).

Когда вызывается метод:

1. Создаётся **новая запись в стеке** (`Stack Frame`).
2. В неё помещаются:
    - Параметры метода,
    - Локальные переменные,
    - Ссылки на другие объекты,
    - Некоторая информация о возврате.

Когда метод завершается:

- Его стек-фрейм удаляется ("выворачивается" из стека).

_Что именно хранится в стеке:_

| Элемент              | Описание                                                    |
|:---------------------|:------------------------------------------------------------|
| Параметры метода     | Переданные значения при вызове                              |
| Локальные переменные | Внутренние переменные метода                                |
| Адрес возврата       | Куда переходить после выполнения метода                     |
| Ссылки на объекты    | Сами объекты лежат в куче (Heap), а ссылки на них — в стеке |

Пример: как растёт стек

```java
public class StackExample {
    public static void main(String[] args) {
        int result = add(2, 3);
        System.out.println(result);
    }

    public static int add(int a, int b) {
        return a + b;
    }
}
```

**Что происходит в памяти:**

1. `main()` запускается → создается фрейм для `main()`.
2. `add(2, 3)` вызывается → новый фрейм для `add()`.
3. В `add()` создаются локальные переменные `a=2`, `b=3`.
4. `add()` завершает работу ➔ его фрейм удаляется.
5. `main()` продолжает работу.

**StackOverflowError**

Если метод вызывает сам себя бесконечно (рекурсия без выхода), стек
переполняется:

```java
public class OverflowExample {
    public static void endless() {
        endless(); // бесконечный вызов
    }

    public static void main(String[] args) {
        endless();
    }
}
```

**Ошибка:**

```
Exception in thread "main" java.lang.StackOverflowError
```

Потому что стек ограничен по размеру (например, 1–2 МБ на поток, можно
настраивать через `-Xss`).

_Важные особенности стека:_

| Особенность           | Что означает                                                                   |
|:----------------------|:-------------------------------------------------------------------------------|
| Быстрая работа        | Стек — очень быстрый (память выделяется и освобождается за константное время). |
| Безопасность потоков  | У каждого потока свой стек ➔ нет гонок за память.                              |
| Живёт во время вызова | Переменные существуют только пока жив метод.                                   |

_Сравнение Stack vs Heap_

| Характеристика | Stack                           | Heap                   |
|:---------------|:--------------------------------|:-----------------------|
| Содержимое     | Локальные переменные, параметры | Объекты, массивы       |
| Жизненный цикл | До завершения метода            | Пока объект достижим   |
| Доступ         | Быстрый (LIFO)                  | Медленный (по ссылкам) |
| Размер         | Маленький                       | Большой                |
| Управление     | Автоматически                   | Сборщик мусора (GC)    |

Мини-схема:

```
Stack Memory (поток 1)
└─ main() frame
   └─ вызвал add()
      └─ frame add()
         └─ локальные переменные: a=2, b=3
Stack Memory (поток 2)
└─ свой стек
```

Итого:

- **Стек** — память для хранения контекста выполнения метода.
- **Быстрая** работа за счёт простой структуры.
- **Изолирован** для каждого потока.
- При ошибках глубоких вызовов ➔ возможен `StackOverflowError`.

#### Metaspace (Раньше был PermGen)

- Хранит информацию о загруженных классах: названия, методы, поля и т.д.
- Начиная с Java 8 вместо PermGen используется **Metaspace**.
- Использует **нативную память** (не ограничена кучей).

#### Code Cache

- Для ускорения работы JIT-компилятор компилирует часто используемый байт-код в
  **машинный код**.
- Этот код хранится в **Code Cache**.

#### Direct Memory

- Обход обычной кучи.
- Используется в высокопроизводительных приложениях, например через
  `ByteBuffer.allocateDirect()`.
- Управляется вручную (Java NIO, Netty и пр.).

#### Визуальная схема

```plaintext
+---------------------------------------------------+
|                   Память процесса                 |
| +---------------------+  +----------------------+ |
| |    Стек потока 1    |  |   Стек потока 2      | |
| +---------------------+  +----------------------+ |
|                    Куча (Heap)                    |
|  +---------------------------------------------+  |
|  |  Young Gen (Eden + Survivor)                |  |
|  |  Old Gen                                    |  |
|  +---------------------------------------------+  |
|               Метаспейс (Metaspace)               |
|               Code Cache                          |
|               Direct Memory                       |
+---------------------------------------------------+
```

**Важно помнить**

- Java сама управляет памятью через **GC**.
- StackOverflowError происходит, когда стек слишком сильно разрастается
  (например, рекурсия без выхода).
- OutOfMemoryError возникает, если куча или метаспейс переполнены.

================================================================================
--------------------------------------------------------------------------------

# Сборка мусора

#### Что такое сборка мусора?

**Garbage Collection** — это механизм в Java, который автоматически **находит и
удаляет неиспользуемые объекты** из памяти, чтобы освободить место.

**Идея:** если на объект **нет больше ссылок**, значит, он **больше не нужен**,
и его можно безопасно удалить.

#### Основные этапы работы GC

1. **Маркировка (Marking):**
    - GC проходит по всем "живым" объектам, начиная с корней (`GC roots`) и
      помечает доступные объекты как живые.
2. **Удаление (Sweeping):**
    - Все немаркированные объекты считаются мусором и удаляются.
3. **Компактирование (Compacting) (иногда):**
    - Перемещает живые объекты, чтобы убрать пустые промежутки и уменьшить
      фрагментацию памяти.

### Что такое GC roots?

**GC Roots** — это начальные точки, откуда GC начинает искать живые объекты.
Примеры:

- Статические поля (`static`)
- Стековые переменные методов
- Активные потоки
- Ссылки внутри JNI

**GC Root** — это **специальная точка отсчёта** для сборщика мусора (**Garbage
Collector**), откуда начинается поиск **живых объектов** в памяти.

**Проще говоря:**  
Когда сборщик мусора ищет, какие объекты можно удалить, он сначала смотрит,
**какие объекты доступны из GC Roots**.  
Все объекты, **которые достижимы** (через цепочку ссылок) от GC Roots, считаются
**живыми**.  
Остальные — **мусор** ➔ их можно удалить.

**Ключевая идея:**

**Если на объект есть хотя бы одна цепочка ссылок от GC Root — он живой.**  
**Если нет — его можно собрать и освободить память.**

**Какие бывают GC Roots?**

В Java в роли **GC Root** выступают:

| Тип GC Root                          | Описание                                                                      |
|:-------------------------------------|:------------------------------------------------------------------------------|
| **Ссылки из стека потоков**          | Все локальные переменные и параметры методов в стеке потока.                  |
| **Ссылки из статических переменных** | Статические поля классов (`static` поля).                                     |
| **Ссылки из классов**                | Классы, загруженные через специальные ClassLoader'ы.                          |
| **Ссылки от JNI**                    | Объекты, которые используются нативным кодом (через Java Native Interface).   |
| **Менеджеры JVM**                    | Например, системные объекты (пулы потоков, классы сдержания ресурсов и т.д.). |

**Как работает сборка мусора через GC Roots:**

1. GC начинает обход всех GC Roots.
2. По каждой ссылке ищет, какие объекты достижимы.
3. Строится граф "живых объектов".
4. Всё, до чего нельзя дойти ➔ **собирается**.

Этот процесс называется **"Tracing Garbage Collection"** (сборка мусора через
трассировку ссылок).

**Краткий пример:**

```java
public class GCRootExample {
    static Object staticObject;
    Object instanceObject;

    public static void main(String[] args) {
        GCRootExample example = new GCRootExample();
        staticObject = new Object();
        example.instanceObject = new Object();
        // Здесь staticObject и instanceObject доступны через GC Roots
    }
}
```

- `staticObject` — доступен через статическую ссылку (GC Root).
- `example.instanceObject` — доступен через локальную переменную `example` в
  стеке main-потока (GC Root через стек).

**Почему это важно знать?**

- **Понимание GC Roots** позволяет правильно **анализировать утечки памяти**.
- В профайлерах памяти (например, **VisualVM**, **YourKit**, **JProfiler**)
  можно смотреть "путь к GC Root" ➔ это показывает, **почему объект не может
  быть собран**.

**Если коротко:**

| Вопрос                 | Ответ                                                   |
|:-----------------------|:--------------------------------------------------------|
| Что такое GC Root?     | Точка, откуда начинается поиск живых объектов.          |
| Какие бывают GC Roots? | Стек потоков, статические поля, классы, JNI-ссылки.     |
| Почему важно?          | Помогает понимать сборку мусора и искать утечки памяти. |

=================

## Garbage Collector. GCRoot

В Java, GC Root (или корень сборщика мусора) — это объект, который является
начальной точкой для процесса сборки мусора (Garbage Collection, GC). Сборщик
мусора использует корни для определения, какие объекты в памяти все еще доступны
и могут быть использованы, а какие объекты больше не нужны и могут быть удалены.

Что такое GC Root?<br>
GC Root — это набор объектов, которые всегда доступны и служат отправной точкой
для поиска всех достижимых объектов в памяти. Если объект не может быть
достигнут из любого из корней, он считается "мусором" и может быть удален
сборщиком мусора.

Примеры GC Root<br>
Вот несколько примеров объектов, которые считаются GC Root:<br>

- Статические поля:<br>
  Объекты, на которые ссылаются статические поля классов. Например, если у вас
  есть статическое поле в классе, которое ссылается на объект, этот объект будет
  являться корнем.
- Активные потоки:<br>
  Объекты, связанные с активными потоками (например, текущий поток выполнения).
- Объекты в локальных переменных:<br>
  Объекты, на которые ссылаются локальные переменные методов. Пока метод
  выполняется и локальные переменные находятся в стеке вызовов, эти объекты
  считаются достижимыми.
- JNI ссылки:<br>
  Объекты, на которые ссылаются нативные методы через Java Native Interface (
  JNI).
- Объекты класса java.lang.Runtime:<br>
  Объект Runtime, который предоставляет информацию о среде выполнения Java.

Как работает сборка мусора?<br>
Сборщик мусора использует алгоритмы для определения достижимости объектов:

1. Начинает с GC Roots: Сборщик начинает с объектов GC Root и проходит по всем
   ссылкам от этих объектов.
2. Обходит граф объектов: Он рекурсивно проверяет все объекты, на которые
   ссылаются корни.
3. Определяет недостижимые объекты: Все объекты, которые не могут быть
   достигнуты из корней, помечаются как "мусор" и подлежат удалению.

Важность GC Root<br>
Понимание концепции GC Root важно для оптимизации работы приложения и управления
памятью:<br>

1. Помогает разработчикам избегать утечек памяти.
2. Позволяет лучше понимать поведение сборщика мусора.
3. Способствует более эффективному управлению ресурсами в приложениях.

Как пометить объект "живым"<br>
В Java объекты помечаются как "живые" (или "достижимые") в контексте сборки
мусора (Garbage Collection) на основе ссылок на них. Если объект доступен через
одну или несколько ссылок, он считается живым и не может быть удален сборщиком
мусора. Вот несколько способов, как можно пометить объект как живой:

1. Создание ссылок на объект<br>
   Чтобы объект считался живым, необходимо создать хотя бы одну ссылку на него.
   Например:

```java
class MyObject {
// Поля и методы
}

public class Main {
    public static void main(String[] args) {
        MyObject obj = new MyObject(); // Создаем объект и сохраняем ссылку на него
// Объект obj считается "живым", пока существует ссылка на него
    }
}
```

В этом примере obj является ссылкой на экземпляр MyObject, и пока эта ссылка
существует, объект будет считаться живым.

2. Использование коллекций<br>
   Объекты могут быть помечены как живые, если они хранятся в коллекциях, таких
   как списки, множества или карты:

```java
import java.util.ArrayList;
import java.util.List;

class MyObject {
    // Поля и методы
}

public class Main {
    public static void main(String[] args) {
        List<MyObject> list = new ArrayList<>();
        MyObject obj = new MyObject();
        list.add(obj); // Объект obj теперь считается "живым", так как он хранится в списке
    }
}
```

3. Статические поля<br>
   Если объект хранится в статическом поле класса, он также будет считаться
   живым:

```java
class MyClass {
    static MyObject staticObj = new MyObject(); // Статическое поле хранит ссылку на объект
}

public class Main {
    public static void main(String[] args) {
        // Объект staticObj считается "живым" благодаря статической ссылке
    }
}
```

4. Передача объектов в методы<br>
   Когда вы передаете объект в метод, он также считается живым, пока метод
   выполняется:

```java
class MyObject {
    // Поля и методы
}

public class Main {
    public static void process(MyObject obj) {
        // Объект obj считается "живым" внутри этого метода
    }

    public static void main(String[] args) {
        MyObject myObj = new MyObject();
        process(myObj); // Передаем объект в метод
    }
}

```

5. Использование внешних библиотек или фреймворков
   Некоторые фреймворки и библиотеки могут управлять жизненным циклом объектов и
   поддерживать ссылки на них для обеспечения их доступности.

Заключение<br>
Объекты в Java считаются "живыми", если на них существуют ссылки из других
объектов или переменных. Чтобы пометить объект как живой, достаточно создать
хотя бы одну ссылку на него — это может быть локальная переменная, элемент
коллекции или статическое поле класса. Как только все ссылки на объект будут
удалены (например, переменные выйдут из области видимости или будут присвоены
null), объект станет недостижимым и может быть удален сборщиком мусора.

GC Root — это ключевая концепция в управлении памятью Java и сборке мусора. Она
определяет начальные точки для поиска достижимых объектов и помогает сборщику
мусора эффективно освобождать память от ненужных объектов.

==============

## String Pool

**String Pool** — это одна из фишек Java, которая позволяет **оптимизировать
работу с памятью** при использовании строк.

**Что такое String Pool?**

**String Pool** — это специальная область памяти в куче (**Heap**), где Java
хранит **уникальные экземпляры строк** (`String`).

**Идея:**  
Если две строки имеют одинаковое значение, **Java не создает два объекта**, а
**использует один и тот же**.

То есть:

`String a = "hello";`  
`String b = "hello";`

`a` и `b` будут ссылаться на **один и тот же объект** в памяти!

**Где именно находится String Pool?**

- До **Java 7**: String Pool был в **PermGen** (область для метаданных классов).
- Начиная с **Java 7 и выше**: String Pool переместили в **Heap** (кучу) вместе
  с обычными объектами.

Это позволило избежать ошибок, связанных с ограниченным размером PermGen.

**Как строки попадают в String Pool?**

1. Если строка создана **литералом** (`"someText"`), то Java сначала ищет строку
   в String Pool.
2. Если такой строки нет — она **добавляется** туда.
3. Если строка **уже есть** — возвращается ссылка на существующую строку.

Пример:

```java
void demo() {
    String a = "test";
    String b = "test";

    System.out.println(a == b); // true (они указывают на один объект)
}
```

**А если создать через `new`?**

```code
String a = new String("test");
String b = new String("test");
System.out.println(a ==b); // false (два разных объекта)
```

- `new String()` **всегда создает новый объект** в куче, независимо от того,
  есть строка в пуле или нет.
- Но можно потом добавить такую строку в пул явно через `.intern()`.

**Что делает метод `.intern()`?**

Метод `intern()`:

- Проверяет, есть ли строка в пуле.
- Если есть — возвращает ссылку на существующую строку.
- Если нет — добавляет в пул.

Пример:

```java
String a = new String("hello").intern();
String b = "hello";

System.out.

println(a ==b); // true
```

Почему String Pool важен?

- **Экономия памяти**: одинаковые строки хранятся только один раз.
- **Быстрая проверка строк**: можно использовать `==`, а не `equals()`, если
  строки интернированы.
- **Оптимизация производительности**: меньше затрат на создание и сборку мусора.

## JIT компилятор

Отличный вопрос! Давай разберем максимально понятно. 🚀

---

# 📚 Что такое JIT-компилятор в Java?

**JIT** — это **Just-In-Time Compiler**,  
или по-русски **"компилятор на лету"**.

**Его задача** — **ускорить выполнение Java-программ**.

---

## 🔥 Кратко: зачем нужен JIT?

Когда ты запускаешь Java-программу:

- Сначала код компилируется в **байткод** (`.class` файлы).
- Байткод выполняется на **JVM** (Java Virtual Machine).
- Обычно интерпретатор **читает и выполняет** байткод **построчно**.

**Проблема**: интерпретация — **медленная**.  
**Решение**: часто используемые участки кода компилировать в **машинный код**
прямо **во время работы программы** ➔ выполняется намного быстрее!

**Вот этим и занимается JIT.**

---

# 🛠 Как работает JIT-компилятор:

1. Ты запускаешь приложение ➔ JVM начинает интерпретировать байткод.
2. JVM **следит**, какие методы часто вызываются (**"горячие методы"**).
3. Когда метод становится популярным:
    - JIT-компилятор **компилирует байткод в нативный код процессора (CPU)**.
4. Теперь JVM **больше не интерпретирует этот метод**, а **исполняет его как
   обычный машинный код** ➔ очень быстро!

---

## ✨ Пример:

```java
public class HelloWorld {
    public static void main(String[] args) {
        for (int i = 0; i < 1_000_000; i++) {
            sayHello();
        }
    }

    static void sayHello() {
        System.out.println("Hello");
    }
}
```

- Метод `sayHello()` **очень часто вызывается**.
- JVM это замечает ➔ **JIT компилирует** `sayHello()` в машинный код.
- Последующие вызовы работают быстрее.

---

# 🎯 Какие есть режимы у JIT?

| Режим  | Описание                                                                                |
|:-------|:----------------------------------------------------------------------------------------|
| Client | Быстрая компиляция, без сильной оптимизации. Подходит для приложений с короткой жизнью. |
| Server | Медленная, но очень агрессивная оптимизация кода. Для долгоживущих сервисов (бэкенд).   |

(Сейчас в Java все умнее: используются гибридные режимы.)

---

# 🧠 Какие оптимизации делает JIT?

✅ Инлайнинг методов (вставка тела метода прямо в код)  
✅ Удаление лишних проверок (например, ненужных `null`-проверок)  
✅ Предсказание циклов и ветвлений  
✅ Удаление мертвого кода (который никогда не исполняется)  
✅ Escape analysis (если объект не "убегает" за пределы метода — создается прямо
в стеке, а не в куче)

---

# 🔥 Что еще важно знать?

- **JIT улучшает производительность**, но **разгоняется не сразу** ➔  
  в начале программа может работать медленно (интерпретация), потом быстро (
  после JIT-компиляции).
- Оптимизированный код может **адаптивно пересобираться**: если условия
  изменились ➔ JIT может пересобрать по-другому.

---

# 📦 В двух словах:

| Без JIT                          | С JIT                              |
|:---------------------------------|:-----------------------------------|
| Медленная интерпретация байткода | Быстрое исполнение машинного кода  |
| Построчное выполнение            | Компиляция "горячего" кода на лету |
| Простая JVM                      | Умная и быстрая JVM                |

---

# 📢 Итого

- **JIT** — это часть JVM, которая **ускоряет выполнение программ**.
- Он **компилирует часто используемые методы** в **нативный код** прямо во время
  работы.
- Благодаря JIT, **Java-программы работают почти так же быстро**, как C++
  программы, особенно после "разгона".

================================================================================
--------------------------------------------------------------------------------



> - ## Java Core. HashCode, equals()

`hashCode()` и `equals()` — это **два ключевых метода**,
которые влияют на сравнение объектов и работу **коллекций**, таких как
`HashMap`, `HashSet`, `Hashtable`. Давай разберем всё по полочкам. 🚀

### Что такое `equals()`?

Метод `equals()` сравнивает **содержимое объектов** (не их ссылки).
По умолчанию (в `Object`) он работает как `==`, т.е. сравнивает **адреса в
памяти**.

Чтобы сравнивать по содержанию (например, по полям), нужно переопределить его.

#### Пример:

```java
public class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        Person p = (Person) obj;
        return this.age == p.age && this.name.equals(p.name);
    }
}
```

### Что такое `hashCode()`?

Метод `hashCode()` возвращает **целое число**, которое используется для быстрого
поиска объекта в хэш-таблицах (`HashMap`, `HashSet` и др.).

Если два объекта **равны по `equals()`**, они **обязаны иметь
одинаковый `hashCode()`**.

**_Важное правило:_**

> Если переопределяешь `equals()`, обязательно переопредели и `hashCode()`.
> Иначе `HashMap`, `HashSet` и т.п. будут работать **неправильно**.


Пример ошибки:

```java
void demo() {
    Person p1 = new Person("Alice", 30);
    Person p2 = new Person("Alice", 30);

    System.out.println(p1.equals(p2)); // true
    set.add(p1);
    set.contains(p2); // false, если hashCode не переопределен!
}
```

Причина: `hashCode` разный, и `HashSet` ищет в другой "корзине".

Как правильно переопределить `hashCode()`:

```java

@Override
public int hashCode() {
    return Objects.hash(name, age); // С Java 7+
}
```

_**Резюме:**_

| Метод        | Назначение                                  | Что сравнивает                |
|--------------|---------------------------------------------|-------------------------------|
| `equals()`   | Проверяет логическое равенство объектов     | Содержимое полей              |
| `hashCode()` | Возвращает хэш-значение для быстрого поиска | Используется в хэш-структурах |

_**Где применяются:**_

| Коллекция   | Что требует                      |
|-------------|----------------------------------|
| `HashMap`   | `equals()` и `hashCode()`        |
| `HashSet`   | `equals()` и `hashCode()`        |
| `TreeSet`   | `compareTo()` (или `Comparator`) |
| `ArrayList` | `equals()` для поиска и удаления |

