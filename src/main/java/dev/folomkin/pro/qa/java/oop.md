# ООП

Объектно-ориентированное программирование (ООП) в Java — это парадигма
программирования, основанная на концепции объектов, которые объединяют данные (
поля) и методы (поведение) для работы с этими данными. Java является одним из
самых популярных языков, поддерживающих ООП, и реализует его основные принципы:
**инкапсуляцию**, **наследование**, **полиморфизм** и **абстракцию**. Рассмотрим
их подробнее:

---

### 1. **Основные принципы ООП в Java**

#### Инкапсуляция

- **Суть**: Скрытие внутренней реализации объекта и предоставление доступа к
  данным только через публичные методы (геттеры и сеттеры).
- **Как реализуется в Java**:
    - Поля класса объявляются с модификатором `private`, чтобы ограничить прямой
      доступ.
    - Для доступа к полям создаются публичные методы (`public getX()` и
      `public setX()`).
    - Пример:
      ```java
      public class Person {
          private String name;
          private int age;
  
          public String getName() {
              return name;
          }
  
          public void setName(String name) {
              this.name = name;
          }
  
          public int getAge() {
              return age;
          }
  
          public void setAge(int age) {
              if (age >= 0) {
                  this.age = age;
              }
          }
      }
      ```
    - В этом примере данные `name` и `age` скрыты, а доступ к ним контролируется
      через методы, что позволяет, например, проверять корректность возраста.

#### Наследование

- **Суть**: Возможность одному классу (потомку) наследовать свойства и методы
  другого класса (родителя).
- **Как реализуется в Java**:
    - Используется ключевое слово `extends`.
    - Java поддерживает только **однократное наследование** (класс может
      наследовать только один родительский класс).
    - Пример:
      ```java
      public class Animal {
          public void eat() {
              System.out.println("This animal eats food.");
          }
      }
  
      public class Dog extends Animal {
          public void bark() {
              System.out.println("Woof!");
          }
      }
  
      public class Main {
          public static void main(String[] args) {
              Dog dog = new Dog();
              dog.eat(); // Унаследованный метод
              dog.bark(); // Собственный метод
          }
      }
      ```
    - Класс `Dog` наследует метод `eat()` от класса `Animal`.

#### Полиморфизм

- **Суть**: Возможность объектам одного типа вести себя по-разному в зависимости
  от их реализации или контекста.
- **Как реализуется в Java**:
    - **Статический полиморфизм** (перегрузка методов): методы с одинаковым
      именем, но разными параметрами.
    - **Динамический полиморфизм** (переопределение методов): использование
      аннотации `@Override` для изменения поведения метода родительского класса.
    - Пример:
      ```java
      public class Animal {
          public void makeSound() {
              System.out.println("Some generic animal sound");
          }
      }
  
      public class Cat extends Animal {
          @Override
          public void makeSound() {
              System.out.println("Meow!");
          }
      }
  
      public class Main {
          public static void main(String[] args) {
              Animal animal = new Cat(); // Полиморфизм
              animal.makeSound(); // Выведет "Meow!"
          }
      }
      ```
    - Переменная типа `Animal` ссылается на объект `Cat`, и вызывается метод
      `makeSound()` класса `Cat`.

#### Абстракция

- **Суть**: Сокрытие сложной реализации и предоставление только необходимого
  интерфейса для работы с объектом.
- **Как реализуется в Java**:
    - Используются **абстрактные классы** (`abstract class`) и **интерфейсы** (
      `interface`).
    - Абстрактный класс может содержать как реализованные, так и абстрактные
      методы (без реализации).
    - Интерфейсы содержат только сигнатуры методов (до Java 8) или могут
      включать методы по умолчанию (`default`) и статические методы.
    - Пример:
      ```java
      public interface Vehicle {
          void start(); // Абстрактный метод
          default void stop() {
              System.out.println("Vehicle stopped.");
          }
      }
  
      public class Car implements Vehicle {
          @Override
          public void start() {
              System.out.println("Car started.");
          }
      }
  
      public class Main {
          public static void main(String[] args) {
              Vehicle car = new Car();
              car.start(); // Выведет "Car started."
              car.stop(); // Выведет "Vehicle stopped."
          }
      }
      ```

---

### 2. **Ключевые элементы ООП в Java**

#### Классы и объекты

- **Класс** — это шаблон, описывающий свойства (поля) и поведение (методы)
  объектов.
- **Объект** — экземпляр класса, созданный с помощью оператора `new`.
- Пример:
  ```java
  public class Book {
      String title;
      int pages;

      public Book(String title, int pages) {
          this.title = title;
          this.pages = pages;
      }

      public void displayInfo() {
          System.out.println("Title: " + title + ", Pages: " + pages);
      }
  }

  public class Main {
      public static void main(String[] args) {
          Book book = new Book("Java Programming", 500);
          book.displayInfo(); // Выведет "Title: Java Programming, Pages: 500"
      }
  }
  ```

#### Модификаторы доступа

- Управляют видимостью полей, методов и классов:
    - `public`: доступно всем.
    - `protected`: доступно в пакете и в подклассах.
    - `default` (package-private): доступно только в пределах пакета.
    - `private`: доступно только внутри класса.

#### Конструкторы

- Специальные методы для создания объектов. Имя совпадает с именем класса, нет
  возвращаемого типа.
- Пример:
  ```java
  public class Student {
      String name;

      public Student(String name) {
          this.name = name;
      }
  }
  ```

#### Статические элементы

- Модификатор `static` делает поле или метод принадлежащим классу, а не объекту.
- Пример:
  ```java
  public class Counter {
      static int count = 0;

      public Counter() {
          count++;
      }

      public static int getCount() {
          return count;
      }
  }
  ```

#### Перегрузка и переопределение методов

- **Перегрузка**: методы с одинаковым именем, но разными параметрами (
  статический полиморфизм).
- **Переопределение**: изменение реализации метода родительского класса в
  подклассе с помощью `@Override`.

---

### 3. **Преимущества ООП в Java**

- **Модульность**: код организован в классы, что упрощает поддержку и
  масштабирование.
- **Повторное использование**: наследование и интерфейсы позволяют
  переиспользовать код.
- **Гибкость**: полиморфизм упрощает расширение функциональности.
- **Безопасность**: инкапсуляция защищает данные от несанкционированного
  доступа.

---

### 4. **Пример комплексного использования ООП**

```java
public abstract class Shape {
    public abstract double getArea(); // Абстрактный метод
}

public class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle extends Shape {
    private double width, height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double getArea() {
        return width * height;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape circle = new Circle(5);
        Shape rectangle = new Rectangle(4, 6);

        System.out.println("Circle area: " + circle.getArea()); // Площадь круга
        System.out.println("Rectangle area: " + rectangle.getArea()); // Площадь прямоугольника
    }
}
```

Этот пример демонстрирует абстракцию, наследование и полиморфизм: класс
`Shape` — абстрактный, `Circle` и `Rectangle` наследуют его, а метод `getArea()`
переопределяется для разных фигур.

---

### 5. **Полезные особенности Java для ООП**

- **Интерфейсы с `default` методами** (с Java 8): позволяют добавлять реализацию
  методов в интерфейсы.
- **Абстрактные классы**: используются, когда нужно частично реализовать
  функциональность.
- **Перечисления (`enum`)**: для создания типов с фиксированным набором
  значений.
- **Класс `Object`**: все классы в Java неявно наследуются от `Object`, что дает
  доступ к методам, таким как `toString()`, `equals()`, `hashCode()`.

---

==============================================================================
------------------------------------------------------------------------------

# Отличие абстрактного класса от интерфейса

В Java **абстрактный класс** и **интерфейс** — это механизмы для реализации
абстракции и поддержки ООП, но они имеют разные цели и возможности. Вот основные
различия:

### 1. **Определение и назначение**

- **Абстрактный класс**:
    - Это класс, объявленный с ключевым словом `abstract`, который не может быть
      создан напрямую (нельзя создать объект с помощью `new`).
    - Используется для предоставления общей функциональности для дочерних
      классов, включая частичную реализацию методов.
    - Подходит, когда классы имеют общую логику и/или состояние (поля).
- **Интерфейс**:
    - Это полностью абстрактный тип (до Java 8 — только сигнатуры методов),
      задающий контракт, который классы должны реализовать.
    - Используется для определения поведения без реализации (хотя с Java 8 можно
      добавлять `default` и `static` методы).
    - Подходит для обеспечения гибкости и независимости от конкретной
      реализации.

### 2. **Наследование**

- **Абстрактный класс**:
    - Java поддерживает только **однократное наследование** (`extends`), поэтому
      класс может наследовать только один абстрактный класс.
    - Пример:
      ```java
      public abstract class Animal {
          public void eat() {
              System.out.println("This animal eats food.");
          }
          public abstract void makeSound();
      }
      ```
- **Интерфейс**:
    - Класс может реализовать **несколько интерфейсов** (`implements`), что
      обеспечивает множественное наследование поведения.
    - Пример:
      ```java
      public interface Flyable {
          void fly();
      }
      public interface Swimmable {
          void swim();
      }
      public class Duck implements Flyable, Swimmable {
          public void fly() { System.out.println("Duck flies!"); }
          public void swim() { System.out.println("Duck swims!"); }
      }
      ```

### 3. **Поля (состояние)**

- **Абстрактный класс**:
    - Может содержать поля (переменные экземпляра) с любыми модификаторами
      доступа (`private`, `protected`, `public`).
    - Может хранить состояние, общее для всех подклассов.
    - Пример:
      ```java
      public abstract class Vehicle {
          protected String brand; // Поле для хранения состояния
          public Vehicle(String brand) {
              this.brand = brand;
          }
      }
      ```
- **Интерфейс**:
    - Не может содержать обычные поля. Все поля в интерфейсе автоматически
      являются `public static final` (константами).
    - Пример:
      ```java
      public interface Constants {
          int MAX_SPEED = 100; // Константа
      }
      ```

### 4. **Методы**

- **Абстрактный класс**:
    - Может содержать как **абстрактные методы** (без реализации), так и *
      *реализованные методы**.
    - Пример:
      ```java
      public abstract class Shape {
          public abstract double getArea(); // Абстрактный метод
          public void display() { // Реализованный метод
              System.out.println("This is a shape.");
          }
      }
      ```
- **Интерфейс**:
    - До Java 8 содержал только абстрактные методы (без реализации).
    - С Java 8 добавлены:
        - **Методы по умолчанию** (`default`) с реализацией.
        - **Статические методы** с реализацией.
    - Пример:
      ```java
      public interface Movable {
          void move(); // Абстрактный метод
          default void stop() { // Метод по умолчанию
              System.out.println("Stopped.");
          }
          static void describe() { // Статический метод
              System.out.println("This is a movable object.");
          }
      }
      ```

### 5. **Конструкторы**

- **Абстрактный класс**:
    - Может иметь конструкторы, которые вызываются при создании объектов
      подклассов.
    - Пример:
      ```java
      public abstract class Animal {
          protected String name;
          public Animal(String name) {
              this.name = name;
          }
      }
      ```
- **Интерфейс**:
    - Не может иметь конструкторов, так как интерфейсы не создают объектов.

### 6. **Когда использовать**

- **Абстрактный класс**:
    - Когда нужно создать общий базовый класс с частичной реализацией и/или
      общим состоянием.
    - Пример: базовый класс `Vehicle` для `Car` и `Bike`, где есть общие поля (
      например, `speed`) и методы (например, `startEngine()`).
- **Интерфейс**:
    - Когда нужно определить контракт поведения, который могут реализовать
      разные, не связанные классы.
    - Пример: интерфейс `Flyable` для классов `Bird` и `Airplane`, которые не
      имеют общего родителя, но оба могут летать.

### 7. **Ключевые различия в таблице**

| Характеристика           | Абстрактный класс                    | Интерфейс                                |
|--------------------------|--------------------------------------|------------------------------------------|
| **Наследование**         | Однократное (`extends`)              | Множественное (`implements`)             |
| **Поля**                 | Могут быть любые                     | Только константы (`public static final`) |
| **Методы**               | Абстрактные и реализованные          | Абстрактные, `default`, `static`         |
| **Конструкторы**         | Поддерживаются                       | Не поддерживаются                        |
| **Модификаторы доступа** | Любые (`private`, `protected`, etc.) | Только `public`                          |
| **Использование**        | Общая функциональность и состояние   | Контракт поведения                       |

### 8. **Пример для сравнения**

```java
// Абстрактный класс
public abstract class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    public void eat() {
        System.out.println(name + " eats food.");
    }

    public abstract void makeSound();
}

// Интерфейс
public interface Jumpable {
    void jump();

    default void land() {
        System.out.println("Landed safely.");
    }
}

// Класс, использующий оба
public class Dog extends Animal implements Jumpable {
    public Dog(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println(name + " says Woof!");
    }

    @Override
    public void jump() {
        System.out.println(name + " jumps high!");
    }
}

// Тест
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy");
        dog.eat();      // Унаследовано от Animal
        dog.makeSound(); // Реализация абстрактного метода
        dog.jump();     // Из интерфейса Jumpable
        dog.land();     // Метод по умолчанию из Jumpable
    }
}
```

### Итог

- Используйте **абстрактный класс**, если нужна общая реализация и состояние для
  группы классов, связанных иерархически.
- Используйте **интерфейс**, если нужно задать поведение, которое могут
  реализовать разные классы, или обеспечить множественное наследование.

================================================================================
--------------------------------------------------------------------------------

# Статические методы

Статические методы в Java — это методы, которые принадлежат классу, а не
конкретному объекту этого класса. Они объявляются с ключевым словом `static` и
имеют ряд особенностей, которые делают их полезными в определённых сценариях.
Вот подробное объяснение:

---

### 1. **Что такое статический метод?**

- Статический метод — это метод, который можно вызывать без создания экземпляра
  класса.
- Он привязан к классу, а не к объекту, поэтому не имеет доступа к
  нестатическим (экземплярным) полям и методам напрямую, так как они требуют
  создания объекта.
- Статические методы часто используются для операций, которые не зависят от
  состояния конкретного объекта.

---

### 2. **Особенности статических методов**

- **Вызов**: Вызываются через имя класса, а не через объект (например,
  `ClassName.methodName()`).
- **Доступ к данным**:
    - Могут обращаться только к **статическим полям** и другим **статическим
      методам** класса.
    - Для доступа к нестатическим полям или методам нужно создать экземпляр
      класса.
- **Ограничения**:
    - Нельзя использовать ключевое слово `this` или `super`, так как они
      ссылаются на текущий объект, которого у статического метода нет.
    - Нельзя переопределять статические методы в подклассах (переопределение
      связано с полиморфизмом и работает только для нестатических методов).
      Однако можно **перекрыть** (hide) статический метод в подклассе, создав
      метод с той же сигнатурой.
- **Использование**:
    - Для утилитарных функций (например, методы в классе `Math` вроде
      `Math.sqrt()`).
    - Для работы с общими данными, принадлежащими классу (например, счётчики
      объектов).
    - Для реализации фабричных методов, создающих экземпляры класса.

---

### 3. **Синтаксис и пример**

```java
public class Counter {
    // Статическое поле
    private static int count = 0;

    // Статический метод
    public static int getCount() {
        return count;
    }

    // Конструктор, увеличивающий счётчик
    public Counter() {
        count++;
    }

    // Нестатический метод
    public void instanceMethod() {
        System.out.println("Это нестатический метод.");
    }

    // Статический метод, вызывающий нестатический через объект
    public static void callInstanceMethod() {
        Counter counter = new Counter(); // Создаём объект
        counter.instanceMethod(); // Вызываем нестатический метод
    }
}

public class Main {
    public static void main(String[] args) {
        // Вызов статического метода без создания объекта
        System.out.println("Текущее количество объектов: " + Counter.getCount()); // 0

        // Создание объектов
        Counter c1 = new Counter();
        Counter c2 = new Counter();

        // Повторный вызов статического метода
        System.out.println("Текущее количество объектов: " + Counter.getCount()); // 2

        // Вызов статического метода, который вызывает нестатический
        Counter.callInstanceMethod(); // Выведет: Это нестатический метод.
    }
}
```

---

### 4. **Примеры использования статических методов**

1. **Утилитарные классы**:
    - Класс `Math` в Java содержит статические методы, такие как `Math.abs()`,
      `Math.random()`, `Math.pow()`, которые не требуют создания объекта.
    - Пример:
      ```java
      double result = Math.sqrt(16); // Вызов статического метода
      System.out.println(result); // 4.0
      ```

2. **Фабричные методы**:
    - Статические методы часто используются для создания объектов (паттерн "
      Фабричный метод").
    - Пример:
      ```java
      public class Singleton {
          private static Singleton instance;
 
          private Singleton() {} // Приватный конструктор
 
          public static Singleton getInstance() {
              if (instance == null) {
                  instance = new Singleton();
              }
              return instance;
          }
      }
      ```

3. **Работа с общими данными**:
    - Статические методы удобно использовать для управления данными, общими для
      всех экземпляров класса (например, счётчик объектов, как в примере выше).

---

### 5. **Статические методы и наследование**

- Статические методы **не поддерживают полиморфизм** в том же смысле, что и
  нестатические методы.
- Если в подклассе определить статический метод с той же сигнатурой, что и в
  родительском классе, это называется **перекрытием** (hiding), а не
  переопределением.
- Пример:
  ```java
  public class Parent {
      public static void staticMethod() {
          System.out.println("Статический метод в Parent");
      }
  }

  public class Child extends Parent {
      public static void staticMethod() {
          System.out.println("Статический метод в Child");
      }
  }

  public class Main {
      public static void main(String[] args) {
          Parent.staticMethod(); // Статический метод в Parent
          Child.staticMethod();  // Статический метод в Child

          Parent obj = new Child();
          obj.staticMethod();    // Статический метод в Parent (не полиморфизм!)
      }
  }
  ```
    - Вызов метода зависит от типа переменной (`Parent`), а не от типа объекта (
      `Child`), так как статические методы привязаны к классу.

---

### 6. **Преимущества и недостатки**

#### Преимущества:

- **Эффективность**: Не требуют создания объекта, что экономит память.
- **Удобство**: Используются для общих утилитарных функций или управления
  состоянием, общим для всех объектов.
- **Простота доступа**: Вызываются напрямую через имя класса.

#### Недостатки:

- **Ограниченный доступ**: Не могут работать с нестатическими полями и методами
  без создания объекта.
- **Отсутствие полиморфизма**: Не поддерживают динамическое связывание, что
  ограничивает их использование в ООП.
- **Потенциальные проблемы с состоянием**: Статические поля, используемые в
  статических методах, могут создавать проблемы в многопоточных приложениях,
  если не синхронизированы.

---

### 7. **Статические методы в интерфейсах**

С Java 8 в интерфейсах можно определять статические методы с реализацией:

```java
public interface Utility {
    static void printMessage(String message) {
        System.out.println("Сообщение: " + message);
    }
}

public class Main {
    public static void main(String[] args) {
        Utility.printMessage("Привет, мир!"); // Вызов статического метода интерфейса
    }
}
```

- Такие методы полезны для предоставления утилитарных функций, связанных с
  интерфейсом, без необходимости создавать класс.

---

### 8. **Когда использовать статические методы?**

- Для утилитарных функций, не зависящих от состояния объекта (например,
  `Math.min()`).
- Для фабричных методов, создающих экземпляры класса.
- Для работы с общими данными, которые относятся к классу, а не к конкретному
  объекту (например, счётчики).
- В интерфейсах для предоставления вспомогательных методов.

---

### 9. **Пример комплексного использования**

```java
public class DatabaseConnection {
    private static int connectionCount = 0;

    // Статический метод для получения количества подключений
    public static int getConnectionCount() {
        return connectionCount;
    }

    // Статический фабричный метод
    public static DatabaseConnection createConnection() {
        connectionCount++;
        return new DatabaseConnection();
    }

    // Нестатический метод
    public void connect() {
        System.out.println("Подключение к базе данных установлено.");
    }

    public static void main(String[] args) {
        DatabaseConnection conn1 = DatabaseConnection.createConnection();
        conn1.connect();
        DatabaseConnection conn2 = DatabaseConnection.createConnection();
        conn2.connect();

        System.out.println("Всего подключений: " + DatabaseConnection.getConnectionCount()); // 2
    }
}
```

---

Если нужно углубиться в конкретный аспект статических методов (например, их
использование в многопоточности или сравнение с нестатическими методами), дайте
знать!

================================================================================
--------------------------------------------------------------------------------

# Сравнение статических методов с нестатическими

Статические и нестатические методы в Java имеют разные роли и поведение, так как
статические методы принадлежат классу, а нестатические — конкретному объекту.
Ниже приведено подробное сравнение статических и нестатических методов по
ключевым характеристикам.

---

### 1. **Принадлежность**

- **Статические методы**:
    - Принадлежат **классу**, а не объекту.
    - Вызываются через имя класса: `ClassName.methodName()`.
    - Пример: `Math.sqrt(16)`.
- **Нестатические методы**:
    - Принадлежат **объекту** (экземпляру класса).
    - Вызываются через объект: `object.methodName()`.
    - Пример: `String.toUpperCase()`.

---

### 2. **Доступ к данным**

- **Статические методы**:
    - Могут обращаться только к **статическим полям** и другим **статическим
      методам** класса напрямую.
    - Для доступа к нестатическим полям или методам нужно создать экземпляр
      класса.
    - Пример:
      ```java
      public class Example {
          static int staticField = 10;
          int instanceField = 20;
  
          public static void staticMethod() {
              System.out.println(staticField); // Доступно
              // System.out.println(instanceField); // Ошибка компиляции
              Example ex = new Example();
              System.out.println(ex.instanceField); // Доступ через объект
          }
      }
      ```
- **Нестатические методы**:
    - Могут обращаться как к **статическим**, так и к **нестатическим полям и
      методам** класса.
    - Имеют доступ к `this`, что позволяет работать с данными текущего объекта.
    - Пример:
      ```java
      public class Example {
          static int staticField = 10;
          int instanceField = 20;
  
          public void instanceMethod() {
              System.out.println(staticField); // Доступно
              System.out.println(instanceField); // Доступно через this
          }
      }
      ```

---

### 3. **Вызов**

- **Статические методы**:
    - Вызываются без создания объекта: `ClassName.staticMethod()`.
    - Могут быть вызваны из любого места, если доступ разрешён (например,
      `public`).
- **Нестатические методы**:
    - Требуют создания объекта: `new ClassName().instanceMethod()`.
    - Не могут быть вызваны напрямую через имя класса.

---

### 4. **Переопределение и полиморфизм**

- **Статические методы**:
    - **Не поддерживают полиморфизм**. Они связаны с классом, а не с объектом,
      поэтому не могут быть переопределены в подклассах. Вместо этого происходит
      **перекрытие** (hiding).
    - Вызов зависит от типа переменной, а не от типа объекта.
    - Пример:
      ```java
      public class Parent {
          public static void staticMethod() {
              System.out.println("Parent static method");
          }
      }
  
      public class Child extends Parent {
          public static void staticMethod() {
              System.out.println("Child static method");
          }
      }
  
      public class Main {
          public static void main(String[] args) {
              Parent parent = new Child();
              parent.staticMethod(); // Выведет: Parent static method
              Child.staticMethod();  // Выведет: Child static method
          }
      }
      ```
- **Нестатические методы**:
    - Поддерживают **полиморфизм** и могут быть переопределены в подклассах с
      помощью `@Override`.
    - Вызов зависит от типа объекта, а не от типа переменной (динамическое
      связывание).
    - Пример:
      ```java
      public class Parent {
          public void instanceMethod() {
              System.out.println("Parent instance method");
          }
      }
  
      public class Child extends Parent {
          @Override
          public void instanceMethod() {
              System.out.println("Child instance method");
          }
      }
  
      public class Main {
          public static void main(String[] args) {
              Parent parent = new Child();
              parent.instanceMethod(); // Выведет: Child instance method
          }
      }
      ```

---

### 5. **Использование ключевых слов `this` и `super`**

- **Статические методы**:
    - Не могут использовать `this` или `super`, так как они не привязаны к
      объекту.
    - Ошибка компиляции при попытке их использования.
- **Нестатические методы**:
    - Могут использовать `this` для обращения к текущему объекту и `super` для
      обращения к родительскому классу.

---

### 6. **Назначение**

- **Статические методы**:
    - Используются для операций, не зависящих от состояния объекта:
        - Утилитарные функции (например, `Math.random()`, `Arrays.sort()`).
        - Фабричные методы (например, `LocalDate.now()`).
        - Работа с общими данными (например, счётчик объектов).
    - Пример:
      ```java
      public class Utility {
          public static int add(int a, int b) {
              return a + b;
          }
      }
      ```
- **Нестатические методы**:
    - Используются для операций, связанных с состоянием конкретного объекта:
        - Работа с полями объекта (например, изменение или получение значений).
        - Реализация поведения, специфичного для объекта.
    - Пример:
      ```java
      public class Car {
          private String model;
  
          public void setModel(String model) {
              this.model = model;
          }
  
          public String getModel() {
              return model;
          }
      }
      ```

---

### 7. **Производительность и память**

- **Статические методы**:
    - Экономят память, так как не требуют создания объекта.
    - Загружаются в память один раз при загрузке класса.
- **Нестатические методы**:
    - Требуют создания объекта, что увеличивает потребление памяти.
    - Каждый объект имеет доступ к своей копии нестатических методов (хотя код
      метода хранится в памяти один раз).

---

### 8. **Пример для сравнения**

```java
public class Counter {
    private static int totalCount = 0; // Статическое поле
    private int instanceCount = 0;     // Нестатическое поле

    // Статический метод
    public static void incrementTotal() {
        totalCount++;
        // instanceCount++; // Ошибка: нельзя получить доступ к instanceCount
    }

    // Нестатический метод
    public void incrementInstance() {
        instanceCount++; // Доступ к нестатическому полю
        totalCount++;    // Доступ к статическому полю
    }

    public static int getTotalCount() {
        return totalCount;
    }

    public int getInstanceCount() {
        return instanceCount;
    }

    public static void main(String[] args) {
        // Вызов статического метода
        Counter.incrementTotal();
        System.out.println("Total count: " + Counter.getTotalCount()); // 1

        // Вызов нестатического метода
        Counter c1 = new Counter();
        c1.incrementInstance();
        System.out.println("Instance count (c1): " + c1.getInstanceCount()); // 1
        System.out.println("Total count: " + Counter.getTotalCount()); // 2

        Counter c2 = new Counter();
        c2.incrementInstance();
        System.out.println("Instance count (c2): " + c2.getInstanceCount()); // 1
        System.out.println("Total count: " + Counter.getTotalCount()); // 3
    }
}
```

- **Вывод**:
    - `totalCount` увеличивается при вызове как статического, так и
      нестатического метода, так как оно общее для класса.
    - `instanceCount` увеличивается только для конкретного объекта.

---

### 9. **Ключевые различия в таблице**

| Характеристика           | Статические методы             | Нестатические методы             |
|--------------------------|--------------------------------|----------------------------------|
| **Принадлежность**       | Классу                         | Объекту                          |
| **Вызов**                | Через `ClassName.method()`     | Через `object.method()`          |
| **Доступ к полям**       | Только статические             | Статические и нестатические      |
| **Полиморфизм**          | Не поддерживается (перекрытие) | Поддерживается (переопределение) |
| **Использование `this`** | Не доступно                    | Доступно                         |
| **Назначение**           | Утилиты, общие данные, фабрики | Работа с состоянием объекта      |
| **Память**               | Не требует объекта             | Требует создания объекта         |

---

### 10. **Когда использовать**

- **Статические методы**:
    - Для утилитарных функций, не зависящих от состояния объекта (например,
      вычисления, конвертации).
    - Для управления общими данными (например, счётчики, конфигурации).
    - Для фабричных методов, создающих объекты.
- **Нестатические методы**:
    - Для работы с данными конкретного объекта (например, изменение полей).
    - Для реализации поведения, зависящего от состояния объекта.
    - Когда требуется полиморфизм и переопределение в подклассах.

================================================================================
--------------------------------------------------------------------------------

# Позднее и раннее связывание

В Java **раннее связывание** (early binding) и **позднее связывание** (late
binding) — это концепции, связанные с тем, как и когда JVM определяет, какой
метод или переменную использовать во время выполнения программы. Эти термины
относятся к механизму выбора метода при вызове, особенно в контексте
полиморфизма и ООП. Рассмотрим их подробно.

---

### 1. **Раннее связывание (Early Binding)**

- **Определение**: Раннее связывание (или статическое связывание) происходит на
  этапе **компиляции**, когда компилятор заранее определяет, какой метод или
  переменная будет использован на основе типа переменной (а не объекта).
- **Когда применяется**:
    - Для **статических методов**, так как они привязаны к классу, а не к
      объекту.
    - Для **финализированных методов** (`final`), которые нельзя переопределить.
    - Для **приватных методов**, которые недоступны для переопределения.
    - Для **переменных** и **перегруженных методов**, где выбор метода зависит
      от сигнатуры (количества и типов параметров).
- **Особенности**:
    - Решение о вызове метода принимается на этапе компиляции.
    - Быстрее, так как не требует дополнительной проверки во время выполнения.
    - Не поддерживает динамический полиморфизм.
- **Пример**:
  ```java
  public class Animal {
      public static void makeSound() {
          System.out.println("Animal sound");
      }
      public void eat() { // Нестатический метод, но помечен как final
          System.out.println("Animal eats");
      }
  }

  public class Dog extends Animal {
      public static void makeSound() { // Перекрытие (hiding), а не переопределение
          System.out.println("Woof!");
      }
      // Нельзя переопределить eat(), если он final
  }

  public class Main {
      public static void main(String[] args) {
          Animal animal = new Dog();
          animal.makeSound(); // Раннее связывание: вызов метода Animal.makeSound()
          animal.eat();       // Раннее связывание, если eat() помечен как final
      }
  }
  ```
    - **Вывод**: `Animal sound`, так как статический метод `makeSound()`
      привязан к типу переменной (`Animal`), а не к объекту (`Dog`).
    - Здесь компилятор решает, что вызывать, на основе типа переменной `Animal`.

---

### 2. **Позднее связывание (Late Binding)**

- **Определение**: Позднее связывание (или динамическое связывание) происходит
  на этапе **выполнения**, когда JVM определяет, какой метод вызывать, на основе
  **реального типа объекта**, а не типа переменной.
- **Когда применяется**:
    - Для **нестатических методов**, которые могут быть переопределены в
      подклассах (полиморфизм).
    - Для методов, помеченных аннотацией `@Override` в подклассах.
    - Используется в ситуациях, связанных с **наследованием** и **полиморфизмом
      **.
- **Особенности**:
    - Решение о вызове метода принимается во время выполнения через таблицу
      виртуальных методов (vtable).
    - Поддерживает динамический полиморфизм, что делает код более гибким.
    - Может быть чуть медленнее из-за необходимости проверки типа объекта во
      время выполнения.
- **Пример**:
  ```java
  public class Animal {
      public void makeSound() {
          System.out.println("Animal sound");
      }
  }

  public class Dog extends Animal {
      @Override
      public void makeSound() {
          System.out.println("Woof!");
      }
  }

  public class Main {
      public static void main(String[] args) {
          Animal animal = new Dog(); // Тип переменной — Animal, но объект — Dog
          animal.makeSound(); // Позднее связывание: вызов метода Dog.makeSound()
      }
  }
  ```
    - **Вывод**: `Woof!`, так как JVM во время выполнения определяет, что
      реальный объект — это `Dog`, и вызывает его переопределённый метод
      `makeSound()`.

---

### 3. **Ключевые различия**

| Характеристика         | Раннее связывание (Early Binding)                    | Позднее связывание (Late Binding)             |
|------------------------|------------------------------------------------------|-----------------------------------------------|
| **Время связывания**   | На этапе компиляции                                  | На этапе выполнения                           |
| **Тип определения**    | На основе типа переменной                            | На основе реального типа объекта              |
| **Применяется к**      | Статические, финальные, приватные методы, переменные | Нестатические методы, переопределённые методы |
| **Полиморфизм**        | Не поддерживается                                    | Поддерживается (динамический полиморфизм)     |
| **Производительность** | Быстрее (решение на этапе компиляции)                | Чуть медленнее (проверка во время выполнения) |
| **Примеры**            | Статические методы, перегрузка методов               | Переопределённые методы в подклассах          |

---

### 4. **Примеры для сравнения**

#### Раннее связывание (статический метод):

```java
public class Parent {
    public static void display() {
        System.out.println("Parent display");
    }
}

public class Child extends Parent {
    public static void display() { // Перекрытие, а не переопределение
        System.out.println("Child display");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent parent = new Child();
        parent.display(); // Выведет: Parent display (раннее связывание)
    }
}
```

- Компилятор смотрит на тип переменной (`Parent`) и вызывает метод
  `Parent.display()`.

#### Позднее связывание (нестатический метод):

```java
public class Parent {
    public void display() {
        System.out.println("Parent display");
    }
}

public class Child extends Parent {
    @Override
    public void display() {
        System.out.println("Child display");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent parent = new Child();
        parent.display(); // Выведет: Child display (позднее связывание)
    }
}
```

- JVM во время выполнения определяет, что объект — это `Child`, и вызывает его
  метод `display()`.

---

### 5. **Когда используется**

- **Раннее связывание**:
    - Для методов, которые не предполагают переопределения (статические,
      финальные, приватные).
    - Для перегрузки методов, где выбор метода зависит от параметров, а не от
      типа объекта.
    - Для доступа к переменным (полям), так как их выбор определяется типом
      переменной.
- **Позднее связывание**:
    - Для реализации полиморфизма, когда метод может быть переопределён в
      подклассах.
    - Для обеспечения гибкости в ООП, когда поведение объекта определяется его
      реальным типом.

---

### 6. **Практическое значение**

- **Раннее связывание**:
    - Упрощает оптимизацию, так как компилятор заранее знает, какой код будет
      выполнен.
    - Подходит для утилитарных функций (например, `Math.abs()`).
- **Позднее связывание**:
    - Позволяет создавать гибкие и расширяемые программы, где поведение объектов
      может меняться в зависимости от их типа.
    - Ключевая особенность ООП, используемая в паттернах проектирования (
      например, "Стратегия", "Фабрика").

---

### 7. **Пример с перегрузкой и переопределением**

```java
public class Calculator {
    // Перегрузка методов (раннее связывание)
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    // Нестатический метод для переопределения
    public void printResult() {
        System.out.println("Result from Calculator");
    }
}

public class AdvancedCalculator extends Calculator {
    @Override
    public void printResult() {
        System.out.println("Result from AdvancedCalculator");
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new AdvancedCalculator();
        System.out.println(calc.add(1, 2)); // Раннее связывание: выбор метода add(int, int)
        System.out.println(calc.add(1.5, 2.5)); // Раннее связывание: выбор метода add(double, double)
        calc.printResult(); // Позднее связывание: вызов метода AdvancedCalculator.printResult()
    }
}
```

- **Вывод**:
  ```
  3
  4.0
  Result from AdvancedCalculator
  ```

---

### Итог

- **Раннее связывание** используется для методов, которые не зависят от типа
  объекта (статические, финальные, приватные) или для перегрузки, и определяется
  на этапе компиляции.
- **Позднее связывание** применяется для переопределённых нестатических методов,
  поддерживает полиморфизм и определяется во время выполнения на основе
  реального типа объекта.

Если нужен более глубокий разбор (например, как JVM реализует позднее связывание
или примеры с интерфейсами), дайте знать!