# Материал для подготовки к собесам

## Вопросы

- SOLID - [SOLID.md](code_style/SOLID.md)
- Java Generic. Можем как-то ограничить типы (про
  super) - [generics.md](java/generics.md)
- JAVA CORE. <br> Generics. PECS -  [generics.md](java/generics.md)
- Java StreamApi. Вызов без терминальной
  операции - [stream-api.md](java/stream-api.md)
- Java StreamApi. .parallel(),
  fork-join-poll - [stream-api.md](java/stream-api.md)
- Java multithreading.
  ExecutorService - [executorservice.md](java/multithreading/executorservice.md)
- Java multithreading. Atomic пакет Механизм под капотом (
  CAS) - [atomic_cas.md](java/multithreading/atomic_cas.md)
- Spring. Scope бинов чуть лучше - [beans.md](../spring/beans/beans.md)
- Жизненный цикл бинов - [beans.md](../spring/beans/beans.md)

-----

- Java Collection. Сложность получения последнего элемента в LinkedList (O(1))
- Java Collection. HashMap чуть лучше про то как устроен и сложности методов
- Java Core. GCRoot
- Оптимистические/писсимистические блокировки

> ## Hibernate. Проблема n+1

**Проблема N+1 запросов** возникает, когда при работе с ORM (например,
Hibernate) в приложении для получения данных из базы вместо одного оптимального
запроса выполняется **множество отдельных запросов**. Это приводит к
существенным затратам времени и ресурсов.

**_Как возникает проблема?_**

Допустим, у нас есть две связанные сущности: **`User`** и **`Order`**, где
`User` имеет список `orders`. Например:

```java

@Entity
public class User {
    @Id
    private Long id;

    private String name;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders;
}

@Entity
public class Order {
    @Id
    private Long id;

    private String description;

    @ManyToOne
    private User user;
}
```

Теперь мы хотим получить список пользователей с их заказами:

```java
class Demo {
    void demo() {

        List<User> users = entityManager
                .createQuery("SELECT u FROM User u", User.class)
                .getResultList();

        for (User user : users) {
            System.out.println("User: " + user.getName());
            System.out.println("Orders: " + user.getOrders());
        }
    }
}

```

_**Что происходит под капотом?**_

1. Первый запрос:
   ```sql
   SELECT * FROM user;
   ```
   Загружаются все пользователи.

2. Для каждого пользователя (N пользователей) выполняется отдельный запрос для
   получения его заказов:
   ```sql
   SELECT * FROM order WHERE user_id = ?;
   ```

Итого:

- **1 запрос для загрузки пользователей.**
- **N запросов для загрузки заказов.**
- Получается `N+1` запросов.

### Решение проблемы N+1

#### 1. **Использование `JOIN FETCH` (жадная загрузка)**

Перепишем запрос, чтобы сразу загрузить заказы:

```java
List<User> users = entityManager
        .createQuery("SELECT u FROM User u JOIN FETCH u.orders", User.class)
        .getResultList();
```

Теперь Hibernate выполнит **один запрос** с `JOIN`:

```sql
SELECT u.*, o.*
FROM user u
         JOIN order o ON u.id = o.user_id;
```

**Важно:** Это решает проблему, но может вернуть дублирующиеся строки, если у
одного пользователя несколько заказов. Hibernate автоматически устраняет
дубликаты, но это тоже имеет накладные расходы.

#### 2. **Использование графов сущностей (Entity Graphs)**

С помощью **графов сущностей** можно явно указать, какие данные подгружать:

```java

@EntityGraph(attributePaths = "orders")
List<User> users = entityManager
        .createQuery("SELECT u FROM User u", User.class)
        .setHint("javax.persistence.fetchgraph", entityGraph)
        .getResultList();
```

Это также позволяет избежать проблемы N+1, загружая связанные сущности в одном
запросе.

### 3. **Использование `@BatchSize`**

Hibernate может группировать загрузку данных с помощью аннотации `@BatchSize`:

```java

@Entity
@BatchSize(size = 10)
public class User {
    @Id
    private Long id;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders;
}
```

Теперь вместо одного запроса на каждый объект, Hibernate будет подгружать данные
пачками:

```sql
SELECT *
FROM order
WHERE user_id IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
```

### 4. **Кэширование (`Second-Level Cache`)**

В некоторых случаях проблему можно частично решить с помощью **вторичного кэша
Hibernate**. Он позволяет повторно использовать данные, которые уже были
загружены, чтобы избежать лишних запросов.

## ENTITY MANAGER

_**Что такое `EntityManager`?**_

`EntityManager` — это **основной интерфейс JPA**, через который осуществляется
**вся работа с базой данных**:создание, чтение, обновление, удаление объектов (
CRUD), а также управление жизненным циклом сущностей.

Это как "менеджер" между Java-приложением и базой данных. Он отвечает за:

- сохранение объекта в базу
- получение объекта из базы
- обновление и удаление
- управление транзакциями
- кеширование сущностей
- создание запросов (JPQL, SQL, Criteria API)

_**Пример использования `EntityManager`**_

```java

@PersistenceContext
private EntityManager entityManager;

public User getUserById(Long id) {
    return entityManager.find(User.class, id);
}

public void saveUser(User user) {
    entityManager.persist(user);
}
```

_**Основные методы `EntityManager`**_

| Метод                    | Что делает                                   |
|--------------------------|----------------------------------------------|
| `persist(Object entity)` | Сохраняет объект в базу данных               |
| `find(Class<T>, id)`     | Находит сущность по id                       |
| `merge(Object entity)`   | Обновляет объект в базе                      |
| `remove(Object entity)`  | Удаляет объект                               |
| `createQuery()`          | Создаёт JPQL-запрос                          |
| `createNativeQuery()`    | SQL-запрос                                   |
| `flush()`                | Принудительно синхронизирует изменения с БД  |
| `clear()`                | Очищает контекст (все отслеживаемые объекты) |

### Жизненный цикл сущностей

`EntityManager` управляет состоянием объектов:

| Состояние                 | Описание                                                                   |
|---------------------------|----------------------------------------------------------------------------|
| `Transient`(Новая)        | Объект создан, но не привязан к БД                                         |
| `Managed`(Управляемая)    | Контролируется `EntityManager`, любые изменения автоматически попадут в БД |
| `Detached`(Отсоединенная) | Больше не контролируется, но может быть сохранён снова через `merge()`     |
| `Removed`(Удаленная)      | Помечен на удаление                                                        |

### Откуда берётся `EntityManager`?

В Spring или Jakarta EE его можно внедрить через:

```java

@PersistenceContext
private EntityManager em;
```

А в обычных Java SE-приложениях — создать вручную:

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("myUnit");
EntityManager em = emf.createEntityManager();
```

_**Резюме**_

`EntityManager` = главный API для работы с базой в JPA.  
Он:

- управляет сущностями
- делает запросы к базе
- отвечает за транзакции
- предоставляет гибкий доступ к данным

## ENTITY GRAPH

**`Entity Graph`** в Hibernate (и JPA в целом) — это инструмент,
который помогает **гибко управлять стратегиями загрузки данных**: что подгружать
сразу (жадно), а что позже (лениво), **без изменения аннотаций в сущностях**.
Entity Graphs (графы сущностей) — это механизм в JPA (Java Persistence API),
который позволяет разработчикам управлять загрузкой связанных сущностей более
гибко и эффективно. С помощью графов сущностей можно указать, какие связанные
объекты должны быть загружены вместе с основной сущностью, что помогает избежать
проблемы N+1 и оптимизировать производительность запросов.



> ## Hibernate. Уровни кеширования в Hibernate лучше изучить

### Основные уровни кэширования в Hibernate:

1. **Первичный кэш (Session Cache)** — кэш на уровне сессии.
2. **Вторичный кэш (Second-level Cache)** — кэш на уровне сессии-фабрики.
3. **Кэш запросов (Query Cache)** — кэширование результатов запросов.

### 1. Первичный кеш (First-Level Cache)

- Это **встроенный кеш**, работающий **в пределах одной сессии (`Session`) или
  транзакции**.
- **Всегда включён** — ничего дополнительно настраивать не нужно.
- Кэширует сущности, загруженные в текущей `Session`.
- Первичный кеш является неотъемлемой частью сессии Hibernate. Он
  хранит объекты, загруженные в текущей сессии, и обеспечивает их повторное
  использование без необходимости повторного запроса к базе данных.

**Пример:**

```java
Session session = sessionFactory.openSession();
User user1 = session.get(User.class, 1L); // SELECT из БД
User user2 = session.get(User.class, 1L); // из кэша, без запроса
```

Второй вызов не пойдёт в базу, потому что объект уже есть в памяти.

#### Очистка кэша:

- `session.clear()` — очищает весь кэш
- `session.evict(user)` — удаляет конкретную сущность из кэша
- `session.close()` — кэш уничтожается

### 2. Вторичный кеш (Second-Level Cache)

Это глобальный кеш, работающий между сессиями и транзакциями. Выключен
по умолчанию, его нужно явно включить и настроить. Используется для повторно
используемых данных (справочники, настройки, часто читаемые сущности).
Действует на уровне сессии-фабрики (SessionFactory). Данные остаются в этом кэше
даже после закрытия сессий. Вторичный кэш может быть использован для хранения
часто запрашиваемых сущностей или коллекций, что позволяет уменьшить количество
запросов к базе данных. Вторичный кеш доступен для всех сессий, использующих
одну и ту же фабрику сессий. Для использования второго уровня кеша необходимо
включить его в конфигурации Hibernate и выбрать провайдер кеша (например,
Ehcache, Infinispan и т.д.).

**Настраивается через конфигурацию и провайдер кеша:**

Hibernate сам по себе не кеширует на 2 уровне — он **использует сторонние
библиотеки**, например:

- **Ehcache**
- **Infinispan**
- **Caffeine**
- **Redis (через адаптеры)**

Как включить 2-й уровень кеша

```properties
hibernate.cache.use_second_level_cache=true
hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory
hibernate.javax.cache.provider=org.ehcache.jsr107.EhcacheCachingProvider
```

И в сущности:

```java

@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User {
    ...
}
```

#### Стратегии кэширования

Hibernate поддерживает несколько стратегий кэширования для второго уровня:

1. **READ_ONLY**: Используется для объектов, которые не изменяются после их
   создания. Это наиболее эффективная стратегия.
2. **READ_WRITE**: Используется для объектов, которые могут изменяться.
   Hibernate управляет блокировками при записи.
3. **NONSTRICT_READ_WRITE**: Позволяет более высокую производительность за счет
   менее строгого контроля за изменениями.
4. **TRANSACTIONAL**: Поддерживает транзакционное поведение.

### 3. **Кэш запросов (Query Cache)**

- **Описание:** Это дополнительный уровень кеширования, который позволяет
  кешировать результаты запросов.
- **Область видимости:** Работает совместно со вторичным кэшем и может
  использоваться для кеширования результатов HQL или Criteria запросов.
- **Применение:** Если вы выполняете один и тот же запрос несколько раз,
  результаты могут быть извлечены из кеша вместо выполнения запроса к базе
  данных.

### Включение кэша запросов в Hibernate

1. Включить **вторичный кэш**.
2. Включить **кэш запросов**.

#### Кэширование запросов с параметрами

Кэширование работает **по запросу и его параметрам**. Это значит, что если ты
выполняешь запрос с разными параметрами, то результат будет кэшироваться
отдельно для каждого набора параметров. Но если запрос повторится с тем же
параметром "John", результат будет взят из кэша

#### Интеграция с Spring Data JPA

В **Spring Data JPA** кэширование запросов также поддерживается. Для этого можно
использовать аннотацию `@Query` с параметром `cacheable = true`.

#### Важные замечания:

- Кэширование запросов не **обновляет** кэш автоматически. То есть, если данные
  изменяются в базе данных, кэшированные результаты не будут обновлены.
- Нужно помнить, что если запрос включает много данных или параметров,
  кэширование может **занимать много памяти**. Старайся кэшировать только *
  *часто используемые запросы с ограниченным количеством результатов**.
- **Параметризация** запросов критична — кэширование работает по параметрам, и
  если параметры изменяются, запрос будет выполнен заново.

> ## Сессии в Hibernate

Сессия в Hibernate — это основной интерфейс для взаимодействия с базой данных.
Она представляет собой единицу работы с данными и обеспечивает механизм для
выполнения операций с сущностями, таких как создание, чтение, обновление и
удаление (CRUD). Сессия управляет состоянием объектов и их жизненным циклом, а
также обеспечивает кэширование на уровне первого уровня.

Сессия отслеживает изменения в сущностях, которые она загружает. Когда вы
загружаете сущность из базы данных, она становится "управляемой" (managed)и
находится в состоянии "приложения" (persistent). Если вы изменяете управляемую
сущность, Hibernate автоматически отслеживает эти изменения и может
синхронизировать их с базой данных при вызове метода `session.flush()` или при
закрытии сессии.

Сессия имеет свой собственный первичный кэш (first-level cache), который
хранит загруженные объекты. Если вы запрашиваете одну и ту же сущность
несколько раз в рамках одной сессии, Hibernate будет возвращать объект из
этого кэша вместо выполнения нового запроса к базе данных.

### Фабрика сессий

Фабрика сессий (SessionFactory) в Hibernate — это интерфейс, который отвечает за
создание и управление сессиями (Session). Она является основным компонентом,
который настраивается один раз при запуске приложения и используется для
получения экземпляров сессий. В контексте второго уровня кэширования (Second
Level Cache) фабрика сессий играет важную роль в управлении кэшированием данных
между различными сессиями.

> ## HQL, native, JPQL, Criteria запросы

### HQL

HQL (Hibernate Query Language) — это язык запросов, очень похожий на SQL, но с
одной ключевой разницей - HQL работает с сущностями и их полями, а не с
таблицами и колонками.

### Native Query

В Hibernate **native запросы** — это **SQL-запросы**, написанные напрямую, **без
использования HQL** или `Criteria API`.
Это **"сырой" SQL-запрос**, который выполняется прямо в базу данных, **в обход
Hibernate Query Language** (HQL).

### JPQL

**JPQL (Java Persistence Query Language)** — это **стандартизированный язык
запросов**, который входит в JPA (Java Persistence API). Он **похож на SQL**, но
работает **с Java-сущностями и их полями**, а **не с таблицами и колонками**
базы данных.

### Criteria запросы

**Criteria-запросы** в JPA (или Hibernate) — это способ
**построения запросов через Java-код**, а не через строки. Это особенно полезно,
когда запрос должен быть **динамическим**, например, фильтры меняются во время
выполнения.


> ## SQL. Оптимистические/Пессимистические блокировки

**Оптимистические** и **пессимистические блокировки** —
два подхода к управлению **конкурентным доступом** к данным в
многопользовательских системах или распределённых приложениях.  
**Блокировка** — это механизм, который предотвращает **конкурентный доступ** к
данным, чтобы избежать **несогласованных изменений** или **повреждения данных**.

- **Пессимистическая блокировка**: когда мы блокируем данные на время их
  использования, чтобы гарантировать эксклюзивный доступ.
- **Оптимистическая блокировка**: когда предполагается, что **конфликтов не
  будет**, и проверка их происходит только в момент **сохранения** данных.

### Пессимистическая блокировка (Pessimistic Locking)

**Пессимистическая блокировка** — это подход, при котором предполагается, что
**конфликт между транзакциями** может возникнуть. Поэтому, прежде чем начать
работать с данными, транзакция **блокирует** их на уровне базы данных или на
уровне приложения. Другие транзакции **не могут получить доступ к этим данным**,
пока первая не завершит свои операции.

#### Как это работает?

1. **Захват блокировки**: когда транзакция получает доступ к записи, она
   "блокирует" её, чтобы другие транзакции не могли её изменить.
2. **Ожидание**: если другая транзакция пытается изменить эти данные, она будет
   **ждать**, пока первая не завершит работу.
3. **Завершение работы**: блокировка снимается, когда транзакция завершена, и
   другие транзакции могут получить доступ к данным.

### Оптимистическая блокировка (Optimistic Locking)

**Оптимистическая блокировка** предполагает, что **конфликтов не будет**, и
предоставляет всем транзакциям возможность работать с данными без блокировки.
Вместо того чтобы блокировать ресурсы, транзакция будет **проверять, были ли
данные изменены**, прежде чем записать их обратно в базу данных.

#### Как это работает?

1. **Чтение данных**: транзакция считывает данные и работает с ними.
2. **Запись данных**: перед сохранением изменений в базу данных транзакция
   проверяет, не были ли данные изменены другой транзакцией (например, через
   версионный номер).
3. **Конфликт**: если данные были изменены другим пользователем (или
   транзакцией), то транзакция **не будет выполнена** (будет выброшено
   исключение, например, `OptimisticLockException`), и нужно решить, как
   поступить — повторить операцию или отменить.

#### Итог:

- **Пессимистическая блокировка** — это более **агрессивный подход** с гарантией
  того, что данные не изменяются другими транзакциями, но может привести к
  проблемам с производительностью.
- **Оптимистическая блокировка** — **более лёгкий** подход, который
  предполагает, что конфликтов не будет, и проверяет это только при сохранении
  данных.

> ## Spring. Self injection и как работать с аннотациями в спринге. Например, Transaction, Уровни транзакции, ACID, проблемы

## Self injection

**Self Injection** в **Spring Framework** — это концепция, при которой **объект
сам себе инжектит зависимости** через механизмы Spring DI (Dependency
Injection). Обычно это может происходить с помощью **аннотаций**, таких как
`@Autowired`, когда объект **автоматически подставляется** в сам себя как
зависимость.

**Self Injection** возникает, когда компонент (bean) инжектит **сам себя** через
механизмы Spring DI (Dependency Injection) в своём собственном контексте. Это
может быть полезно в некоторых ситуациях, например, когда нужно обеспечить
доступ к текущему экземпляру класса в самом классе, например, для внедрения
через какие-то специфические методы или для манипуляции внутри компонента.

### В чем смысл Self Injection?

**Self Injection** может быть полезен в специфичных случаях, например:

- **Для кэширования**: когда компонент сам себе инжектирует зависимости для
  работы с кэшом.
- **Для рекурсии**: когда объект должен быть способен работать сам с собой в
  рекурсивных структурах.
- **Циклические зависимости**: хотя Spring не рекомендует циклические
  зависимости, бывают случаи, когда такой подход используется для их разрешения.

Однако стоит помнить, что использование **Self Injection** — это довольно редкая
практика, которая чаще всего может сигнализировать о том, что архитектура
нуждается в **рефакторинге**. В большинстве случаев, **инжекция зависимостей**
должна быть направлена на **внедрение внешних зависимостей**, а не инъекцию
самого себя.

### Зачем это нужно?

Например, если у вас есть метод с аннотацией `@Transactional`, и вы вызываете
этот метод из другого метода того же класса напрямую
(`this.someTransactionalMethod()`), то Spring **не применит прокси и не создаст
транзакцию**, потому что вызов идёт внутри одного объекта.

Если же вызвать метод через прокси (через self injection), то аспекты сработают
корректно.

### Когда стоит использовать Self Injection?

- **Инициализация через бин**: если требуется инжектить зависимости **только
  через Spring** (например, для корректной работы в контексте Spring).
- **Тестирование**: в некоторых случаях Self Injection используется в **тестовых
  приложениях**, когда важно, чтобы зависимости инжектировались, а сам объект
  должен быть доступен для проверки в других местах.

#### Пример self injection

```java

@Component
public class MyService {

    @Autowired
    private MyService self;  // self injection

    public void methodA() {
        // вызов метода с транзакцией через прокси
        self.methodB();
    }

    @Transactional
    public void methodB() {
        // код, который должен выполняться в транзакции
    }
}
```

Здесь вызов `self.methodB()` пройдет через прокси Spring, и транзакция будет
создана. Если бы вызвали `this.methodB()`, то аннотация `@Transactional` не
сработала бы.

#### Как работает?

Spring создает прокси-объект для бина и внедряет его в поле `self`. Таким
образом, при вызове методов через `self` вызывается проксированный объект с
применением аспектов.

#### Кратко

**Self Injection** — это когда бин внедряет сам себя из контекста Spring для
того, чтобы внутренние вызовы методов проходили через прокси и корректно
работали такие механизмы как транзакции и AOP.

## Как работать с аннотациями на примере @Transaction

Аннотация **`@Transactional`** в **Spring Framework** используется для
управления транзакциями в приложении, что позволяет обеспечить консистентность
данных при работе с базой данных. С помощью этой аннотации можно обозначить, что
определённый метод или класс должен работать в рамках одной транзакции, и Spring
автоматически будет управлять процессом начала, коммита и отката транзакции.

### Основные моменты, которые стоит учитывать при работе с `@Transactional`:

1. **`@Transactional` на уровне класса и метода:**
    - **На уровне метода:** Когда аннотация применяется на методе, транзакция
      будет начинаться и завершаться (коммититься или откатываться) для этого
      конкретного метода.
    - **На уровне класса:** Если `@Transactional` применяется на уровне класса,
      то транзакция будет работать для всех методов этого класса (если только
      для метода не задано своё поведение).

2. **Типы транзакций:**
    - **Программные транзакции** — Spring создает транзакции на основе операций
      с базой данных с помощью менеджера транзакций.
    - **Менеджер транзакций:** Spring использует `PlatformTransactionManager`
      для управления транзакциями, например, `DataSourceTransactionManager` для
      работы с базой данных через JDBC.

3. **Поведение транзакций:**
    - **Коммит и откат:** Если метод выполняется без ошибок, то транзакция будет
      зафиксирована (commit). Если произойдёт исключение, то транзакция будет
      откатана (rollback).
    - **Типы исключений:** По умолчанию транзакция откатывается только в случае
      непроверяемых исключений (наследников `RuntimeException`). Для
      проверяемых исключений (наследников `Exception`) транзакция не будет
      откатана, если это явно не указано в аннотации.

## @Transactional

Аннотация `@Transactional` в **Spring Framework** используется для обозначения
методов или классов, которые должны работать в рамках **транзакции**. Она
упрощает управление транзакциями, автоматически обрабатывая создание, коммиты и
откаты транзакций, что значительно упрощает работу с базой данных и другими
ресурсами.

### Основные моменты:

- **Транзакции** — это механизмы, которые обеспечивают **атомарность** операций,
  чтобы данные оставались согласованными, даже если система сталкивается с
  ошибками.
- **`@Transactional`** позволяет Spring автоматически управлять транзакциями,
  начиная их в момент вызова метода и заканчивая при его завершении (с коммитом
  или откатом, в зависимости от результата).

### Важные аспекты `@Transactional`

1. **Управление транзакциями**:

    - **Начало транзакции** происходит сразу перед выполнением метода.
    - **Коммит**: если метод завершился успешно, транзакция будет зафиксирована.
    - **Откат**: если в методе произошло исключение, Spring автоматически
      откатит транзакцию, восстанавливая состояние данных до начала метода.

2. **По умолчанию откат на RuntimeException**:

   Spring откатывает транзакцию по умолчанию только для unchecked exceptions
   (например, `RuntimeException`), но не для checked exceptions (например,
   `IOException` или `SQLException`).

3. **Сквозной аспект (Aspect-Oriented Programming, AOP)**:

   `@Transactional` работает на основе **аспектно-ориентированного
   программирования (AOP)**, что означает, что Spring создаёт прокси для класса,
   а сама транзакция управляется этим прокси. Это позволяет Spring автоматически
   перехватывать вызовы методов и оборачивать их в транзакции.

### Настройки аннотации `@Transactional`

Аннотация `@Transactional` имеет несколько полезных атрибутов, которые позволяют
настроить поведение транзакции.

1. **`propagation`** — уровень распространения транзакции

(или propagation level) в Spring Framework
определяет, как транзакция будет вести себя в случае, если она уже существует
или не существует в текущем потоке. Этот параметр используется в аннотации
@Transactional и играет ключевую роль в управлении транзакциями, особенно при
работе с вложенными вызовами методов и несколькими сервисами.

- **`REQUIRED`** (по умолчанию): Если существует активная транзакция, то текущий
  метод будет выполнен в рамках этой транзакции. Если транзакции нет — она будет
  создана.
- **`REQUIRES_NEW`**: Всегда создаёт новую транзакцию. Если транзакция уже
  существует, она будет приостановлена.
- **`NESTED`**: Создаёт новую транзакцию, но внутри существующей. Это как
  вложенная транзакция, которая может быть откатана отдельно, не влияя на
  внешнюю.
- **`SUPPORTS`**: Если существует активная транзакция, метод будет выполнен в её
  рамках, если нет — транзакция не будет создана.
- **`NOT_SUPPORTED`**: Метод не будет выполнять транзакцию, если она есть.
- **`MANDATORY`**: Требует, чтобы существовала активная транзакция. Если
  транзакции нет, будет выброшено исключение.
- **`NEVER`**: Метод не может быть выполнен в транзакции. Если она существует,
  будет выброшено исключение.

2. **`isolation`** — уровень изоляции транзакции

определяет, как транзакция будет взаимодействовать с
другими параллельными транзакциями:

- **`DEFAULT`**: Используется уровень изоляции по умолчанию, настроенный в базе
  данных.
- **`READ_COMMITTED`**: Гарантирует, что данные, которые транзакция читает, были
  зафиксированы.
- **`READ_UNCOMMITTED`**: Разрешает чтение "грязных" данных (неподтвержденных
  другими транзакциями).
- **`REPEATABLE_READ`**: Гарантирует, что данные, которые были прочитаны, не
  изменятся в течение транзакции.
- **`SERIALIZABLE`**: Самый высокий уровень изоляции, при котором транзакции
  выполняются последовательно, исключая всякую параллельность.

3. **`timeout`** — время ожидания транзакции

позволяет задать максимальное время, в течение которого транзакция
должна быть завершена. Если транзакция не завершится за это время, она будет
откатана.

4. **`readOnly`** — режим только для чтения

Если транзакция не должна изменять данные (только читать), то можно пометить её
как **`readOnly`** для оптимизации. В некоторых случаях это позволяет базе
данных или другим компонентам системы оптимизировать выполнение транзакции.

5. **`rollbackFor` и `noRollbackFor`** — управление откатом

Эти атрибуты позволяют задать исключения, при которых транзакция будет откатана.

- **`rollbackFor`**: Указывает исключения, при которых транзакция должна быть
  откатана.
- **`noRollbackFor`**: Указывает исключения, при которых транзакция **не будет
  откатана**.

### Пример работы с несколькими транзакциями:

#### Можно ли вызывать метод с @Transactional из другого метода с @Transactional?

Да, можно вызывать метод с аннотацией `@Transactional` внутри другого метода,
также помеченного аннотацией `@Transactional`. Однако нужно учитывать несколько
важных моментов, чтобы это работало корректно.

##### 1. **Влияние уровня распространения транзакции (`Propagation`)**

- Если оба метода помечены аннотацией `@Transactional` и используют уровень
  распространения по умолчанию (`Propagation.REQUIRED`), то оба метода будут
  работать в одной и той же транзакции. Это означает, что если один из методов
  завершится с ошибкой, то транзакция будет откачена для обоих методов.
- Если же уровни распространения транзакции в этих методах отличаются, например,
  один использует `Propagation.REQUIRES_NEW` (создание новой транзакции), то для
  каждого метода будет своя отдельная транзакция, и ошибки в одном методе не
  повлияют на другую.

##### 2. **Важный момент: прокси и внутренняя вызовность**

- Важно понимать, что аннотация `@Transactional` работает через **прокси** (
  используется аспектно-ориентированное программирование, или AOP). Это
  означает, что транзакционная логика будет применяться только для **внешних
  вызовов методов**, то есть только когда метод вызывается из другого класса или
  из другого компонента.

Если метод с аннотацией `@Transactional` вызывается внутри того же класса (
например, из другого метода этого же класса), то транзакция **не будет**
корректно управляться. Это связано с тем, что прокси применяется только к
внешним вызовам, а внутри класса Java вызов метода будет обычным вызовом,
который не проходит через механизм транзакционного проксирования.

Чтобы это работало, необходимо, чтобы один метод был вызван **из другого
компонента** (например, с использованием Dependency Injection).

##### 3. **Пример: внутренний вызов**

В следующем примере метод `methodB` вызывает метод `methodA` внутри того же
класса, и это не приведет к созданию новой транзакции, так как транзакции будут
управляться только при внешнем вызове:

   ```java

@Service
public class MyService {

    @Transactional
    public void methodA() {
        // Транзакция начнется здесь
        methodB();  // Внутренний вызов, транзакция не будет проксирована
    }

    @Transactional
    public void methodB() {
        // Транзакция начнется здесь, но на самом деле она не будет работать
        // корректно, так как вызов был внутри того же класса.
    }
}
   ```

В данном случае `methodB` не будет транзакционным, потому что он вызван из того
же класса, и Spring не применит прокси-транзакцию.

##### 4. **Решение: использование инъекции зависимостей**

Чтобы транзакционная аннотация работала корректно при вызове метода из другого
метода в том же классе, вы должны инжектировать экземпляр текущего класса в тот
же класс (или использовать другой механизм). Пример:

   ```java

@Service
public class MyService {

    @Autowired
    private MyService self;  // инжекция самого себя

    @Transactional
    public void methodA() {
        // Транзакция начнется здесь
        self.methodB();  // Вызов через инжекцию приводит к правильному проксированию
    }

    @Transactional
    public void methodB() {
        // Транзакция будет правильно управляться
    }
}
   ```

Здесь `self.methodB()` вызовет метод через прокси, и транзакционная логика будет
корректно применена.

##### 5. **Пример с разными уровнями распространения транзакции**

Если вы хотите, чтобы один метод создал новую транзакцию, а другой использовал
уже существующую, вы можете использовать разные уровни распространения
транзакций.

   ```java

@Service
public class MyService {

    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // Транзакция начнется здесь
        methodB();  // Внутренний вызов, метод будет использовать ту же транзакцию
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // В методе будет создана новая транзакция, независимо от текущей
    }
}
   ```

В данном примере, метод `methodA` будет использовать транзакцию, если она
существует, а метод `methodB` будет создавать свою собственную транзакцию (в
случае использования `REQUIRES_NEW`).

##### **Заключение**

1. **Внешний вызов метода**: Если метод с аннотацией `@Transactional` вызывается
   из другого компонента, Spring правильно применяет транзакцию.
2. **Внутренний вызов метода**: Если метод с аннотацией `@Transactional`
   вызывается внутри того же класса, то транзакция не будет работать, так как
   транзакции управляются через прокси, а вызов метода внутри того же класса не
   приводит к проксированию.
3. **Использование разных уровней распространения** позволяет гибко управлять
   поведением транзакций при вызове методов.

Таким образом, если вы хотите использовать транзакции при вызове методов внутри
одного класса, нужно инжектировать сам класс (самого себя) и вызывать методы
через инжекцию, чтобы проксирование сработало.

#### Метод с аннотацией `@Transactional` из метода без этой аннотации?

Да, можно вызывать метод с аннотацией `@Transactional` из метода без этой
аннотации, и это будет работать, как ожидается, **при условии, что вызов
происходит из другого компонента** или другого слоя в приложении (например,
через Spring's Dependency Injection).

##### Как работает `@Transactional`:

Аннотация `@Transactional` работает на основе **прокси**, и транзакционное
поведение применяется только тогда, когда метод вызывается **вне зависимости**
от самого объекта, то есть через проксирование.

Если метод с аннотацией `@Transactional` вызывается из другого метода, который
находится в другом классе или через Spring инъекцию, то Spring создаст прокси
для этого метода и обеспечит правильное управление транзакциями.

##### Важные моменты:

1. **Внешний вызов метода**: Когда вы вызываете метод, помеченный аннотацией
   `@Transactional`, из метода без аннотации `@Transactional`, и этот вызов
   происходит через Spring (например, через инъекцию зависимостей), то
   транзакция будет создана и управляться для вызова этого метода. Метод,
   который не аннотирован `@Transactional`, не будет автоматически участвовать в
   транзакции. Однако сам вызов метода с `@Transactional` будет обработан
   Spring, и транзакция будет работать корректно.

2. **Внутренний вызов метода**: Важно заметить, что если метод с
   `@Transactional` вызывается внутри того же класса, это не приведет к
   корректному применению транзакции, так как прокси работает только для
   внешних вызовов. Если же метод с аннотацией вызывается из другого класса,
   например, через инъекцию зависимостей, то транзакция будет работать, как
   ожидалось.

##### Пример: Вызов метода с `@Transactional` из метода без этой аннотации

```java

@Service
public class MyService {

    @Autowired
    private AnotherService anotherService;  // Другой сервис с транзакционным методом

    public void methodWithoutTransaction() {
        // Этот метод не будет транзакционным, но вызовет метод с @Transactional
        anotherService.methodWithTransaction();
    }
}

@Service
public class AnotherService {

    @Transactional
    public void methodWithTransaction() {
        // Этот метод будет выполняться в рамках транзакции
        System.out.println("This method is transactional.");
    }
}
```

В данном примере:

- `methodWithoutTransaction()` не имеет аннотации `@Transactional`, но вызывает
  метод `methodWithTransaction()`, который помечен как транзакционный.
- Поскольку вызов `methodWithTransaction()` происходит через инъекцию
  зависимостей (то есть это внешний вызов), транзакция будет корректно
  управляться Spring для метода `methodWithTransaction()`.

##### Важное ограничение:

- **Внутренний вызов**: Если вы вызовете метод с аннотацией `@Transactional` из
  другого метода **в том же классе**, транзакция не будет корректно применена.
  Прокси транзакций в Spring работает только для **внешних** вызовов, то есть
  вызов должен происходить через Spring (например, через инъекцию зависимостей).

Пример, где транзакция **не будет работать**:

```java

@Service
public class MyService {

    @Transactional
    public void methodWithTransaction() {
        // Транзакция начнется здесь
        methodWithoutTransaction();  // Вызов из того же класса, транзакция не будет применена
    }

    public void methodWithoutTransaction() {
        // Этот метод не будет транзакционным
    }
}
```

В этом случае, вызов `methodWithoutTransaction()` из `methodWithTransaction()`
не приведет к транзакционному поведению, так как вызов происходит внутри того же
класса, и прокси не срабатывает.

#### Заключение:

- **Да**, можно вызывать метод с аннотацией `@Transactional` из метода, не
  помеченного этой аннотацией, если вызов происходит через Spring (например,
  через инъекцию зависимостей).
- Однако **если метод с аннотацией `@Transactional` вызывается внутри того же
  класса**, транзакция не будет применяться, так как прокси применяется только к
  внешним вызовам.

Поэтому всегда учитывайте, что Spring применяет проксирование только к **внешним
вызовам**.

### Работа аннотации @Transactional шаг за шагом

#### Что происходит, когда ты пишешь `@Transactional`

```java

@Service
public class OrderService {

    @Transactional
    public void createOrder() {
        // 1. Начинаем транзакцию
        // 2. Выполняем SQL/ORM операции
        // 3. Коммит или откат
    }
}
```

Ты вроде написал всего одну аннотацию, а на самом деле запускается целый
механизм:

#### Шаг за шагом — как это работает

##### **1. Spring создает прокси**

Когда Spring видит аннотацию `@Transactional`, он не просто использует твой
класс напрямую, а **создает обёртку** (прокси), которая перехватывает вызовы
методов и добавляет транзакционную логику.

- Если ты используешь интерфейсы — применяется **JDK proxy**.
- Если нет интерфейсов — используется **CGLIB proxy** (динамическое
  наследование).

> Это важно: внутренние вызовы методов не проходят через прокси — именно поэтому
`@Transactional` может не сработать, если вызвать метод изнутри того же класса.

##### **2. Прокси перехватывает вызов метода**

Когда ты вызываешь `createOrder()`, на самом деле вызывается:

```
proxy.createOrder();
```

И тут Spring делает следующее:

**Проверка контекста транзакции:**

- Есть ли уже активная транзакция?
    - Если **да**, и `Propagation` = `REQUIRED` — используем её.
    - Если `REQUIRES_NEW` — **приостанавливаем текущую**, начинаем новую.
    - Если `NOT_SUPPORTED` — **приостанавливаем текущую** и выполняем без
      транзакции.
    - И т.д.

**Вызов `TransactionManager`:**

- Выбирается нужный `PlatformTransactionManager`.
- Вызывается метод `getTransaction()` -> начинается транзакция.

##### **3. Выполняется твой метод**

Теперь вызывается **реальный** метод `createOrder()`.

##### **4. Коммит или откат**

После завершения метода:

- Если всё прошло без исключений → `commit`.
- Если было `RuntimeException` или `Error` → `rollback`.

> По умолчанию Spring откатывает **только unchecked exceptions** (например,
`RuntimeException`). Для checked-исключений (`IOException`, `SQLException`) —
> нужно указать явно:

```java
@Transactional(rollbackFor = IOException.class)
```

##### **5. Завершение**

Текущая транзакция закрывается, и Spring "возвращает" выполнение дальше.

**Пример жизненного цикла**

```java

@Transactional
public void process() {
    dao.save();
    dao.update();
    if (someConditionFails()) {
        throw new RuntimeException("Oops");
    }
}
```

**Под капотом:**

1. `TransactionManager.begin()` — старт
2. `save()` и `update()` вызываются внутри транзакции
3. Если исключение — `rollback`
4. Если всё ок — `commit`

#### Подводные камни

- **Внутренний вызов метода** — не работает, транзакция не включится.
- **Не те исключения** — если не RuntimeException, то откат не произойдёт.
- **Неправильный уровень распространения (`Propagation`)** — можно нечаянно
  вложить транзакции или потерять их.

## ACID

**ACID** — это набор четырёх принципов, которые гарантируют, что транзакции в
**системах управления базами данных (СУБД)** выполняются корректно и с
сохранением **целостности** данных, даже в случае сбоев или ошибок.

ACID — это аббревиатура, расшифровывается как:

1. **A** — **Atomicity** (Атомарность)
2. **C** — **Consistency** (Согласованность)
3. **I** — **Isolation** (Изоляция)
4. **D** — **Durability** (Долговечность)

Каждый из этих принципов играет важную роль в обеспечении корректной работы
транзакций в базе данных.

### 1. **Atomicity** (Атомарность)

**Атомарность** означает, что транзакция рассматривается как **единое целое**,
которое либо выполняется полностью, либо не выполняется вообще. Если в процессе
выполнения транзакции произошла ошибка, все изменения, сделанные в рамках
транзакции, будут откатаны, и база данных вернется в состояние, которое было до
её начала.

- **Пример**: Если транзакция включает в себя два действия, например, перевод
  денег с одного счёта на другой, и при этом происходит сбой при снятии денег,
  то операция будет отменена, и деньги не будут сняты.

### 2. **Consistency** (Согласованность)

**Согласованность** гарантирует, что транзакция переводит базу данных из одного
**консистентного состояния** в другое, соблюдая все бизнес-правила, ограничения
и инварианты, заданные для данных. Если транзакция завершена успешно, база
данных должна оставаться в консистентном состоянии. В случае сбоя транзакция не
должна приводить к нарушению целостности данных.

- **Пример**: Если в базе данных есть ограничения, например, на уникальность
  идентификаторов или на значения валюты, то транзакция должна быть такой, чтобы
  после её выполнения эти ограничения не нарушались.

### 3. **Isolation** (Изоляция)

**Изоляция** гарантирует, что транзакции выполняются независимо друг от друга, и
их результаты не могут быть видны другим транзакциям до завершения. Это
означает, что одна транзакция не может "увидеть" изменения, сделанные другой
транзакцией, если эта другая транзакция ещё не завершена (в зависимости от
уровня изоляции транзакций).

- **Пример**: Если две транзакции одновременно пытаются изменить один и тот же
  объект, одна из них должна быть заблокирована до завершения другой, чтобы
  избежать конфликтов и несогласованности данных.

### 4. **Durability** (Долговечность)

**Долговечность** гарантирует, что как только транзакция завершена (коммичена),
все её изменения будут сохранены в базе данных и не будут потеряны, даже если
произойдёт сбой системы, например, сбой питания или отключение компьютера.

- **Пример**: После того как вы перевели деньги на счёт другого человека,
  изменения должны остаться в базе данных даже если сервер упадет сразу после
  завершения транзакции.

## Уровни изоляции транзакций

**Уровни изоляции транзакций** — это ключевая концепция в работе с базами
данных, которая определяет, как транзакции взаимодействуют друг с другом и как
их операции влияют на данные в условиях параллельного выполнения. Эти уровни
обеспечивают баланс между **производительностью** и **согласованностью** данных.

В **SQL** и **Spring** есть несколько стандартных уровней изоляции, которые
контролируют, насколько одна транзакция может «видеть» изменения, сделанные
другими транзакциями. Чем выше уровень изоляции, тем больше ограничений
накладывается на параллельные транзакции, чтобы избежать **нежелательных
эффектов**, но это может снижать производительность.

### Уровни изоляции транзакций

1. **READ UNCOMMITTED** (Чтение неподтвержденных данных)
2. **READ COMMITTED** (Чтение только подтвержденных данных)
3. **REPEATABLE READ** (Повторяемое чтение)
4. **SERIALIZABLE** (Сериализуемый)

### 1. **READ UNCOMMITTED** (Чтение неподтвержденных данных)

- этот уровень изоляции позволяет транзакциям читать данные, которые еще не были
  зафиксированы другими транзакциями. Это может привести к **грязным чтениям**
  (dirty reads), когда транзакция читает данные, которые могут быть отменены,
  если транзакция, изменившая их, будет откатана.

- **Проблемы:**
    - **Грязные чтения**: Транзакция может читать данные, которые могут быть
      откатаны, что приведет к недостоверной информации.
    - **Невозможность гарантировать консистентность**.

- **Когда использовать?**
  Этот уровень обычно используется, если необходимо получить **высокую
  производительность**, но если допустимы **неполные или неточные данные** (
  например, для отчетности, где точность не так критична).

### 2. **READ COMMITTED** (Чтение только подтвержденных данных)

- транзакции могут читать только те данные, которые были **подтверждены**
  другими транзакциями (т.е. изменения, сделанные транзакциями, которые уже
  завершились, будут видны). Однако, если другая транзакция меняет данные во
  время чтения, текущая транзакция может получить разные данные при последующих
  чтениях одних и тех же строк (так называемое **неповторяемое чтение**).

- **Проблемы:**
    - **Неповторяемое чтение**: Транзакция может получить разные результаты при
      нескольких чтениях одних и тех же данных, если другая транзакция изменила
      их между чтениями.

- **Когда использовать?**
  Этот уровень изоляции — хороший компромисс между производительностью и
  консистентностью для большинства приложений, где требуется, чтобы транзакции
  не видели неподтвержденные изменения.

### 3. **REPEATABLE READ** (Повторяемое чтение)

- Этот уровень изоляции гарантирует, что данные, считанные транзакцией, не могут
  быть изменены другими транзакциями до завершения текущей транзакции.
  Транзакция не столкнется с **неповторяемыми чтениями**: если она прочитала
  данные, эти данные не изменятся, пока транзакция не завершится.

- **Проблемы:**
    - **Фантомные чтения**: Транзакция может столкнуться с ситуацией, когда
      новые строки данных появляются в результате других транзакций, несмотря на
      то, что сама транзакция видит стабильные данные.

- **Когда использовать?**
  Этот уровень подходит для приложений, где важно, чтобы данные, прочитанные в
  транзакции, оставались неизменными на протяжении всей транзакции. Например, в
  системах бронирования или финансовых приложениях, где важно, чтобы транзакция
  не "потеряла" информацию о том, что она уже прочитала.

### 4. **SERIALIZABLE** (Сериализуемый)

- Самый высокий уровень изоляции. Транзакции выполняются **по очереди**: каждая
  транзакция выполняется так, как если бы она была единственной в системе, и ее
  действия не могут пересекаться с действиями других транзакций. Это
  предотвращает **грязные чтения**, **неповторяемые чтения** и **фантомные
  чтения**.

- **Проблемы:**
    - **Производительность**: Это может значительно замедлить систему, потому
      что транзакции будут работать поочередно, а не параллельно.
    - **Блокировки**: Весь ряд данных, с которым работает транзакция, будет
      заблокирован для других, что может сильно снизить производительность
      системы при высокой нагрузке.

- **Когда использовать?**
  Используется, когда **требуется абсолютная консистентность** данных и при этом
  возможны **высокие задержки**. Например, в банковских системах или системах,
  где критически важна корректность финансовых данных.

### Таблица уровней изоляции

| Уровень изоляции     | Грязные чтения | Неповторяемое чтение | Фантомные чтения | Пример применения                |
|----------------------|----------------|----------------------|------------------|----------------------------------|
| **READ UNCOMMITTED** | Разрешены      | Разрешены            | Разрешены        | Внешняя отчетность               |
| **READ COMMITTED**   | Запрещены      | Разрешены            | Разрешены        | Большинство веб-приложений       |
| **REPEATABLE READ**  | Запрещены      | Запрещены            | Разрешены        | Финансовые приложения            |
| **SERIALIZABLE**     | Запрещены      | Запрещены            | Запрещены        | Критические системы (банковские) |

### Как установить уровень изоляции транзакции в Spring?

В Spring можно настроить уровень изоляции через аннотацию `@Transactional`,
используя атрибут `isolation`.

Пример:

```java
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

@Transactional(isolation = Isolation.SERIALIZABLE)
public void someMethod() {
    // Код, который будет выполнен с самым высоким уровнем изоляции
}
```

В Spring доступны следующие значения для **`Isolation`**:

- `Isolation.DEFAULT` — используется уровень изоляции по умолчанию (обычно это
  `READ_COMMITTED`).
- `Isolation.READ_UNCOMMITTED` — позволяет читать неподтвержденные данные.
- `Isolation.READ_COMMITTED` — запрещает грязные чтения.
- `Isolation.REPEATABLE_READ` — гарантирует отсутствие неповторяемых чтений.
- `Isolation.SERIALIZABLE` — самый строгий уровень изоляции.

### Резюме:

1. **`READ UNCOMMITTED`** — самый слабый уровень, позволяет грязные чтения.
2. **`READ COMMITTED`** — запрещает грязные чтения, но не исключает
   неповторяемые чтения.
3. **`REPEATABLE READ`** — гарантирует отсутствие неповторяемых чтений, но не
   защищает от фантомных чтений.
4. **`SERIALIZABLE`** — самый строгий уровень изоляции, исключает все виды
   конфликтов, но может сильно снижать производительность.

Выбор уровня изоляции зависит от потребностей вашего приложения: если вам нужно
**повышение производительности**, можно использовать **READ COMMITTED** или
**READ UNCOMMITTED**; если важна **абсолютная консистентность** данных, лучше
выбрать **SERIALIZABLE**.

## Проблемы, связанные с уровнями изоляции

Каждый уровень изоляции транзакций в базах данных имеет свои преимущества
и недостатки. При настройке уровней изоляции важно учитывать баланс между
**производительностью** и **целостностью данных**. Хотя более строгие уровни
изоляции обеспечивают большую консистентность данных, они могут привести к
потере производительности и другим проблемам, таким как блокировки и мёртвые
блокировки.

Основные проблемы, связанные с уровнями изоляции:

### 1. Потерянное обновление (lost update)

- при одновременном изменении одного блока данных разными транзакциями теряются
  все изменения, кроме последнего. Т.е. в этом случае одна транзакция
  переписывает изменения, осуществленные другой транзакцией, в результате одно
  из изменений будет утеряно;

### 2. **Грязные чтения (Dirty Reads)** — **`READ UNCOMMITTED`**

**Грязные чтения** происходят, когда одна транзакция читает данные,
которые были изменены другой транзакцией, но ещё не зафиксированы.

Это может привести к ошибочным или некорректным данным, так как данные,
прочитанные одной транзакцией, могут быть отменены другой.

Транзакция A считывает данные, которые были изменены транзакцией B, но
транзакция B откатывает изменения. Транзакция A использует некорректные
данные.

- **Решение**: Использовать более строгие уровни изоляции, такие как *
  *`READ COMMITTED`** или выше, чтобы исключить грязные чтения.

### 3. **Неповторяемое чтение (Non-repeatable Read)** — **`READ COMMITTED`**

Когда в одной и той же транзакции значение одной и той же строки при повторном
чтении меняется, потому что другая транзакция изменила и закоммитила эту строку

Решение: Использование уровня изоляции `REPEATABLE READ` или
`SERIALIZABLE` для блокировки данных и предотвращения их изменения другими
транзакциями.

### 4. **Фантомные чтения (Phantom Reads)** — **`REPEATABLE READ`**

**Фантомные чтения** происходят, когда в одной транзакции выполняется одинаковый
SELECT, возвращающий набор строк, и во втором чтении появляются новые строки,
которых раньше не было, потому что другая транзакция их вставила/удалила.

- **Проблема**:
    - Из-за изменения данных другим пользователем (добавление или удаление
      строк) результат выборки может измениться, что приводит к *
      *непредсказуемости** или **несогласованности данных**.

- **Пример**:
    - Транзакция A выполняет запрос для выборки всех заказов на сумму более 100
      долларов и получает 3 строки. В то время как транзакция A работает,
      транзакция B добавляет новый заказ на сумму 150 долларов. После завершения
      транзакции A тот же запрос даёт 4 строки, включая новый заказ.

- **Решение**: Использование уровня изоляции **`SERIALIZABLE`**, который
  блокирует изменения в наборе строк данных во время работы транзакции.

### 5. Мёртвая блокировка (Deadlock) — `SERIALIZABLE` и `REPEATABLE READ`

- **Что это?**
    - **Мёртвая блокировка** возникает, когда две или более транзакции блокируют
      друг друга, ожидая ресурсы, занятые другими транзакциями, образуя **цикл
      зависимостей**. Это приводит к тому, что транзакции не могут завершиться,
      и система остаётся в состоянии блокировки.

- **Проблема**:
    - Когда транзакции не могут быть выполнены, это может привести к **потере
      производительности** и **висению** системы, так как транзакции никогда не
      завершатся.

- **Пример**:
    - Транзакция A блокирует строку 1, а транзакция B блокирует строку 2.
      Транзакция A пытается получить блокировку на строку 2, а транзакция B
      пытается заблокировать строку 1. Обе транзакции ожидают друг друга, что
      приводит к **мёртвой блокировке**.

- **Решение**: Использование таймаутов, а также грамотная организация
  порядка блокировок и использование **уровней изоляции**, минимизирующих
  необходимость в блокировках (например, **`READ COMMITTED`**).

### 6. **Проблемы с производительностью** — **`SERIALIZABLE`**

- **Что это?**
    - Уровень изоляции **`SERIALIZABLE`** представляет собой самый строгий
      уровень изоляции и блокирует все данные, с которыми работает транзакция.
      Это может привести к значительным **потерям производительности**, так как
      транзакции становятся последовательными, и система не может эффективно
      использовать многозадачность.

- **Проблема**:
    - **Медленная работа** системы, поскольку транзакции ожидают друг друга, что
      значительно снижает **пропускную способность** и **конкурентность**.

- **Решение**: Использование более слабых уровней изоляции, таких как *
  *`READ COMMITTED`** или **`REPEATABLE READ`**, в зависимости от потребностей
  приложения.

### 7. **Иллюзия согласованности (Phantom Read + Dirty Read)** — *

*`READ UNCOMMITTED`**

- **Что это?**
    - Когда транзакции выполняются с уровнем изоляции **`READ UNCOMMITTED`**,
      могут возникать не только грязные чтения, но и иллюзия согласованности
      данных. Например, транзакция может видеть изменения данных, которые будут
      отменены или изменены другой транзакцией.

- **Проблема**:
    - Это может привести к **некорректным решениям** или действиям, основанным
      на данных, которые не являются истинными (например, неправильные расчеты
      или отчеты).

- **Решение**: Повышение уровня изоляции транзакций до **`READ COMMITTED`** или
  выше для предотвращения грязных чтений и повышения надёжности работы с
  данными.

### 🔧 **Резюме: Проблемы и решения**

| Проблема                           | Уровень изоляции   | Описание проблемы                                               | Рекомендация                                       |
|------------------------------------|--------------------|-----------------------------------------------------------------|----------------------------------------------------|
| **Грязные чтения**                 | `READ UNCOMMITTED` | Чтение неподтвержденных данных.                                 | Использовать `READ COMMITTED` или выше.            |
| **Неповторяемое чтение**           | `READ COMMITTED`   | Изменение данных между чтениями одной транзакции.               | Использовать `REPEATABLE READ` или выше.           |
| **Фантомные чтения**               | `REPEATABLE READ`  | Изменение набора данных (добавление/удаление строк).            | Использовать `SERIALIZABLE`.                       |
| **Мёртвая блокировка**             | Все уровни         | Транзакции блокируют друг друга, ожидая освобождения ресурсов.  | Использовать таймауты и упорядочивание блокировок. |
| **Проблемы с производительностью** | `SERIALIZABLE`     | Очень строгие блокировки могут замедлить систему.               | Использовать более слабые уровни изоляции.         |
| **Иллюзия согласованности**        | `READ UNCOMMITTED` | Невозможность корректно работать с промежуточными результатами. | Использовать `READ COMMITTED` или выше.            |

Выбор уровня изоляции зависит от **конкретных требований** к приложению. Для
большинства приложений достаточно **`READ COMMITTED`** или **`REPEATABLE READ`
**, но для критичных данных (например, в банковских системах) лучше использовать
**`SERIALIZABLE`** с учётом того, что это может снизить производительность.


> ## Kafka про партиции чуть лучше



> ## SQL. Индексы в SQL

Индексы в **SQL** — это структуры данных, которые улучшают производительность
операций поиска в базе данных, а также позволяют эффективно выполнять сортировку
и фильтрацию данных. Они создаются для улучшения скорости извлечения данных,
особенно когда таблицы становятся большими.

В SQL существует несколько типов индексов, каждый из которых имеет свои
особенности и применяется в зависимости от задач и структуры данных.

### 1. **Первичный индекс (Primary Index)**

- **Описание**: Это индекс, который автоматически создается для столбца (или
  столбцов), помеченных как **PRIMARY KEY**. Он гарантирует уникальность
  значений в столбце или группе столбцов.
- **Особенности**:
    - Таблица может иметь только один первичный индекс.
    - Он всегда уникален и не может содержать `NULL` значения.
    - Первичный индекс обычно является кластеризованным (см. ниже).
- **Пример**:
  ```sql
  CREATE TABLE users (
      user_id INT PRIMARY KEY,
      username VARCHAR(50),
      email VARCHAR(100)
  );
  ```

### 2. **Кластеризованный индекс (Clustered Index)**

- **Описание**: Кластеризованный индекс определяет физический порядок строк в
  таблице. Когда вы создаете кластеризованный индекс, данные таблицы будут
  отсортированы в соответствии с этим индексом. Как правило, в таблице может
  быть только один кластеризованный индекс.
- **Особенности**:
    - Обычно первичный ключ автоматически создаёт кластеризованный индекс.
    - Если кластеризованный индекс присутствует, строки таблицы хранятся в
      порядке, соответствующем этому индексу.
- **Пример**:
  ```sql
  CREATE CLUSTERED INDEX idx_user_id ON users(user_id);
  ```

### 3. **Некластеризованный индекс (Non-clustered Index)**

- **Описание**: Это обычный индекс, который хранит указатели на строки в
  таблице, но не изменяет физический порядок данных в таблице. Он работает как
  отдельная структура, которая хранит ключи и ссылки на строки.
- **Особенности**:
    - Один столбец или несколько столбцов могут быть индексированы.
    - Может быть создано несколько некластеризованных индексов на одной таблице.
- **Пример**:
  ```sql
  CREATE NONCLUSTERED INDEX idx_username ON users(username);
  ```

### 4. **Уникальный индекс (Unique Index)**

- **Описание**: Этот индекс гарантирует, что все значения в индексируемом
  столбце или группе столбцов будут уникальными, то есть не будет дублирующихся
  значений.
- **Особенности**:
    - Он создаётся автоматически, когда на столбец накладывается ограничение
      **UNIQUE**.
    - Может быть кластеризованным или некластеризованным.
- **Пример**:
  ```sql
  CREATE UNIQUE INDEX idx_email ON users(email);
  ```

### 5. **Индекс полного текста (Full-text Index)**

- **Описание**: Этот индекс используется для быстрого поиска текстовой
  информации в больших текстовых полях (например, в статьях или комментариях).
  Он позволяет выполнять полнотекстовый поиск, который учитывает не только
  точные совпадения, но и слова, синонимы, морфологию.
- **Особенности**:
    - Полнотекстовые индексы создаются на столбцах, которые содержат текстовые
      данные.
    - Используется для запросов с операторами типа `MATCH ... AGAINST`.
- **Пример**:
  ```sql
  CREATE FULLTEXT INDEX idx_fulltext_content ON articles(content);
  ```

### 6. **Индекс с битовыми картами (Bitmap Index)**

- **Описание**: Индекс с битовой картой используется для эффективного поиска в
  столбцах с небольшим количеством уникальных значений (например, в столбцах с
  флагами или перечислениями).
- **Особенности**:
    - Хорошо подходит для столбцов с небольшим числом уникальных значений,
      например, для флагов (т.е. `YES`/`NO`, `TRUE`/`FALSE`).
    - Быстрее, чем обычный индекс, для чтения, но медленнее при обновлениях или
      вставках.
- **Пример**:
  ```sql
  CREATE BITMAP INDEX idx_is_active ON users(is_active);
  ```

### 7. Индекс на основе B-дерева

### 8. Hash индекс

### 9. **Индекс для нескольких столбцов (Composite Index)**

- **Описание**: Этот индекс создаётся для нескольких столбцов одновременно. Он
  помогает ускорить запросы, которые фильтруют данные по нескольким столбцам
  одновременно.
- **Особенности**:
    - Используется для комбинированных запросов, которые включают несколько
      условий.
        - Индекс будет эффективным только для тех запросов, использующих  
          столбцы в том порядке, в котором они были определены в индексе.
- **Пример**:
  ```sql
  CREATE INDEX idx_username_email ON users(username, email);
  ```

### **Как выбирать индекс для своей базы данных?**

1. **Производительность чтения vs записи**: Индексы значительно ускоряют
   операции чтения (поиск, фильтрация, сортировка), но замедляют операции
   записи (вставка, обновление, удаление), так как они требуют обновления самого
   индекса. Поэтому нужно тщательно подбирать, какие столбцы индексировать.
2. **Тип данных**: Некоторые индексы лучше подходят для работы с текстовыми
   данными (например, полнотекстовый индекс), другие — с числовыми или булевыми
   значениями (например, битовые индексы).
3. **Размер таблицы**: Для очень больших таблиц индексы становятся
   необходимостью для ускорения запросов.
4. **Тип запросов**: Индексы помогают при выполнении запросов с фильтрацией,
   сортировкой или объединениями по индексированным столбцам.

### **Заключение**

Индексы в SQL играют важную роль в повышении производительности запросов,
особенно при работе с большими объемами данных. Различные типы индексов
предоставляют разные преимущества в зависимости от типа данных и структуры
запросов, которые выполняются в базе данных. Выбор правильного типа индекса и
грамотное управление ими может значительно улучшить производительность системы.

=====================================================================
> ## Hibernate. Стратегии генерирования id

В Hibernate существует несколько **стратегий генерации идентификаторов (ID)**,
которые определяют, как создаются значения для первичных ключей сущностей. Эти
стратегии задаются с помощью аннотации `@GeneratedValue` и параметра `strategy`.

### Основные стратегии генерации ID

1. `GenerationType.AUTO`

- 📌 **Hibernate сам выбирает стратегию** в зависимости от диалекта базы данных.
- Может выбрать `IDENTITY`, `SEQUENCE`, `TABLE`, в зависимости от СУБД.

```java

@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;
```

2. `GenerationType.IDENTITY`

- Использует **автоинкремент** (`AUTO_INCREMENT`, `IDENTITY`) на уровне базы
  данных.
- Подходит для MySQL, SQL Server.

```java

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

🟡 **Минусы**:

- ID генерируется **только при insert**, не работает с batch inserts.
- Не кэшируется Hibernate’ом.


3. `GenerationType.SEQUENCE`

- Использует **sequence** из базы данных (обычно в PostgreSQL, Oracle).
- Позволяет Hibernate **предсказывать** следующий ID и кэшировать.

```java

@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq_gen")
@SequenceGenerator(name = "seq_gen", sequenceName = "my_seq", allocationSize = 1)
private Long id;
```

🟢 **Плюсы**:

- Можно настраивать `allocationSize` для пакетной генерации.
- Идеально для PostgreSQL.


4. `GenerationType.TABLE`

- Создаёт **отдельную таблицу** для хранения текущего значения ID.
- Работает в любой СУБД.

```java

@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = "tbl_gen")
@TableGenerator(name = "tbl_gen", table = "id_table", pkColumnName = "key_name",
        valueColumnName = "next_val", pkColumnValue = "my_entity", allocationSize = 1)
private Long id;
```

🔴 **Минусы**:

- Самая **медленная стратегия**, потому что требует обращения к специальной
  таблице.
- Используется, если нет поддержки `SEQUENCE` или `IDENTITY`.

---

## 🧠 Альтернативы:

- **UUID / GUID**:
  ```java
  @Id
  @GeneratedValue(generator = "uuid2")
  @GenericGenerator(name = "uuid2", strategy = "uuid2")
  private UUID id;
  ```

- **Custom генераторы**:
    - Можно реализовать собственную стратегию генерации через
      `IdentifierGenerator`.

---

## 🔍 Как выбрать стратегию?

| Ситуация                              | Рекомендуемая стратегия      |
|---------------------------------------|------------------------------|
| MySQL / SQL Server                    | `IDENTITY`                   |
| PostgreSQL / Oracle                   | `SEQUENCE`                   |
| Кросс-БД совместимость                | `TABLE` или `AUTO`           |
| Используешь UUID                      | `uuid2` / `uuid`             |
| Нужен контроль / нестандартная логика | `Custom IdentifierGenerator` |

---

================================================================================

> ## Hibernate. тип загрузки (fetching strategy)** для связанных сущностей в JPA


Отлично, давай подробно разберёмся, что такое **тип загрузки (fetching strategy)
** для связанных сущностей в JPA / Hibernate — это ключевой момент для
производительности и правильной работы с данными.

---

## 📦 Что такое Fetching Strategy?

**Fetching strategy** — это способ, которым **Hibernate загружает связанные
сущности** из базы данных при обращении к основному объекту.

Есть два типа:

| Тип загрузки       | Описание                                                              |
|--------------------|-----------------------------------------------------------------------|
| **LAZY** (ленивая) | Связанная сущность загружается **только при первом обращении** к ней. |
| **EAGER** (жадная) | Связанная сущность загружается **сразу вместе с родительской**.       |

---

## 🔍 Где это используется?

В аннотациях связей:

```java
@OneToMany(fetch = FetchType.LAZY)
@ManyToOne(fetch = FetchType.EAGER)
```

---

## 🧪 Пример

```java

@Entity
public class User {
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders;
}
```

- Когда ты загружаешь `User`, `orders` **не будут загружены**.
- Они загрузятся **только при вызове `user.getOrders()`**.

---

## 📊 Сравнение: LAZY vs EAGER

| Параметр                | LAZY                                               | EAGER                                      |
|-------------------------|----------------------------------------------------|--------------------------------------------|
| Когда загружается?      | При первом доступе к полю                          | Сразу, при загрузке объекта                |
| Производительность      | Лучше, если данные не нужны                        | Может тянуть ненужные данные               |
| Количество SQL-запросов | Больше (при обращении к полю)                      | Меньше (если данные нужны сразу)           |
| Возможные ошибки        | `LazyInitializationException`, если сессия закрыта | Нет ошибок, но можно грузить слишком много |

---

## 🔄 Как подгрузить связанные сущности вручную?

1. **`JOIN FETCH` в JPQL**:

```java
SELECT u
FROM User
u JOIN
FETCH u.
orders WHERE
u.id =:id
```

2. **EntityGraph**:

```java

@EntityGraph(attributePaths = {"orders"})
User user = em.find(User.class, id, hints);
```

3. **Hibernate.initialize()**:

```java
Hibernate.initialize(user.getOrders());
```

(работает только в открытой сессии)

---

## 📘 По умолчанию:

| Связь         | Тип загрузки по умолчанию |
|---------------|---------------------------|
| `@ManyToOne`  | `EAGER`                   |
| `@OneToOne`   | `EAGER`                   |
| `@OneToMany`  | `LAZY`                    |
| `@ManyToMany` | `LAZY`                    |

---

## ✅ Рекомендации

- Всегда **используй LAZY по умолчанию**, и **подгружай явно**, когда нужно.
- Используй **JOIN FETCH** или **DTO**-проекцию, чтобы избежать N+1.
- Не забывай про `@Transactional`, если используешь LAZY в сервисах.

=========================================================================

## Сравнение EAGER и LAZY

Отличный вопрос! В контексте **Hibernate (и JPA)** термины `eager` и `lazy`
относятся к **типу загрузки (fetching strategy)** связанных сущностей.

---

## 📦 Что такое `EAGER` и `LAZY`?

Они определяют, **когда Hibernate загружает связанные данные** из базы данных:

| Стратегия | Описание                                                       |
|-----------|----------------------------------------------------------------|
| **LAZY**  | Загрузка **по требованию**, только когда реально используется. |
| **EAGER** | Загрузка **сразу**, вместе с родительским объектом.            |

---

## 📘 Пример

Представим, есть сущность `User` и у него есть список `orders`.

```java

@Entity
public class User {
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY) // или EAGER
    private List<Order> orders;
}
```

---

## 🐢 `LAZY` (ленивая загрузка)

- `orders` не загружается при загрузке `User`.
- Загружается **только при первом доступе к `getOrders()`**.
- Подходит, если тебе **не всегда нужны связанные данные**.

```java
User user = entityManager.find(User.class, 1L); // SELECT * FROM users WHERE id = 1;
List<Order> orders = user.getOrders();         // <-- В этот момент SELECT * FROM orders ...
```

---

## ⚡ `EAGER` (жадная загрузка)

- `orders` загружается **сразу** вместе с `User`.
- Даже если ты **не используешь `orders`**, Hibernate всё равно подгрузит их.

```java
User user = entityManager.find(User.class, 1L);
// Выполнится JOIN-запрос или два отдельных SELECT’а
```

---

## 📊 Сравнение

| Особенность                                               | `LAZY`                             | `EAGER`                         |
|-----------------------------------------------------------|------------------------------------|---------------------------------|
| Производительность                                        | 🔼 Лучше (если не нужна коллекция) | 🔽 Может тянуть ненужные данные |
| Управление запросами                                      | ✅ Гибко                            | ❌ Меньше контроля               |
| Риск `LazyInitializationException`                        | ❌ Есть (если сессия закрыта)       | ✅ Нет                           |
| Используется по умолчанию для `@OneToMany`, `@ManyToMany` | ✅ Да (`LAZY`)                      | ❌ Нет (`EAGER` вручную)         |

---

## ⚠️ Важные нюансы

- Hibernate **по умолчанию делает `LAZY`** для коллекций (`@OneToMany`,
  `@ManyToMany`) и **`EAGER`** для одиночных ссылок (`@ManyToOne`, `@OneToOne`).
- У **`LAZY` загрузки есть риск**: если сессия уже закрыта, доступ к полю
  вызовет `LazyInitializationException`.

---

## 🛠️ Как защититься от `LazyInitializationException`?

- Используй `JOIN FETCH` в HQL/JPQL.
- Используй DTO и `EntityGraph`.
- Загружай данные внутри открытой транзакции (например, в `@Transactional`
  методе).

---

Хочешь пример с
`JOIN FETCH` или как правильно подгрузить LAZY-поле в контроллере?
===============================================================================

> ## Стратегии связывания сущностей

Отличный вопрос! В **Hibernate / JPA** стратегии связывания сущностей
определяются через аннотации отношений между объектами, и отвечают на вопрос: *
*как одна сущность связана с другой?** И как эта связь хранится в базе данных.

---

## 🔗 Основные типы связей между сущностями

| Тип связи     | Описание         | Примеры                     |
|---------------|------------------|-----------------------------|
| `@OneToOne`   | Один к одному    | У пользователя один профиль |
| `@OneToMany`  | Один ко многим   | Один автор — много книг     |
| `@ManyToOne`  | Многие к одному  | Много заказов — один клиент |
| `@ManyToMany` | Многие ко многим | Пользователи и роли         |

---

### Примеры аннотаций

#### 1. **@OneToOne**

```java

@Entity
public class User {
    @OneToOne
    @JoinColumn(name = "profile_id")
    private Profile profile;
}
```

> В базе: `user.profile_id → profile.id`

#### 2. **@OneToMany / @ManyToOne**

```java

@Entity
public class Author {
    @OneToMany(mappedBy = "author")
    private List<Book> books;
}

@Entity
public class Book {
    @ManyToOne
    @JoinColumn(name = "author_id")
    private Author author;
}
```

> В таблице `book` есть колонка `author_id`

---

#### 3. **@ManyToMany**

```java

@Entity
public class Student {
    @ManyToMany
    @JoinTable(
            name = "student_course",
            joinColumns = @JoinColumn(name = "student_id"),
            inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
}
```

> 🧠 Связь через промежуточную таблицу `student_course(student_id, course_id)`

---

## 🧩 Стратегии каскадирования (`cascade`)

Позволяют управлять действиями над связанными сущностями:

```java
@OneToMany(cascade = CascadeType.ALL)
```

| Cascade Type        | Что делает                   |
|---------------------|------------------------------|
| `ALL`               | Применяет все действия       |
| `PERSIST`           | Сохраняет связанные сущности |
| `MERGE`             | Обновляет их                 |
| `REMOVE`            | Удаляет                      |
| `DETACH`, `REFRESH` | Прочее управление состоянием |

---

## 💾 Дополнительно: `mappedBy` vs `JoinColumn`

- `mappedBy` — на стороне **обратной связи** (не владеющей)
- `@JoinColumn` — **владеющая сторона** (где находится внешний ключ)

---

## 🧠 Советы

- Для `@OneToMany` желательно всегда указывать `mappedBy`, иначе Hibernate может
  создать **лишнюю таблицу связи**.
- При `@ManyToMany` используется **промежуточная таблица**, и `@JoinTable` нужно
  указывать явно.
- Не злоупотребляй `CascadeType.ALL` — это может привести к неожиданным
  удалениям/обновлениям.

=======================================


> - ## Работа с исключениями


**Что такое исключения в Java?**

**Исключение (Exception)** — это событие, которое возникает во время выполнения
программы и **нарушает нормальный поток выполнения**.

Проще говоря:  
**Исключение** = **ошибка**, которую программа должна как-то обработать.

**Важно понимать:**

- В Java **всё является объектом**, включая ошибки.
- Исключения — это объекты, которые **унаследованы от класса `Throwable`**.

**Иерархия исключений:**

```
Throwable
├── Error (серьёзные сбои, например OutOfMemoryError)
└── Exception
     ├── RuntimeException (непроверяемые исключения)
     └── Проверяемые исключения (Checked Exceptions)
```

### Виды исключений:

| Тип                                      | Описание                                                     | Примеры                                                  |
|:-----------------------------------------|:-------------------------------------------------------------|:---------------------------------------------------------|
| **Checked Exceptions (Проверяемые)**     | Компилятор заставляет обработать или объявить.               | `IOException`, `SQLException`                            |
| **Unchecked Exceptions (Непроверяемые)** | Ошибки времени выполнения. Компилятор не требует обработки.  | `NullPointerException`, `ArrayIndexOutOfBoundsException` |
| **Errors**                               | Очень серьёзные ошибки, не должны обрабатываться программно. | `OutOfMemoryError`, `StackOverflowError`                 |

**Пример: обработка исключения**

```java
void demo() {
    try {
        int result = 10 / 0; // Здесь возникнет ArithmeticException
    } catch (ArithmeticException e) {
        System.out.println("Деление на ноль запрещено!");
    } finally {
        System.out.println("Этот блок выполнится в любом случае.");
    }
}

```

- `try` — код, который может выбросить исключение.
- `catch` — обработчик исключения.
- `finally` — блок, который выполнится **всегда** (даже если произошло
  исключение).

**Ключевые моменты:**

| Пункт               | Пояснение                                                            |
|:--------------------|:---------------------------------------------------------------------|
| `try-catch-finally` | Стандартная конструкция для обработки ошибок.                        |
| `throws`            | Метод может выбрасывать исключение — нужно объявить это в сигнатуре. |
| `throw`             | Используется для **выброса** конкретного исключения вручную.         |

Пример объявления `throws`

```java
public void readFile() throws IOException {
    // Чтение файла, которое может вызвать IOException
}
```

**Как создать своё исключение:**

Ты можешь создать собственный класс исключения:

```java
public class MyCustomException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}
```

И использовать:

```java
if(somethingBadHappened){
        throw new

MyCustomException("Что-то пошло не так!");
}
```

### Checked / Unchecked

_**Проверяемые исключения (Checked Exceptions)**_

**Что это такое:**  
Компилятор **требует** либо обработать их через `try-catch`, либо объявить в
методе через `throws`.

### Примеры проверяемых исключений:

| Класс исключения         | Где встречается               | Краткое объяснение            |
|:-------------------------|:------------------------------|:------------------------------|
| `IOException`            | Работа с файлами, потоками    | Ошибка чтения/записи файла    |
| `SQLException`           | Работа с базами данных (JDBC) | Ошибка при работе с SQL       |
| `ClassNotFoundException` | Работа с рефлексией           | Класс не найден в ClassLoader |
| `InterruptedException`   | Работа с потоками             | Поток был прерван             |
| `FileNotFoundException`  | Работа с файлами              | Файл не найден на диске       |

**Пример:**

```java
import java.io.*;

public class CheckedExample {
    public static void main(String[] args) {
        try {
            FileReader reader = new FileReader("file.txt"); // Может выбросить FileNotFoundException
        } catch (FileNotFoundException e) {
            System.out.println("Файл не найден!");
        }
    }
}
```

_**Непроверяемые исключения (Unchecked Exceptions)**_

**Что это такое:**  
Компилятор **не требует** обработку. Они обычно возникают из-за **ошибок
программиста**.

Все **унаследованы от `RuntimeException`**.

Примеры непроверяемых исключений:

| Класс исключения                 | Где встречается        | Краткое объяснение                    |
|:---------------------------------|:-----------------------|:--------------------------------------|
| `NullPointerException`           | При обращении к `null` | Попытка вызвать метод на null-объекте |
| `ArrayIndexOutOfBoundsException` | Массивы                | Выход за пределы массива              |
| `ArithmeticException`            | Математика             | Деление на ноль                       |
| `IllegalArgumentException`       | Неверные аргументы     | Аргумент некорректен                  |
| `ClassCastException`             | Приведение типов       | Неверное приведение объекта           |

**Пример:**

```java
public class UncheckedExample {
    public static void main(String[] args) {
        int[] arr = new int[5];
        System.out.println(arr[10]); // ArrayIndexOutOfBoundsException
    }
}
```

Итого коротко:

| Вид исключения | Требует обработку? | Наследуется от                         |
|:---------------|:-------------------|:---------------------------------------|
| Проверяемые    | Да                 | `Exception` (но не `RuntimeException`) |
| Непроверяемые  | Нет                | `RuntimeException`                     |

> - ## Java Core. HashCode, equals()

`hashCode()` и `equals()` — это **два ключевых метода**,
которые влияют на сравнение объектов и работу **коллекций**, таких как
`HashMap`, `HashSet`, `Hashtable`. Давай разберем всё по полочкам. 🚀

### Что такое `equals()`?

Метод `equals()` сравнивает **содержимое объектов** (не их ссылки).
По умолчанию (в `Object`) он работает как `==`, т.е. сравнивает **адреса в
памяти**.

Чтобы сравнивать по содержанию (например, по полям), нужно переопределить его.

#### Пример:

```java
public class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        Person p = (Person) obj;
        return this.age == p.age && this.name.equals(p.name);
    }
}
```

### Что такое `hashCode()`?

Метод `hashCode()` возвращает **целое число**, которое используется для быстрого
поиска объекта в хэш-таблицах (`HashMap`, `HashSet` и др.).

Если два объекта **равны по `equals()`**, они **обязаны иметь
одинаковый `hashCode()`**.

**_Важное правило:_**

> Если переопределяешь `equals()`, обязательно переопредели и `hashCode()`.
> Иначе `HashMap`, `HashSet` и т.п. будут работать **неправильно**.


Пример ошибки:

```java
void demo() {
    Person p1 = new Person("Alice", 30);
    Person p2 = new Person("Alice", 30);

    System.out.println(p1.equals(p2)); // true
    set.add(p1);
    set.contains(p2); // false, если hashCode не переопределен!
}
```

Причина: `hashCode` разный, и `HashSet` ищет в другой "корзине".

Как правильно переопределить `hashCode()`:

```java

@Override
public int hashCode() {
    return Objects.hash(name, age); // С Java 7+
}
```

_**Резюме:**_

| Метод        | Назначение                                  | Что сравнивает                |
|--------------|---------------------------------------------|-------------------------------|
| `equals()`   | Проверяет логическое равенство объектов     | Содержимое полей              |
| `hashCode()` | Возвращает хэш-значение для быстрого поиска | Используется в хэш-структурах |

_**Где применяются:**_

| Коллекция   | Что требует                      |
|-------------|----------------------------------|
| `HashMap`   | `equals()` и `hashCode()`        |
| `HashSet`   | `equals()` и `hashCode()`        |
| `TreeSet`   | `compareTo()` (или `Comparator`) |
| `ArrayList` | `equals()` для поиска и удаления |

> ## Multithreading
> - Механизмы синхронизации: synchronized, volatile, atomic types
> - Проблемы race condition и deadlock, способы решения
> - Многопоточные коллекции, пулы потоков, Future и CompletableFuture

> - Collection Framework и внутренняя работа коллекций, Compare/Comparable

