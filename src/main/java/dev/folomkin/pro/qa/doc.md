# Материал для подгоовки к собесам

> ## SOLID

### Single Responsibility Principle - Принцип единственной ответственности.

_**У класса должен быть только один мотив для изменения.**_<br>

Каждый класс должен отвечать только за одну часть функциональности программы,
причём она должна быть полностью инкапсулирована в этот класс
(читай, скрыта внутри класса).

### Open/Closed Principle - Принцип открытости/закрытости

**_Расширяйте классы, но не изменяйте их первоначальный код._**

Классы должны быть открыты для расширения, но закрыты для изменения. Главная
идея этого принципа в том, чтобы не ломать существующий код при
внесении изменений в программу.

### Liskov Substitution Principle - Принцип подстановки Барбары Лисков

**_Подклассы должны дополнять, а не замещать поведение базового класса._**

Подклассы должны создаваться таким образом, чтобы их объекты можно было бы
подставлять вместо объектов базового класса, не ломая при этом функциональности
клиентского кода.

### Interface Segregation Principle - Принцип разделения интерфейса

**_Клиенты не должны зависеть от методов, которые они не используют._**

Интерфейсы должны быть достаточно узкими, чтобы классам не приходилось
реализовывать
избыточное поведение.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы
необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких
интерфейсов знали только о методах, которые необходимы им в работе. В итоге при
изменении метода интерфей- са не должны меняться клиенты, которые этот метод не
используют.

Наследование позволяет классу иметь только один суперкласс, но не ограничивает
количество интерфейсов, которые он может реализовать. Большинство объектных
языков программирования позволяют классам реализовывать сразу несколько
интерфейсов, поэтому нет нужды заталкивать в ваш интерфейс больше поведений, чем
он того требует. Вы всегда можете присвоить классу сразу несколько интерфейсов
поменьше.

### Dependency Inversion Principle - Принцип инверсии зависимостей

**_Классы верхних уровней не должны зависеть от классов нижних уровней. Оба
должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали
должны зависеть от абстракций._**



> ## Java Generic. Можем как-то ограничить типы (про super)

Верхний уровень обобщений (Upper Bound Wildcards)

Верхний уровень обобщений используется для ограничения типа, который может быть
использован в качестве параметра. Это делается с помощью ключевого слова
extends. Например:

```java
public void processList(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```

Нижний уровень обобщений (Lower Bound Wildcards)

Нижний уровень обобщений используется для указания того, что параметр может быть
определён как определённый тип или любой его суперкласс. Это делается с помощью
ключевого слова super. Например:

```java
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}
```

Применение

Верхние границы полезны, когда вы хотите читать данные из структуры данных и не
хотите беспокоиться о том, какой конкретный подтип вы получаете.
Нижние границы полезны, когда вы хотите добавлять данные в структуру данных и
хотите гарантировать, что вы можете добавлять элементы определенного типа или
его подтипов.  
Эти концепции позволяют создавать более гибкие и безопасные API в Java.

> ## JAVA CORE. <br> Generics. PECS

Принцип PECS (Producer Extends, Consumer Super) — это концепция, связанная с
использованием обобщений (generics) в Java, которая помогает правильно управлять
типами при работе с коллекциями и другими обобщенными структурами данных. Этот
принцип особенно полезен для понимания, как использовать wildcard-тип (неопреде-
ленный тип) в Java.

**Основные идеи PECS**

Producer Extends: Если вы хотите создать структуру данных, которая будет
производить элементы (например, возвращать элементы из коллекции), используйте
`? extends T`. Это означает, что вы можете использовать любой подтип T.

Consumer Super: Если вы хотите создать структуру данных, которая будет
потреблять элементы (например, добавлять элементы в коллекцию), используйте
`? super T`. Это означает, что вы можете использовать любой суперкласс T.

Идея принципа в следующем:

### **Producer — Extends**

Если коллекция **производит** объекты (т.е. ты **читаешь** из неё), тогда нужно
использовать `? extends T`.

```java
List<? extends Number> numbers = List.of(1, 2, 3);
Number n = numbers.get(0); // OK
// numbers.add(4);  — нельзя добавлять, неизвестно, какой именно тип
```

Пример: ты читаешь числа из списка, но не добавляешь — подойдёт
`? extends Number`.

### **Consumer — Super**

Если коллекция **потребляет** объекты (т.е. ты **записываешь** в неё), тогда
нужно использовать `? super T`.

```java
public class Demo {
    public static void main(String[] args) {
        List<? super Integer> numbers2 = new ArrayList<Number>();
        numbers2.add(42); // OK
        Object obj = numbers2.get(0);
    }
}

```

Пример: ты добавляешь `Integer` в список — подойдёт `? super Integer`.

Или проще запомнить:
**"Если достаёшь — используй `extends`, если кладёшь — используй `super`"**


> ## Java StreamApi. Вызов без терминальной операции

Промежуточные операции не выполняются немедленно — они откладываются до тех пор,
пока не будет вызвана терминальная операция.  
Именно терминальная операция запускает выполнение потока. После ее вызова
происходит анализ операций в пайплайне, и определяется эффективная стратегия его
выполнения.

> ## Java StreamApi. .parallel(), fork-join-poll

Для параллельного выполнения потоков в Stream Api collection.stream()
можно заменить на` collection.parallelStream().operation()`  
либо в общем случае для произвольного stream:
`Source.stream().parallel().operation()`.

.parallel()<br>

Для запуска потоков в параллельном режиме можно использовать методы
parallelStream() или parallel(). По умолчанию потоки выполняются
последовательно, но с явным вызовом одного из этих методов поток переключается в
параллельный режим.<br>
Для разделения коллекций на части, которые обрабатываются параллельно, Java
использует Spliterator и его метод trySplit(). Этот метод разделяет данные на
подзадачи, которые затем могут быть распределены между несколькими потоками.
Каждая часть обрабатывается независимо, и результаты объединяются после
завершения работы всех потоков.<br>

parallelStream()

Методы stream().parallel() и parallelStream() в Java представляют два разных
способа создания параллельного потока.

1. stream().parallel(): этот метод используется для преобразования
   последовательного потока в параллельный поток. Его можно вызвать для любого
   объекта последовательного потока, чтобы включить параллельную обработку этого
   потока. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> parallelStream = list.stream().parallel();

2. parallelStream(): этот метод вызывается непосредственно для объекта коллекции
   для создания параллельного потока. Он возвращает параллельный поток,
   позволяющий выполнять параллельную обработку элементов коллекции. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> parallelStream = list.parallelStream();

Оба метода достигают одного и того же результата создания параллельного потока,
но основное различие заключается в способе их вызова. Метод stream().parallel()
вызывается для последовательного объекта потока, тогда как метод
parallelStream() вызывается непосредственно для объекта коллекции.

ForkJoinPool<br>

Когда вы создаете параллельный поток, он использует ForkJoinPool по умолчанию,
предоставленный Java, для параллельного выполнения операций потока. Это
означает, что работа по
разделению данных и их распределению по нескольким потокам выполняется
ForkJoinPool. ForkJoinPool управляет пулом рабочих потоков и планирует
выполнение подзадач параллельного потока этими потоками. Он динамически
регулирует количество потоков в зависимости от доступных ядер ЦП и рабочей
нагрузки. Таким образом обеспечивается эффективное использование системных
ресурсов и повышается общая производительность обработки параллельных потоков.
Таким образом, связь между параллельными потоками и ForkJoinPool заключается в
том, что параллельные потоки используют ForkJoinPool для параллельного
выполнения операций потока, используя возможности параллельной обработки и
эффективного распределения рабочей нагрузки.




> Java Core. GCRoot
> Java Collection. HashMap чуть лучше про то как устроен , и сложности методов
> Java Collection. Сложность получения последнего элемента в LinkedList (O(1))
> Java multithreading. ExecutorService
> Java multithreading. Atomic пакет Механизм под капотом (CAS)
> Spring. Scope бинов чуть лучше
> Hibernate. Проблема n+1
> Hibernate. Уровни кеширования в Hibernate лучше изучить
> SQL. Оптимистические/Пессимистические блокировки
> Spring. Self injection и как работать с аннотациями в спринге. Например,
> Transaction, Уровни транзакции, ACID, проблемы
> Kafka про патриции чуть лучше
> SQL. Индексы в SQL
> Java Core:
> - устройство памяти и сборка мусора
> - Collection Framework и внутренняя работа коллекций
> - Работа с исключениями
> - Устройство и особенности StreamAPI
    > Multithreading
> - Механизмы синхронизации: synchronized, volatile, atomic types
> - Пробелемы race condition и deadlock, способы решения
> - Optimistic и Pessimistic locking
> - Многопоточные коллекции, пулы потоков, Future и CompletableFutute
    > Java Core. HashCode, equals()
