# Материал для подгоовки к собесам

> ## SOLID

### Single Responsibility Principle - Принцип единственной ответственности.

_**У класса должен быть только один мотив для изменения.**_<br>

Каждый класс должен отвечать только за одну часть функциональности программы,
причём она должна быть полностью инкапсулирована в этот класс
(читай, скрыта внутри класса).

### Open/Closed Principle - Принцип открытости/закрытости

**_Расширяйте классы, но не изменяйте их первоначальный код._**

Классы должны быть открыты для расширения, но закрыты для изменения. Главная
идея этого принципа в том, чтобы не ломать существующий код при
внесении изменений в программу.

### Liskov Substitution Principle - Принцип подстановки Барбары Лисков

**_Подклассы должны дополнять, а не замещать поведение базового класса._**

Подклассы должны создаваться таким образом, чтобы их объекты можно было бы
подставлять вместо объектов базового класса, не ломая при этом функциональности
клиентского кода.

### Interface Segregation Principle - Принцип разделения интерфейса

**_Клиенты не должны зависеть от методов, которые они не используют._**

Интерфейсы должны быть достаточно узкими, чтобы классам не приходилось
реализовывать
избыточное поведение.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы
необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких
интерфейсов знали только о методах, которые необходимы им в работе. В итоге при
изменении метода интерфей- са не должны меняться клиенты, которые этот метод не
используют.

Наследование позволяет классу иметь только один суперкласс, но не ограничивает
количество интерфейсов, которые он может реализовать. Большинство объектных
языков программирования позволяют классам реализовывать сразу несколько
интерфейсов, поэтому нет нужды заталкивать в ваш интерфейс больше поведений, чем
он того требует. Вы всегда можете присвоить классу сразу несколько интерфейсов
поменьше.

### Dependency Inversion Principle - Принцип инверсии зависимостей

**_Классы верхних уровней не должны зависеть от классов нижних уровней. Оба
должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали
должны зависеть от абстракций._**



> ## Java Generic. Можем как-то ограничить типы (про super)

Верхний уровень обобщений (Upper Bound Wildcards)

Верхний уровень обобщений используется для ограничения типа, который может быть
использован в качестве параметра. Это делается с помощью ключевого слова
extends. Например:

```java
public void processList(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```

Нижний уровень обобщений (Lower Bound Wildcards)

Нижний уровень обобщений используется для указания того, что параметр может быть
определён как определённый тип или любой его суперкласс. Это делается с помощью
ключевого слова super. Например:

```java
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}
```

Применение

Верхние границы полезны, когда вы хотите читать данные из структуры данных и не
хотите беспокоиться о том, какой конкретный подтип вы получаете.
Нижние границы полезны, когда вы хотите добавлять данные в структуру данных и
хотите гарантировать, что вы можете добавлять элементы определенного типа или
его подтипов.  
Эти концепции позволяют создавать более гибкие и безопасные API в Java.

> ## JAVA CORE. <br> Generics. PECS

Принцип PECS (Producer Extends, Consumer Super) — это концепция, связанная с
использованием обобщений (generics) в Java, которая помогает правильно управлять
типами при работе с коллекциями и другими обобщенными структурами данных. Этот
принцип особенно полезен для понимания, как использовать wildcard-тип (неопреде-
ленный тип) в Java.

**Основные идеи PECS**

Producer Extends: Если вы хотите создать структуру данных, которая будет
производить элементы (например, возвращать элементы из коллекции), используйте
`? extends T`. Это означает, что вы можете использовать любой подтип T.

Consumer Super: Если вы хотите создать структуру данных, которая будет
потреблять элементы (например, добавлять элементы в коллекцию), используйте
`? super T`. Это означает, что вы можете использовать любой суперкласс T.

Идея принципа в следующем:

### **Producer — Extends**

Если коллекция **производит** объекты (т.е. ты **читаешь** из неё), тогда нужно
использовать `? extends T`.

```java
List<? extends Number> numbers = List.of(1, 2, 3);
Number n = numbers.get(0); // OK
// numbers.add(4);  — нельзя добавлять, неизвестно, какой именно тип
```

Пример: ты читаешь числа из списка, но не добавляешь — подойдёт
`? extends Number`.

### **Consumer — Super**

Если коллекция **потребляет** объекты (т.е. ты **записываешь** в неё), тогда
нужно использовать `? super T`.

```java
public class Demo {
    public static void main(String[] args) {
        List<? super Integer> numbers2 = new ArrayList<Number>();
        numbers2.add(42); // OK
        Object obj = numbers2.get(0);
    }
}

```

Пример: ты добавляешь `Integer` в список — подойдёт `? super Integer`.

Или проще запомнить:
**"Если достаёшь — используй `extends`, если кладёшь — используй `super`"**


> ## Java StreamApi. Вызов без терминальной операции

Промежуточные операции не выполняются немедленно — они откладываются до тех пор,
пока не будет вызвана терминальная операция.  
Именно терминальная операция запускает выполнение потока. После ее вызова
происходит анализ операций в пайплайне, и определяется эффективная стратегия его
выполнения.

> ## Java StreamApi. .parallel(), fork-join-poll

Для параллельного выполнения потоков в Stream Api collection.stream()
можно заменить на` collection.parallelStream().operation()`  
либо в общем случае для произвольного stream:
`Source.stream().parallel().operation()`.

.parallel()<br>

Для запуска потоков в параллельном режиме можно использовать методы
parallelStream() или parallel(). По умолчанию потоки выполняются
последовательно, но с явным вызовом одного из этих методов поток переключается в
параллельный режим.<br>
Для разделения коллекций на части, которые обрабатываются параллельно, Java
использует Spliterator и его метод trySplit(). Этот метод разделяет данные на
подзадачи, которые затем могут быть распределены между несколькими потоками.
Каждая часть обрабатывается независимо, и результаты объединяются после
завершения работы всех потоков.<br>

parallelStream()

Методы stream().parallel() и parallelStream() в Java представляют два разных
способа создания параллельного потока.

1. stream().parallel(): этот метод используется для преобразования
   последовательного потока в параллельный поток. Его можно вызвать для любого
   объекта последовательного потока, чтобы включить параллельную обработку этого
   потока. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> parallelStream = list.stream().parallel();

2. parallelStream(): этот метод вызывается непосредственно для объекта коллекции
   для создания параллельного потока. Он возвращает параллельный поток,
   позволяющий выполнять параллельную обработку элементов коллекции. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> parallelStream = list.parallelStream();

Оба метода достигают одного и того же результата создания параллельного потока,
но основное различие заключается в способе их вызова. Метод stream().parallel()
вызывается для последовательного объекта потока, тогда как метод
parallelStream() вызывается непосредственно для объекта коллекции.

ForkJoinPool<br>

Когда вы создаете параллельный поток, он использует ForkJoinPool по умолчанию,
предоставленный Java, для параллельного выполнения операций потока. Это
означает, что работа по разделению данных и их распределению по нескольким
потокам выполняется ForkJoinPool. ForkJoinPool управляет пулом рабочих потоков и
планирует выполнение подзадач параллельного потока этими потоками. Он
динамически регулирует количество потоков в зависимости от доступных ядер ЦП и
рабочей нагрузки. Таким образом обеспечивается эффективное использование
системных ресурсов и повышается общая производительность обработки параллельных
потоков. Таким образом, связь между параллельными потоками и ForkJoinPool
заключается в том, что параллельные потоки используют ForkJoinPool для
параллельного выполнения операций потока, используя возможности параллельной
обработки и эффективного распределения рабочей нагрузки.


> Java Core. GCRoot

В Java, GC Root (или корень сборщика мусора) — это объект, который является
начальной точкой для процесса сборки мусора (Garbage Collection, GC). Сборщик
мусора использует корни для определения, какие объекты в памяти все еще доступны
и могут быть использованы, а какие объекты больше не нужны и могут быть удалены.
GC Root — это набор объектов, которые всегда доступны и служат отправной точкой
для поиска всех достижимых объектов в памяти. Если объект не может быть
достигнут из любого из корней, он считается "мусором" и может быть удален
сборщиком мусора.

Примеры GC Root<br>
Вот несколько примеров объектов, которые считаются GC Root:<br>

- Статические поля:<br>
  Объекты, на которые ссылаются статические поля классов. Например, если у вас
  есть статическое поле в классе, которое ссылается на объект, этот объект будет
  являться корнем.
- Активные потоки:<br>
  Объекты, связанные с активными потоками (например, текущий поток выполнения).
- Объекты в локальных переменных:<br>
  Объекты, на которые ссылаются локальные переменные методов. Пока метод
  выполняется и локальные переменные находятся в стеке вызовов, эти объекты
  считаются достижимыми.
- JNI ссылки:<br>
  Объекты, на которые ссылаются нативные методы через Java Native Interface (
  JNI).
- Объекты класса java.lang.Runtime:<br>
  Объект Runtime, который предоставляет информацию о среде выполнения Java.

Как работает сборка мусора?<br>
Сборщик мусора использует алгоритмы для определения достижимости объектов:

1. Начинает с GC Roots: Сборщик начинает с объектов GC Root и проходит по всем
   ссылкам от этих объектов.
2. Обходит граф объектов: Он рекурсивно проверяет все объекты, на которые
   ссылаются корни.
3. Определяет недостижимые объекты: Все объекты, которые не могут быть
   достигнуты из корней, помечаются как "мусор" и подлежат удалению.

Важность GC Root<br>
Понимание концепции GC Root важно для оптимизации работы приложения и управления
памятью:<br>

1. Помогает разработчикам избегать утечек памяти.
2. Позволяет лучше понимать поведение сборщика мусора.
3. Способствует более эффективному управлению ресурсами в приложениях.

Как пометить объект "живым"<br>
В Java объекты помечаются как "живые" (или "достижимые") в контексте сборки
мусора (Garbage Collection) на основе ссылок на них. Если объект доступен через
одну или несколько ссылок, он считается живым и не может быть удален сборщиком
мусора. Вот несколько способов, как можно пометить объект как живой:

1. Создание ссылок на объект<br>
   Чтобы объект считался живым, необходимо создать хотя бы одну ссылку на него.
   Например:

```java
class MyObject {
// Поля и методы
}

public class Main {
    public static void main(String[] args) {
        MyObject obj = new MyObject(); // Создаем объект и сохраняем ссылку на него
// Объект obj считается "живым", пока существует ссылка на него
    }
}
```

В этом примере obj является ссылкой на экземпляр MyObject, и пока эта ссылка
существует, объект будет считаться живым.

2. Использование коллекций<br>
   Объекты могут быть помечены как живые, если они хранятся в коллекциях, таких
   как списки, множества или карты:

```java
import java.util.ArrayList;
import java.util.List;

class MyObject {
    // Поля и методы
}

public class Main {
    public static void main(String[] args) {
        List<MyObject> list = new ArrayList<>();
        MyObject obj = new MyObject();
        list.add(obj); // Объект obj теперь считается "живым", так как он хранится в списке
    }
}
```

3. Статические поля<br>
   Если объект хранится в статическом поле класса, он также будет считаться
   живым:

```java
class MyClass {
    static MyObject staticObj = new MyObject(); // Статическое поле хранит ссылку на объект
}

public class Main {
    public static void main(String[] args) {
        // Объект staticObj считается "живым" благодаря статической ссылке
    }
}
```

4. Передача объектов в методы<br>
   Когда вы передаете объект в метод, он также считается живым, пока метод
   выполняется:

```java
class MyObject {
    // Поля и методы
}

public class Main {
    public static void process(MyObject obj) {
        // Объект obj считается "живым" внутри этого метода
    }

    public static void main(String[] args) {
        MyObject myObj = new MyObject();
        process(myObj); // Передаем объект в метод
    }
}

```

5. Использование внешних библиотек или фреймворков
   Некоторые фреймворки и библиотеки могут управлять жизненным циклом объектов и
   поддерживать ссылки на них для обеспечения их доступности.

Заключение<br>
Объекты в Java считаются "живыми", если на них существуют ссылки из других
объектов или переменных. Чтобы пометить объект как живой, достаточно создать
хотя бы одну ссылку на него — это может быть локальная переменная, элемент
коллекции или статическое поле класса. Как только все ссылки на объект будут
удалены (например, переменные выйдут из области видимости или будут присвоены
null), объект станет недостижимым и может быть удален сборщиком мусора.

GC Root — это ключевая концепция в управлении памятью Java и сборке мусора. Она
определяет начальные точки для поиска достижимых объектов и помогает сборщику
мусора эффективно освобождать память от ненужных объектов.


> Java Collection. HashMap чуть лучше про то как устроен , и сложности методов
> Java Collection. Сложность получения последнего элемента в LinkedList (O(1))
> Java multithreading. ExecutorService
> Java multithreading. Atomic пакет Механизм под капотом (CAS)
> Spring. Scope бинов чуть лучше
> Hibernate. Проблема n+1
> Hibernate. Уровни кеширования в Hibernate лучше изучить
> SQL. Оптимистические/Пессимистические блокировки
> Spring. Self injection и как работать с аннотациями в спринге. Например,
> Transaction, Уровни транзакции, ACID, проблемы
> Kafka про патриции чуть лучше
> SQL. Индексы в SQL
> Java Core:
> - устройство памяти и сборка мусора
> - Collection Framework и внутренняя работа коллекций
> - Работа с исключениями
> - Устройство и особенности StreamAPI
    > Multithreading
> - Механизмы синхронизации: synchronized, volatile, atomic types
> - Пробелемы race condition и deadlock, способы решения
> - Optimistic и Pessimistic locking
> - Многопоточные коллекции, пулы потоков, Future и CompletableFutute
    > Java Core. HashCode, equals()
