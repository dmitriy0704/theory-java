# Деревья

**Что такое дерево?**

Дерево состоит из узлов, каждый из которых может иметь:

- **Корень** — начальный узел дерева.
- **Ребра** — связи между узлами.
- **Листья** — узлы, не имеющие потомков.
- **Узел** — элемент дерева, который может иметь несколько дочерних узлов.

### Термины:

- **Родитель** — узел, который содержит указатель на дочерние узлы.
- **Потомок** — узел, на который указывает родитель.
- **Глубина узла** — количество рёбер от корня до данного узла.
- **Глубина дерева** — максимальная глубина среди всех узлов (обычно это глубина
  самого дальнего листа).
- **Высота** — максимальная глубина в дереве.
- **Дерево поиска (BST)** — дерево, в котором для каждого узла значение левого
  поддерева меньше, чем значение самого узла, а значение правого поддерева
  больше.

В Java ты можешь работать с разными **видами деревьев**, как вручную, так и
через стандартные структуры (`TreeMap`, `TreeSet` и т. д.). Вот обзор **основных
типов деревьев**, используемых на практике:

---

## _**ВИДЫ ДЕРЕВЬЕВ**_

В Java термин "деревья" обычно относится к структурам данных, которые
используются для представления иерархических отношений. В стандартной библиотеке
Java (`java.util`) нет прямой реализации дерева как отдельной структуры данных,
но существуют классы и интерфейсы, которые можно использовать для создания или
работы с деревьями. Также деревья часто реализуются в пользовательских
структурах данных. Рассмотрим основные виды деревьев, которые используются в
Java, и их реализации:

### 1. **Общие типы деревьев (структуры данных)**

- **Бинарное дерево (Binary Tree)**:
    - Каждый узел имеет не более двух потомков (левый и правый).
    - Используется для задач, таких как сортировка, поиск и хранение данных.
    - Реализация: Обычно создается вручную с использованием классов `Node` с
      полями `left`, `right` и `value`.
  ```java
  class Node {
      int value;
      Node left, right;
      Node(int value) {
          this.value = value;
          left = right = null;
      }
  }
  ```

- **Бинарное поисковое дерево (Binary Search Tree, BST)**:
    - Подвид бинарного дерева, где для каждого узла левое поддерево содержит
      значения меньше, а правое — больше.
    - Используется для эффективного поиска, вставки и удаления.
    - Реализация: Похожа на бинарное дерево, но с логикой сравнения значений.

- **Сбалансированные деревья**:
    - **AVL-дерево**:
        - Самобалансирующееся бинарное поисковое дерево, где разница высот
          поддеревьев любого узла не превышает 1.
        - Реализация: Требует дополнительных операций для балансировки
          (вращения).
    - **Красно-черное дерево (Red-Black Tree)**:
        - Самобалансирующееся бинарное поисковое дерево с дополнительным
          свойством цвета узлов (красный или черный) для поддержания баланса.
        - Реализация в Java: Используется в классе `TreeMap` и `TreeSet`
          (внутренне основаны на красно-черном дереве).

- **N-арное дерево (N-ary Tree)**:
    - Узел может иметь произвольное количество потомков.
    - Используется для представления иерархий, таких как файловая система.
    - Реализация: Узел содержит список дочерних узлов (`List<Node>`).

- **Суффиксное дерево (Trie)**:
    - Специализированное дерево для хранения строк, где каждый узел представляет
      префикс.
    - Используется для задач автодополнения, поиска подстрок и т.д.
    - Реализация: Часто создается вручную или с использованием библиотек.

- **Куча (Heap)**:
    - Бинарное дерево, где значение каждого узла больше (или меньше) значений
      его потомков (max-heap или min-heap).
    - Реализация в Java: Класс `PriorityQueue` использует min-heap внутренне.

### 2. **Реализации деревьев в стандартной библиотеке Java**

- **TreeMap**:
    - Реализует интерфейс `NavigableMap` и основана на красно-черном дереве.
    - Хранит пары ключ-значение в отсортированном порядке по ключам.
    - Пример использования:
      ```java
      TreeMap<Integer, String> treeMap = new TreeMap<>();
      treeMap.put(1, "One");
      treeMap.put(2, "Two");
      ```

- **TreeSet**:
    - Реализует интерфейс `NavigableSet` и также основан на красно-черном
      дереве.
    - Хранит уникальные элементы в отсортированном порядке.
    - Пример использования:
      ```java
      TreeSet<String> treeSet = new TreeSet<>();
      treeSet.add("Apple");
      treeSet.add("Banana");
      ```

- **PriorityQueue**:
    - Основана на бинарной куче (min-heap по умолчанию).
    - Используется для приоритетной очереди.
    - Пример использования:
      ```java
      PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();
      priorityQueue.add(5);
      priorityQueue.add(1);
      ```

### 3. **Библиотеки для работы с деревьями**

- **Apache Commons Collections**:
    - Предоставляет дополнительные структуры данных, такие как `TreeList` или
      `PatriciaTrie`.
- **Google Guava**:
    - Содержит структуры, такие как `TreeMultiset` или `Trie`.
- **JGraphT**:
    - Библиотека для работы с графами и деревьями, поддерживает различные виды
      деревьев.

### 4. **Пример пользовательской реализации бинарного дерева**

```java
class BinaryTree {
    class Node {
        int value;
        Node left, right;

        Node(int value) {
            this.value = value;
            left = right = null;
        }
    }

    Node root;

    void insert(int value) {
        root = insertRec(root, value);
    }

    Node insertRec(Node root, int value) {
        if (root == null) {
            root = new Node(value);
            return root;
        }
        if (value < root.value) {
            root.left = insertRec(root.left, value);
        } else if (value > root.value) {
            root.right = insertRec(root.right, value);
        }
        return root;
    }
}
```

### Заключение

В Java нет встроенной универсальной структуры данных "дерево", но вы можете
использовать `TreeMap`, `TreeSet` и `PriorityQueue` для специфических задач или
реализовать собственное дерево (например, бинарное, AVL, красно-черное). Для
сложных задач можно применять сторонние библиотеки, такие как JGraphT или Guava.

Если вам нужен конкретный пример реализации или объяснение определенного типа
дерева, дайте знать!

## GROK: ВИДЫ ДЕРЕВЬЕВ В JAVA

В Java деревья как структуры данных используются в различных контекстах, и
стандартная библиотека (`java.util`) включает несколько реализаций, основанных
на деревьях, а также позволяет создавать пользовательские деревья. Я расскажу о
видах деревьев, встречающихся в Java, включая те, что используются в
стандартной библиотеке, и упомяну общие типы деревьев, которые могут быть
реализованы вручную.

### **1. Деревья в стандартной библиотеке Java**

Стандартная библиотека Java (JDK) использует деревья в нескольких классах,
преимущественно для упорядоченного хранения данных. Вот основные реализации:

1. **Красно-чёрное дерево (Red-Black Tree)**:
    - **Где используется**: `TreeMap` и `TreeSet` (пакет `java.util`).
    - **Описание**: Сбалансированное бинарное дерево поиска, использующее
      цвета (красный/чёрный) для поддержания баланса. Гарантирует
      логарифмическую сложность (\(O(\log n)\)) для операций поиска, вставки и
      удаления.
    - **Особенности**:
        - `TreeMap` хранит пары ключ-значение, ключи упорядочены.
        - `TreeSet` хранит уникальные элементы в отсортированном порядке.
        - Балансировка через ротации и перекрашивание (как обсуждалось ранее).
    - **Пример**:
      ```java
      import java.util.TreeMap;
      TreeMap<Integer, String> map = new TreeMap<>();
      map.put(1, "Один");
      map.put(2, "Два");
      System.out.println(map); // {1=Один, 2=Два}
      ```

2. **Список с пропусками (Skip List, косвенно связан с деревьями)**:
    - **Где используется**: `ConcurrentSkipListMap` и `ConcurrentSkipListSet`.
    - **Описание**: Это не классическое дерево, а вероятностная структура
      данных, которая имитирует поведение сбалансированного дерева с помощью
      многоуровневых списков. Используется для потокобезопасного упорядоченного
      хранения.
    - **Особенности**:
        - Эффективность сравнима с красно-чёрным деревом (\(O(\log n)\) в
          среднем).
        - Подходит для параллельных приложений.
    - **Пример**:
      ```java
      import java.util.concurrent.ConcurrentSkipListMap;
      ConcurrentSkipListMap<Integer, String> map = new ConcurrentSkipListMap<>();
      map.put(1, "Один");
      map.put(2, "Два");
      System.out.println(map); // {1=Один, 2=Два}
      ```

3. **Куча (Heap, реализуется как дерево)**:
    - **Где используется**: `PriorityQueue` (пакет `java.util`).
    - **Описание**: Бинарное дерево, реализованное как куча (обычно min-heap или
      max-heap), где значение каждого узла меньше (или больше) значений его
      детей. В `PriorityQueue` используется min-heap.
    - **Особенности**:
        - Не является деревом поиска, но поддерживает эффективное извлечение
          минимального/максимального элемента (\(O(\log n)\)).
        - Хранится в массиве, а не как явное дерево с указателями.
        - Не упорядочивает элементы полностью, только поддерживает приоритет.
    - **Пример**:
      ```java
      import java.util.PriorityQueue;
      PriorityQueue<Integer> queue = new PriorityQueue<>();
      queue.add(3);
      queue.add(1);
      queue.add(2);
      System.out.println(queue.poll()); // 1 (минимальный элемент)
      ```

### **2. Общие типы деревьев, реализуемые вручную**

Помимо стандартной библиотеки, в Java можно реализовать различные виды деревьев
для специфических задач. Вот наиболее распространённые типы, которые
программисты создают вручную:

1. **Бинарное дерево поиска (Binary Search Tree, BST)**:
    - **Описание**: Простое бинарное дерево, где левое поддерево содержит ключи
      меньше узла, а правое — больше.
    - **Особенности**:
        - Несбалансированное по умолчанию, может выродиться в список (\(O(n)\) в
          худшем случае).
        - Используется как основа для более сложных деревьев (например, AVL,
          красно-чёрное).
    - **Пример реализации**:
      ```java
      class Node {
          int value;
          Node left, right;
          Node(int value) { this.value = value; }
      }
      class BST {
          Node root;
          void insert(int value) {
              root = insertRec(root, value);
          }
          Node insertRec(Node root, int value) {
              if (root == null) return new Node(value);
              if (value < root.value) root.left = insertRec(root.left, value);
              else if (value > root.value) root.right = insertRec(root.right, value);
              return root;
          }
      }
      ```

2. **AVL-дерево**:
    - **Описание**: Сбалансированное бинарное дерево поиска, где разница высот
      левого и правого поддеревьев не превышает 1.
    - **Особенности**:
        - Строже, чем красно-чёрное дерево, но требует больше операций
          балансировки.
        - Используется в задачах, где важна максимальная сбалансированность.
        - Не реализован в стандартной библиотеке, но может быть создан вручную.
    - **Балансировка**: Ротации (левая, правая, лево-правая, право-левая).

3. **B-дерево и B+-дерево**:
    - **Описание**: Многоуровневые сбалансированные деревья, где каждый узел
      может содержать несколько ключей и указателей.
    - **Особенности**:
        - Оптимизированы для работы с большими данными (например, в базах
          данных, файловых системах).
        - Минимизируют обращения к диску.
        - Не реализованы в `java.util`, но используются в некоторых
          библиотеках (например, для индексов в H2, HSQLDB).
    - **Применение**: Реализация вручную или через сторонние библиотеки.

4. **Сплей-дерево (Splay Tree)**:
    - **Описание**: Самоадаптивное бинарное дерево поиска, где недавно
      использованные узлы перемещаются ближе к корню.
    - **Особенности**:
        - Не гарантирует строгую сбалансированность, но обеспечивает
          амортизированную сложность \(O(\log n)\).
        - Не используется в стандартной библиотеке, но может быть реализован
          вручную.
    - **Применение**: Кэширование, задачи с частым доступом к одним и тем же
      данным.

5. **Префиксное дерево (Trie)**:
    - **Описание**: Дерево для хранения строк, где каждый узел представляет
      префикс или символ.
    - **Особенности**:
        - Эффективно для поиска слов, автодополнения, словарей.
        - Не входит в стандартную библиотеку, но часто реализуется вручную.
    - **Пример**:
      ```java
      class TrieNode {
          TrieNode[] children = new TrieNode[26];
          boolean isEndOfWord;
      }
      class Trie {
          TrieNode root = new TrieNode();
          void insert(String word) {
              TrieNode node = root;
              for (char c : word.toCharArray()) {
                  int index = c - 'a';
                  if (node.children[index] == null) node.children[index] = new TrieNode();
                  node = node.children[index];
              }
              node.isEndOfWord = true;
          }
      }
      ```

6. **Сегментное дерево (Segment Tree)**:
    - **Описание**: Дерево для хранения интервалов или сегментов, позволяющее
      эффективно выполнять запросы на диапазоны (например, сумму, минимум).
    - **Особенности**:
        - Используется в алгоритмах, связанных с обработкой массивов (например,
          RMQ — Range Minimum Query).
        - Реализуется вручную.
    - **Применение**: Алгоритмические задачи, обработка данных.

7. **Фенвиковое дерево (Binary Indexed Tree, BIT)**:
    - **Описание**: Компактное дерево для вычисления префиксных сумм и
      обновления элементов.
    - **Особенности**:
        - Эффективнее сегментного дерева для некоторых задач.
        - Реализуется вручную.
    - **Применение**: Алгоритмы на массивах, задачи на Codeforces и др.

8. **Общее n-арное дерево**:
    - **Описание**: Дерево, где каждый узел может иметь произвольное число
      детей (не обязательно бинарное).
    - **Особенности**:
        - Используется для представления иерархий (например, DOM в XML/HTML,
          файловые системы).
        - Реализуется вручную или через библиотеки (например, JDOM для XML).
    - **Пример**:
      ```java
      class NaryNode {
          String value;
          List<NaryNode> children = new ArrayList<>();
          NaryNode(String value) { this.value = value; }
          void addChild(NaryNode child) { children.add(child); }
      }
      ```

### **3. Деревья в сторонних библиотеках**

Java-разработчики часто используют сторонние библиотеки для специфических типов
деревьев:

- **Apache Commons Collections**: Предоставляет структуры вроде `TreeList`
  (гибрид дерева и списка).
- **Guava**: `TreeMultiset` и `TreeMultimap` используют красно-чёрные деревья
  для упорядоченного хранения с поддержкой дубликатов.
- **JGraphT**: Библиотека для работы с графами и деревьями, включая минимальные
  остовные деревья (Kruskal, Prim).

### **4. Деревья в специфических контекстах**

- **Синтаксические деревья (AST)**:
    - Используются в компиляторах и парсерах (например, в Java Parser или
      ANTLR).
    - Представляют структуру кода (операторы, выражения).
- **Деревья решений**:
    - Используются в машинном обучении (например, в библиотеке Weka).
    - Реализуются как n-арные деревья.
- **Пространственные деревья**:
    - **Квадродеревья (QuadTree)** и **Октодеревья (OctTree)**: Для работы с
      2D/3D данными (игры, графика).
    - **R-дерево**: Для пространственных индексов (например, в базах данных
      PostGIS).

### **Сравнение основных деревьев в Java**

| Тип дерева                   | Где используется            | Сбалансированность | Сложность операций         | Особенности                                 |
|------------------------------|-----------------------------|--------------------|----------------------------|---------------------------------------------|
| Красно-чёрное дерево         | `TreeMap`, `TreeSet`        | Да                 | \(O(\log n)\)              | Баланс через цвета, стандартная библиотека  |
| Список с пропусками          | `ConcurrentSkipListMap/Set` | Да (вероятностная) | \(O(\log n)\)              | Потокобезопасность, не дерево в явном виде  |
| Куча                         | `PriorityQueue`             | Да (частично)      | \(O(\log n)\)              | Для приоритетов, не упорядочивает полностью |
| Бинарное дерево поиска (BST) | Пользовательская реализация | Нет                | \(O(n)\) (худший)          | Простое, может выродиться                   |
| AVL-дерево                   | Пользовательская реализация | Да                 | \(O(\log n)\)              | Строгий баланс, больше ротаций              |
| Префиксное дерево (Trie)     | Пользовательская реализация | Нет                | \(O(m)\) (m — длина ключа) | Для строк, автодополнения                   |
| B-дерево/B+-дерево           | Базы данных, вручную        | Да                 | \(O(\log n)\)              | Для больших данных, много ключей в узле     |

### **Итог**

- **Стандартная библиотека**: Основные деревья — красно-чёрное (`TreeMap`,
  `TreeSet`), куча (`PriorityQueue`) и список с пропусками (
  `ConcurrentSkipListMap/Set`).
- **Пользовательские реализации**: BST, AVL, B-дерево, Trie, сегментное дерево,
  Фенвиковое дерево, n-арное дерево и др.
- **Сторонние библиотеки**: Apache Commons, Guava, JGraphT добавляют
  специфические деревья.
- **Применение**: От упорядоченного хранения до алгоритмов, баз данных и
  графики.

## _**GROK: ВИДЫ БИНАРНЫХ ДЕРЕВЬЕВ**_

Бинарные деревья — это структуры данных, в которых каждый узел имеет не более
двух дочерних узлов (левый и правый). В Java и в теории компьютерных наук
существует множество видов бинарных деревьев, которые отличаются по своим
свойствам, способам организации и применению. Вот основные виды бинарных
деревьев:

### **1. Общее бинарное дерево (Binary Tree)**

- **Описание**: Базовый тип бинарного дерева, где каждый узел имеет до двух
  детей (левый и правый), без дополнительных ограничений на структуру.
- **Особенности**:
    - Не обязательно упорядоченное или сбалансированное.
    - Может быть использовано для представления иерархий (например,
      синтаксических деревьев).
- **Применение**: Парсинг выражений, представление структуры данных.
- **Пример в Java**:
  ```java
  class Node {
      int value;
      Node left, right;
      Node(int value) { this.value = value; }
  }
  ```

### **2. Бинарное дерево поиска (Binary Search Tree, BST)**

- **Описание**: Бинарное дерево, в котором для каждого узла все ключи в левом
  поддереве меньше значения узла, а в правом — больше.
- **Особенности**:
    - Не обязательно сбалансированное, может выродиться в список (сложность \(O(
      n)\) в худшем случае).
    - Основа для многих сбалансированных деревьев.
- **Применение**: Поиск, вставка, удаление элементов в упорядоченном виде.
- **Пример в Java**:
  ```java
  class BST {
      Node root;
      void insert(int value) {
          root = insertRec(root, value);
      }
      Node insertRec(Node root, int value) {
          if (root == null) return new Node(value);
          if (value < root.value) root.left = insertRec(root.left, value);
          else if (value > root.value) root.right = insertRec(root.right, value);
          return root;
      }
  }
  ```

### **3. Сбалансированные бинарные деревья**

Эти деревья разработаны для поддержания высоты близкой к \(\log n\), что
обеспечивает сложность операций \(O(\log n)\).

#### **3.1. AVL-дерево**

- **Описание**: Бинарное дерево поиска, где разница высот левого и правого
  поддеревьев (баланс-фактор) не превышает 1.
- **Особенности**:
    - Строго сбалансированное, требует ротаций после вставки/удаления.
    - Более частые балансировки, чем в красно-чёрном дереве, но меньшая высота.
- **Применение**: Когда важна максимальная сбалансированность (например, в базах
  данных).
- **Связь с красно-чёрным деревом**: AVL-дерево строже, чем красно-чёрное, но
  красно-чёрное чаще используется в стандартных библиотеках (например,
  `TreeMap`) из-за меньшего числа ротаций.

#### **3.2. Красно-чёрное дерево (Red-Black Tree)**

- **Описание**: Сбалансированное бинарное дерево поиска, использующее цвета (
  красный/чёрный) для поддержания баланса (как обсуждалось ранее).
- **Особенности**:
    - Менее строгое, чем AVL: высота до \(2 \cdot \log(n + 1)\).
    - Балансировка через перекрашивание и ротации.
    - Используется в Java в `TreeMap` и `TreeSet`.
- **Применение**: Упорядоченное хранение данных, стандартные структуры данных.
- **Пример в Java**:
  ```java
  import java.util.TreeMap;
  TreeMap<Integer, String> map = new TreeMap<>();
  map.put(1, "Один");
  map.put(2, "Два");
  ```

#### **3.3. Сплей-дерево (Splay Tree)**

- **Описание**: Самоадаптивное бинарное дерево поиска, где часто используемые
  узлы перемещаются ближе к корню через операцию "сплей" (splay).
- **Особенности**:
    - Не гарантирует строгую сбалансированность, но обеспечивает
      амортизированную сложность \(O(\log n)\).
    - Нет в стандартной библиотеке Java, но может быть реализовано вручную.
- **Применение**: Кэширование, задачи с частым доступом к одним данным.
- **Связь с красно-чёрным деревом**: Менее предсказуемо, но может быть
  эффективнее в сценариях с локальностью доступа.

---

### **4. Куча (Heap)**

- **Описание**: Бинарное дерево, где значение каждого узла больше (max-heap) или
  меньше (min-heap) значений его детей.
- **Особенности**:
    - Не является деревом поиска, но поддерживает эффективное извлечение
      минимального/максимального элемента (\(O(\log n)\)).
    - В Java реализовано в `PriorityQueue` (min-heap).
    - Хранится в массиве, но логически представляет дерево.
- **Применение**: Очереди с приоритетами, алгоритмы (например, Dijkstra,
  HeapSort).
- **Пример в Java**:
  ```java
  import java.util.PriorityQueue;
  PriorityQueue<Integer> queue = new PriorityQueue<>();
  queue.add(3);
  queue.add(1);
  System.out.println(queue.poll()); // 1
  ```

### **5. Заполненное бинарное дерево (Complete Binary Tree)**

- **Описание**: Бинарное дерево, в котором все уровни, кроме, возможно,
  последнего, полностью заполнены, а последний уровень заполняется слева
  направо.
- **Особенности**:
    - Используется в кучах (например, в `PriorityQueue`).
    - Эффективно хранится в массиве без явных указателей.
- **Применение**: Реализация куч, компактное представление деревьев.

### **6. Полное бинарное дерево (Full Binary Tree)**

- **Описание**: Бинарное дерево, в котором каждый узел имеет либо 0, либо 2
  ребёнка.
- **Особенности**:
    - Не обязательно сбалансированное или упорядоченное.
    - Используется в специфических задачах (например, для вычисления выражений).
- **Применение**: Парсинг математических выражений.

### **7. Идеально сбалансированное бинарное дерево (Perfect Binary Tree)**

- **Описание**: Бинарное дерево, в котором все внутренние узлы имеют двух детей,
  а все листья находятся на одном уровне.
- **Особенности**:
    - Максимально компактное: (2^h-1) узлов, где (h) — высота.
    - Редко встречается на практике из-за строгих требований.
- **Применение**: Теоретические модели, тестирование алгоритмов.

### **8. Сегментное дерево (Segment Tree)**

- **Описание**: Бинарное дерево для хранения информации о сегментах или
  интервалах (например, суммы или минимума на диапазоне массива).
- **Особенности**:
    - Не является деревом поиска, а специализированным деревом для запросов на
      диапазоны.
    - Реализуется вручную.
    - Сложность запросов и обновлений: \(O(\log n)\).
- **Применение**: Алгоритмические задачи (например, Range Minimum Query).
- **Пример**:
  ```java
  class SegmentTree {
      int[] tree;
      int n;
      SegmentTree(int[] arr) {
          n = arr.length;
          tree = new int[4 * n];
          build(arr, 0, 0, n - 1);
      }
      void build(int[] arr, int node, int start, int end) {
          if (start == end) {
              tree[node] = arr[start];
          } else {
              int mid = (start + end) / 2;
              build(arr, 2 * node + 1, start, mid);
              build(arr, 2 * node + 2, mid + 1, end);
              tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
          }
      }
  }
  ```

### **9. Фенвиковое дерево (Binary Indexed Tree, BIT)**

- **Описание**: Компактное бинарное дерево для вычисления префиксных сумм и
  обновления элементов.
- **Особенности**:
    - Не является классическим деревом с узлами, а реализуется через массив.
    - Эффективнее сегментного дерева для некоторых задач (\(O(\log n)\)).
    - Реализуется вручную.
- **Применение**: Алгоритмы на массивах, задачи на динамическое
  программирование.

### **10. Декартово дерево (Treap)**

- **Описание**: Бинарное дерево поиска, сочетающее свойства BST и кучи. Каждый
  узел имеет ключ и приоритет, где BST-условие выполняется по ключу, а
  приоритеты образуют кучу.
- **Особенности**:
    - Вероятностная сбалансированность: случайные приоритеты обеспечивают высоту
      \(O(\log n)\) в среднем.
    - Реализуется вручную.
- **Применение**: Динамические структуры данных, задачи с объединением деревьев.
- **Связь с красно-чёрным деревом**: Похоже по сложности, но проще в реализации
  для некоторых задач.

### **11. Синтаксическое дерево (Abstract Syntax Tree, AST)**

- **Описание**: Бинарное или n-арное дерево, представляющее структуру программы
  или выражения.
- **Особенности**:
    - Не является деревом поиска, а иерархической структурой.
    - Используется в компиляторах (например, в Java Compiler API).
- **Применение**: Парсинг кода, оптимизация программ.

### **Сравнение основных видов бинарных деревьев**

| Тип дерева                   | Сбалансированность | Сложность операций | Где используется в Java     | Применение                         |
|------------------------------|--------------------|--------------------|-----------------------------|------------------------------------|
| Общее бинарное дерево        | Нет                | \(O(n)\)           | Пользовательская реализация | Иерархии, парсинг                  |
| Бинарное дерево поиска (BST) | Нет                | \(O(n)\) (худший)  | Пользовательская реализация | Поиск, основа для сбалансированных |
| AVL-дерево                   | Да                 | \(O(\log n)\)      | Пользовательская реализация | Строгий баланс, базы данных        |
| Красно-чёрное дерево         | Да                 | \(O(\log n)\)      | `TreeMap`, `TreeSet`        | Упорядоченное хранение             |
| Сплей-дерево                 | Нет (амортизир.)   | \(O(\log n)\)      | Пользовательская реализация | Кэширование, частый доступ         |
| Куча (Heap)                  | Да (частично)      | \(O(\log n)\)      | `PriorityQueue`             | Очереди с приоритетами, алгоритмы  |
| Сегментное дерево            | Да                 | \(O(\log n)\)      | Пользовательская реализация | Запросы на диапазонах              |
| Фенвиковое дерево (BIT)      | Да                 | \(O(\log n)\)      | Пользовательская реализация | Префиксные суммы, массивы          |
| Декартово дерево (Treap)     | Да (вероятностная) | \(O(\log n)\)      | Пользовательская реализация | Динамические структуры             |

### **Связь с красно-чёрным деревом**

- Красно-чёрное дерево — один из видов сбалансированных бинарных деревьев,
  используемых в Java (`TreeMap`, `TreeSet`).
- Оно менее строгое, чем AVL-дерево, но более эффективное для вставки/удаления
  за счёт меньшего числа ротаций.
- В отличие от кучи, оно поддерживает упорядоченный доступ к элементам.
- По сравнению с несбалансированным BST, красно-чёрное дерево гарантирует \(O(
  \log n)\) за счёт цветовых правил и балансировки.

### **Итог**

- Основные виды бинарных деревьев: общее бинарное дерево, BST,
  сбалансированные (AVL, красно-чёрное, сплей), куча, сегментное, Фенвиковое,
  декартово, синтаксическое.
- В Java стандартная библиотека использует красно-чёрное дерево (`TreeMap`,
  `TreeSet`) и кучу (`PriorityQueue`).
- Другие виды (AVL, Trie, сегментное и т.д.) реализуются вручную для
  специфических задач.

## ВИДЫ ДЕРЕВЬЕВ ПОДРОБНО

## 1. _**БИНАРНОЕ ДЕРЕВО(Binary Tree)**_

**Бинарное дерево** в Java — это структура данных, в которой каждый узел имеет
не более двух потомков, обычно называемых **левым** и **правым**. Оно
используется для представления иерархических данных, таких как деревья поиска,
кучи или синтаксические деревья. В стандартной библиотеке Java нет готового
класса для бинарного дерева, поэтому его обычно реализуют вручную.

### Основные характеристики бинарного дерева:

- **Узел**: Содержит значение (данные) и ссылки на левого и правого потомка.
- **Корень**: Верхний узел дерева.
- **Лист**: Узел без потомков.
- **Глубина/высота**: Максимальное расстояние от корня до листа.

### Пример реализации бинарного дерева в Java:

```java
// Класс для узла бинарного дерева
class Node {
    int value; // Значение узла
    Node left; // Левый потомок
    Node right; // Правый потомок

    Node(int value) {
        this.value = value;
        left = null;
        right = null;
    }
}

// Класс для бинарного дерева
class BinaryTree {
    Node root; // Корень дерева

    // Конструктор
    BinaryTree() {
        root = null;
    }

    // Метод для добавления узла (пример для бинарного поискового дерева)
    void insert(int value) {
        root = insertRec(root, value);
    }

    Node insertRec(Node root, int value) {
        if (root == null) {
            root = new Node(value);
            return root;
        }
        if (value < root.value) {
            root.left = insertRec(root.left, value);
        } else if (value > root.value) {
            root.right = insertRec(root.right, value);
        }
        return root;
    }

    // Обход дерева (in-order traversal)
    void inOrderTraversal(Node node) {
        if (node != null) {
            inOrderTraversal(node.left);
            System.out.print(node.value + " ");
            inOrderTraversal(node.right);
        }
    }

    // Пример использования
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.insert(50);
        tree.insert(30);
        tree.insert(70);
        tree.insert(20);
        tree.insert(40);

        System.out.println("In-order traversal:");
        tree.inOrderTraversal(tree.root); // Вывод: 20 30 40 50 70
    }
}
```

### Использование в Java:

- **В стандартной библиотеке**:
    - `TreeMap` и `TreeSet` используют **красно-черное дерево** (разновидность
      сбалансированного бинарного дерева).
    - `PriorityQueue` основана на **куче**, которая является бинарным деревом.
- **Применение**:
    - Поиск и сортировка (BST).
    - Построение выражений (деревья выражений).
    - Реализация алгоритмов (например, обход графа, Huffman coding).
    - Хранение иерархических данных (например, структура каталогов).

### Операции в бинарном дереве:

| Операция        | Время (BST)                       |
|-----------------|-----------------------------------|
| Вставка         | O(log n) в среднем, O(n) в худшем |
| Поиск           | O(log n) в среднем                |
| Удаление        | O(log n) в среднем                |
| Обход (DFS/BFS) | O(n)                              |

_**Обход бинарного дерева:**_

Существует три основных способа обхода:

1. **In-order** (`левый -> корень -> правый`): Используется для BST, чтобы
   получить элементы в отсортированном порядке.
2. **Pre-order** (`корень -> левый -> правый`): Для копирования дерева или
   сериализации.
3. **Post-order** (`левый -> правый -> корень`): Для удаления дерева или
   вычисления выражений.

_**Пример структуры дерева:**_

```
       50
      /  \
     30   70
    /  \
   20  40
```

- **In-order**: 20, 30, 40, 50, 70
- **Pre-order**: 50, 30, 20, 40, 70
- **Post-order**: 20, 40, 30, 70, 50

### Заключение:

Бинарное дерево в Java — это мощная структура данных, которую можно реализовать
вручную для решения множества задач. Оно лежит в основе многих алгоритмов и
встроенных классов (`TreeMap`, `TreeSet`). Если вам нужен конкретный пример (
например, реализация BST, AVL или обхода), уточните, и я предоставлю подробный
код или объяснение!

## 2. **Бинарное дерево поиска (Binary Search Tree — BST)**

**Бинарное дерево поиска (Binary Search Tree, BST)** — это разновидность
бинарного дерева, в котором каждый узел имеет не более двух потомков (левый и
правый), и выполняются следующие условия:

- Значение в каждом узле больше всех значений в его **левом поддереве**.
- Значение в каждом узле меньше всех значений в его **правом поддереве**.
- Значения в узлах обычно уникальны (дубликаты могут обрабатываться особым
  образом, если требуется).

Эти свойства делают BST эффективной структурой данных для операций поиска,
вставки и удаления, особенно если дерево сбалансировано.

### Основные характеристики:

- **Узел**: Содержит значение и ссылки на левого и правого потомка.
- **Корень**: Верхний узел дерева.
- **Лист**: Узел без потомков.
- **Свойство BST**: Для любого узла с значением `value` все значения в левом
  поддереве < `value`, а в правом > `value`.

### Пример структуры BST:

```
       50
      /  \
     30   70
    /  \
   20  40
```

- Узел `50` — корень.
- Левое поддерево (`30`, `20`, `40`) содержит значения < `50`.
- Правое поддерево (`70`) содержит значения > `50`.

### Основные операции в BST:

1. **Поиск (Search)**:
    - Сравниваем искомое значение с текущим узлом:
        - Если равно — узел найден.
        - Если меньше — идем в левое поддерево.
        - Если больше — идем в правое поддерево.
    - Время: (O(h)), где (h) — высота дерева ((O(log n)) для
      сбалансированного дерева, (O(n)) для вырожденного).

2. **Вставка (Insert)**:
    - Находим место для нового значения, следуя свойствам BST, и добавляем новый
      узел.
    - Время: (O(h)).

3. **Удаление (Delete)**:
    - Находим узел для удаления. Возможны три случая:
        - Узел — лист: просто удаляем.
        - Узел имеет одного потомка: заменяем узел на потомка.
        - Узел имеет двух потомков: заменяем узел на минимальный элемент из
          правого поддерева (или максимальный из левого) и удаляем этот
          минимальный узел.
    - Время: (O(h)).

4. **Обход (Traversal)**:
    - **In-order** (`левый -> корень -> правый`): Возвращает элементы в
      отсортированном порядке.
    - **Pre-order** (`корень -> левый -> правый`): Для копирования дерева.
    - **Post-order** (`левый -> правый -> корень`): Для удаления дерева.

### Реализация BST в Java:

```java
// Класс для узла
class Node {
    int value;
    Node left, right;

    Node(int value) {
        this.value = value;
        left = right = null;
    }
}

// Класс для бинарного дерева поиска
class BinarySearchTree {
    Node root;

    // Вставка
    void insert(int value) {
        root = insertRec(root, value);
    }

    Node insertRec(Node root, int value) {
        if (root == null) {
            root = new Node(value);
            return root;
        }
        if (value < root.value) {
            root.left = insertRec(root.left, value);
        } else if (value > root.value) {
            root.right = insertRec(root.right, value);
        }
        return root;
    }

    // Поиск
    boolean search(int value) {
        return searchRec(root, value) != null;
    }

    Node searchRec(Node root, int value) {
        if (root == null || root.value == value) {
            return root;
        }
        if (value < root.value) {
            return searchRec(root.left, value);
        }
        return searchRec(root.right, value);
    }

    // In-order обход
    void inOrderTraversal(Node node) {
        if (node != null) {
            inOrderTraversal(node.left);
            System.out.print(node.value + " ");
            inOrderTraversal(node.right);
        }
    }

    // Пример использования
    public static void main(String[] args) {
        BinarySearchTree bst = new BinarySearchTree();
        bst.insert(50);
        bst.insert(30);
        bst.insert(70);
        bst.insert(20);
        bst.insert(40);

        System.out.println("In-order traversal:");
        bst.inOrderTraversal(bst.root); // Вывод: 20 30 40 50 70

        System.out.println("\nSearch 40: " + bst.search(40)); // true
        System.out.println("Search 90: " + bst.search(90)); // false
    }
}
```

### Преимущества BST:

- Эффективный поиск, вставка и удаление (\( O(\log n) \) в среднем для
  сбалансированного дерева).
- Поддерживает упорядоченное хранение данных (in-order обход дает
  отсортированный список).
- Простота реализации базовых операций.

### Недостатки:

- **Несбалансированность**: Если дерево становится вырожденным (например, при
  вставке отсортированных данных), оно превращается в связный список, и операции
  занимают (O(n)).
- Для устранения этого недостатка используются **сбалансированные деревья**
  (AVL, красно-черное), которые поддерживают высоту порядка (O(log n)).

### Использование в Java:

- В стандартной библиотеке Java классы `TreeMap` и `TreeSet` используют *
  *красно-черное дерево**, которое является сбалансированной версией BST.
- BST часто применяется в задачах:
    - Поиск и сортировка.
    - Хранение словарей или ассоциативных массивов.
    - Реализация алгоритмов (например, построение интервальных деревьев).

### Примечание:

Если дерево должно быть сбалансированным, лучше использовать встроенные
`TreeMap` или `TreeSet` или реализовать AVL/красно-черное дерево. Простое BST
подходит для учебных целей или случаев, где данные не приводят к вырождению.


## 3. **Красно-чёрное дерево (Red-Black Tree)**

## Grok: Красно-черное дерево

Красно-черное дерево (Red-Black Tree) в Java — это самобалансирующееся бинарное
дерево поиска, которое обеспечивает эффективные операции вставки, удаления и
поиска с гарантированной логарифмической сложностью O(log n). Оно поддерживает
баланс за счёт соблюдения определённых правил, что предотвращает вырождение
дерева в связный список.

### Основные свойства красно-черного дерева:

1. **Узлы имеют цвет**: Каждый узел окрашен либо в красный, либо в чёрный цвет.
2. **Корень всегда чёрный**: Корень дерева всегда имеет чёрный цвет.
3. **Красные узлы не соседствуют**: Красный узел не может иметь красного
   родителя или ребёнка.
4. **Равное количество чёрных узлов**: Все пути от корня до листьев (или пустых
   узлов) содержат одинаковое количество чёрных узлов (чёрная высота).
5. **Листовые узлы (null)**: Все листовые узлы (обычно null) считаются чёрными.

### Применение в Java

В Java красно-черное дерево используется, например, в классе `TreeMap` (и,
соответственно, в `TreeSet`), который реализует интерфейс `NavigableMap`.
`TreeMap` хранит пары ключ-значение в порядке сортировки ключей, используя
красно-черное дерево для поддержания баланса и обеспечения логарифмической
сложности операций.

### Как это работает?

- **Вставка**: Новый узел добавляется как красный. Если это нарушает свойства
  дерева (например, создаёт два соседних красных узла), выполняются **ротации
  ** (левая или правая) и **перекрашивание** узлов для восстановления баланса.
- **Удаление**: Удаление узла может нарушить чёрную высоту. Для исправления
  также используются ротации и перекрашивание.
- **Поиск**: Операция поиска работает как в обычном бинарном дереве поиска, но
  благодаря балансировке высота дерева остаётся O(log n).

### Пример кода

В стандартной библиотеке Java реализация красно-черного дерева скрыта внутри
`TreeMap`, но вы можете использовать его так:

```java
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<Integer, String> treeMap = new TreeMap<>();
        treeMap.put(1, "One");
        treeMap.put(2, "Two");
        treeMap.put(3, "Three");

        System.out.println(treeMap); // Вывод: {1=One, 2=Two, 3=Three}
    }
}
```

### Преимущества

- Гарантированная производительность O(log n) для операций вставки, удаления и
  поиска.
- Поддержание порядка ключей (удобно для сортированных данных).

### Недостатки

- Сложнее в реализации по сравнению с другими структурами данных, такими как
  хэш-таблицы.
- Меньшая производительность на операциях по сравнению с хэш-таблицами (O(1)
  против O(log n)).

Если вам нужна собственная реализация красно-черного древа, это требует
написания сложной логики для ротаций и перекрашивания. Обычно рекомендуется
использовать встроенные классы, такие как `TreeMap`.

##################### Grok: Цвета

Цвета в красно-чёрном дереве — это ключевая особенность, которая помогает
поддерживать баланс дерева и обеспечивать логарифмическую сложность операций.
Каждый узел дерева окрашен либо в **красный**, либо в **чёрный** цвет, и эти
цвета используются для соблюдения правил, которые предотвращают слишком длинные
пути в дереве. Давайте разберём подробнее, как цвета работают, зачем они нужны и
как влияют на структуру дерева.

---

### **Роль цветов**

Цвета узлов — это механизм, который позволяет дереву оставаться *
*сбалансированным** без необходимости строгого равенства высот поддеревьев (как,
например, в AVL-деревьях). Вместо этого красно-чёрное дерево использует цвета
для контроля структуры, чтобы гарантировать, что ни один путь от корня до листа
не станет слишком длинным. Это достигается через **пять основных свойств**
красно-чёрного дерева:

1. **Каждый узел — красный или чёрный.**
2. **Корень всегда чёрный.**
3. **Все листья (NIL-узлы, пустые указатели) — чёрные.**
4. **Красный узел не может иметь красного родителя или ребёнка** (то есть два
   красных узла не могут быть соседними).
5. **Чёрная высота**: для каждого узла все пути от него до листьев содержат
   одинаковое количество чёрных узлов.

---

### **Зачем нужны цвета?**

Цвета нужны для того, чтобы:

- **Контролировать высоту дерева**: Красные узлы позволяют временно нарушать
  строгую сбалансированность, но правила (особенно запрет на два красных узла
  подряд) ограничивают, насколько длинными могут быть пути.
- **Упрощать балансировку**: Вместо сложных операций, как в AVL-деревьях,
  красно-чёрное дерево использует перекрашивание и ротации, что делает вставку и
  удаление более эффективными.
- **Гарантировать логарифмическую сложность**: Правила цветов обеспечивают, что
  высота дерева не превышает \(2 \cdot \log(n + 1)\), где \(n\) — число узлов.

---

### **Как цвета используются?**

Цвета играют ключевую роль при выполнении операций **вставки** и **удаления**,
так как эти операции могут нарушить баланс дерева. Рассмотрим подробнее:

#### **1. Вставка**

- Новый узел всегда добавляется как **красный**. Это минимизирует нарушение
  чёрной высоты (свойство 5), так как красный узел не влияет на количество
  чёрных узлов на путях.
- После вставки проверяются свойства дерева. Основная проблема — это нарушение *
  *свойства 4** (два красных узла подряд). Возможные случаи:
    - **Красный родитель и красный ребёнок**: Если новый узел красный, а его
      родитель тоже красный, это нарушение. Для исправления применяются:
        - **Перекрашивание**: Например, родитель и его брат (если он есть)
          становятся чёрными, а их родитель (дед) — красным. Это может вызвать
          новые нарушения, которые обрабатываются рекурсивно.
        - **Ротации**: Если перекрашивание не решает проблему (например, дед
          чёрный, а родитель и ребёнок красные), выполняются левые или правые
          ротации, чтобы восстановить структуру.
    - Если корень стал красным после перекрашивания, он перекрашивается в
      чёрный (свойство 2).

**Пример**:
Допустим, мы вставляем узел \(X\) (красный) в дерево, где его родитель \(P\)
тоже красный. Если дед \(G\) чёрный, а брат родителя \(S\) (если есть) красный:

1. Перекрашиваем \(P\) и \(S\) в чёрный, а \(G\) в красный.
2. Проверяем, не нарушает ли новый красный \(G\) свойства с его родителем.
   Если \(S\) чёрный или отсутствует, выполняем ротацию (например, левую или
   правую) и перекрашивание.

#### **2. Удаление**

- Удаление узла сложнее, так как оно может нарушить **чёрную высоту** (свойство
  5). Если удаляется чёрный узел, количество чёрных узлов на некоторых путях
  уменьшается, что требует исправления.
- При удалении узла используется **замена** (например, на минимальный узел из
  правого поддерева). Если удаляемый или заменяемый узел был чёрным, дерево
  может стать несбалансированным.
- Для восстановления чёрной высоты применяются:
    - **Перекрашивание**: Например, изменение цвета соседних узлов, чтобы
      компенсировать потерю чёрного узла.
    - **Ротации**: Перестройка структуры дерева, чтобы восстановить свойства.

**Пример**:
Если удаляется чёрный узел, а его ребёнок красный, можно просто перекрасить
ребёнка в чёрный, и чёрная высота сохранится. Если ребёнок тоже чёрный, может
потребоваться перекрашивание соседних узлов (например, брата удалённого узла) и
ротации.

---

### **Почему именно красный и чёрный?**

- Два цвета выбраны условно — это бинарное свойство (0 или 1), которое легко
  хранить (1 бит на узел).
- Красный цвет позволяет "временно" добавлять узлы без изменения чёрной высоты,
  что упрощает вставку.
- Чёрный цвет фиксирует структуру, обеспечивая минимальную высоту дерева.

---

### **Пример в Java (TreeMap)**

В Java `TreeMap` использует красно-чёрное дерево, но цвет узлов скрыт от
пользователя. Внутренне узлы имеют поле для хранения цвета (обычно реализуется
как булево поле `color`). Пример упрощённой структуры узла:

```java
class Node<K, V> {
    K key;
    V value;
    Node<K, V> left, right, parent;
    boolean color; // true = красный, false = чёрный
}
```

При вставке или удалении `TreeMap` вызывает методы вроде `fixAfterInsertion` или
`fixAfterDeletion`, которые:

1. Проверяют нарушения свойств (например, два красных узла подряд).
2. Выполняют перекрашивание (меняют `color` узлов).
3. Выполняют ротации (перестраивают ссылки `left`, `right`, `parent`).

---

### **Визуализация цветов**

Представьте дерево:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

- Узел 5 красный, но его родитель (10) чёрный, так что свойства соблюдены.
- Чёрная высота от корня до листьев: 2 (10 → 3 или 10 → 7 или 10 → 15).

Если добавить красный узел 6 как ребёнка 5, возникнет нарушение (два красных
узла подряд: 5 и 6). Это потребует перекрашивания или ротации.

---

### **Итог**

- Цвета (красный и чёрный) — это инструмент для поддержания баланса в
  красно-чёрном дереве.
- Красные узлы позволяют гибко добавлять новые элементы, минимизируя нарушения.
- Чёрные узлы обеспечивают строгую структуру, гарантируя сбалансированную
  высоту.
- При вставке и удалении цвета узлов изменяются (перекрашивание) вместе с
  ротациями, чтобы восстановить свойства дерева.

Если хотите, могу показать пример кода для вставки с обработкой цветов или
объяснить конкретный случай (например, что происходит при вставке узла в
определённое место). Уточните, пожалуйста!

=====

**Красно-чёрное дерево (Red-Black Tree)** — это самобалансирующееся **бинарное
дерево поиска (BST)**, в котором соблюдаются определённые правила для
поддержания **почти логарифмической высоты** даже при множественных вставках и
удалениях.

### Основная идея:

Каждый узел имеет дополнительный атрибут — **цвет**:
**красный** или **чёрный**

Эти цвета помогают сбалансировать дерево во время вставки и удаления.

### Свойства красно-чёрного дерева:

Каждый узел имеет цвет: **красный (R)** или **чёрный (B)**. Далее — ключевые
правила:

1. **Каждый узел либо красный, либо чёрный**

— Это базовое определение

2. **Корень всегда чёрный**

— Это помогает поддерживать равномерную высоту дерева

3. **Все листья (null-узлы) считаются чёрными**

— Даже если они не хранят значения (это "пустые указатели")

4. **Красный узел не может иметь красных потомков**

— То есть, **не может быть двух красных узлов подряд**
Это правило запрещает длинные красные цепочки и помогает балансировать дерево

5. **Путь от любого узла до всех его потомков-листьев содержит одинаковое
   количество чёрных узлов**

— Это называется **чёрная высота** (black height)
Это ключевое свойство, которое ограничивает высоту дерева

_**Благодаря этим правилам:**_

* Максимальная глубина дерева — **не более чем в 2 раза больше логарифма числа
  узлов** ⇒ Поиск, вставка, удаление работают за `O(log n)`

### Как это работает:

* При вставке или удалении может нарушиться одно из правил
  ➡ Дерево автоматически **перекрашивает узлы и делает повороты (ротации)**,
  чтобы восстановить баланс.

### Операции и их сложность:

| Операция | Время    |
|----------|----------|
| Поиск    | O(log n) |
| Вставка  | O(log n) |
| Удаление | O(log n) |

➡ Высота дерева всегда O(log n)

### Где используется:

| Класс Java | Основан на           |
|------------|----------------------|
| `TreeMap`  | Красно-чёрное дерево |
| `TreeSet`  | Красно-чёрное дерево |

### Пример:

Вот как может выглядеть красно-чёрное дерево после вставок:

```
      10(B)
     /     \
  5(R)     20(R)
 /   \       \
3(B) 7(B)     25(B)
```

### Почему оно лучше простого BST?

В обычном BST вставка отсортированных данных может привести к **вырожденному
дереву** (списку) с O(n) временем.
Красно-чёрное дерево этого **избегает за счёт балансировки**.

### Балансировка при вставке и удалении:

* Нарушение одного из правил вызывает **повторную окраску** и/или **ротации**:

    * **Левая/правая ротация** — поворот поддерева для восстановления структуры
    * **Перекраска** — смена цвета узлов

### Где используется:

| Java класс | Основан на           |
|------------|----------------------|
| `TreeMap`  | Красно-чёрное дерево |
| `TreeSet`  | Красно-чёрное дерево |

---

## СБАЛАНСИРОВАННОЕ ДЕРЕВО

========

################ Grok: Сбалансированное дерево

Сбалансированное дерево — это бинарное дерево поиска, в котором высота
поддеревьев каждого узла поддерживается таким образом, чтобы минимизировать
разницу в их высотах. Это обеспечивает эффективные операции (поиск, вставка,
удаление) с временной сложностью \(O(\log n)\), где \(n\) — количество узлов.
Рассмотрим подробнее:

---

### **Что значит "сбалансированное"?**

В обычном бинарном дереве поиска (BST) узлы добавляются в зависимости от их
значений, что может привести к **несбалансированности**. Например, если
вставлять элементы в порядке возрастания (1, 2, 3, ...), дерево выродится в
связный список с высотой \(O(n)\), и операции станут медленными (\(O(n)\)).

Сбалансированное дерево предотвращает это, поддерживая высоту дерева близкой к
\(\log n\). Это достигается за счёт дополнительных правил или операций, которые
ограничивают разницу в высотах левого и правого поддеревьев.

---

### **Ключевые характеристики сбалансированного дерева**

- **Ограниченная разница высот**: Разница в высотах поддеревьев (баланс-фактор)
  ограничена. Например:
    - В **AVL-дереве** разница высот не превышает 1.
    - В **красно-чёрном дереве** высота ограничена косвенно через правила
      цветов (максимум \(2 \cdot \log(n + 1)\)).
- **Логарифмическая высота**: Высота дерева близка к \(\log n\), что гарантирует
  быстрые операции.
- **Автоматическая балансировка**: После вставки или удаления выполняются
  операции (ротации, перекрашивание), чтобы восстановить баланс.

---

### **Примеры сбалансированных деревьев**

1. **AVL-дерево**:
    - Строго сбалансированное: разница высот левого и правого поддеревьев не
      больше 1.
    - Балансировка через ротации (левые, правые, лево-правые, право-левые).
    - Используется, когда важна максимальная сбалансированность.
2. **Красно-чёрное дерево** (о котором мы говорили ранее):
    - Менее строгое, чем AVL: использует цвета (красный/чёрный) для контроля
      баланса.
    - Высота может быть до \(2 \cdot \log(n + 1)\), но операции проще, чем в
      AVL.
    - Используется в Java (`TreeMap`, `TreeSet`).
3. **B-дерево** и **B+-дерево**:
    - Многоуровневые сбалансированные деревья, оптимизированные для работы с
      большими данными (например, в базах данных).
4. **Сплей-дерево**:
    - Самоадаптивное сбалансированное дерево, где часто используемые узлы
      перемещаются ближе к корню.

---

### **Зачем нужна сбалансированность?**

- **Эффективность операций**: Поиск, вставка и удаление выполняются за \(O(\log
  n)\), так как высота дерева минимальна.
- **Предсказуемость**: Сбалансированное дерево предотвращает вырождение в
  линейную структуру, что гарантирует стабильную производительность.
- **Применение**: Используется в структурах данных (например, `TreeMap` в Java),
  базах данных, файловых системах и других системах, где важна быстрая работа с
  упорядоченными данными.

---

### **Как достигается сбалансированность?**

Сбалансированность поддерживается через **балансировочные операции**:

1. **Ротации**:
    - Левый поворот: поднимает правое поддерево, опуская левое.
    - Правый поворот: поднимает левое поддерево, опуская правое.
    - Используются в AVL и красно-чёрных деревьях.
2. **Перекрашивание** (в красно-чёрных деревьях):
    - Изменение цветов узлов (красный/чёрный) для соблюдения правил, что
      косвенно ограничивает высоту.
3. **Реорганизация структуры**:
    - В B-деревьях: разделение или слияние узлов.
    - В сплей-деревьях: перемещение узлов ближе к корню.

---

### **Красно-чёрное дерево как сбалансированное**

Красно-чёрное дерево, о котором вы спрашивали ранее, является сбалансированным
благодаря своим цветовым правилам:

- Запрет на два красных узла подряд ограничивает длину путей с красными узлами.
- Равная чёрная высота на всех путях гарантирует, что дерево не станет слишком "
  вытянутым".
- После вставки или удаления выполняются перекрашивание и ротации, чтобы
  восстановить свойства, обеспечивающие сбалансированность.

**Пример**:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

Это сбалансированное красно-чёрное дерево: чёрная высота путей одинакова (2), а
высота дерева минимальна (\(\approx \log n\)).

---

### **Сравнение со несбалансированным деревом**

**Несбалансированное дерево** (например, обычное BST):

```
10
 \
  15
   \
    20
```

- Высота \(O(n)\), операции за \(O(n)\).
- Похоже на связный список.

**Сбалансированное дерево** (например, красно-чёрное):

```
   15
  /  \
10    20
```

- Высота \(O(\log n)\), операции за \(O(\log n)\).

---

### **Реализация в Java**

В Java сбалансированное дерево (красно-чёрное) используется в `TreeMap` и
`TreeSet`. Они автоматически поддерживают баланс, скрывая детали (цвета,
ротации) от пользователя. Например:

```java
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(10, "Десять");
        map.put(5, "Пять");
        map.put(15, "Пятнадцать");
        System.out.println(map); // {5=Пять, 10=Десять, 15=Пятнадцать}
    }
}
```

`TreeMap` гарантирует, что дерево остаётся сбалансированным, а ключи
упорядочены.

---

### **Итог**

- Сбалансированное дерево — это бинарное дерево поиска с ограниченной высотой (
  \(\approx \log n\)), что обеспечивает быстрые операции.
- Красно-чёрное дерево — пример сбалансированного дерева, где баланс достигается
  через цвета и правила.
- Сбалансированность важна для производительности и предсказуемости в задачах с
  большими объёмами данных.

Если хотите углубиться, например, в сравнение AVL и красно-чёрных деревьев или в
код ротаций, дайте знать!

############### Grok что такое сбалансированное дерево?

Сбалансированное дерево — это бинарное дерево поиска, в котором высота
поддеревьев каждого узла поддерживается таким образом, чтобы минимизировать
разницу в их высотах. Это обеспечивает эффективные операции (поиск, вставка,
удаление) с временной сложностью \(O(\log n)\), где \(n\) — количество узлов.
Рассмотрим подробнее:

---

### **Что значит "сбалансированное"?**

В обычном бинарном дереве поиска (BST) узлы добавляются в зависимости от их
значений, что может привести к **несбалансированности**. Например, если
вставлять элементы в порядке возрастания (1, 2, 3, ...), дерево выродится в
связный список с высотой \(O(n)\), и операции станут медленными (\(O(n)\)).

Сбалансированное дерево предотвращает это, поддерживая высоту дерева близкой к
\(\log n\). Это достигается за счёт дополнительных правил или операций, которые
ограничивают разницу в высотах левого и правого поддеревьев.

---

### **Ключевые характеристики сбалансированного дерева**

- **Ограниченная разница высот**: Разница в высотах поддеревьев (баланс-фактор)
  ограничена. Например:
    - В **AVL-дереве** разница высот не превышает 1.
    - В **красно-чёрном дереве** высота ограничена косвенно через правила
      цветов (максимум \(2 \cdot \log(n + 1)\)).
- **Логарифмическая высота**: Высота дерева близка к \(\log n\), что гарантирует
  быстрые операции.
- **Автоматическая балансировка**: После вставки или удаления выполняются
  операции (ротации, перекрашивание), чтобы восстановить баланс.

---

### **Примеры сбалансированных деревьев**

1. **AVL-дерево**:
    - Строго сбалансированное: разница высот левого и правого поддеревьев не
      больше 1.
    - Балансировка через ротации (левые, правые, лево-правые, право-левые).
    - Используется, когда важна максимальная сбалансированность.
2. **Красно-чёрное дерево** (о котором мы говорили ранее):
    - Менее строгое, чем AVL: использует цвета (красный/чёрный) для контроля
      баланса.
    - Высота может быть до \(2 \cdot \log(n + 1)\), но операции проще, чем в
      AVL.
    - Используется в Java (`TreeMap`, `TreeSet`).
3. **B-дерево** и **B+-дерево**:
    - Многоуровневые сбалансированные деревья, оптимизированные для работы с
      большими данными (например, в базах данных).
4. **Сплей-дерево**:
    - Самоадаптивное сбалансированное дерево, где часто используемые узлы
      перемещаются ближе к корню.

---

### **Зачем нужна сбалансированность?**

- **Эффективность операций**: Поиск, вставка и удаление выполняются за \(O(\log
  n)\), так как высота дерева минимальна.
- **Предсказуемость**: Сбалансированное дерево предотвращает вырождение в
  линейную структуру, что гарантирует стабильную производительность.
- **Применение**: Используется в структурах данных (например, `TreeMap` в Java),
  базах данных, файловых системах и других системах, где важна быстрая работа с
  упорядоченными данными.

---

### **Как достигается сбалансированность?**

Сбалансированность поддерживается через **балансировочные операции**:

1. **Ротации**:
    - Левый поворот: поднимает правое поддерево, опуская левое.
    - Правый поворот: поднимает левое поддерево, опуская правое.
    - Используются в AVL и красно-чёрных деревьях.
2. **Перекрашивание** (в красно-чёрных деревьях):
    - Изменение цветов узлов (красный/чёрный) для соблюдения правил, что
      косвенно ограничивает высоту.
3. **Реорганизация структуры**:
    - В B-деревьях: разделение или слияние узлов.
    - В сплей-деревьях: перемещение узлов ближе к корню.

---

### **Красно-чёрное дерево как сбалансированное**

Красно-чёрное дерево, о котором вы спрашивали ранее, является сбалансированным
благодаря своим цветовым правилам:

- Запрет на два красных узла подряд ограничивает длину путей с красными узлами.
- Равная чёрная высота на всех путях гарантирует, что дерево не станет слишком "
  вытянутым".
- После вставки или удаления выполняются перекрашивание и ротации, чтобы
  восстановить свойства, обеспечивающие сбалансированность.

**Пример**:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

Это сбалансированное красно-чёрное дерево: чёрная высота путей одинакова (2), а
высота дерева минимальна (\(\approx \log n\)).

---

### **Сравнение со несбалансированным деревом**

**Несбалансированное дерево** (например, обычное BST):

```
10
 \
  15
   \
    20
```

- Высота \(O(n)\), операции за \(O(n)\).
- Похоже на связный список.

**Сбалансированное дерево** (например, красно-чёрное):

```
   15
  /  \
10    20
```

- Высота \(O(\log n)\), операции за \(O(\log n)\).

---

### **Реализация в Java**

В Java сбалансированное дерево (красно-чёрное) используется в `TreeMap` и
`TreeSet`. Они автоматически поддерживают баланс, скрывая детали (цвета,
ротации) от пользователя. Например:

```java
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(10, "Десять");
        map.put(5, "Пять");
        map.put(15, "Пятнадцать");
        System.out.println(map); // {5=Пять, 10=Десять, 15=Пятнадцать}
    }
}
```

`TreeMap` гарантирует, что дерево остаётся сбалансированным, а ключи
упорядочены.

---

### **Итог**

- Сбалансированное дерево — это бинарное дерево поиска с ограниченной высотой (
  \(\approx \log n\)), что обеспечивает быстрые операции.
- Красно-чёрное дерево — пример сбалансированного дерева, где баланс достигается
  через цвета и правила.
- Сбалансированность важна для производительности и предсказуемости в задачах с
  большими объёмами данных.

Если хотите углубиться, например, в сравнение AVL и красно-чёрных деревьев или в
код ротаций, дайте знать!

=======

Самобалансирующееся бинарное дерево поиска (Self-Balancing Binary Search Tree)
— это разновидность бинарного дерева поиска (BST), которое **автоматически
поддерживает сбалансированную структуру** после вставки или удаления элементов.

### Почему нужно самобалансирующееся дерево?

Обычное BST может **выродиться в список**, если элементы вставляются в
отсортированном порядке:

```
Вставка: 1 → 2 → 3 → 4 → 5

BST становится:
1
 \
  2
   \
    3
     ...
```

➡ В таком случае **поиск, вставка и удаление становятся O(n)**.
Самобалансирующееся дерево сохраняет **высоту O(log n)**.

### Как оно балансируется?

После вставки или удаления:

* **выполняются повороты (ротации)** узлов
* **перекрашиваются** (в случае красно-чёрного дерева)
* **пересчитываются факторы баланса** (например, в AVL)

### Популярные типы самобалансирующихся деревьев:

| Дерево                   | Особенности                                                   |
|--------------------------|---------------------------------------------------------------|
| **AVL-дерево**           | Поддерживает строгое равновесие по высоте (макс. разница 1)   |
| **Красно-чёрное дерево** | Более "лениво" балансирует, но быстрее при вставке и удалении |
| **Splay-дерево**         | Перемещает часто используемые элементы вверх                  |
| **Treap**                | Комбинирует свойства BST и кучи                               |
| **B-дерево / B+**        | Используется в базах данных и файловых системах               |

### Сложность (у всех O(log n) в среднем и худшем случае):

| Операция | Время    |
|----------|----------|
| Поиск    | O(log n) |
| Вставка  | O(log n) |
| Удаление | O(log n) |

### Применение:

* `TreeMap`, `TreeSet` в Java (на основе красно-чёрного дерева)
* Индексация в базах данных (например, B-деревья)
* Алгоритмы с приоритетами, сбалансированными интервалами

---

## КАК РАБОТАЕТ БАЛАНСИРОВКА

Балансировка в **самобалансирующихся бинарных деревьях поиска (например, AVL или
красно-чёрное дерево)** — это процесс, при котором после **вставки или удаления
узла** дерево автоматически изменяет свою структуру, чтобы сохранить
**логарифмическую высоту**, а значит — эффективную производительность (O(log
n)).

### Рассмотрим на примере **AVL-дерева**

_**Что такое "фактор баланса" узла?**_

Фактор баланса = высота левого поддерева − высота правого поддерева.

* Допустимы значения: **−1, 0, 1**
* Если выходит за эти пределы → требуется **балансировка**

#### 🔄 Сценарии дисбаланса и повороты (ротации):

1. **LL (Left-Left) — правый поворот (Right Rotation)**

```
  30            20
 /             / \
20    →      10  30
/
10
```

2. **RR (Right-Right) — левый поворот (Left Rotation)**

```
10               20
  \             /  \
   20    →     10  30
     \
     30
```

3. **LR (Left-Right) — левый + правый поворот**

```
   30          30          20
  /           /           /  \
10    →     20    →     10  30
  \         /
   20     10
```

4. **RL (Right-Left) — правый + левый поворот**

```
10             10             20
  \              \           /  \
   30     →       20   →   10   30
  /                  \
 20                   30
```

### В Java (на уровне логики):

1. После вставки/удаления — пересчитываются высоты всех узлов.
2. Если нарушен баланс (|фактор| > 1) → определяется тип дисбаланса.
3. Выполняется соответствующий поворот.

### Зачем это всё?

* Без балансировки: вставка 1, 2, 3, 4, 5 → **линейное дерево**
* С балансировкой: всегда сохраняется **почти идеальная форма**

---

## Что из себя представляет бинарное дерево в памяти java?

В памяти Java бинарное дерево представляет собой **набор связанных объектов**,
каждый из которых — это **узел дерева** (класс `Node`), содержащий:

1. Данные (например, `int value`)
2. Ссылку на **левого потомка** (`left`)
3. Ссылку на **правого потомка** (`right`)

### Структура узла:

```java
class Node {
    int value;
    Node left;
    Node right;

    Node(int value) {
        this.value = value;
    }
}
```

### В памяти:

Каждый узел — это объект в куче (heap), содержащий:

* Поле `value` (например, 10)
* Ссылки `left` и `right` (указатели на другие объекты `Node`)
* Эти указатели формируют структуру дерева

### 📊 Пример:

```java
void demo() {
    Node root = new Node(10);
    root.left = new Node(5);
    root.right = new Node(15);
}
```

В памяти Java:

```
     [10]
     /   \
  [5]     [15]
```

Каждый `[]` — отдельный объект в памяти.

_**Где это хранится в памяти?**_

| Часть                                   | Расположение                                       |
|-----------------------------------------|----------------------------------------------------|
| `Node` объекты                          | Куча (Heap)                                        |
| Локальные переменные (например, `root`) | Стек (Stack), содержит **ссылку** на объект в куче |

## Особенности:

* Узлы дерева не обязательно хранятся последовательно в памяти.
* Каждая связь между узлами — это **ссылка**.
* Если дерево большое, то оно может быть **разбросано по куче**.

---

## Балансировка в jvm

Процесс балансировки красно-чёрного дерева в JVM (Java Virtual Machine),
например, в реализации `TreeMap` из пакета `java.util`, представляет собой
внутренний механизм, который автоматически восстанавливает свойства
красно-чёрного дерева после операций вставки или удаления. Поскольку вы
спрашивали о красно-чёрных деревьях и сбалансированности, я сосредоточусь на
том, как JVM (точнее, реализация `TreeMap` в стандартной библиотеке Java)
выполняет балансировку, опираясь на цвета узлов, ротации и перекрашивание.

---

### **Контекст: Красно-чёрное дерево в `TreeMap`**

В Java `TreeMap` использует красно-чёрное дерево для хранения пар ключ-значение,
где ключи упорядочены. Балансировка происходит после:

- **Вставки** нового узла (метод `put`).
- **Удаления** узла (метод `remove`).

Цель балансировки — восстановить **пять свойств красно-чёрного дерева**:

1. Каждый узел красный или чёрный.
2. Корень чёрный.
3. Листья (NIL) чёрные.
4. Нет двух красных узлов подряд.
5. Чёрная высота одинакова для всех путей от узла до листьев.

JVM скрывает детали реализации от пользователя, но мы можем разобрать, как это
работает, основываясь на стандартной реализации в OpenJDK.

---

### **Как выглядит процесс балансировки?**

#### **1. Структура узла**

Внутренне `TreeMap` использует класс `Entry` для представления узла:

```java
static class Entry<K, V> {
    K key;
    V value;
    Entry<K, V> left, right, parent;
    boolean color; // true = красный, false = чёрный
}
```

- `color` хранит цвет узла (обычно `false` для чёрного, `true` для красного).
- `left`, `right`, `parent` — ссылки на дочерние узлы и родителя.

#### **2. Балансировка после вставки**

Когда новый узел добавляется в `TreeMap` (через `put`), он вставляется как *
*красный** узел, чтобы минимизировать нарушение чёрной высоты. После вставки
метод `fixAfterInsertion` восстанавливает свойства дерева.

**Шаги балансировки после вставки**:

1. **Проверка нарушений**:
    - Если новый узел — корень, он перекрашивается в чёрный (свойство 2).
    - Если родитель нового узла красный, возникает нарушение свойства 4 (два
      красных узла подряд). Тогда начинаются корректирующие действия.
2. **Случаи обработки (для узла \(x\))**:
    - **Случай 1: Родитель \(p\) красный, а его брат (дядя) тоже красный**:
        - Перекрашиваем родителя \(p\) и дядю в чёрный.
        - Деда \(g\) (родителя \(p\)) перекрашиваем в красный.
        - Проверяем деда рекурсивно, так как он теперь красный и может нарушать
          свойства.
    - **Случай 2: Родитель красный, дядя чёрный или отсутствует, \(x\) — внешний
      внук**:
        - Выполняется одна ротация (левая или правая) вокруг деда.
        - Родитель становится чёрным, дед — красным.
    - **Случай 3: Родитель красный, дядя чёрный или отсутствует, \(x\) —
      внутренний внук**:
        - Выполняется двойная ротация: сначала вокруг родителя, потом вокруг
          деда.
        - Родитель становится чёрным, дед — красным.
3. **Финальный шаг**:
    - Корень всегда перекрашивается в чёрный.

**Пример**:
Допустим, дерево:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

Вставляем узел 4 (красный) как левого ребёнка 5:

- 5 (родитель) красный, 4 (новый узел) красный → нарушение свойства 4.
- Дядя (7) чёрный, 4 — левый ребёнок 5 (внешний внук).
- Выполняется правая ротация вокруг деда (10), 5 становится новым корнем:

```
       5 (чёрный)
      /  \
   3 (чёрный)  10 (красный)
  /             / \
 4 (красный)  7 (чёрный) 15 (чёрный)
```

- Перекрашиваем 5 в чёрный, 10 в красный. Свойства восстановлены.

**Код в OpenJDK** (упрощённо, метод `fixAfterInsertion`):

```java
private void fixAfterInsertion(Entry<K, V> x) {
    x.color = RED;
    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K, V> y = rightOf(parentOf(parentOf(x))); // дядя
            if (colorOf(y) == RED) { // случай 1
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else { // случаи 2 и 3
                if (x == rightOf(parentOf(x))) { // случай 3
                    x = parentOf(x);
                    rotateLeft(x);
                }
                setColor(parentOf(x), BLACK); // случай 2
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else { // симметрично для правой стороны
            // аналогичная логика
        }
    }
    root.color = BLACK; // корень всегда чёрный
}
```

#### **3. Балансировка после удаления**

Удаление узла (через `remove`) сложнее, так как удаление чёрного узла может
нарушить чёрную высоту (свойство 5). Метод `fixAfterDeletion` корректирует
дерево.

**Шаги балансировки после удаления**:

1. **Замена узла**:
    - Удаляемый узел заменяется его преемником (например, минимальным узлом
      правого поддерева).
    - Если удаляемый узел или его преемник чёрный, это может уменьшить чёрную
      высоту на одном из путей.
2. **Случаи обработки (для узла \(x\), который заменил удалённый)**:
    - Если \(x\) красный, его просто перекрашивают в чёрный, и чёрная высота
      восстанавливается.
    - Если \(x\) чёрный, проверяется его брат \(s\) (sibling):
        - **Случай 1: Брат красный**:
            - Перекрашиваем брата в чёрный, родителя в красный, выполняем
              ротацию.
            - Переходим к другим случаям.
        - **Случай 2: Брат чёрный, оба его ребёнка чёрные**:
            - Перекрашиваем брата в красный, родителя проверяем рекурсивно.
        - **Случай 3: Брат чёрный, один из его детей красный**:
            - Выполняются ротации и перекрашивание, чтобы восстановить чёрную
              высоту.
3. **Финальный шаг**:
    - Корень перекрашивается в чёрный.

**Пример**:
Допустим, удаляем узел 3 из дерева:

```
       10 (чёрный)
      /  \
   5 (красный)  15 (чёрный)
  / \
3 (чёрный) 7 (чёрный)
```

- 3 — чёрный, его удаление уменьшает чёрную высоту левого пути.
- Заменяем 3 на NIL (чёрный лист).
- Проверяем брата 7 (чёрный) и его детей (NIL, чёрные).
- Перекрашиваем 7 в красный, 5 проверяем рекурсивно.
- Если нужно, выполняем ротации.

**Код в OpenJDK** (упрощённо, метод `fixAfterDeletion`):

```java
private void fixAfterDeletion(Entry<K, V> x) {
    while (x != root && colorOf(x) == BLACK) {
        if (x == leftOf(parentOf(x))) {
            Entry<K, V> sib = rightOf(parentOf(x)); // брат
            if (colorOf(sib) == RED) { // случай 1
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateLeft(parentOf(x));
                sib = rightOf(parentOf(x));
            }
            if (colorOf(leftOf(sib)) == BLACK && colorOf(rightOf(sib)) == BLACK) { // случай 2
                setColor(sib, RED);
                x = parentOf(x);
            } else { // случай 3
                if (colorOf(rightOf(sib)) == BLACK) {
                    setColor(leftOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateRight(sib);
                    sib = rightOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(rightOf(sib), BLACK);
                rotateLeft(parentOf(x));
                x = root;
            }
        } else { // симметрично для правой стороны
            // аналогичная логика
        }
    }
    setColor(x, BLACK);
}
```

#### **4. Ротации**

Ротации — это ключевой механизм балансировки, используемый при вставке и
удалении. Они изменяют структуру дерева, сохраняя порядок ключей.

**Левая ротация** (на узле \(p\)):

```
   p           r
  / \         / \
 l   r  →    p   rr
    / \     / \
   rl  rr  l   rl
```

- \(r\) становится родителем, \(p\) — левым ребёнком \(r\).
- \(rl\) становится правым ребёнком \(p\).

**Правая ротация** (на узле \(p\)):

```
     p         l
    / \       / \
   l   r  →  ll  p
  / \           / \
 ll  lr        lr  r
```

- \(l\) становится родителем, \(p\) — правым ребёнком \(l\).
- \(lr\) становится левым ребёнком \(p\).

Код ротации (пример из OpenJDK):

```java
private void rotateLeft(Entry<K, V> p) {
    if (p != null) {
        Entry<K, V> r = p.right;
        p.right = r.left;
        if (r.left != null)
            r.left.parent = p;
        r.parent = p.parent;
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p;
        p.parent = r;
    }
}
```

---

### **Как это работает в JVM?**

- **Память**: Каждый узел (`Entry`) хранит ключ, значение, ссылки (`left`,
  `right`, `parent`) и цвет. JVM управляет выделением памяти через сборщик
  мусора.
- **Производительность**: Ротации и перекрашивание — быстрые операции (\(O(
  1)\)), а общее количество итераций балансировки ограничено высотой дерева (
  \(O(\log n)\)).
- **Оптимизация**: Реализация в OpenJDK оптимизирована для минимизации операций
  с памятью и проверок условий.
- **Потокобезопасность**: `TreeMap` не потокобезопасен. Для параллельного
  доступа используется `ConcurrentSkipListMap`, который реализует другую
  структуру.

---

### **Итог**

- Балансировка в `TreeMap` (красно-чёрное дерево) в JVM происходит через:
    - **Перекрашивание**: изменение цветов узлов для соблюдения свойств (нет
      двух красных подряд, равная чёрная высота).
    - **Ротации**: перестройка структуры дерева (левые/правые ротации).
- После **вставки** корректируются нарушения из-за красных узлов (
  `fixAfterInsertion`).
- После **удаления** восстанавливается чёрная высота (`fixAfterDeletion`).
- Все операции выполняются за \(O(\log n)\), что гарантирует эффективность.

Если нужен конкретный пример (например, пошаговая трассировка вставки или
удаления) или анализ кода, уточните, и я разберу!

