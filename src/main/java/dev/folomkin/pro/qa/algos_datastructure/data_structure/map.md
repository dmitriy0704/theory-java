# Map

В Java структура данных **Map** представляет собой коллекцию пар ключ–значение
(key–value), где:

* **Ключи уникальны** — не может быть двух одинаковых.
* **Значения могут повторяться**.
* Ключи используются для **поиска значений за постоянное или логарифмическое
  время** в зависимости от реализации.

## Интерфейс `Map<K, V>`

Объявление:

```java
Map<String, Integer> map = new HashMap<>();
```

### Основные реализации `Map` в Java:

| Реализация        | Основана на          | Порядок ключей        | Время операций (get/put) | Особенности                                   |
|-------------------|----------------------|-----------------------|--------------------------|-----------------------------------------------|
| **HashMap**       | Хеш-таблица          | Не гарантируется      | O(1) в среднем           | Быстрая, неупорядоченная                      |
| **LinkedHashMap** | Хеш-таблица + список | Порядок вставки       | O(1)                     | Сохраняет порядок                             |
| **TreeMap**       | Красно-чёрное дерево | Отсортирован по ключу | O(log n)                 | Ключи должны быть Comparable                  |
| **Hashtable**     | Хеш-таблица          | Не гарантируется      | O(1), но устаревшая      | Потокобезопасна, заменена `ConcurrentHashMap` |

### Основные методы `Map`:

```java
void demo() {
    map.put("apple", 3);           // добавить/обновить
    map.get("apple");              // получить значение
    map.containsKey("apple");      // есть ли ключ
    map.containsValue(3);          // есть ли значение
    map.remove("apple");           // удалить
    map.keySet();                  // все ключи
    map.values();                  // все значения
    map.entrySet();                // все пары ключ–значение
}
```

### Пример:

```java
void demo() {
    Map<String, Integer> scores = new HashMap<>();
    scores.put("Alice", 90);
    scores.put("Bob", 85);
    System.out.println(scores.get("Alice")); // 90
    System.out.println(scores.containsKey("Bob")); // true
}
```

### Особенности:

* Все реализации `Map` используют **разные структуры под капотом**:

    * `HashMap` — массив + цепочки (или деревья с Java 8+)
    * `TreeMap` — бинарное дерево (красно-чёрное)
    * `LinkedHashMap` — хеш-таблица + двусвязный список

## Map.Entry

**`Map.Entry<K, V>`** представляет **одну пару "ключ–значение"** в любой
реализации интерфейса `Map`.

### Что такое `Map.Entry<K, V>`

Это **вложенный интерфейс** внутри `Map`, определяющий методы работы с отдельной
записью:

```java
public interface Map<K, V> {
    interface Entry<K, V> {
        K getKey();

        V getValue();

        V setValue(V value);

        boolean equals(Object o);

        int hashCode();
    }
}
```

### Пример реализации одной записи в `HashMap`

Во внутренней реализации `HashMap`, один элемент (`Entry`) может выглядеть
примерно так:

```java
static class Node<K, V> implements Map.Entry<K, V> {
    final int hash;
    final K key;
    V value;
    Node<K, V> next;

    Node(int hash, K key, V value, Node<K, V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
        return Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue());
    }
}
```

### Как это работает в `HashMap`:

* Каждое значение в `HashMap` хранится в `Node<K,V>`, которая реализует
  `Map.Entry<K,V>`.
* Эти узлы формируют цепочку (`next`) в случае коллизий — как связанный список.
* Методы `entrySet()`, `keySet()`, `values()` используют эти `Entry`-объекты для
  доступа к данным.

### Пример работы с `entrySet()`:

```java
void demo() {
    Map<String, Integer> map = new HashMap<>();
    map.put("A", 1);
    map.put("B", 2);
    for (Map.Entry<String, Integer> entry : map.entrySet()) {
        System.out.println(entry.getKey() + " -> " + entry.getValue());
    }
}


//-> Вывод:

//-> A -> 1
//-> B -> 2
```

---

## Цепочка узлов `Entry` в одном бакете при коллизии

![map_entry.png](/img/map_entry.png)

Это изображение иллюстрирует цепочку объектов `Map.Entry` (внутреннюю структуру,
используемую в `HashMap`) при коллизии, когда несколько пар ключ–значение
находятся в одном бакете.

### Что изображено:

* **Прямоугольники** представляют элементы, реализующие интерфейс
  `Map.Entry<K, V>`:

    * `A, 1`
    * `B, 2`
    * `C, 3`

* **Стрелки** между ними показывают связь через поле `next`, образуя
  **односвязный список**:

    * `A,1 → B,2 → C,3 → null`

* Это цепочка внутри одного бакета `HashMap`.

### Как это работает:

* Если несколько ключей получают один и тот же индекс после `hash % capacity`,
  они попадают в один бакет.
* Они размещаются в цепочку объектов `Entry`, связанных через `next`.
* При `put()` и `get()` хеш-карта пробегает эту цепочку, чтобы найти нужный
  ключ.

--------------------------------------------------------------------------------

## HashMap

- Пары ключ-значение, быстрая работа: `O(1)` в среднем.

### **Устройство**

HashMap в Java — это структура данных, которая реализует интерфейс Map и
использует хеш-таблицу для хранения пар "ключ-значение". Она обеспечивает
быстрый доступ к элементам по ключу, что делает её одной из самых популярных
реализаций Map.

**Основные характеристики HashMap**

1. Ключи и значения: HashMap хранит данные в виде пар "ключ-значение". Каждый
   ключ должен быть уникальным, но значения могут повторяться.
2. Неупорядоченность: Элементы в HashMap не имеют определенного порядка. Порядок
   вставки не сохраняется.
3. Допускает null: HashMap позволяет использовать один null в качестве ключа и
   любое количество null в качестве значений.
4. Не синхронизирован: HashMap не является потокобезопасным. Если несколько
   потоков одновременно изменяют его, необходимо использовать внешнюю
   синхронизацию.

**Как работает HashMap**

1. Хеширование<br>
   Когда вы добавляете пару "ключ-значение" в HashMap, ключ проходит через
   хеш-функцию, которая вычисляет хеш-код для этого ключа. Хеш-код — это целое
   число, которое используется для определения индекса (или бакета) в массиве
   (хеш-таблице), где будет храниться значение.

```java
int hash = key.hashCode();
int index = hash % array.length; // Определяем индекс в массиве
```

2. Создание бакета: Если по этому индексу еще нет других элементов, создается
   новый бакет. В Java это обычно реализуется как связный список или дерево.
3. Добавление элементов: Если по этому индексу уже есть элементы (из-за
   коллизий), новая пара "ключ-значение" добавляется в существующий бакет. В
   случае связного списка новый элемент добавляется в конец списка, а если
   используется сбалансированное дерево (например, Red-Black Tree), то элемент
   будет вставлен в соответствующее место дерева.
4. Обработка коллизий<br>
   Когда два ключа имеют одинаковый хеш-код и попадают в один и тот же индекс
   массива, HashMap создает связный список (или дерево) для хранения всех пар
   "ключ-значение", которые имеют одинаковый индекс. HashMap использует метод
   цепочек (chaining) для обработки этих коллизий. В Java 8 и выше, если
   количество элементов в цепочке превышает определенный порог (обычно 8),
   HashMap преобразует связный список в сбалансированное дерево (например,
   Red-Black Tree) для улучшения производительности.
5. Резервирование места<br>
   Когда количество элементов в HashMap превышает определенный порог (обычно 75%
   от текущей емкости), происходит увеличение емкости:
6. Время доступа<br>
   В среднем время доступа к элементам по ключу составляет O(1) благодаря
   использованию хеширования. Однако в худшем случае (например, если все
   элементы попадают в одну цепочку) время доступа может составлять O(n). Чтобы
   избежать этого, важно правильно выбирать размер начального массива и
   коэффициент загрузки.
7. Получение значения по ключу сначала вычисляется его хеш-код. Затем
   определяется индекс массива. Если по этому индексу есть несколько элементов
   (из-за коллизий), HashMap будет перебирать элементы в связанном списке или
   дереве до тех пор, пока не найдет нужный ключ.

**Бакеты**

В контексте HashMap в Java "бакеты" (или "ведра") — это структуры данных,
которые используются для хранения пар "ключ-значение". Бакеты помогают
организовать данные в HashMap и обеспечивают эффективный доступ к ним. Давайте
рассмотрим, как это работает.

**Причины Колизий**

1. Ограниченное количество индексов<br>
2. Хеш-функция<br>
3. Ограниченная длина хеша<br>
4. Сходство ключей<br>

Причины, почему два ключа могут иметь одинаковый хеш-код:<br>

1. **Ограниченное пространство значений**: Хеш-функция преобразует объект в
   целое число (хеш-код), и поскольку количество возможных объектов значительно
   больше, чем количество возможных целых чисел, разные объекты могут быть
   преобразованы в одно и то же значение.
2. **Алгоритм хеширования**: Хеш-функции не идеальны и могут создавать коллизии.
   Например, если два объекта имеют одинаковые значения для всех полей, которые
   участвуют в вычислении хеш-кода, они будут иметь одинаковый хеш-код.
3. **Пользовательские классы**: Если вы создаете собственный класс и
   переопределяете метод `hashCode()`, вы можете случайно создать коллизии, если
   не будете учитывать все важные поля объекта.

### Сложности методов

В среднем, операция добавления, удаления и поиска элемента по ключу в HashMap
имеют временную сложность O(1).

Проверка наличия значения (containsValue), итерация по элементам - O(n).

Однако, в худшем случае, когда все элементы попадают в
одну корзину, они будут связаны в связный список или дерево, и операция может
занимать время O(n), где n - количество элементов в корзине. Таким образом,
сложность операций в HashMap зависит от количества коллизий и хеш-функции.<br>
В среднем, сложность выборки элемента также составляет O(1), но в худшем случае
может достигать O(n).

### Ручная реализация Hashmap

Реализация **упрощённой версии `HashMap` вручную** — с минимальной
функциональностью:

* Используем **массив "бакетов"** (контейнеров)
* Разрешение коллизий — через **цепочки (связные списки)**

_**Упрощённый `MyHashMap<K, V>` на Java:**_

```java
import java.util.LinkedList;

public class MyHashMap<K, V> {
    private static final int SIZE = 16;

    private LinkedList<Entry<K, V>>[] buckets;

    public MyHashMap() {
        buckets = new LinkedList[SIZE];
        for (int i = 0; i < SIZE; i++) {
            buckets[i] = new LinkedList<>();
        }
    }

    private int getIndex(K key) {
        return Math.abs(key.hashCode() % SIZE);
    }

    public void put(K key, V value) {
        int index = getIndex(key);
        LinkedList<Entry<K, V>> bucket = buckets[index];

        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                entry.value = value; // Обновление
                return;
            }
        }

        bucket.add(new Entry<>(key, value)); // Вставка
    }

    public V get(K key) {
        int index = getIndex(key);
        LinkedList<Entry<K, V>> bucket = buckets[index];

        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }

        return null;
    }

    public boolean containsKey(K key) {
        return get(key) != null;
    }

    public void remove(K key) {
        int index = getIndex(key);
        buckets[index].removeIf(entry -> entry.key.equals(key));
    }

    private static class Entry<K, V> {
        K key;
        V value;

        Entry(K k, V v) {
            key = k;
            value = v;
        }
    }
}
```

_**Пример использования:**_

```java
public class Main {
    public static void main(String[] args) {
        MyHashMap<String, Integer> map = new MyHashMap<>();
        map.put("apple", 10);
        map.put("banana", 20);
        map.put("apple", 30); // обновление

        System.out.println(map.get("apple"));   // 30
        System.out.println(map.get("banana"));  // 20
        System.out.println(map.containsKey("pear")); // false

        map.remove("banana");
        System.out.println(map.get("banana"));  // null
    }
}
```

_**Как работает:**_

1. `hashCode()` → получаем хеш ключа.
2. `index = hash % buckets.length` → вычисляем индекс бакета.
3. Каждый бакет — это список пар (ключ, значение).
4. При коллизии элементы добавляются в список (цепочку).

### Как устроен `HashMap` с цепочками?

![hashmap-structure.png](/img/hashmap-structure.png)

На изображении показана структура данных **HashMap с разрешением коллизий через
цепочки**:

_**Бакеты (Buckets)**_

* Слева указаны индексы: `0`, `1`, `2`, `3`, `4` — это ячейки массива (размер
  хеш-таблицы = 5).
* Каждая ячейка — **бакет**, куда может попасть ключ в зависимости от его
  `hashCode()`.

_**Содержимое бакетов:**_

* **Bucket 0**: пустой → `null`
* **Bucket 1**: содержит два элемента (коллизия):

    * `A, 2`
    * `B, 2`
    * Они связаны в **цепочку** (связный список)
* **Bucket 2**: `C, 3`
* **Bucket 3**: коллизия:

    * `D, 4`
    * `E, 5`
* **Bucket 4**: пустой → `null`

_**Разрешение коллизий**_

Если два ключа дают один и тот же индекс (из-за `hash % size`), они помещаются в
**один и тот же бакет** — образуя **цепочку** (обычно связный список или дерево
в Java 8+ при большой нагрузке).

_**Что это иллюстрирует:**_

* HashMap — это массив списков.
* Каждый элемент добавляется в бакет по хешу.
* Коллизии не заменяют данные, а просто добавляют ещё один элемент в цепочку.

### Как вставляется новый элемент при коллизии по шагам

Как вставляется элемент в `HashMap`, когда происходит **коллизия** — то есть два
ключа попадают в один и тот же бакет.

_**Исходная ситуация:**_

* Размер хеш-таблицы: `5`
* Имеем бакеты: `[0, 1, 2, 3, 4]`
* Уже лежит:

```
Bucket[1]: [ ("A", 2) ]
```

#### Вставим ключ `"B"` со значением `2`

1. Вычисляем хеш:

   ```java
   int hash = "B".hashCode();
   ```
2. Индекс бакета:

   ```java
   int index = hash % 5; // допустим, снова 1
   ```

#### Коллизия!

* В `bucket[1]` уже есть `"A"`
* Мы ищем `"B"` в списке: его нет
* Добавляем `"B"` в конец цепочки

### После вставки:

```
Bucket[1]: [ ("A", 2) → ("B", 2) ]
```

* Бакет теперь содержит цепочку из двух элементов.
* При поиске `get("B")`:

    * Идём в `bucket[1]`
    * Перебираем цепочку
    * Находим `B` и возвращаем `2`

### Общая логика `put(K key, V value)` при коллизии:

1. Вычисляем индекс бакета.
2. Ищем в списке по ключу:

    * Если найден → **обновляем значение**
    * Если не найден → **добавляем в конец цепочки**

_**Пример кода:**_

```java
public void put(K key, V value) {
    int index = Math.abs(key.hashCode() % SIZE);
    for (Entry<K, V> entry : buckets[index]) {
        if (entry.key.equals(key)) {
            entry.value = value; // обновление
            return;
        }
    }
    buckets[index].add(new Entry<>(key, value)); // вставка
}
```

--------------------------------------------------------------------------------

## TreeMap

- Ключи сортируются по естественному порядку или `Comparator`.
- Операции — `O(log n)`

`TreeMap` — Это структура данных в Java, которая реализует интерфейс `Map` и
**хранит пары ключ-значение в отсортированном порядке по ключам**. Внутри он
устроен как **красно-черное дерево** (Red-Black Tree), точно так же, как и
`TreeSet`, только вместо одного значения хранится **ключ и связанное с ним
значение**.

### Внутреннее устройство `TreeMap`

#### Основная структура:

```java
public class TreeMap<K, V> extends AbstractMap<K, V>
        implements NavigableMap<K, V>, Cloneable, java.io.Serializable {

    private transient Entry<K, V> root;
    ...
}
```

- Внутренне `TreeMap` реализован как **бинарное дерево поиска** с
  балансировкой — **красно-черное дерево**.
- Каждый узел дерева содержит:
    - `K key`
    - `V value`
    - `Entry<K,V> left`, `right`, `parent`
    - `boolean color` (RED/BLACK)

`TreeMap<K, V>` в Java — это реализация интерфейса `Map`, которая **хранит
пары ключ–значение в отсортированном порядке**. В отличие от `HashMap`,
`TreeMap` основан не на хешах, а на **самоорганизующемся дереве** —
**красно-чёрном дереве**.

### Как устроен `TreeMap`:

1. Использует **красно-чёрное бинарное дерево поиска**:

    * Каждый узел имеет **ключ**, **значение**, **ссылки на левое и правое
      поддеревья**, цвет (`красный` или `чёрный`), а также ссылку на родителя.
    * Ключи отсортированы по **естественному порядку (`Comparable`)** или через
      **переданный `Comparator`**.

2. Вставка, удаление и поиск — работают со **сложностью O(log n)**.

### Пример структуры:

```java
void demo() {
    TreeMap<Integer, String> map = new TreeMap<>();
    map.put(5, "apple");
    map.put(2, "banana");
    map.put(8, "cherry");
}
```

Внутренне структура дерева будет примерно такая:

```
      5
     / \
    2   8
```

### Поведение:

* `firstKey()` — минимальный ключ
* `lastKey()` — максимальный ключ
* `higherKey(k)` — следующий больше ключ
* `lowerKey(k)` — предыдущий меньше ключ
* `subMap(from, to)` — диапазон ключей

### Основные операции

| Операция     | Сложность | Описание                           |
|--------------|-----------|------------------------------------|
| `put(k, v)`  | O(log n)  | вставка                            |
| `get(k)`     | O(log n)  | поиск                              |
| `remove(k)`  | O(log n)  | удаление                           |
| `firstKey()` | O(log n)  | минимальный ключ                   |
| `lastKey()`  | O(log n)  | максимальный ключ                  |
| `entrySet()` | O(n)      | все пары в отсортированном порядке |

### Когда использовать `TreeMap`?

Используй `TreeMap`, если тебе важно:

* Хранить элементы в **отсортированном порядке**
* Делать **поиск ближайших ключей**, диапазонов
* Работать с диапазонами (`subMap`, `headMap`, `tailMap`)

### Схема, как устроен `TreeMap` на уровне узлов

![treemap-structure.png](/img/treemap-structure.png)

На изображении представлена структура **бинарного дерева поиска (BST)**, как это
реализовано в `TreeMap` Java. Каждый узел содержит:

* Левую часть — **ключ (key)**
* Правую часть — **значение (value)**

#### Структура дерева:

```
        5:A
       /   \
    3:B     8:D
   /         /
 1:C       7:E
```

#### Что это означает:

* **Корень** дерева — узел с ключом `5`, значением `"A"`.
* Ключи **слева** от каждого узла — **меньше** текущего ключа.
* Ключи **справа** — **больше** текущего ключа.
* Таким образом, структура дерева **отсортирована по ключам**.

#### Поведение в TreeMap:

* Операции `put()`, `get()` и `remove()` используют структуру дерева.
* Вставка новых элементов поддерживает порядок ключей и сбалансированность
  дерева (через алгоритм красно-чёрного дерева — не показан цветами здесь).
* При добавлении, например, ключа `6`, он бы попал **между** `5` и `7`, как
  левый потомок `7`.

### Цель: вставить пару `6:F` в текущее дерево

Текущее дерево:

```
        5:A
       /   \
    3:B     8:D
   /         /
 1:C       7:E
```

#### Шаги вставки ключа `6`:

1. **Сравниваем с корнем** (`5`):

    * `6 > 5` → идём вправо к `8`

2. **Сравниваем с `8`**:

    * `6 < 8` → идём влево к `7`

3. **Сравниваем с `7`**:

    * `6 < 7` → идём влево
    * **слева от `7` — пусто** → вставляем сюда

## ✅ Обновлённое дерево:

```
        5:A
       /   \
    3:B     8:D
   /         /
 1:C       7:E
          /
        6:F
```

### Как это реализовано в `TreeMap`:

`TreeMap` реализует вставку через **рекурсивный или итеративный обход** с
использованием **Comparator** (если задан) или `Comparable` (по умолчанию),
поддерживая при этом **балансировку** через алгоритм **красно-чёрного дерева**
(например, перекидывание цветов, повороты).

### Как работает поиск по ключу (`get(6)`) в этом дереве

Как работает `get(6)` в `TreeMap`, используя структуру бинарного дерева поиска,
которую мы только что сформировали:

#### Структура дерева:

```
        5:A
       /   \
    3:B     8:D
   /         /
 1:C       7:E
          /
        6:F
```

#### Шаги выполнения `get(6)`:

1. **Начинаем с корня** (`5:A`):

    * `6 > 5` → идём вправо к `8:D`

2. **Сравниваем с `8:D`**:

    * `6 < 8` → идём влево к `7:E`

3. **Сравниваем с `7:E`**:

    * `6 < 7` → идём влево к `6:F`

4. **Сравнение с `6:F`**:

    * `6 == 6` → нашли ключ! ✅

#### Результат:

* Возвращаем значение `F`

#### Временная сложность:

* В сбалансированном дереве (как у `TreeMap`) глубина ≈ `log₂(n)`
* Поэтому `get()` работает за **O(log n)**

### Как работает удаление (`remove(6)`) из этого дерева

**Как работает `remove(6)`** в `TreeMap`, используя нашу текущую структуру
дерева:

#### Исходное дерево:

```
        5:A
       /   \
    3:B     8:D
   /         /
 1:C       7:E
          /
        6:F
```

Мы хотим удалить узел с ключом `6`.

#### Шаги удаления:

1. 🔍 Найти узел `6`

* Идём: `5 → 8 → 7 → 6`
* Нашли узел с ключом `6` и значением `F`.

2. Тип узла: **лист** (нет детей)

* Это простой случай: удаляется напрямую.
* Ссылка `left` у узла `7` теперь указывает на `null`.

Обновлённая структура дерева:

```
        5:A
       /   \
    3:B     8:D
   /         /
 1:C       7:E
```

#### Общие правила удаления в TreeMap:

1. **Если узел — лист** → просто удаляется.
2. **Если один ребёнок** → узел заменяется на своего ребёнка.
3. **Если два ребёнка** → ищется **наименьший узел в правом поддереве** (или
   наибольший в левом), он перемещается наверх, а исходный узел удаляется.

TreeMap дополнительно поддерживает **балансировку** (т.к. основан на
красно-чёрном дереве), но логика поиска и замены остаётся такой же.

---

### Как работают основные операции TreeMap

1. **`put(K key, V value)`**

- Ключ сравнивается с уже существующими ключами с помощью `compareTo()` или
  `Comparator`.
- Если такой ключ уже есть — значение перезаписывается.
- Если нет — создается новый узел и вставляется.
- Затем дерево **перебалансируется** по правилам красно-черного дерева.

> Сложность: **O(log n)**

2. **`get(K key)`**

- Ключ сравнивается с другими в дереве.
- Поиск идёт по правилам бинарного дерева поиска (лево <, право >).
- Возвращается связанное значение или `null`.

> Сложность: **O(log n)**

3. **`remove(K key)`**

- Ключ находится в дереве, удаляется соответствующий узел.
- Дерево **перестраивается и перебалансируется**.

> Сложность: **O(log n)**

4. **Навигационные методы (`NavigableMap`)**

TreeMap поддерживает удобные методы:

| Метод            | Что делает                   |
|------------------|------------------------------|
| `firstKey()`     | Первый (наименьший) ключ     |
| `lastKey()`      | Последний (наибольший) ключ  |
| `higherKey(k)`   | Следующий ключ после `k`     |
| `lowerKey(k)`    | Предыдущий ключ до `k`       |
| `ceilingKey(k)`  | Первый `≥ k`                 |
| `floorKey(k)`    | Последний `≤ k`              |
| `subMap(k1, k2)` | Подмножество от `k1` до `k2` |

Временная сложность операций

| Операция                  | Сложность    |
|---------------------------|--------------|
| `get()`                   | **O(log n)** |
| `put()`                   | **O(log n)** |
| `remove()`                | **O(log n)** |
| `firstKey()`, `lastKey()` | **O(log n)** |
| `iterator()` (по ключам)  | **O(n)**     |

### Пример использования

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        TreeMap<String, Integer> scores = new TreeMap<>();

        scores.put("Alice", 90);
        scores.put("Bob", 85);
        scores.put("Charlie", 92);

        System.out.println(scores); // {Alice=90, Bob=85, Charlie=92}
        System.out.println("Bob's score: " + scores.get("Bob")); // 85

        System.out.println("First key: " + scores.firstKey()); // Alice
        System.out.println("Next after Bob: " + scores.higherKey("Bob")); // Charlie

        scores.remove("Alice");
        System.out.println(scores); // {Bob=85, Charlie=92}
    }
}
```

### `TreeMap` vs `HashMap`

| Критерий             | `HashMap`        | `TreeMap`                            |
|----------------------|------------------|--------------------------------------|
| Порядок              | Нет              | Сортирует по ключам                  |
| Сложность `get()`    | O(1) (в среднем) | O(log n)                             |
| Сложность `put()`    | O(1)             | O(log n)                             |
| Поддержка диапазонов | ❌                | ✅ `subMap()`, `ceilingKey()` и т. д. |
| Null-ключи           | ✅ (один)         | ❌ (исключение)                       |

### Вывод:

- `TreeMap` — выбор, когда нужно **держать ключи в порядке** и выполнять
  поиск, навигацию, диапазоны.
- Использует **красно-черное дерево**: все операции выполняются за **O(log n)**.
- Не допускает `null` в качестве ключа, так как `compareTo()`/`Comparator` не
  работают с `null`.

### РЕАЛИЗАЦИЯ

- Добавление (`put`)
- Поиск (`get`)
- Упорядоченность по ключам (через `Comparable`)
- Простое бинарное дерево поиска (без балансировки)

> Это **упрощённая реализация** — без красно-черного дерева и
> перебалансировки, но с сохранением порядка по ключам.

## 🛠 Пример: `SimpleTreeMap<K, V>`

```java
public class SimpleTreeMap<K extends Comparable<K>, V> {

    private class Node {
        K key;
        V value;
        Node left, right;

        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private Node root;

    // Добавление пары ключ-значение
    public void put(K key, V value) {
        root = put(root, key, value);
    }

    private Node put(Node node, K key, V value) {
        if (node == null) return new Node(key, value);

        int cmp = key.compareTo(node.key);
        if (cmp < 0) node.left = put(node.left, key, value);
        else if (cmp > 0) node.right = put(node.right, key, value);
        else node.value = value; // перезапись
        return node;
    }

    // Поиск значения по ключу
    public V get(K key) {
        Node node = root;
        while (node != null) {
            int cmp = key.compareTo(node.key);
            if (cmp < 0) node = node.left;
            else if (cmp > 0) node = node.right;
            else return node.value;
        }
        return null;
    }

    // Вывод всех ключей в отсортированном порядке
    public void printInOrder() {
        printInOrder(root);
    }

    private void printInOrder(Node node) {
        if (node != null) {
            printInOrder(node.left);
            System.out.println(node.key + " = " + node.value);
            printInOrder(node.right);
        }
    }
}
```

### Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        SimpleTreeMap<String, Integer> map = new SimpleTreeMap<>();

        map.put("Charlie", 3);
        map.put("Alice", 1);
        map.put("Bob", 2);
        map.put("Bob", 22); // обновление

        System.out.println("Bob's value: " + map.get("Bob")); // 22

        System.out.println("All entries:");
        map.printInOrder();  // Выведет в порядке: Alice, Bob, Charlie
    }
}
```

### Особенности этой реализации:

| Особенность             | Реализация                            |
|-------------------------|---------------------------------------|
| Упорядоченность         | ✅ По `Comparable<K>` (in-order обход) |
| Балансировка            | ❌ Нет (может деградировать до O(n))   |
| Вставка, поиск          | O(h), где h — высота дерева           |
| Поведение при дубликате | Значение обновляется (`put`)          |

--------------------------------------------------------------------------------

## LinkedHashMap

- Сохраняет порядок вставки.

`LinkedHashMap` — это расширенная версия `HashMap` в Java, которая сохраняет
**порядок вставки элементов** или **порядок доступа**. Она объединяет
**быстроту `HashMap`** и **предсказуемый порядок обхода** как в списке.

### Что такое `LinkedHashMap`?

- Это реализация интерфейса `Map`, наследуется от `HashMap`.
- В отличие от обычного `HashMap`, `LinkedHashMap` сохраняет **порядок
  добавления** (или порядок использования, если задан `accessOrder = true`).

### Как он устроен внутри?

1. **Наследуется от `HashMap`**

```java
public class LinkedHashMap<K, V> extends HashMap<K, V> implements Map<K, V> {
    ...
}
```

2. **Внутренние связи: двусвязный список**

Каждая запись (`Entry`) в `HashMap` расширена до `LinkedHashMap.Entry`, и
содержит указатели:

```java
static class Entry<K, V> extends HashMap.Node<K, V> {
    Entry<K, V> before, after; // для связного списка
}
```

- `before`: предыдущий элемент
- `after`: следующий элемент

Этот список отслеживает **порядок элементов**.

### Типы порядка

Когда создаётся `LinkedHashMap`, можно выбрать поведение:

```java
new LinkedHashMap<>(initialCapacity,loadFactor,accessOrder)
```

- `accessOrder = false` (по умолчанию) → **порядок вставки**
- `accessOrder = true` → **порядок доступа (LRU-подобный)**

### Пример различий:

#### `accessOrder = false` (вставка)

```java
void demo() {

    LinkedHashMap<Integer, String> map = new LinkedHashMap<>();
    map.put(1, "A");
    map.put(2, "B");
    map.put(3, "C");
    System.out.println(map); // {1=A, 2=B, 3=C}
}

```

#### `accessOrder = true` (доступ)

```java
void demo() {
    LinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);
    map.put(1, "A");
    map.put(2, "B");
    map.put(3, "C");
    map.get(2); // доступ к элементу 2
    System.out.println(map); // {1=A, 3=C, 2=B}
}

```

#### 🔧 Автоматическое удаление (LRU Cache)

Можно создать `LinkedHashMap`, который сам удаляет старые элементы:

```java
LinkedHashMap<Integer, String> lruCache = new LinkedHashMap<>(16, 0.75f, true) {
    protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
        return size() > 3; // оставляем только 3 последних элемента
    }
};
```

Временная сложность операций

| Операция               | Сложность                            |
|------------------------|--------------------------------------|
| `put`, `get`, `remove` | **O(1)**                             |
| `iteration`            | **O(n)** (в порядке вставки/доступа) | 

_**Пример полного использования:**_

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        LinkedHashMap<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);

        map.put("A", 1);
        map.put("B", 2);
        map.put("C", 3);

        map.get("A"); // доступ — меняет порядок

        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " => " + entry.getValue());
        }
        // Выведет: B => 2, C => 3, A => 1 (порядок по доступу)
    }
}
```

_**Вывод**_

| Свойство          | `HashMap`        | `LinkedHashMap`                 |
|-------------------|------------------|---------------------------------|
| Сохраняет порядок | ❌                | ✅                               |
| Тип порядка       | Нет              | Вставка или доступ              |
| Быстродействие    | O(1)             | O(1)                            |
| Используется для  | Быстрого доступа | LRU кэши, предсказуемый порядок |

### РЕАЛИЗАЦИЯ

Ниже — **упрощённая реализация `LinkedHashMap`**, которую мы назовём
`MiniLinkedHashMap`. Она сохраняет:

- **вставку ключей в порядке** (как обычный `LinkedHashMap`)
- быстрые операции `get`, `put` за **O(1)** (на основе `HashMap`)
- порядок обхода с помощью **двусвязного списка**

#### `MiniLinkedHashMap<K, V>` (реализация)

```java
import java.util.*;

public class MiniLinkedHashMap<K, V> {
    private class Node {
        K key;
        V value;
        Node prev, next;

        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private final Map<K, Node> map = new HashMap<>();
    private Node head, tail;

    // Добавление или обновление элемента
    public void put(K key, V value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            return;
        }

        Node newNode = new Node(key, value);
        map.put(key, newNode);
        appendToTail(newNode);
    }

    // Получение значения по ключу
    public V get(K key) {
        Node node = map.get(key);
        return node != null ? node.value : null;
    }

    // Удаление по ключу
    public void remove(K key) {
        Node node = map.remove(key);
        if (node != null) removeNode(node);
    }

    // Печать всех пар ключ-значение в порядке вставки
    public void printInOrder() {
        Node current = head;
        while (current != null) {
            System.out.println(current.key + " = " + current.value);
            current = current.next;
        }
    }

    // Вспомогательные методы:
    private void appendToTail(Node node) {
        if (tail != null) {
            tail.next = node;
            node.prev = tail;
            tail = node;
        } else {
            head = tail = node;
        }
    }

    private void removeNode(Node node) {
        if (node.prev != null) node.prev.next = node.next;
        else head = node.next;

        if (node.next != null) node.next.prev = node.prev;
        else tail = node.prev;
    }
}
```

#### Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        MiniLinkedHashMap<String, Integer> map = new MiniLinkedHashMap<>();

        map.put("A", 1);
        map.put("B", 2);
        map.put("C", 3);

        map.put("B", 22); // обновляем значение

        System.out.println("B = " + map.get("B")); // 22

        map.remove("A");

        System.out.println("Map entries in insertion order:");
        map.printInOrder();  // Должно вывести: B = 22, C = 3
    }
}
```

#### Что эта реализация поддерживает:

| Возможность           | Реализовано?               |
|-----------------------|----------------------------|
| Сложность `get/put`   | ✅ O(1)                     |
| Сохранение порядка    | ✅ Вставка                  |
| Удаление элемента     | ✅ O(1)                     |
| `accessOrder`         | ❌ (можно добавить)         |
| `removeEldestEntry()` | ❌ (можно добавить для LRU) |

