# Очереди

## - `Queue` и `Deque`

- `LinkedList`, `ArrayDeque` — реализации.
- FIFO (очередь), LIFO (стек).
- Примеры: `offer()`, `poll()`, `peek()`, `push()`, `pop()`

Очереди в Java — это структуры данных, реализующие **интерфейс `Queue`**,
который представляет собой **первый вошёл — первый вышел (FIFO)** способ
обработки элементов. Java предлагает несколько реализаций очередей, каждая с
разным внутренним устройством и назначением.

---

## Интерфейс: `Queue<E>`

```java
public interface Queue<E> extends Collection<E>
```

Этот интерфейс содержит методы:

| Метод       | Описание                                                                        |
|-------------|---------------------------------------------------------------------------------|
| `offer(e)`  | Добавляет элемент в конец очереди (false, если нет места)                       |
| `add(e)`    | Добавить элемент (может выбросить исключение)                                   |
| `poll()`    | Удаляет и возвращает первый элемент (или null)                                  |
| `remove()`  | Удаляет и возвращает первый, бросает NoSuchElementException, если очередь пуста |
| `peek()`    | Как peek(), но бросает исключение, если очередь пуста                           |
| `element()` | Посмотреть на голову (или исключение)                                           |

---

## Интерфейс Deque

Интерфейс Deque расширяет вышеописанный интерфейс Queue и определяет поведение
двунаправленной очереди, которая работает как обычная однонаправленная очередь,
либо как стек, действующий по принципу LIFO (последний вошел - первый вышел).


---

## Основные реализации очередей

### 1. **`LinkedList` как `Queue`**

- Двусвязный список.
- Реализует интерфейсы `List`, `Deque`, `Queue`.
- FIFO или двусторонняя очередь (Deque).
- Не потокобезопасна.

Устройство: элементы хранятся в узлах, связанных `next` и `prev`.

```java
void demo() {
    Queue<String> queue = new LinkedList<>();
    queue.offer("A");
    queue.offer("B");
    System.out.println(queue.poll()); // A

}
```

### 2. **`ArrayDeque`**

ArrayDeque в Java — это двусторонняя очередь, основанная на динамическом
кольцевом массиве. Она очень быстрая и используется вместо Stack, Queue,
LinkedList для операций добавления/удаления с обеих сторон.

**Свойства:**

- Быстрая реализация очереди и стека на основе массива.
- Более эффективна, чем `LinkedList`.
- Позволяет добавление/удаление с обеих сторон (`Deque`).

**Структура `ArrayDeque`**

Внутри она устроена так:

```java
Object[] elements; // массив, где хранятся элементы
int head;          // индекс начала (где читаем)
int tail;          // индекс конца (где пишем)
```

#### Кольцевой буфер

* Массив **не перемещается** при удалении элементов — `head` и `tail`
  **двигаются по кругу**.
* Когда `tail` доходит до конца массива, он **обнуляется (0)** — и снова
  начинает заполнять массив с начала.

Кольцевой динамический массив (или кольцевой буфер, circular buffer) — это
структура данных, основанная на обычном массиве, но с особой логикой,
позволяющей эффективно использовать его как цикл. Часто используется в
реализациях очередей, таких как ArrayDeque.

**Основная идея**

- Когда конец массива достигается, следующий элемент записывается в начало
  массива, если там есть место.
- Индексы head и tail отслеживают, откуда читать и куда писать.
- Логика построена так, будто массив — это кольцо: конец соединён с началом.

**Пример (размер массива 5):**

```
[ A ][ B ][ C ][ - ][ - ]
   ↑             ↑
 head           tail
```

* `poll()` (чтение) будет с позиции `head` (`A`)
* `offer(X)` (запись) — в `tail` (`D`) → `tail = (tail + 1) % capacity`

После удаления `A` и `B`, и добавления новых:

```
[ X ][ Y ][ C ][ D ][ E ]
      ↑            ↑
    head         tail
```

**Почему **динамический**?**

Если все ячейки заняты и ты добавляешь ещё элемент:

* создаётся **новый массив в 2 раза больше**,
* все элементы копируются **в правильном порядке** (начиная с `head`),
* `head` сбрасывается в 0, `tail` — в `size`.

**Сложности операций:**

| Операция   | Сложность                        |
|------------|----------------------------------|
| Вставка    | `O(1)` (амортизированная)        |
| Удаление   | `O(1)`                           |
| Расширение | `O(n)` — только при переполнении |

### Применения:

* `ArrayDeque`, `ArrayBlockingQueue`
* Потоковые буферы
* Продюсер/консьюмер очереди
* Аудио/видео обработка

#### Пример работы

```java
void() {
    ArrayDeque<String> deque = new ArrayDeque<>();
    deque.addLast("A"); // tail = 0
    deque.addLast("B"); // tail = 1
    deque.addFirst("X"); // head = 15 (если capacity = 16)
}
```

#### Визуально (capacity = 16):

```
[ X , A , B , null, null, ..., null ]
   ↑     ↑
 head   tail
```

#### Операции

| Операция        | Что делает                      | Сложность |
|-----------------|---------------------------------|-----------|
| `addFirst(e)`   | Записывает `e` перед `head`     | O(1)      |
| `addLast(e)`    | Записывает `e` в `tail`         | O(1)      |
| `removeFirst()` | Удаляет и возвращает `head`     | O(1)      |
| `removeLast()`  | Удаляет и возвращает `tail - 1` | O(1)      |
| `peekFirst()`   | Смотрит `head`, не удаляя       | O(1)      |

#### Расширение массива

Если `head == tail` и очередь не пуста, значит массив переполнен:

1. Создаётся **массив в 2 раза больше**.
2. Элементы **копируются в новый массив**, начиная с `head`.
3. `head` сбрасывается в 0, `tail` — в `size`.

Это происходит редко — поэтому амортизированная вставка остаётся **O(1)**.

### Почему `ArrayDeque` лучше `Stack` и `LinkedList`:

* `Stack` устарел, медленнее (`Vector`-based, синхронизирован).
* `LinkedList` тратит больше памяти на ссылки.
* `ArrayDeque` быстрее, компактнее, не имеет накладных расходов на GC.

#### Head и tail

`head` и `tail` — ключевые указатели (индексы), которые
управляют работой кольцевого буфера (например, в `ArrayDeque`), позволяя
эффективно вставлять и удалять элементы без сдвига данных.

---

**Что такое `head` и `tail`?**

| Указатель | Что делает                                                |
|-----------|-----------------------------------------------------------|
| `head`    | Указывает на **первый элемент** (откуда читать / удалять) |
| `tail`    | Указывает на **следующую свободную ячейку** (куда писать) |

**Пример: очередь с размером 5**

Изначально буфер пуст:

```
Индексы:   0   1   2   3   4
Буфер:   [ - ][ - ][ - ][ - ][ - ]
           ↑
         head, tail
```

**Добавим 3 элемента: A, B, C**

```
[ A ][ B ][ C ][ - ][ - ]
               ↑
         head  tail
         (0)   (3)
```

* `A` пишется в `tail = 0`, потом `tail = (0 + 1) % 5 = 1`
* `B` → `tail = 1`, затем → `2`
* `C` → `tail = 2`, затем → `3`

**Удалим 1 элемент (`poll()`)**

```
[ - ][ B ][ C ][ - ][ - ]
      ↑
    head   tail
    (1)    (3)
```

* `poll()` читает и удаляет `A` из `head = 0`, затем `head = (0 + 1) % 5 = 1`

**Цикличность**

Если `tail` или `head` доходят до конца массива (`capacity - 1`), они просто
**обнуляются**:

```java
tail =(tail +1)%capacity;
head =(head +1)%capacity;
```

**Пример на Java:**

```java
int capacity = 5;
String[] buffer = new String[capacity];
int head = 0;
int tail = 0;

void offer(String val) {
    buffer[tail] = val;
    tail = (tail + 1) % capacity;
}

String poll() {
    String val = buffer[head];
    buffer[head] = null;
    head = (head + 1) % capacity;
    return val;
}
```

**Как избежать перезаписи?**

Если `tail + 1 == head`, буфер заполнен. Нужно:

* либо **расширить массив** (динамический рост),
* либо отказаться от добавления (если очередь фиксирована).

Схема, как `head` и `tail` перемещаются по кругу при добавлении/удалении

![circle_array_logic.png](/img/circle_array_logic.png)

На изображении показана работа **кольцевого буфера (circular buffer)** —
структуры данных, в которой элементы записываются и считываются по кругу.

**Обозначения на схеме:**

* 🟦 **Ячейки A, B, C** — уже добавленные элементы.
* ◻️ **Две пустые ячейки** — свободные места для новых данных.
* 🔄 **`head` (чёрная стрелка)** — указывает на элемент, который будет
  прочитан/удалён следующим (`A`).
* 🔄 **`tail` (красная стрелка)** — указывает на место, куда будет записан
  следующий элемент (пустая ячейка после `C`).

**Что происходит:**

* Если вызвать `poll()` — будет удалён `A`, и `head` сдвинется на `B`.
* Если вызвать `offer("D")` — он будет записан на место, куда указывает `tail`,
  и `tail` сдвинется дальше.

**Кольцевая логика:**

_**Если head = tail**_

Когда `tail` достигнет конца массива, он вернётся в начало. То же самое с
`head`. Это и делает буфер **кольцевым**.

Когда говорят, что **`tail` догоняет `head`** в **кольцевом буфере**, это
означает:

> `tail == head`, и буфер **полностью заполнен** — больше **нельзя добавлять
элементы**, не потеряв данные.

**Почему так?**

В кольцевом буфере:

* `head` указывает **где читать** (первый элемент).
* `tail` указывает **где писать** (следующая свободная ячейка).

Но если `tail` дошёл до того же индекса, где стоит `head` — **мы не можем
отличить "пустой буфер" от "переполненного"**, если не храним дополнительную
информацию (например, размер или флаг).

**Пример (буфер из 5 ячеек):**

```
Состояние до вставки:
[ A ][ B ][ C ][ D ][ E ]
   ↑                 ↑
 head             tail

После вставки `F` — tail догонит head:

[ F ][ B ][ C ][ D ][ E ]
   ↑
 head, tail (оба = 0) ← конфликт
```

Теперь `tail == head`:

* это может значить, что **буфер пуст** *(если ни одного элемента нет)*,
* или что **буфер полностью заполнен** *(если все ячейки заняты)*.

**Как решается:**

1. **Ограничение на количество элементов**:

* Держим `capacity - 1` ячеек активными.
* Одна всегда остаётся пустой для различения «пусто» и «полно».

2. **Храним `size` отдельно**:

* Если `size == capacity` → буфер полон.
* Если `size == 0` → буфер пуст.

3. **Флаг состояния (`isFull`)**:

* Явно отслеживаем, был ли `tail` догнан `head` после записи.

**Вывод:**

> Когда `tail == head`, это ключевой момент — буфер либо **пуст**, либо *
*переполнен**. Нужно доп. информацию, чтобы отличить эти состояния.


**_Как расширить массив если head = tail?_**

Если в **кольцевом буфере `head == tail`** и **буфер полон**, это сигнал, что
нужно **расширить массив**. Расширение важно, чтобы избежать перезаписи и
сохранить порядок элементов.

**Цель:**

Создать **новый массив в 2 раза больше**, скопировать в него элементы **в
правильном порядке**, и сбросить `head` и `tail`.

**Шаги по расширению:**

Допустим:

* Старый массив: `oldArray` размером `N`
* Новый массив: `newArray` размером `2 * N`
* `head` — индекс начала очереди
* `tail` — индекс конца (равен `head`, но очередь полна)


1. Вычислить количество элементов

```java
int size = oldArray.length;
```

Или если используется `count`, можно использовать его напрямую.

2. Скопировать данные в новый массив по порядку

```java
void demo() {
    Object[] newArray = new Object[2 * size];
    for (int i = 0; i < size; i++) {
        newArray[i] = oldArray[(head + i) % size];
    }
}

```

* Это копирует от `head` до `tail`, по кольцу.
* Используется `mod` (`%`) для обработки перехода через конец массива.


3. Обновить указатели

```java
head =0;
tail =size;
elements =newArray;
```

**Итого:**

* Элементы теперь идут с позиции `0` до `size - 1` в новом массиве.
* `head = 0` — начало очереди.
* `tail = size` — следующее свободное место.

Гарантия:

* Порядок элементов сохранён.
* Вставка и удаление снова будут `O(1)`.
* Расширение занимает `O(n)`, но **случается редко**, поэтому **амортизированная
  вставка — всё равно `O(1)`**.

**Авторасширение**

Вот пример **простого кольцевого буфера с автоматическим расширением** на Java.
Он реализует базовые методы: `offer()`, `poll()` и `peek()`. При переполнении
буфер **удваивает размер**, сохраняя порядок элементов.

**Реализация: `CircularQueue`**

```java
public class CircularQueue<E> {
    private Object[] elements;
    private int head = 0;
    private int tail = 0;
    private int size = 0;

    public CircularQueue(int initialCapacity) {
        elements = new Object[initialCapacity];
    }

    public void offer(E e) {
        if (size == elements.length) {
            resize();
        }
        elements[tail] = e;
        tail = (tail + 1) % elements.length;
        size++;
    }

    @SuppressWarnings("unchecked")
    public E poll() {
        if (size == 0) return null;
        E value = (E) elements[head];
        elements[head] = null; // очистка для GC
        head = (head + 1) % elements.length;
        size--;
        return value;
    }

    @SuppressWarnings("unchecked")
    public E peek() {
        if (size == 0) return null;
        return (E) elements[head];
    }

    public int size() {
        return size;
    }

    private void resize() {
        int newCapacity = elements.length * 2;
        Object[] newElements = new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[(head + i) % elements.length];
        }
        elements = newElements;
        head = 0;
        tail = size;
    }
}
```

**Пример использования:**

```java
public class Main {
    public static void main(String[] args) {
        CircularQueue<String> queue = new CircularQueue<>(3);

        queue.offer("A");
        queue.offer("B");
        queue.offer("C"); // заполняем
        queue.offer("D"); // триггер расширения

        System.out.println(queue.poll()); // A
        System.out.println(queue.poll()); // B
        System.out.println(queue.peek()); // C
    }
}
```

**Особенности:**

* Использует **модульную арифметику** для кольцевой навигации.
* При расширении сохраняет **порядок FIFO**.
* Подходит как база для реализации очередей, стеков, буферов.

Хочешь добавить поддержку `removeLast()` (двустороннюю очередь, как
`ArrayDeque`)?
----

### 3. **`PriorityQueue`**
Очередь с приоритетом (**PriorityQueue**) — это структура данных, в которой **элементы извлекаются не в порядке вставки**, а в **порядке приоритета**. В Java она реализована как **минимальная бинарная куча (min-heap)**.

---

## 🔷 Основные свойства `PriorityQueue` в Java

* Находится в пакете `java.util`.
* Элементы **сортируются** автоматически по:

  * естественному порядку (`Comparable`), например `Integer`, `String`
  * или через переданный `Comparator`.

---

## ⚙️ Как работает:

* **Вставка** (`offer()` / `add()`) добавляет элемент в кучу и восстанавливает структуру.
* **Удаление** (`poll()`) всегда извлекает **наименьший элемент** (по приоритету).
* Все операции выполняются через **бинарную кучу** — представляется массивом.

---

## ⏱️ Сложность операций:

| Операция     | Сложность |
| ------------ | --------- |
| `add(e)`     | O(log n)  |
| `poll()`     | O(log n)  |
| `peek()`     | O(1)      |
| `contains()` | O(n)      |
| `remove(e)`  | O(n)      |

---

## 🧪 Пример:

```java
import java.util.PriorityQueue;

public class Main {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(5);
        pq.add(1);
        pq.add(3);

        System.out.println(pq.poll()); // 1
        System.out.println(pq.poll()); // 3
        System.out.println(pq.poll()); // 5
    }
}
```

---

## 🧭 Устройство (бинарная куча):

* Представлена как **массив**, где:

  * Для узла `i`:

    * Левый потомок = `2*i + 1`
    * Правый потомок = `2*i + 2`
    * Родитель = `(i - 1) / 2`
* Гарантируется, что **родитель < потомков** (в min-heap).

---

## 🎛 Пример с компаратором:

```java
PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> b.length() - a.length());
pq.add("one");
pq.add("three");
pq.add("two");

System.out.println(pq.poll()); // "three" (длина 5)
```

---

## 📌 Особенности:

* Не гарантирует порядок итерации.
* Можно использовать для задач: планирование, топ K, A\* алгоритмы, обработка событий.

---

Что такое бинарная куча и как назначается приоритет?


### 4. **`ConcurrentLinkedQueue`**

- Неблокирующая потокобезопасная очередь.
- Использует алгоритм **CAS (compare-and-swap)**.
- Хорошо подходит для многопоточности.

Устройство: односвязный список, без блокировок.

---

### 5. **`BlockingQueue` (и её подтипы)** — многопоточные очереди

| Реализация              | Особенности                                   |
|-------------------------|-----------------------------------------------|
| `ArrayBlockingQueue`    | Ограниченная очередь на массиве (FIFO)        |
| `LinkedBlockingQueue`   | Ограниченная/неограниченная очередь на списке |
| `PriorityBlockingQueue` | С приоритетом (не FIFO)                       |
| `DelayQueue`            | Очередь с отложенной выдачей                  |
| `SynchronousQueue`      | Без буфера, прямой обмен между потоками       |

🔧 Используют **блокировки (`ReentrantLock`)** или **семантику
ожидания (`wait/notify`)**.

---

## Выводы по устройству очередей в Java

| Реализация              | Структура          | Потокобезопасность | Использование           |
|-------------------------|--------------------|--------------------|-------------------------|
| `LinkedList`            | Двусвязный список  | ❌                  | Простые FIFO-очереди    |
| `ArrayDeque`            | Кольцевой буфер    | ❌                  | Стек + очередь          |
| `PriorityQueue`         | Двоичная куча      | ❌                  | Очередь с приоритетом   |
| `ConcurrentLinkedQueue` | Односвязный список | ✅ (без блокировок) | Многопоточные очереди   |
| `BlockingQueue`         | Разные             | ✅ (блокировки)     | Потокобезопасная работа |

---

## Временная сложность

Хорошо! Давайте разберем **временную сложность операций** для различных типов
**очередей в Java**, чтобы понимать, какие из них подходят для разных задач.

---

### Таблица временной сложности основных реализаций

| Реализация              | `offer()` / `add()` | `poll()` / `remove()` | `peek()` / `element()` | Поиск / contains |
|-------------------------|---------------------|-----------------------|------------------------|------------------|
| `LinkedList`            | O(1)                | O(1)                  | O(1)                   | O(n)             |
| `ArrayDeque`            | O(1) (амортиз.)     | O(1) (амортиз.)       | O(1)                   | O(n)             |
| `PriorityQueue`         | O(log n)            | O(log n)              | O(1)                   | O(n)             |
| `ConcurrentLinkedQueue` | O(1)                | O(1)                  | O(1)                   | O(n)             |
| `ArrayBlockingQueue`    | O(1)                | O(1)                  | O(1)                   | O(n)             |
| `LinkedBlockingQueue`   | O(1)                | O(1)                  | O(1)                   | O(n)             |
| `PriorityBlockingQueue` | O(log n)            | O(log n)              | O(1)                   | O(n)             |
| `DelayQueue`            | O(log n)            | O(log n)              | O(1)                   | O(n)             |

> 🔹 **O(1)** — операция за постоянное время  
> 🔹 **O(log n)** — из-за использования кучи (например, `PriorityQueue`)  
> 🔹 **O(n)** — если нужно просмотреть все элементы (например, `contains`,
`remove(object)`)

---

### Разбор по операциям

#### 1. **Добавление (`offer`, `add`)**

- У обычных FIFO очередей (`LinkedList`, `ArrayDeque`) — это O(1)
- У `PriorityQueue` и `DelayQueue` — O(log n), потому что нужно вставить в
  кучу (heap)

#### 2. **Удаление (`poll`, `remove`)**

- У `LinkedList`, `ArrayDeque` — быстрое удаление головы: O(1)
- У `PriorityQueue` — O(log n), нужно перебалансировать кучу

#### 3. **Чтение головы (`peek`, `element`)**

- У всех — **O(1)**, так как доступ к первому элементу не требует обхода

### 4. **Поиск (`contains`, удаление произвольного элемента)**

- В обычных реализациях (`LinkedList`, `ArrayDeque`, `PriorityQueue`) —
  **O(n)**, потому что нет индексации

---

### Примеры задач и подходящих очередей

| Задача                           | Лучшая структура                          | Почему                                                |
|----------------------------------|-------------------------------------------|-------------------------------------------------------|
| FIFO очередь без многопоточности | `ArrayDeque`                              | Быстрее и легче `LinkedList`                          |
| Очередь с приоритетами           | `PriorityQueue`                           | Доступ к минимуму — O(1), вставка/удаление — O(log n) |
| Многопоточная очередь            | `ConcurrentLinkedQueue` / `BlockingQueue` | Безопасно между потоками                              |
| Реализация LRU-кэша              | `LinkedHashMap` с доступом                | Сохраняет порядок доступа                             |

---

# Стек

Стек (Stack) в Java — это структура данных, работающая по принципу **LIFO**:
*Last-In, First-Out* (последний вошёл — первый вышел). То есть, элемент,
добавленный последним, извлекается первым.

---

## 📦 Где используется стек

- Вызовы методов (call stack)
- Обратный обход данных
- Проверка скобок
- Рекурсивные алгоритмы
- Постфиксная арифметика (Reverse Polish Notation)

---

## 📚 Основные реализации стека в Java

### 1. **Класс `Stack<E>`**

Находится в пакете `java.util`, устаревший, но всё ещё используемый.

```java
Stack<Integer> stack = new Stack<>();
stack.

push(10);            // добавить
stack.

push(20);
System.out.

println(stack.pop());  // 20
        System.out.

println(stack.peek()); // 10 (но не удаляет)
```

| Метод       | Описание                                |
|-------------|-----------------------------------------|
| `push(e)`   | Добавляет элемент                       |
| `pop()`     | Удаляет и возвращает верхний элемент    |
| `peek()`    | Возвращает верхний элемент без удаления |
| `isEmpty()` | Проверяет, пуст ли стек                 |

---

### 2. **Рекомендуемый способ: `Deque` как стек**

Современная альтернатива `Stack` — использовать `ArrayDeque` или `LinkedList` с
интерфейсом `Deque` (двусторонняя очередь).

```java
Deque<Integer> stack = new ArrayDeque<>();
stack.

push(1);
stack.

push(2);
System.out.

println(stack.pop()); // 2
```

Преимущества:

- Быстрее, чем `Stack`, так как не синхронизирован
- Прост в использовании

---

## ⏱ Временная сложность

| Операция | Сложность |
|----------|-----------|
| `push()` | O(1)      |
| `pop()`  | O(1)      |
| `peek()` | O(1)      |

---

## ⚠️ Почему `Stack` устарел?

- `Stack` расширяет `Vector`, который синхронизирован по умолчанию (тяжеловесен)
- Предпочтительнее использовать **`Deque` через `ArrayDeque`** — он быстрее и
  проще

---

## 🧪 Пример: Проверка сбалансированности скобок

```java
public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();
    for (char c : s.toCharArray()) {
        if (c == '(') stack.push(')');
        else if (c == '[') stack.push(']');
        else if (c == '{') stack.push('}');
        else if (stack.isEmpty() || stack.pop() != c) return false;
    }
    return stack.isEmpty();
}
```

---

## 🧠 Итог

| Свойство           | `Stack`       | `Deque` (рекомендуется) |
|--------------------|---------------|-------------------------|
| Потокобезопасность | Да (`Vector`) | Нет (можно обернуть)    |
| Производительность | Низкая        | Высокая                 |
| Гибкость           | Только стек   | Стек и очередь          |

---

Хочешь, чтобы я показал, как реализовать стек вручную (с нуля) на массиве или
связном списке?

## РЕАЛИЗАЦИЯ

Отлично! Ниже покажу, **как вручную реализовать стек** в Java двумя способами:

1. ✅ На **массиве**
2. ✅ На **односвязном списке**

---

## 🔧 Реализация стека на **массиве**

```java
public class ArrayStack<T> {
    private T[] data;
    private int top; // индекс следующей пустой ячейки

    @SuppressWarnings("unchecked")
    public ArrayStack(int capacity) {
        data = (T[]) new Object[capacity];
        top = 0;
    }

    public void push(T value) {
        if (top == data.length) throw new RuntimeException("Stack overflow");
        data[top++] = value;
    }

    public T pop() {
        if (isEmpty()) throw new RuntimeException("Stack underflow");
        return data[--top];
    }

    public T peek() {
        if (isEmpty()) throw new RuntimeException("Empty stack");
        return data[top - 1];
    }

    public boolean isEmpty() {
        return top == 0;
    }

    public int size() {
        return top;
    }
}
```

### ✅ Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        ArrayStack<Integer> stack = new ArrayStack<>(5);

        stack.push(10);
        stack.push(20);
        System.out.println(stack.pop()); // 20
        System.out.println(stack.peek()); // 10
    }
}
```

---

## 🔧 Реализация стека на **связанном списке**

```java
public class LinkedStack<T> {
    private class Node {
        T value;
        Node next;

        Node(T value, Node next) {
            this.value = value;
            this.next = next;
        }
    }

    private Node top = null;
    private int size = 0;

    public void push(T value) {
        top = new Node(value, top);
        size++;
    }

    public T pop() {
        if (isEmpty()) throw new RuntimeException("Stack underflow");
        T val = top.value;
        top = top.next;
        size--;
        return val;
    }

    public T peek() {
        if (isEmpty()) throw new RuntimeException("Empty stack");
        return top.value;
    }

    public boolean isEmpty() {
        return top == null;
    }

    public int size() {
        return size;
    }
}
```

### ✅ Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        LinkedStack<String> stack = new LinkedStack<>();

        stack.push("A");
        stack.push("B");
        System.out.println(stack.pop());  // B
        System.out.println(stack.peek()); // A
    }
}
```

---

## 📊 Сравнение реализаций

| Критерий         | Массив (`ArrayStack`)     | Связный список (`LinkedStack`) |
|------------------|---------------------------|--------------------------------|
| Размер           | Ограничен (фиксированный) | Гибкий, растёт динамически     |
| Скорость         | Быстрее (без аллокации)   | Медленнее (из-за `new Node`)   |
| Память           | Заранее выделяется        | Используется по необходимости  |
| Удаление/вставка | O(1)                      | O(1)                           |

---

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Временная сложность операций со стеком довольно проста, так как стек работает по
принципу **LIFO (Last-In, First-Out)**. Для основных операций со стеком
временная сложность следующая:

| Операция    | Временная сложность |
|-------------|---------------------|
| `push()`    | O(1)                |
| `pop()`     | O(1)                |
| `peek()`    | O(1)                |
| `isEmpty()` | O(1)                |
| `size()`    | O(1)                |

---

### Объяснение:

1. **`push(T value)`** — добавление элемента в стек:

- Вставка элемента на вершину стека происходит за **O(1)**, так как мы просто
  добавляем его в конец (или в начало списка).

2. **`pop()`** — удаление элемента с вершины стека:

- Удаление верхнего элемента стека также выполняется за **O(1)**, так как мы
  просто извлекаем элемент из вершины стека и смещаем указатель на предыдущий
  элемент.

3. **`peek()`** — получение элемента с вершины стека:

- Взятие верхнего элемента без его удаления происходит за **O(1)**, так как
  достаточно вернуть значение текущей вершины.

4. **`isEmpty()`** — проверка на пустоту:

- Проверка, пуст ли стек (по индексу или через указатель на верхний элемент),
  также выполняется за **O(1)**.

5. **`size()`** — получение размера стека:

- Если размер поддерживается как дополнительная переменная, то операция
  выполняется за **O(1)**.

---

Таким образом, все основные операции стека — это **O(1)**.

---

Хочешь узнать, как меняется сложность при других особенностях реализации,
например, при динамическом расширении массива в стеке?