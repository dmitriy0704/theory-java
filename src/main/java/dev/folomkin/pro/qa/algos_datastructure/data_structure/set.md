# Set

## HashSet

Отличный выбор — `HashSet` — это одна из ключевых структур данных в Java,
обеспечивающая **хранение уникальных элементов с быстрой вставкой, удалением и
поиском**.

### Что такое `HashSet`?

`HashSet` — это **реализация интерфейса `Set`**, основанная на **хеш-таблице**,
и **внутренне использует `HashMap`** для хранения данных.

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {
    private transient HashMap<E, Object> map;
    private static final Object PRESENT = new Object();
}
```

> Каждый элемент `E` сохраняется как ключ в `HashMap`, а значением всегда
> является `PRESENT` (заглушка).

### Как он работает внутри?

#### 1. **Хеш-функция**

- Когда ты добавляешь элемент в `HashSet`, Java вызывает его метод `hashCode()`:
  ```java
  int hash = element.hashCode();
  ```
- Этот хеш используется для определения **"бакета"** (ячейки) в хеш-таблице,
  куда помещается элемент.

#### 2. **Разрешение коллизий**

- Если два разных объекта дают одинаковый `hashCode`, используется метод
  `equals()` для сравнения.
- Java использует **цепочки (связанные списки или деревья)** внутри бакетов:
    - До Java 8: просто связанный список.
    - С Java 8+: при большом количестве коллизий — **красно-черное дерево**.

#### 3. **Добавление (`add`)**

- Проверяется, есть ли уже такой элемент (по `hashCode` и `equals`).
- Если нет — добавляется.

#### 4. **Удаление (`remove`)**

- Находится бакет по `hashCode()`.
- Удаляется элемент по `equals()`.

#### 5. **Поиск (`contains`)**

- Опять же — ищем бакет по `hashCode`, ищем элемент через `equals`.

### Временная сложность

| Операция     | Среднее время | Худший случай |
|--------------|---------------|---------------|
| `add()`      | O(1)          | O(n)          |
| `remove()`   | O(1)          | O(n)          |
| `contains()` | O(1)          | O(n)          |

> В худшем случае (например, если `hashCode` плохой и все в один бакет) всё
> превращается в линейный поиск.

### Пример использования

```java
void demo() {
    Set<String> fruits = new HashSet<>();
    fruits.add("Apple");
    fruits.add("Banana");
    fruits.add("Apple"); // дубликат не добавится
    System.out.println(fruits.contains("Apple")); // true
    System.out.println(fruits); // [Apple, Banana] (порядок не гарантируется)
}
```

### Важно: правильная реализация `hashCode()` и `equals()`

Для пользовательских объектов нужно **переопределять** эти методы:

```java

@Override
public int hashCode() {
    return Objects.hash(name, age);
}

@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof Person)) return false;
    Person other = (Person) obj;
    return age == other.age && Objects.equals(name, other.name);
}
```

### Под капотом — аналогия

| Аналогия                   | Java `HashSet`                         |
|----------------------------|----------------------------------------|
| Таблица с ячейками         | Хеш-таблица (массив бакетов)           |
| Имя объекта → номер ячейки | `hashCode()` → индекс бакета           |
| Сравнение имен             | `equals()` → проверка равенства        |
| Бросаем в ящик             | `put()` → добавить, если нет дубликата |

### РЕАЛИЗАЦИЯ

Простая реализация собственного `MiniHashSet`, чтобы понять, **как устроен
`HashSet` под капотом**. Мы реализуем:

- хеш-функцию,
- бакеты (массив списков),
- вставку (`add`),
- проверку наличия (`contains`),
- удаление (`remove`).

### Простейшая реализация `MiniHashSet`

```java
import java.util.LinkedList;

public class MiniHashSet<T> {
    private static final int DEFAULT_CAPACITY = 16;
    private LinkedList<T>[] buckets;

    public MiniHashSet() {
        buckets = new LinkedList[DEFAULT_CAPACITY];
        for (int i = 0; i < DEFAULT_CAPACITY; i++) {
            buckets[i] = new LinkedList<>();
        }
    }

    private int getBucketIndex(T key) {
        return Math.abs(key.hashCode() % buckets.length);
    }

    public void add(T key) {
        int index = getBucketIndex(key);
        LinkedList<T> bucket = buckets[index];
        if (!bucket.contains(key)) {
            bucket.add(key);
        }
    }

    public boolean contains(T key) {
        int index = getBucketIndex(key);
        return buckets[index].contains(key);
    }

    public void remove(T key) {
        int index = getBucketIndex(key);
        buckets[index].remove(key);
    }

    public void printBuckets() {
        for (int i = 0; i < buckets.length; i++) {
            System.out.println("Bucket " + i + ": " + buckets[i]);
        }
    }
}
```

### Пример использования

```java
public class Main {
    public static void main(String[] args) {
        MiniHashSet<String> set = new MiniHashSet<>();

        set.add("apple");
        set.add("banana");
        set.add("cherry");
        set.add("apple"); // не добавится

        System.out.println(set.contains("banana")); // true
        System.out.println(set.contains("grape"));  // false

        set.remove("banana");
        System.out.println(set.contains("banana")); // false

        set.printBuckets(); // покажет распределение по бакетам
    }
}
```

### Что это показывает:

| Компонент    | Реализация                           |
|--------------|--------------------------------------|
| Хеширование  | `hashCode()` и деление по модулю     |
| Коллизии     | Списки внутри бакетов (`LinkedList`) |
| Уникальность | Проверка с помощью `contains()`      |

### Упрощения в этом примере:

- Нет **динамического расширения** массива бакетов.
- Нет **балансировки дерева** (как в Java 8+).
- Нет **универсальной обработки `null`**.

### СЛОЖНОСТЬ

Временная сложность операций в `HashSet` зависит от **качества хеш-функции**,
**числа элементов** и **реализации внутренней структуры (список
или дерево)**. Вот сводка:

### **Временная сложность `HashSet`**

| Операция            | Средняя сложность | Худший случай |
|---------------------|-------------------|---------------|
| `add(element)`      | **O(1)**          | **O(n)**      |
| `remove(element)`   | **O(1)**          | **O(n)**      |
| `contains(element)` | **O(1)**          | **O(n)**      |
| `iterator()`        | O(n)              | O(n)          |

### Почему O(1) в среднем?

Потому что `HashSet` основан на **хеш-таблице (`HashMap`)**:

1. Вызывается `hashCode()` — вычисляется индекс бакета.
2. В этом бакете происходит поиск по `equals()` среди **малого числа элементов**
   (в идеале — одного).

Таким образом:

- **Ожидаемое число коллизий** — небольшое.
- Вставка, удаление и поиск — выполняются за **постоянное время** в большинстве
  случаев.

### Когда возникает O(n)?

- Если все элементы попадают в **один бакет** (плохая реализация `hashCode()`).
- В этом случае `HashSet` превращается в **связанный список**, и поиск требует
  перебора всех элементов.

> С Java 8, если в одном бакете > 8 элементов, список преобразуется в *
*красно-черное дерево** → сложность становится **O(log n)** в худшем случае, не
**O(n)**.

### Пример

```java
Set<String> set = new HashSet<>();
set.

add("A"); // O(1)
set.

add("B"); // O(1)
set.

contains("C"); // O(1)
set.

remove("A"); // O(1)
```

### Вывод:

- **В среднем**: `HashSet` даёт **мгновенный доступ** — `O(1)`
- **В худшем случае**: `O(log n)` (с Java 8+) или `O(n)` (при плохом `hashCode`)
- Ключ к эффективности — корректно переопределённые `hashCode()` и `equals()`

## TreeSet

`TreeSet` — это **реализация интерфейса `Set`**, основанная на **красно-черном
дереве** (это разновидность сбалансированного бинарного дерева). Основная цель
`TreeSet` — хранить элементы в отсортированном порядке и обеспечивать
быстрые операции поиска, добавления и удаления.

### Как работает `TreeSet`?

#### 1. **Структура данных**

- Внутри `TreeSet` используется **красно-черное дерево**. Это
  самобалансирующееся бинарное дерево поиска.
- Каждое дерево имеет узлы с элементами, которые упорядочены по **естественному
  порядку** (`Comparable`) или по компаратору (`Comparator`), который передается
  при создании `TreeSet`.

#### 2. **Красно-черное дерево**

- Это специальный тип **самобалансирующегося дерева**, где:
    - Каждый узел окрашен в **красный** или **черный** цвет.
    - Правила, связанные с цветами, обеспечивают, что дерево всегда остаётся
      сбалансированным, то есть его высота никогда не превышает `2 * log(n)`
      (где `n` — количество элементов).

  В результате такие операции как добавление, удаление и поиск имеют сложность
  **O(log n)**.

#### 3. **Как устроены операции?**

- **Поиск элемента (`contains`)**:
    - Проводится через бинарный поиск с использованием `compareTo()` или
      компаратора.
    - Так как дерево сбалансировано, поиск проходит за **O(log n)**.

- **Добавление элемента (`add`)**:
    - Если элемента нет в дереве, он добавляется.
    - При добавлении соблюдаются все правила для поддержания **баланса дерева**.
    - Операция также выполняется за **O(log n)**.

- **Удаление элемента (`remove`)**:
    - В случае удаления, дерево также сбалансируется, чтобы сохранить свойства
      красно-черного дерева.
    - Это также выполняется за **O(log n)**.

- **Итерация (`iterator()`)**:
    - Поскольку элементы всегда отсортированы, итерация по `TreeSet` будет
      проходить в порядке возрастания.
    - Сложность итерации: **O(n)**, так как необходимо пройти по всем элементам.

### Временная сложность операций в `TreeSet`

| Операция                     | Временная сложность |
|------------------------------|---------------------|
| `add(element)`               | **O(log n)**        |
| `remove(element)`            | **O(log n)**        |
| `contains(element)`          | **O(log n)**        |
| Итерация (по всем элементам) | **O(n)**            |
| `first()`                    | **O(log n)**        |
| `last()`                     | **O(log n)**        |

### Пример использования `TreeSet`

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Создание TreeSet с элементами типа Integer
        Set<Integer> set = new TreeSet<>();

        set.add(3);
        set.add(1);
        set.add(2);
        set.add(5);
        set.add(4);

        System.out.println("TreeSet: " + set);  // Выведет: [1, 2, 3, 4, 5]

        System.out.println("Contains 3: " + set.contains(3));  // true
        System.out.println("Contains 6: " + set.contains(6));  // false

        set.remove(3);  // Удаляем элемент 3
        System.out.println("After removing 3: " + set);  // [1, 2, 4, 5]

        System.out.println("First element: " + ((TreeSet<Integer>) set).first());  // 1
        System.out.println("Last element: " + ((TreeSet<Integer>) set).last());    // 5
    }
}
```

### Ключевые особенности `TreeSet`:

- **Сортировка**: Элементы всегда отсортированы, либо по **естественному порядку
  ** (если они реализуют интерфейс `Comparable`), либо по компаратору,
  переданному при создании.
- **Быстрые операции**: Добавление, удаление и поиск выполняются за **O(log n)
  **, что значительно быстрее, чем у неупорядоченных коллекций (например,
  `HashSet`).
- **Итерация**: Поскольку элементы отсортированы, их можно легко перебирать в
  порядке возрастания.

### Отличие `TreeSet` от `HashSet`:

- **`HashSet`** не гарантирует порядок элементов, но обеспечивает быстрый доступ
  за **O(1)**.
- **`TreeSet`** всегда хранит элементы в отсортированном порядке и гарантирует
  сложность **O(log n)** для основных операций.


