# List

В Java `List` — это **интерфейс** из коллекционного фреймворка, представляющий
**упорядоченную коллекцию элементов**, в которой допускаются **повторы** и
**доступ по индексу**.

## Основное о `List`

`List` — это интерфейс

Реализуется следующими основными классами:

| Класс          | Основан на          | Особенности                                                         |
|----------------|---------------------|---------------------------------------------------------------------|
| **ArrayList**  | массив              | Быстрый доступ по индексу, медленные вставки и удаления из середины |
| **LinkedList** | двусвязный список   | Быстрые вставки/удаления, медленный доступ по индексу               |
| **Vector**     | массив (устаревший) | Синхронизирован, медленнее `ArrayList`                              |

### Методы интерфейса `List`:

| Метод                       | Описание                        |
|-----------------------------|---------------------------------|
| `add(E element)`            | Добавляет элемент в конец       |
| `add(int index, E element)` | Вставляет по индексу            |
| `get(int index)`            | Получает элемент по индексу     |
| `remove(int index)`         | Удаляет элемент по индексу      |
| `set(int index, E element)` | Заменяет элемент                |
| `size()`                    | Возвращает количество элементов |
| `contains(Object o)`        | Проверяет наличие элемента      |

## Временная сложность (ArrayList vs LinkedList)

| Операция            | ArrayList | LinkedList |
|---------------------|-----------|------------|
| `get(i)`            | O(1)      | O(n)       |
| `add(element)`      | O(1)\*    | O(1)       |
| `add(i, element)`   | O(n)      | O(n)       |
| `remove(i)`         | O(n)      | O(n)       |
| `iterator.remove()` | O(n)      | O(1)       |

\* — при амортизированной стоимости (ArrayList расширяется при заполнении)

### Когда использовать:

- `ArrayList` — когда нужно **часто обращаться по индексу**
- `LinkedList` — когда нужно **часто добавлять/удалять в середине/начале**

---

## ARRAYLIST

Класс, реализующий интерфейс List, являющийся динамическим массивом объектных
ссылок. Несинхронизированный.

ArrayList, как и Vector является реализацией динамического массива объектов.
Позволяет хранить любые данные, включая null в качестве элемента. Реализация
основана на обычном массиве. Данную реализацию следует применять, если в
процессе работы с коллекцией предполагается
частое обращение к элементам по индексу. Из-за особенностей реализации
поиндексное обращение к элементам выполняется за константное время O(1). Но
данную коллекцию рекомендуется избегать, если требуется частое
удаление/добавление элементов в середину коллекции.

**_Свойства:_**

Использует под капотом обычный массив elementData <br>
Быстрый доступ к элементам по индексу за константное время O(1)<br>
Быстрая вставка и удаление элементов в конец за O(1) <br>
Доступ к элементам по значению за линейное время O(n)<br>
Медленная вставка и удаление элементов из середины<br>
Хранит любые значения в том числе и null<br>
Не синхронизирован<br>
Автоматически увеличивается, но не уменьшается<br>

ArrayList создается с начальной емкостью capacity 10 ячеек.
Переменная size хранит количество добавленных элементов и изначально равна 0.

Если добавить в ArrayList больше элементов, чем его capacity – неявно для
пользователя произойдет вызов метода grow() и пересоздание внутреннего массива.

Алгоритм расширения внутреннего массива:

- Создается новый массив по формуле (capacity * 3) / 2 + 1
- Все элементы старого массива копируются в новый, методом System.arraycopy()
- Новый массив присваивается внутренней переменной elementData.
  Старый массив объявляется мусором – на него больше нет ссылки

Автоматически внутренний массив не уменьшается.
Чтобы обрезать емкость списка до реального количества элементов в нем –
используем метод trimToSize(). Этот метод есть только у ArrayList и отсутствует
у List.

Удаление и добавление элементов для такой коллекции представляет ресурсоемкую
задачу, поэтому объект ArrayList\<E> лучше всего подходит для хранения списков с
малым числом подобных действий. С другой стороны, навигация по списку
осуществляется очень быстро, поэтому операции поиска производятся за более
короткое время.

### АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ

Алгоритмическая сложность операций с `ArrayList` в Java зависит от
конкретной операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

- В конец списка: O(1) в среднем (если массив не переполнен). Если массив
  переполнен, происходит его увеличение, что требует O(n) времени, но это
  происходит редко, поэтому в среднем сложность остается O(1).
- В начало или в произвольную позицию: O(n) (необходимо сдвинуть элементы).

2. **Удаление элемента**:

- Из конца списка: O(1) (если не требуется уменьшение размера массива).
- Из начала или из произвольной позиции: O(n) (необходимо сдвинуть
  элементы).

3. **Поиск элемента**:

- O(n) (в худшем случае необходимо пройти по всему списку).

4. **Доступ к элементу по индексу**:

- O(1) (доступ к элементу по индексу осуществляется за константное время,
  так как `ArrayList` основан на массиве).

Таким образом, `ArrayList` хорошо подходит для операций доступа по индексу и
добавления элементов в конец списка, но менее эффективен для вставки и удаления
элементов в начале или середине списка из-за необходимости сдвига элементов.

Для `ArrayList` в Java сложность вставки и удаления элементов из середины списка
составляет O(n).

Вот подробности:

1. **Вставка элемента в середину**:

- Чтобы вставить элемент в середину списка, необходимо сначала сдвинуть все
  элементы, находящиеся после позиции вставки, на одну позицию вправо. Это
  требует O(n) времени в худшем случае, так как вам нужно пройти по всем
  элементам после вставляемого.
- После сдвига сам процесс вставки (изменение значения по индексу)
  выполняется за O(1).
- В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

- Для удаления элемента из середины списка также необходимо сначала найти
  этот элемент (если у вас нет ссылки на него), что требует O(n) времени.
- После нахождения элемента необходимо сдвинуть все элементы, находящиеся
  после удаляемого, на одну позицию влево. Это также требует O(n) времени.
- Таким образом, общая сложность удаления элемента из середины списка
  составляет O(n).

В общем, операции вставки и удаления в середине `ArrayList` имеют линейную
сложность из-за необходимости сдвига элементов.

### Основные свойства `ArrayList`

- Хранит элементы в **массиве `Object[]`**.
- Размер массива фиксирован, но при заполнении создаётся новый массив большего
  размера, куда копируются старые элементы.
- Поддерживает **доступ по индексу** через массив (O(1)).
- Доступ к элементам по индексу - O(1)
- Вставка и удаление элементов с конца - O(1)
- Доступ к элементам по значению - O(n)
  Медленная вставка и удаление элементов из середины

### Внутренние детали реализации

1. **Создаём ArrayList** (изначально пустой):

- `elementData = []`, `size = 0`

2. **Добавляем элементы:**
   ```java
   list.add("a");
   list.add("b");
   list.add("c");
   ```
   После добавления:

- `elementData = ["a", "b", "c", null, null, null, ...]`
- `size = 3`

3. **Добавляем 11-й элемент:**

- При заполнении текущего массива (например, длиной 10), создаётся новый массив
  длиной 15.
- Старые элементы копируются в новый массив:
    - `elementData = ["a", "b", ..., "k", null, null, ...]`

4. **Удаляем элемент:**
   ```java
   list.remove(1);
   ```
   После удаления:

- `elementData = ["a", "c", null, null, ...]`
- `size = 2`

### Преимущества `ArrayList`

1. Быстрый доступ по индексу (O(1)).
2. Амортизированная вставка в конец (O(1)).
3. Простая структура, основанная на массиве.

### Недостатки `ArrayList`

1. Медленное удаление/вставка в середине (O(n)), из-за сдвига элементов.
2. При росте массива создаётся новый массив, что требует копирования (временные
   затраты).

## LINKEDLIST

LinkedList\<E> является реализацией двусвязного списка для интерфейса List
который работает эффективно как для вставки элементов, так и для удаления,
используя, как издержки, более сложную структуру. LinkedList\<E> также реализует
интерфейсы Queue\<E> и Deque\<E> и может работать с обоих концов очереди. Он
может работать с очередью как по принципу FIFO, так и по принципу LIFO.  
Связанный список хранит ссылки на объекты отдельно вместе со ссылками
на следующее и предыдущее звенья последовательности, поэтому часто
называется двунаправленным списком.

В этом классе объявлены методы, позволяющие манипулировать им как
очередью, двунаправленной очередью и т.д. Двунаправленный список, кроме
обычного, имеет особый «нисходящий» итератор, позволяющий двигаться от
конца списка к началу, и извлекается методом descendingIterator().

Класс LinkedList содержит три основных поля:

- Node<E> first – Ссылка на первый элемент списка.
- Node<E> last – Ссылка на последний элемент списка.
- int size – Количество элементов в списке

### АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ

Алгоритмическая сложность операций с `LinkedList` в Java зависит от конкретной
операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

    - В начало/конец списка: O(1)
    - В произвольную позицию: O(n) (необходимо пройти до нужной позиции).

2. **Удаление элемента**:

    - Из начала/конца списка: O(1).
    - Из произвольной позиции: O(n).

3. **Поиск элемента**:

    - O(n) (необходимо пройти по всему списку в худшем случае).

4. **Доступ к элементу по индексу**:

    - O(n) (необходимо пройти по списку до нужного индекса).

Таким образом, `LinkedList` хорошо подходит для операций добавления и удаления
элементов в начале или конце списка, но неэффективен для доступа по индексу и
поиска элементов.

Вот подробности:

1. **Вставка элемента в середину**:

    - Чтобы вставить элемент в середину списка, необходимо сначала найти
      позицию, куда вы хотите вставить элемент. Это требует O(n) времени, так
      как вам нужно пройти по списку до нужного индекса.
    - После того как вы нашли нужную позицию, сама операция вставки (изменение
      ссылок) выполняется за O(1).
    - В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

    - Аналогично, для удаления элемента из середины списка сначала нужно найти
      этот элемент, что также требует O(n) времени.
    - После нахождения элемента операция удаления (изменение ссылок) выполняется
      за O(1).
    - Таким образом, общая сложность удаления элемента из середины списка также
      составляет O(n).

Самый быстрый метод класса add(E element). Главным же достоинством
класса является скорость работы метода remove() на Iterator, после получения
его из LinkedList. Также очень быстро работает метод add(E element) на
ListIterator. Операция удаления из начала и конца списка выполняется достаточно
быстро, в отличие от операций поиска и извлечения.

Используется когда необходимо часто добавлять или удалять элементы, особенно в
начало списка. Либо когда нужна вставка элемента в конец за гарантированное
время.

Для манипуляций с первым и последним элементами списка в LinkedList\<E>
реализованы методы:

- **void addFirst(E e), void addLast(E e)** - добавление элементов в начало и
  конец списка;
- **E getFirst(), E getLast()** — извлекающие элементы;
- **E removeFirst(), E removeLast()** — удаляющие и извлекающие элементы;
- **E removeLastOccurrence(E elem), E removeFirstOccurrence(E elem)** —
  удаляющие и извлекающие элемент, первый или последний раз встречаемый
  в списке.

### Отличия ArrayList и LinkedList:

При добавлении в середину, начало или конец списка LinkedList быстрее, чем
ArrayList.

Вставки и удаления элементов из LinkedList происходят за постоянное время, в том
числе и с использованием итераторов, в то же время вставка\удаление элемента в
ArrayList приводит к сдвигу всех элементов после позиции добавления\удаления, а
в случае, если базовый массив хранения переполняется, то еще и сам массив
увеличивается в полтора раза с копированием старого массива в новый.

Список LinkedList занимает больший объем памяти за счет необходимости
хранения ссылок на соседние объекты, что следует учитывать при создании
списков больших размеров. Список LinkedList занимает от 3,5 до 5 раз больше
памяти нежели аналогичный список ArrayList.

Если необходимо осуществлять быструю навигацию по списку, то следует применять
ArrayList, так как перебор элементов в LinkedList осуществляется на порядок
медленнее. С другой стороны, если требуется часто добавлять и удалять элементы
из списка, то уже класс LinkedList обеспечивает значительно более высокую
скорость переиндексации. То есть если коллекция формируется в начале процесса и
в дальнейшем используется только для доступа к информации, то применяется
ArrayList, если же коллекция подвергается изменениям на всем протяжении
функционирования приложения, то выгоднее LinkedList.

Выгода использования LinkedList в работе с серединой и началом списка.
Вставка и удаление в LinkedList устроены гораздо проще, чем в ArrayList – просто
переопределятся ссылки на соседние элементы.

----


### Основные характеристики LinkedList

1. **Структура**: Каждый узел в `LinkedList` состоит из трех частей:

- Ссылка на предыдущий узел.
- Ссылка на следующий узел.
- Данные (значение), хранящиеся в узле.

2. **Двусвязный список**: В отличие от односвязного списка, где каждый узел
   содержит только ссылку на следующий узел, в двусвязном списке каждый узел
   имеет ссылки как на предыдущий, так и на следующий узел. Это позволяет легко
   перемещаться в обоих направлениях.

3. **Гибкость**: `LinkedList` позволяет динамически изменять размер списка,
   добавляя или удаляя элементы без необходимости перераспределения памяти, как
   это происходит в массивах.

### Принцип работы LinkedList

#### Основные операции

1. **Добавление элемента (add)**:

- При добавлении элемента в конец списка создается новый узел, который
  ссылается на `null` (если это последний элемент).
- Если список не пустой, новый узел связывается с текущим последним узлом, а
  последний узел обновляется для ссылки на новый узел.
- Если элемент добавляется в начало или в середину списка, ссылки
  соответствующих узлов обновляются для поддержания связности.

2. **Удаление элемента (remove)**:

- При удалении элемента необходимо найти соответствующий узел.
- После нахождения узла его предыдущий и следующий узлы обновляют свои
  ссылки так, чтобы пропустить удаляемый узел.
- Если удаляется первый или последний элемент, необходимо обновить указатели
  на голову или хвост списка.

3. **Поиск элемента (get)**:

- Для поиска элемента по индексу необходимо пройти по списку от начала до
  нужного индекса (или от конца, если индекс ближе к концу).
- Сложность поиска составляет O(n) в худшем случае.

4. **Итерация**:

- Итерация по элементам `LinkedList` может быть выполнена с помощью
  итератора или цикла for-each.
- Итератор позволяет проходить по элементам без необходимости знать
  внутреннюю структуру списка.

#### Преимущества LinkedList

- **Эффективное добавление и удаление**: Операции добавления и удаления
  элементов выполняются за O(1) при условии, что у вас есть ссылка на нужный
  узел.
- **Динамическое выделение памяти**: Размер списка может изменяться динамически
  без необходимости перераспределения памяти.

#### Недостатки LinkedList

- **Память**: Каждый элемент требует дополнительной памяти для хранения ссылок
  на соседние элементы.
- **Поиск**: Поиск по индексу требует O(n) времени из-за необходимости
  последовательного прохода по списку.


2. **Производительность**:

- **Доступ по индексу**: В `ArrayList` доступ к элементам по индексу
  осуществляется за O(1), так как это просто обращение к массиву. В
  `LinkedList` доступ по индексу требует O(n), так как нужно пройти по
  узлам.
- **Добавление/удаление элементов**: В `ArrayList` добавление элемента в
  конец списка обычно выполняется за O(1), но может потребовать O(n) в
  случае необходимости увеличения размера массива. Удаление элемента также
  может потребовать O(n) из-за необходимости сдвига элементов. В
  `LinkedList` добавление и удаление элементов (в начале, в конце или в
  середине) выполняется за O(1), если у вас есть ссылка на узел, но поиск
  узла требует O(n).

3. **Память**:

- `ArrayList` использует меньше памяти на элемент, так как хранит только
  данные и индекс. Однако он может выделять больше памяти, чем фактически
  используется (из-за динамического массива).
- `LinkedList` использует больше памяти на элемент, так как каждый узел
  хранит ссылки на следующий и предыдущий элементы.

4. **Итерация**:

- Итерация по элементам в `ArrayList` обычно быстрее из-за лучшей
  локальности данных (элементы хранятся последовательно в памяти).
- Итерация по `LinkedList` может быть медленнее из-за необходимости перехода
  от одного узла к другому.

5. **Использование**:

- Используйте `ArrayList`, когда вам нужно часто получать доступ к элементам
  по индексу или когда размер списка не меняется часто.
- Используйте `LinkedList`, когда вам нужно часто добавлять или удалять
  элементы из середины списка.

В общем, выбор между `ArrayList` и `LinkedList` зависит от конкретных требований
вашего приложения и того, какие операции вы будете выполнять чаще всего.
-------

## 🔸 Сравнение вставки (`add`) и удаления (`remove`):

| Операция               | ArrayList                   | LinkedList                          |
|------------------------|-----------------------------|-------------------------------------|
| `add(E)` в конец       | O(1)\* (амортизировано)     | O(1)                                |
| `add(0, E)` в начало   | O(n) – сдвиг всех элементов | O(1)                                |
| `add(i, E)` в середину | O(n) – сдвиг с позиции `i`  | O(n) – пройти до `i`, затем вставка |
| `remove(i)`            | O(n) – сдвиг всех после `i` | O(n) – пройти до `i`, затем удалить |
| `removeFirst()`        | O(n)                        | O(1)                                |
| `removeLast()`         | O(1)                        | O(1)                                |

\* амортизированное — потому что при переполнении массива `ArrayList` делает
копию большего массива (O(n))

### 🔍 Подробное объяснение:

#### 📦 `ArrayList`

* Основан на **массиве**, элементы хранятся подряд.
* Вставка или удаление **внутри массива** требует **сдвига** всех последующих
  элементов.
* Зато **доступ по индексу** и **добавление в конец** — очень быстрые (O(1)).

#### 🔗 `LinkedList`

* Основан на **узлах**, связанных ссылками (`prev`, `next`).
* Вставка и удаление **в любом месте** по ссылке — O(1), но чтобы найти нужный
  узел по индексу — **нужно пройти список** (O(n)).
* Добавление и удаление **в начале/конце** — очень быстрое (O(1)).

### Вывод:

| Когда использовать                        | ArrayList лучше | LinkedList лучше                         |
|-------------------------------------------|-----------------|------------------------------------------|
| Частый доступ по индексу                  | ✅ Да (O(1))     | ❌ Нет (O(n))                             |
| Частые вставки/удаления в начале/середине | ❌ Нет (O(n))    | ✅ Да (O(1) при known-node) or O(n)       |
| Малое количество изменений                | ✅ Да            | ❌ Нет (перегрузка по памяти и структуре) |

---



**ПРИНЦИП РАБОТЫ**

Добавление элементов в конец списка

- Создаётся новый узел (Node).
- Устанавливается значение (item) для нового узла.
- Ссылки узла добавляются в конец списка.
- Устанавливаются ссылки на предыдущий и следующий узлы (для нового и соседних
  узлов).

Добавление элемента в середину списка

- Проверяется индекс. Если он отрицательный или превышает размер списка,
  выбрасывается исключение IndexOutOfBoundsException.
- Если индекс равен размеру списка, элемент добавляется в конец.
- Вставка в середину происходит перед элементом с указанным индексом:
    - Метод node(index) находит узел по индексу.
    - Определяется место вставки (поиск узла идёт с начала или конца списка в
      зависимости от индекса).
    - Создаётся новый узел, и его ссылки устанавливаются между соседними узлами.
- Обновляются ссылки на предыдущие и следующие узлы для нового элемента и его
  соседей.
- Увеличивается размер списка.

Удаление элемента из связного списка по значению:

- Последовательно сравниваются элементы списка с заданным значением, начиная с
  первого узла.
- Когда найден узел с соответствующим значением, элемент сохраняется в отдельную
  переменную.
- Ссылки соседних узлов перенаправляются так, чтобы исключить удаляемый элемент.
- Очищаются ссылки и данные узла, который содержал удалённый элемент, и
  уменьшается размер списка.

### Основные характеристики LinkedList

1. **Структура**: Каждый узел в `LinkedList` состоит из трех частей:

- Ссылка на предыдущий узел.
- Ссылка на следующий узел.
- Данные (значение), хранящиеся в узле.

2. **Двусвязный список**: В отличие от односвязного списка, где каждый узел
   содержит только ссылку на следующий узел, в двусвязном списке каждый узел
   имеет ссылки как на предыдущий, так и на следующий узел. Это позволяет легко
   перемещаться в обоих направлениях.

3. **Гибкость**: `LinkedList` позволяет динамически изменять размер списка,
   добавляя или удаляя элементы без необходимости перераспределения памяти, как
   это происходит в массивах.

### Принцип работы LinkedList

#### Основные операции

1. **Добавление элемента (add)**:

- При добавлении элемента в конец списка создается новый узел, который
  ссылается на `null` (если это последний элемент).
- Если список не пустой, новый узел связывается с текущим последним узлом, а
  последний узел обновляется для ссылки на новый узел.
- Если элемент добавляется в начало или в середину списка, ссылки
  соответствующих узлов обновляются для поддержания связности.

2. **Удаление элемента (remove)**:

- При удалении элемента необходимо найти соответствующий узел.
- После нахождения узла его предыдущий и следующий узлы обновляют свои
  ссылки так, чтобы пропустить удаляемый узел.
- Если удаляется первый или последний элемент, необходимо обновить указатели
  на голову или хвост списка.

3. **Поиск элемента (get)**:

- Для поиска элемента по индексу необходимо пройти по списку от начала до
  нужного индекса (или от конца, если индекс ближе к концу).
- Сложность поиска составляет O(n) в худшем случае.

4. **Итерация**:

- Итерация по элементам `LinkedList` может быть выполнена с помощью
  итератора или цикла for-each.
- Итератор позволяет проходить по элементам без необходимости знать
  внутреннюю структуру списка.

**АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ**

Алгоритмическая сложность операций с `LinkedList` в Java зависит от конкретной
операции. Вот основные операции и их сложности:

1. **Добавление элемента**:

    - В конец списка: O(1) (если у вас есть ссылка на последний элемент).
    - В начало списка: O(1).
    - В произвольную позицию: O(n) (необходимо пройти до нужной позиции).

2. **Удаление элемента**:

    - Из конца списка: O(1) (если у вас есть ссылка на последний элемент).
    - Из начала списка: O(1).
    - Из произвольной позиции: O(n) (необходимо пройти до нужной позиции).

3. **Поиск элемента**:

    - O(n) (необходимо пройти по всему списку в худшем случае).

4. **Доступ к элементу по индексу**:

    - O(n) (необходимо пройти по списку до нужного индекса).

Таким образом, `LinkedList` хорошо подходит для операций добавления и удаления
элементов в начале или конце списка, но неэффективен для доступа по индексу и
поиска элементов.

Для `LinkedList` в Java сложность вставки и удаления элемента из середины списка
составляет O(n).

Вот подробности:

1. **Вставка элемента в середину**:

    - Чтобы вставить элемент в середину списка, необходимо сначала найти
      позицию, куда вы хотите вставить элемент. Это требует O(n) времени, так
      как вам нужно пройти по списку до нужного индекса.
    - После того как вы нашли нужную позицию, сама операция вставки (изменение
      ссылок) выполняется за O(1).
    - В итоге общая сложность вставки элемента в середину списка - O(n).

2. **Удаление элемента из середины**:

    - Аналогично, для удаления элемента из середины списка сначала нужно найти
      этот элемент, что также требует O(n) времени.
    - После нахождения элемента операция удаления (изменение ссылок) выполняется
      за O(1).
    - Таким образом, общая сложность удаления элемента из середины списка также
      составляет O(n).

В общем, операции вставки и удаления в середине `LinkedList` имеют линейную
сложность из-за необходимости поиска нужной позиции.

Самый быстрый метод класса add(E element). Главным же достоинством
класса является скорость работы метода remove() на Iterator, после получения
его из LinkedList. Также очень быстро работает метод add(E element) на
ListIterator. Операция удаления из начала и конца списка выполняется достаточно
быстро, в отличие от операций поиска и извлечения.

Используется когда необходимо часто добавлять или удалять элементы, особенно в
начало списка. Либо когда нужна вставка элемента в конец за гарантированное
время.

Для манипуляций с первым и последним элементами списка в LinkedList\<E>
реализованы методы:

- **void addFirst(E e), void addLast(E e)** - добавление элементов в начало и
  конец списка;
- **E getFirst(), E getLast()** — извлекающие элементы;
- **E removeFirst(), E removeLast()** — удаляющие и извлекающие элементы;
- **E removeLastOccurrence(E elem), E removeFirstOccurrence(E elem)** —
  удаляющие и извлекающие элемент, первый или последний раз встречаемый
  в списке.

**_Отличия ArrayList и LinkedList:_**

При добавлении в середину, начало или конец списка LinkedList быстрее, чем
ArrayList.

Вставки и удаления элементов из LinkedList происходят за постоянное время, в том
числе и с использованием итераторов, в то же время вставка\удаление элемента в
ArrayList приводит к сдвигу всех элементов после позиции добавления\удаления, а
в случае, если базовый массив хранения переполняется, то еще и сам массив
увеличивается в полтора раза с копированием старого массива в новый.

ArrayList быстрее LinkedList при вызове метода get(index), т.к. это происходит
за время O(n), а в LinkedList за O(1).

Список LinkedList занимает больший объем памяти за счет необходимости
хранения ссылок на соседние объекты, что следует учитывать при создании
списков больших размеров. Список LinkedList занимает от 3,5 до 5 раз больше
памяти нежели аналогичный список ArrayList.

Если необходимо осуществлять быструю навигацию по списку, то следует применять
ArrayList, так как перебор элементов в LinkedList осуществляется на порядок
медленнее. С другой стороны, если требуется часто добавлять и удалять элементы
из списка, то уже класс LinkedList обеспечивает значительно более высокую
скорость переиндексации. То есть если коллекция формируется в начале процесса и
в дальнейшем используется только для доступа к информации, то применяется
ArrayList, если же коллекция подвергается изменениям на всем протяжении
функционирования приложения, то выгоднее LinkedList.

Выгода использования LinkedList в работе с серединой и началом списка.
Вставка и удаление в LinkedList устроены гораздо проще, чем в ArrayList – просто
переопределятся ссылки на соседние элементы.

### Основная структура `LinkedList`

```java
class Node<E> {
    E item;         // Значение
    Node<E> next;   // Ссылка на следующий узел
    Node<E> prev;   // Ссылка на предыдущий узел
}
```

`LinkedList` хранит:

```java
Node<E> first;  // Голова списка
Node<E> last;   // Хвост списка
int size;       // Количество элементов
```

### Визуально:

```
null ← [A] ⇄ [B] ⇄ [C] → null
```

- Каждый элемент связан с **предыдущим** и **следующим**.
- Это даёт **быстрые вставки и удаления** в начале, в середине и в конце.

### Ключевые операции:

| Операция            | Что происходит                                | Сложность |
|---------------------|-----------------------------------------------|-----------|
| `addFirst(E)`       | Добавление в начало — новая "голова"          | O(1)      |
| `addLast(E)`        | Добавление в конец — новая "хвостовая" нода   | O(1)      |
| `get(int index)`    | Пройти с начала или конца до нужного элемента | O(n)      |
| `remove(int index)` | Найти и удалить — переустановить ссылки       | O(n)      |
| `add(int index, E)` | Найти место и вставить, поменять ссылки       | O(n)      |
| `iterator.remove()` | Быстрое удаление по итератору                 | O(1)      |

### Сравнение с ArrayList:

| Особенность               | ArrayList          | LinkedList                 |
|---------------------------|--------------------|----------------------------|
| Доступ по индексу         | O(1)               | O(n)                       |
| Вставка/удаление в начало | O(n)               | O(1)                       |
| Вставка/удаление в конец  | O(1)\*             | O(1)                       |
| Память                    | Компактно (массив) | Больше (узлы с 2 ссылками) |

\* для ArrayList вставка в конец амортизированно O(1), но при превышении
размера — O(n) из-за копирования.

### Где использовать `LinkedList`:

- Когда **часто добавляются/удаляются элементы** в середине или в начале.
- Когда нет необходимости в **частом доступе по индексу**.
- Для **реализации очередей, стеков, двухсторонних списков**.

#### Вставка элемента в середину LinkedList

![linkedlist_insertion.png](/img/linkedlist_insertion.png)

На изображении показан процесс **вставки узла "D"** в **двусвязный
список (`LinkedList`)**.

#### Что изображено:

* У нас есть изначальная последовательность узлов:
  `A ⇄ B ⇄ C ⇄ E ⇄ E`
* Узлы соединены **двунаправленными стрелками**, показывающими, что каждый узел
  знает **предыдущий и следующий**.

### Вставка узла "D":

* Узел "D" вставляется **между "B" и "C"**:

    * `B.next = D`
    * `D.prev = B`
    * `D.next = C`
    * `C.prev = D`

### Итоговая последовательность:

```
A ⇄ B ⇄ D ⇄ C ⇄ E ⇄ E
```

### Почему это важно:

* **Вставка в середину `LinkedList`** происходит за **O(1)** (если у нас уже
  есть ссылка на нужный узел).
* Это основное преимущество `LinkedList` перед `ArrayList`, где вставка требует
  сдвига всех элементов вправо.

### Удаление узла из `LinkedList` схематично?

![linkedlist_deleting.png](/img/linkedlist_deleting.png)

На изображении показан процесс **удаления узла "B"** из **двусвязного
списка (`LinkedList`)**.

### Верхняя часть — до удаления:

```
A ⇄ B ⇄ C ⇄ E
```

* Узел `B` стоит между `A` и `C`.
* Стрелки показывают связи: `A → B`, `B → C`, и обратные связи ←.

### Операция удаления:

* Удаляется узел `B`.
* Связи `A → B` и `B → C` разрываются.
* Новые связи: `A → C`, `C → A` (через `prev` и `next`).

### 🔽 Нижняя часть — после удаления:

```
A ⇄ C ⇄ D ⇄ E
```

* Узел `B` полностью удалён.
* Список стал короче, но остался связанным.

### 💡 Что происходит в коде:

```java
b.prev.next =b.next;
b.next.prev =b.prev;
```

* Если у нас есть ссылка на `B`, мы просто "перешагиваем" через него, соединяя
  `A` с `C`.

Так работает **удаление в `LinkedList` за O(1)** — быстро и без сдвига
элементов, в отличие от `ArrayList`.

## Реализация LinkedList

вручную на Java, с базовыми операциями — добавление, удаление и вывод.

```java
public class MyLinkedList<E> {
    private static class Node<E> {
        E data;
        Node<E> prev;
        Node<E> next;

        Node(E data) {
            this.data = data;
        }
    }

    private Node<E> head;
    private Node<E> tail;
    private int size = 0;

    // Добавление в конец
    public void add(E element) {
        Node<E> newNode = new Node<>(element);
        if (tail == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size++;
    }

    // Удаление по индексу
    public void remove(int index) {
        checkBounds(index);
        Node<E> current = getNode(index);

        if (current.prev != null) current.prev.next = current.next;
        else head = current.next; // удаляем первый элемент

        if (current.next != null) current.next.prev = current.prev;
        else tail = current.prev; // удаляем последний элемент

        size--;
    }

    // Получение узла по индексу
    private Node<E> getNode(int index) {
        checkBounds(index);
        Node<E> current;
        if (index < size / 2) {
            current = head;
            for (int i = 0; i < index; i++) current = current.next;
        } else {
            current = tail;
            for (int i = size - 1; i > index; i--) current = current.prev;
        }
        return current;
    }

    private void checkBounds(int index) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException("Index: " + index);
    }

    // Вывод элементов
    public void printList() {
        Node<E> current = head;
        while (current != null) {
            System.out.print(current.data + " ⇄ ");
            current = current.next;
        }
        System.out.println("null");
    }
}
```

### Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        MyLinkedList<String> list = new MyLinkedList<>();

        list.add("A");
        list.add("B");
        list.add("C");
        list.printList(); // A ⇄ B ⇄ C ⇄ null

        list.remove(1);
        list.printList(); // A ⇄ C ⇄ null
    }
}
```

### Что реализовано:

* Двусвязный список.
* Добавление в конец.
* Удаление по индексу.
* Быстрый доступ к элементам с учётом ближнего конца.
* Печать списка.

### Преимущества LinkedList

- **Эффективное добавление и удаление**: Операции добавления и удаления
  элементов выполняются за O(1) при условии, что у вас есть ссылка на нужный
  узел.
- **Динамическое выделение памяти**: Размер списка может изменяться динамически
  без необходимости перераспределения памяти.

### Недостатки LinkedList

- **Память**: Каждый элемент требует дополнительной памяти для хранения ссылок
  на соседние элементы.
- **Поиск**: Поиск по индексу требует O(n) времени из-за необходимости
  последовательного прохода по списку.

### Пример использования LinkedList

Вот пример использования `LinkedList` в Java:

```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        // Создание LinkedList
        LinkedList<String> list = new LinkedList<>();

        // Добавление элементов
        list.add("Первый");
        list.add("Второй");
        list.add("Третий");

        // Вставка элемента в начало
        list.addFirst("Нулевой");

        // Вставка элемента в конец
        list.addLast("Четвертый");

        // Удаление элемента
        list.remove("Второй");

        // Итерация по элементам
        for (String item : list) {
            System.out.println(item);
        }

        // Получение элемента по индексу
        String secondElement = list.get(1);
        System.out.println("Второй элемент: " + secondElement);
    }
}
```

### Заключение

`LinkedList` — это мощная структура данных для работы с динамическими наборами
данных. Она обеспечивает гибкость при добавлении и удалении элементов, но может
быть менее эффективной при поиске элементов по индексу из-за своей линейной
структуры. Выбор между `ArrayList` и `LinkedList` зависит от конкретных
требований вашего приложения и характера операций, которые вы планируете
выполнять с данными.

-----------------

`ArrayList` и `LinkedList` — это две реализации интерфейса `List` в Java, и у
них есть несколько ключевых отличий:

1. **Структура данных**:

- `ArrayList` основан на массиве. Он использует динамический массив для
  хранения элементов, что позволяет быстро получать доступ к элементам по
  индексу.
- `LinkedList` основан на связном списке. Каждый элемент (узел) содержит
  ссылку на следующий (и предыдущий) элемент, что позволяет легко добавлять
  и удалять элементы.

2. **Производительность**:

- **Доступ по индексу**: В `ArrayList` доступ к элементам по индексу
  осуществляется за O(1), так как это просто обращение к массиву. В
  `LinkedList` доступ по индексу требует O(n), так как нужно пройти по
  узлам.
- **Добавление/удаление элементов**: В `ArrayList` добавление элемента в
  конец списка обычно выполняется за O(1), но может потребовать O(n) в
  случае необходимости увеличения размера массива. Удаление элемента также
  может потребовать O(n) из-за необходимости сдвига элементов. В
  `LinkedList` добавление и удаление элементов (в начале, в конце или в
  середине) выполняется за O(1), если у вас есть ссылка на узел, но поиск
  узла требует O(n).

3. **Память**:

- `ArrayList` использует меньше памяти на элемент, так как хранит только
  данные и индекс. Однако он может выделять больше памяти, чем фактически
  используется (из-за динамического массива).
- `LinkedList` использует больше памяти на элемент, так как каждый узел
  хранит ссылки на следующий и предыдущий элементы.

4. **Итерация**:

- Итерация по элементам в `ArrayList` обычно быстрее из-за лучшей
  локальности данных (элементы хранятся последовательно в памяти).
- Итерация по `LinkedList` может быть медленнее из-за необходимости перехода
  от одного узла к другому.

5. **Использование**:

- Используйте `ArrayList`, когда вам нужно часто получать доступ к элементам
  по индексу или когда размер списка не меняется часто.
- Используйте `LinkedList`, когда вам нужно часто добавлять или удалять
  элементы из середины списка.

В общем, выбор между `ArrayList` и `LinkedList` зависит от конкретных требований
вашего приложения и того, какие операции вы будете выполнять чаще всего.

## _Vector\<E>_

Реализация динамического массива объектов. Позволяет хранить любые данные,
включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но, как
и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется
достижения потокобезопасности. Потому как в Vector, в отличии. от других
реализаций List, все операции с данными являются синхронизированными. В качестве
альтернативы часто применяется аналог — ArrayList.  
Как и массив, он содержит элементы, доступ к которым возможен по индексу. Однако
размер вектора может расти или уменьшаться в зависимости от добавления или
удаления элементов после того, как Vector уже был создан. Класс вектор является
синхронизированной реализацией интерфейса List.
Deprecated. Устаревший класс
На смену Vector пришел класс пакета java.util.concurrent СopyOnWriteArrayList


**Различия между классами ArrayList и Vector:**

| ArrayList                                                                                            | Vector                                                                                                                                                                |
|------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ArrayList не синхронизирован                                                                         | Vector синхронизирован                                                                                                                                                |
| ArrayList увеличивает на 50% <br/> текущий размер массива, если число элементов превышает его размер | Vector увеличивает на 100% <br/> текущий размер массива, если число элементов превышает его размер                                                                    |
| ArrayList не является классом-наследником                                                            | Vector является классом наследником                                                                                                                                   |
| ArrayList является быстрым, потому что он не синхронизированный                                      | Vector является медленным, так как он синхронизирован, т.е. при многопоточности он будет удерживать другие потоки до тех пор, пока не освободит от блокировки объект. |
| ArrayList использует интерфейс Iterator для прохода по элементам                                     | Vector использует интерфейс Enumeration для перемещения по элементам. Но может также использовать и интерфейс Iterator.                                               |

## _Stack\<E>_

Stack\<E> — данная коллекция является расширением коллекции Vector. Была
добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является
частично синхронизированной коллекцией (кроме метода добавления push()). После
добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно
реализации этого интерфейса, например ArrayDeque.  
Stack\<E> – класс, определенный для структуры данных «стек», организованной
по принципу LIFO (last-in-first-out – последним вошел – первым вышел). Класс
Stack является наследником класса Vector, который является синхронизированным
массивом с изменяющимся размером.

***Методы:***

- **E void push(E element)** – помещает указанный элемент на вершину стека;
- **E pop()** – возвращает и удаляет элемент с вершины стека;
- **E peek()** – возвращает, но не удаляет;
- **boolean empty()** – проверяет, является ли стек пустым;
- **int search(Object obj)** – возвращает расстояние от указанного объекта до
  вершины стека (от 1 для вершины стека) или –1, если элемент не найден.

> ## Java Collection. Сложность получения последнего элемента в LinkedList (O(1))

### **ARRAYLIST**

**АЛГОРИТМИЧЕСКАЯ СЛОЖНОСТЬ**

1. **Добавление элемента**:

- В конец списка: O(1) в среднем (если массив не переполнен). Если массив
  переполнен, происходит его увеличение, что требует O(n) времени, но это
  происходит редко, поэтому в среднем сложность остается O(1).
- В начало или в произвольную позицию/середину: O(n) (необходимо сдвинуть
  элементы).
- Чтобы вставить элемент в середину списка, необходимо сначала сдвинуть все
  элементы, находящиеся после позиции вставки, на одну позицию вправо. Это
  требует O(n) времени в худшем случае, так как вам нужно пройти по всем
  элементам после вставляемого. После сдвига сам процесс вставки (изменение
  значения по индексу)
  выполняется за O(1). В итоге общая сложность вставки элемента в середину
  списка составляет O(n).

2. **Удаление элемента**:

- Из конца списка: O(1) (если не требуется уменьшение размера массива).
- Из начала или из произвольной позиции/середины: O(n) (необходимо сдвинуть
  элементы).
- Для удаления элемента из середины списка также необходимо сначала найти этот
  элемент (если у вас нет ссылки на него), что требует O(n) времени. После
  нахождения элемента необходимо сдвинуть все элементы, находящиеся после
  удаляемого, на одну позицию влево. Это также требует O(n) времени. Таким
  образом, общая сложность удаления элемента из середины списка составляет O(n).


3. **Поиск элемента**:

- O(n) (в худшем случае необходимо пройти по всему списку).

4. **Доступ к элементу по индексу**:

- O(1) (доступ к элементу по индексу осуществляется за константное время,
  так как `ArrayList` основан на массиве).

Таким образом, `ArrayList` хорошо подходит для операций доступа по индексу и
добавления элементов в конец списка, но менее эффективен для вставки и удаления
элементов в начале или середине списка из-за необходимости сдвига элементов.

Для `ArrayList` в Java сложность вставки и удаления элементов из середины
списка составляет O(n). В общем, операции вставки и удаления в середине
`ArrayList` имеют линейную сложность из-за необходимости сдвига элементов.

### **LINKEDLIST**

LinkedList\<E> является реализацией двусвязного списка для интерфейса List
который работает эффективно как для вставки элементов, так и для удаления,
используя, как издержки, более сложную структуру.

### Принцип работы LinkedList

#### Основные операции

1. **Добавление элемента (add)**:
    - При добавлении элемента в конец списка создается новый узел, который
      ссылается на `null` (если это последний элемент).
    - Если список не пустой, новый узел связывается с текущим последним узлом, а
      последний узел обновляется для ссылки на новый узел.
    - Если элемент добавляется в начало или в середину списка, ссылки
      соответствующих узлов обновляются для поддержания связности.

Сложность:

- В LinkedList добавление нового узла в начало или конец списка осуществляется
  за константное время O(1), так как нужно просто изменить ссылки на первый или
  последний элемент.
- Чтобы добавить элемент по индексу, необходимо сначала найти нужный индекс, что
  требует линейного времени O(n). После нахождения нужного узла добавление
  нового узла происходит за O(1).

2. **Удаление элемента (remove)**:
    - При удалении элемента необходимо найти соответствующий узел.
    - После нахождения узла его предыдущий и следующий узлы обновляют свои
      ссылки так, чтобы пропустить удаляемый узел.
    - Если удаляется первый или последний элемент, необходимо обновить указатели
      на голову или хвост списка.

Сложность

- Удаление первого или последнего элемента также выполняется за O(1), так как
  нужно просто изменить ссылки на первый или последний элемент.
  Для удаления элемента по индексу необходимо сначала найти нужный индекс, что
  требует O(n). Удаление узла после его нахождения выполняется за O(1).
- Удаление элемента по значению также требует линейного времени O(n), так как
  нужно пройти через весь список для поиска элемента.

3. **Поиск элемента (get)**:
    - Для поиска элемента по индексу необходимо пройти по списку от начала до
      нужного индекса (или от конца, если индекс ближе к концу).

Сложность

- Сложность поиска составляет O(n) в худшем случае.
- Сложность поиска элемента по значению в LinkedList в Java составляет O(n)
  в худшем и среднем случаях.
- Итерация: В отличие от массивов или ArrayList, где доступ к элементам
  осуществляется за O(1) благодаря прямому индексированию, в LinkedList нет
  такого механизма. Чтобы получить элемент по индексу, необходимо пройти от
  начала списка до нужного индекса.

4. **Итерация**:
    - Итерация по элементам `LinkedList` может быть выполнена с помощью
      итератора или цикла for-each.
    - Итератор позволяет проходить по элементам без необходимости знать
      внутреннюю структуру списка.
    - В LinkedList нет прямого доступа к элементам по индексу, как в массивах
      или ArrayList. Поэтому для поиска элемента по значению необходимо
      последовательно проверять каждый узел.

> ## Отличия ArrayList и LinkedList:

`ArrayList` и `LinkedList` — это две реализации интерфейса `List` в Java, и у
них есть несколько ключевых отличий:

1. **Структура данных**:
    - `ArrayList` основан на массиве. Он использует динамический массив для
      хранения элементов, что позволяет быстро получать доступ к элементам по
      индексу.
    - `LinkedList` основан на связном списке. Каждый элемент (узел) содержит
      ссылку на следующий (и предыдущий) элемент, что позволяет легко добавлять
      и удалять элементы.

2. **Производительность**:
    - **Доступ по индексу**: В `ArrayList` доступ к элементам по индексу
      осуществляется за O(1), так как это просто обращение к массиву. В
      `LinkedList` доступ по индексу требует O(n), так как нужно пройти по
      узлам.
    - **Добавление/удаление элементов**: В `ArrayList` добавление элемента в
      конец списка обычно выполняется за O(1), но может потребовать O(n) в
      случае необходимости увеличения размера массива. Удаление элемента также
      может потребовать O(n) из-за необходимости сдвига элементов. В
      `LinkedList` добавление и удаление элементов (в начале, в конце или в
      середине) выполняется за O(1), если у вас есть ссылка на узел, но поиск
      узла требует O(n).

3. **Память**:
    - `ArrayList` использует меньше памяти на элемент, так как хранит только
      данные и индекс. Однако он может выделять больше памяти, чем фактически
      используется (из-за динамического массива).
    - `LinkedList` использует больше памяти на элемент, так как каждый узел
      хранит ссылки на следующий и предыдущий элементы.

4. **Итерация**:
    - Итерация по элементам в `ArrayList` обычно быстрее из-за лучшей
      локальности данных (элементы хранятся последовательно в памяти).
    - Итерация по `LinkedList` может быть медленнее из-за необходимости перехода
      от одного узла к другому.

5. **Использование**:
    - Используйте `ArrayList`, когда вам нужно часто получать доступ к элементам
      по индексу или когда размер списка не меняется часто.
    - Используйте `LinkedList`, когда вам нужно часто добавлять или удалять
      элементы из середины списка.

В общем, выбор между `ArrayList` и `LinkedList` зависит от конкретных требований
вашего приложения и того, какие операции вы будете выполнять чаще всего.
___

## _Vector\<E>_

Реализация динамического массива объектов. Позволяет хранить любые данные,
включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но, как
и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется
достижения потокобезопасности. Потому как в Vector, в отличии. от других
реализаций List, все операции с данными являются синхронизированными. В качестве
альтернативы часто применяется аналог — ArrayList.  
Как и массив, он содержит элементы, доступ к которым возможен по индексу. Однако
размер вектора может расти или уменьшаться в зависимости от добавления или
удаления элементов после того, как Vector уже был создан. Класс вектор является
синхронизированной реализацией интерфейса List.
Deprecated. Устаревший класс
На смену Vector пришел класс пакета java.util.concurrent СopyOnWriteArrayList

**_Конструкторы:_**

- *Vector()* – создает пустой вектор таким образом, что внутренний массив имеет
  размер 10, а его стандартный инкремент объема равен нулю;
- *Vector(Collection<? extends E> c)* – создает вектор, содержащий элементы
  указанной коллекции в порядке, возвращенном итератором;
- *Vector(int initialCapacity)* – создает пустой вектор с указанным начальным
  объемом и со стандартным инкрементом объема, равным нулю;
- *Vector(int initialCapacity, int capacityIncrement)* – создает пустой вектор с
  указанными начальным объемом и инкрементом объема.

**_Методы:_**

- **void addElement(E obj)** – добавляет указанный компонент в конец вектора,
  увеличивая его размер на 1;
- **boolean removeElement(Object obj)** – удаляет первый, т.е. имеющий
  минимальный индекс, встретившийся аргумент из вектора;
- **void setElementAt(E obj, int index)** – вставляет элемент, представляющий
  собой указанный объект, на определенное индексом место в векторе;
- **public E elementAt(int index)** – возвращает элемент с указанным индексом;
  этот метод идентичен методу get(int), являющемуся частью интерфейса List;
- **public E firstElement()** – возвращает первый элемент (с индексом 0) данного
  вектора;
- **public E lastElement()** – возвращает последний элемент вектора;
- **public void insertElementAt(E obj,int index)** – вставляет указанный объект
  как элемент данного вектора на место, определенное индексом. Каждый элемент
  данного вектора с индексом, большим или равным указанному индексу, получает
  индекс, больший предыдущего на 1.

```java
public static void main(String[] args) {
    Vector v = new Vector(3, 2);
    System.out.println("Начальный размер " + v.size());
    System.out.println("Начальный объем " + v.capacity());
    v.addElement(1);
    v.addElement(2);
    v.addElement(3);
    v.addElement(4);
    System.out.println("Новый объем " + v.capacity());
    // Enumeration - доступ к серии элементов одновременно;
    Enumeration e = v.elements();
    while (e.hasMoreElements()) {
        System.out.println(e.nextElement());
    }
}
```

**Различия между классами ArrayList и Vector:**

| ArrayList                                                                                            | Vector                                                                                                                                                                |
|------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ArrayList не синхронизирован                                                                         | Vector синхронизирован                                                                                                                                                |
| ArrayList увеличивает на 50% <br/> текущий размер массива, если число элементов превышает его размер | Vector увеличивает на 100% <br/> текущий размер массива, если число элементов превышает его размер                                                                    |
| ArrayList не является классом-наследником                                                            | Vector является классом наследником                                                                                                                                   |
| ArrayList является быстрым, потому что он не синхронизированный                                      | Vector является медленным, так как он синхронизирован, т.е. при многопоточности он будет удерживать другие потоки до тех пор, пока не освободит от блокировки объект. |
| ArrayList использует интерфейс Iterator для прохода по элементам                                     | Vector использует интерфейс Enumeration для перемещения по элементам. Но может также использовать и интерфейс Iterator.                                               |

## _Stack\<E>_

Stack\<E> — данная коллекция является расширением коллекции Vector. Была
добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является
частично синхронизированной коллекцией (кроме метода добавления push()). После
добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно
реализации этого интерфейса, например ArrayDeque.  
Stack\<E> – класс, определенный для структуры данных «стек», организованной
по принципу LIFO (last-in-first-out – последним вошел – первым вышел). Класс
Stack является наследником класса Vector, который является синхронизированным
массивом с изменяющимся размером.

***Методы:***

- **E void push(E element)** – помещает указанный элемент на вершину стека;
- **E pop()** – возвращает и удаляет элемент с вершины стека;
- **E peek()** – возвращает, но не удаляет;
- **boolean empty()** – проверяет, является ли стек пустым;
- **int search(Object obj)** – возвращает расстояние от указанного объекта до
  вершины стека (от 1 для вершины стека) или –1, если элемент не найден.
