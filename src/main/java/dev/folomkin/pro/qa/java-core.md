> ## JAVA CORE. <br> Generics. Можем как-то ограничить типы (про super)

В Java, как и в других языках программирования, концепция уровней обобщений (или
обобщенных типов) позволяет создавать классы, интерфейсы и методы, которые
работают с различными типами данных. Это достигается с помощью параметров типа (
type parameters). В контексте обобщений можно выделить верхний и нижний уровни
обобщений.

Верхний уровень обобщений (Upper Bound Wildcards)

Верхний уровень обобщений используется для ограничения типа, который может быть
использован в качестве параметра. Это делается с помощью ключевого слова
extends. Например:

```java
public void processList(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```

В этом примере метод processList принимает список, содержащий объекты любого
типа, который является подтипом Number (например, Integer, Double и т.д.). Это
позволяет работать с различными типами данных, сохраняя при этом безопасность
типов.

Нижний уровень обобщений (Lower Bound Wildcards)

Нижний уровень обобщений используется для указания того, что параметр может быть
определён как определённый тип или любой его суперкласс. Это делается с помощью
ключевого слова super. Например:

```java
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}
```

В этом примере метод addNumbers принимает список, который может содержать
объекты типа Integer или любого его суперкласса (например, Number или Object).
Это позволяет добавлять элементы в список без необходимости знать точный тип
списка.

Применение

Верхние границы полезны, когда вы хотите читать данные из структуры данных и не
хотите беспокоиться о том, какой конкретный подтип вы получаете.
Нижние границы полезны, когда вы хотите добавлять данные в структуру данных и
хотите гарантировать, что вы можете добавлять элементы определенного типа или
его подтипов.  
Эти концепции позволяют создавать более гибкие и безопасные API в Java.

> ## JAVA CORE. <br> Generics. PECS

PECS расшифровывается как Producer extends Consumer super.
Принцип PECS непосредственно связан с коллекциями и обобщениями.

### Producer Extends

```java
List<? extends Employee> employees = ... // upper bounded wildcard

```

Это значит, что эта коллекция будет содержать объекты либо Employee, либо
классов, которые наследуют Employee.

Код для примера:

```java

class Person {
}

class Employee extends Person {
}

class Manager extends Employee {
}

public class Demo {
    public static void main(String[] args) {

    }

}
```

В примере

```java
List<? extends Employee> employees = ... // upper bounded wildcard

```

List будет содержать класс Employee либо Manager.

```java
public class Demo {
    public static void main(String[] args) {

        List<Person> persons = new ArrayList<>();
        List<Employee> employees = new ArrayList<>();
        List<Manager> managers = new ArrayList<>();

        processUpperBounded(persons); //-> ошибка компиляции
        processUpperBounded(employees);
        processUpperBounded(managers);

    }

    public static void processUpperBounded(List<? extends Employee> employees) {

    }
}
```

В первом случае у нас будет ошибка компиляции - коллекцию типа Person мы
передать не можем, потому что коллекция ограничена с помощью extends. На вход
нашего метода processUpperBounded мы можем передать только коллекцию, которая
содержит Employee либо Manager, но не Person.

Получить из коллекции элементы можно так:

```java
public class Demo {
    public static void main(String[] args) {
    }

    public static void processUpperBounded(List<? extends Employee> employees) {
        Person person = upperBoundedEmployees.get(0);
        Employee employee = upperBoundedEmployees.get(0);
        Manager manager = upperBoundedEmployees.get(0); //-> ошибка - не все 
        // Employee являются Manager, но все employee являются Person.

        //-> Нельзя добавить элементы, потому что в списке находятся 
        // элеенты наследуемые от Employee - Manager и не Manager.
    }
}
```

### Consumer Super

```java
List<? super Employee> managers = ...// // lower bounded wildcard

```

В этом случае мы указываем, что эта коллекция managers будет содержать объекты
Employee, либо его супер классы.

```java

public class Demo {
    public static void main(String[] args) {
        List<Person> persons = new ArrayList<>();
        List<Employee> employees = new ArrayList<>();
        List<Manager> managers = new ArrayList<>();

        //-> Мы можем на вход метода передать коллекцию типа Person и коллекцию
        // с типом Employee. Но мы не можем передать коллекцию, которая содержит
        // объекты типа Manager, у нас будет ошибка компиляции:

        processLowerBounded(persons);
        processLowerBounded(employees);
        processLowerBounded(managers); //-> ошибка компиляции
    }

    public static void processLowerBounded(List<? super Employee> employees) {
        employees.add(new Person()); //-> ошибка компиляции
        employees.add(new Employee());
        employees.add(new Manager());
    }
}
```

Если коллекция является Consumer - в такую коллекцию можно добавлять объекты,
но не получать их. В методе processLowerBounded мы пытаемся
добавить в нашу коллекцию employees объекты типа Person, Employee и Manager.
Когда мы добавляем Person, будет ошибка
компиляции, но мы можем добавить объекты Employee и Manager. Здесь я хочу
обратить внимание на такой тонкий момент - когда мы передаём на вход метода
коллекции, мы можем в employees присвоить только коллекции, которые содержат
объекты типа Person и Employee, но не Manager. Но когда мы в эту коллекцию
добавляем объекты, то мы не можем добавить сюда значение типа Person, только
Employee и Manager. Почему так происходит?
Принцип PECS применим при присвоении одной коллекции другой:

```java
List<? extends Employee> list1 = employees;
List<? extends Employee> list2 = managers;
List<? super Employee> list3 = persons;
```

То есть в переменную, которая объявлена как <? extends Employee>, мы можем
присвоить другую коллекцию, которая содержит объекты типа Employee, либо объекты
типа Manager. В переменную list3 мы можем добавить коллекцию, которая содержит
Person. Но принцип PECS не применим при добавлении объектов в коллекции:

```java
public static void processLowerBounded(List<? super Employee> employees) {
    employees.add(new Person()); //compilation error
    employees.add(new Employee());
    employees.add(new Manager());...
}
```

В коллекцию, объявленную как <? super Employee>, мы можем добавить только
Employee и Manager.
На этапе компиляции компилятор не знает какого именно типа объекты будут
содержаться в employees. Но он чётко знает, что это либо Employee, либо Person,
либо Object. Если это будет коллекция содержащая тип Employee, то объект типа
Person мы в такую коллекцию добавить не можем - не любой Person может быть
Employee. Но мы можем добавить в такую коллекцию объект типа Employee и объект
типа Manager. Даже если коллекция employees будет иметь тип Person, в такую
коллекцию мы можем добавить и Employee, и Manager - они являются Person.



> ## JAVA CORE. <br> StreamAPI. Вызов без терминальной операции

Промежуточные операции не выполняются немедленно — они откладываются до тех пор,
пока не будет вызвана терминальная операция.  
Именно терминальная операция запускает выполнение потока. После ее вызова
происходит анализ операций в пайплайне, и определяется эффективная стратегия его
выполнения.

> ## JAVA CORE. <br> StreamAPI. .parallel(), fork-join-poll

Для параллельного выполнения потоков в Stream Api collection.stream()
можно заменить на` collection.parallelStream().operation()`  
либо в общем случае для произвольного stream:
`Source.stream().parallel().operation()`.
.parallel()<br>
Для запуска потоков в параллельном режиме можно использовать методы
parallelStream() или parallel(). По умолчанию потоки выполняются
последовательно, но с явным вызовом одного из этих методов поток переключается
в параллельный режим.

parallelStream()

Методы stream().parallel() и parallelStream() в Java представляют два разных
способа создания параллельного потока.

1. stream().parallel(): этот метод используется для преобразования
   последовательного потока в параллельный поток. Его можно вызвать для любого
   объекта последовательного потока, чтобы включить параллельную обработку этого
   потока. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        ,Stream<String> parallelStream = list.stream().parallel();

2. parallelStream(): этот метод вызывается непосредственно для объекта коллекции
   для создания параллельного потока. Он возвращает параллельный поток,
   позволяющий выполнять параллельную обработку элементов коллекции. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> parallelStream = list.parallelStream();

Оба метода достигают одного и того же результата создания параллельного потока,
но основное различие заключается в способе их вызова. Метод stream().parallel()
вызывается для последовательного объекта потока, тогда как метод
parallelStream() вызывается непосредственно для объекта коллекции.

ForkJoinPool<br>
Java использует ForkJoinPool для распределения задач параллельных потоков. Это
общий пул потоков, где задачи разбиваются на более мелкие фрагменты и
распределяются между потоками. Такой же подход применяется и в
CompletableFuture. При необходимости можно указать свой пул потоков, если
текущий пул перегружен или необходимо изменить его поведение.

Существующая связь между параллельными потоками и инфраструктурой ForkJoinPool
заключается в базовой реализации параллельных потоков. Когда вы создаете
параллельный поток, он использует ForkJoinPool по умолчанию, предоставленный
Java, для параллельного выполнения операций потока. Это означает, что работа по
разделению данных и их распределению по нескольким потокам выполняется
ForkJoinPool. ForkJoinPool управляет пулом рабочих потоков и планирует
выполнение подзадач параллельного потока этими потоками. Он динамически
регулирует количество потоков в зависимости от доступных ядер ЦП и рабочей
нагрузки. Таким образом обеспечивается эффективное использование системных
ресурсов и повышается общая производительность обработки параллельных потоков.
Таким образом, связь между параллельными потоками и ForkJoinPool заключается в
том, что параллельные потоки используют ForkJoinPool для параллельного
выполнения операций потока, используя возможности параллельной обработки и
эффективного распределения рабочей нагрузки.

===============



> ## JAVA CORE. <br>  Garbage Collector. GCRoot

В Java, GC Root (или корень сборщика мусора) — это объект, который является
начальной точкой для процесса сборки мусора (Garbage Collection, GC). Сборщик
мусора использует корни для определения, какие объекты в памяти все еще доступны
и могут быть использованы, а какие объекты больше не нужны и могут быть удалены.

Что такое GC Root?<br>
GC Root — это набор объектов, которые всегда доступны и служат отправной точкой
для поиска всех достижимых объектов в памяти. Если объект не может быть
достигнут из любого из корней, он считается "мусором" и может быть удален
сборщиком мусора.

Примеры GC Root<br>
Вот несколько примеров объектов, которые считаются GC Root:<br>

- Статические поля:<br>
  Объекты, на которые ссылаются статические поля классов. Например, если у вас
  есть статическое поле в классе, которое ссылается на объект, этот объект будет
  являться корнем.
- Активные потоки:<br>
  Объекты, связанные с активными потоками (например, текущий поток выполнения).
- Объекты в локальных переменных:<br>
  Объекты, на которые ссылаются локальные переменные методов. Пока метод
  выполняется и локальные переменные находятся в стеке вызовов, эти объекты
  считаются достижимыми.
- JNI ссылки:<br>
  Объекты, на которые ссылаются нативные методы через Java Native Interface (
  JNI).
- Объекты класса java.lang.Runtime:<br>
  Объект Runtime, который предоставляет информацию о среде выполнения Java.

Как работает сборка мусора?<br>
Сборщик мусора использует алгоритмы для определения достижимости объектов:

1. Начинает с GC Roots: Сборщик начинает с объектов GC Root и проходит по всем
   ссылкам от этих объектов.
2. Обходит граф объектов: Он рекурсивно проверяет все объекты, на которые
   ссылаются корни.
3. Определяет недостижимые объекты: Все объекты, которые не могут быть
   достигнуты из корней, помечаются как "мусор" и подлежат удалению.

Важность GC Root<br>
Понимание концепции GC Root важно для оптимизации работы приложения и управления
памятью:<br>

1. Помогает разработчикам избегать утечек памяти.
2. Позволяет лучше понимать поведение сборщика мусора.
3. Способствует более эффективному управлению ресурсами в приложениях.

Как пометить объект "живым"<br>
В Java объекты помечаются как "живые" (или "достижимые") в контексте сборки
мусора (Garbage Collection) на основе ссылок на них. Если объект доступен через
одну или несколько ссылок, он считается живым и не может быть удален сборщиком
мусора. Вот несколько способов, как можно пометить объект как живой:

1. Создание ссылок на объект<br>
   Чтобы объект считался живым, необходимо создать хотя бы одну ссылку на него.
   Например:

```java
class MyObject {
// Поля и методы
}

public class Main {
    public static void main(String[] args) {
        MyObject obj = new MyObject(); // Создаем объект и сохраняем ссылку на него
// Объект obj считается "живым", пока существует ссылка на него
    }
}
```

В этом примере obj является ссылкой на экземпляр MyObject, и пока эта ссылка
существует, объект будет считаться живым.

2. Использование коллекций<br>
   Объекты могут быть помечены как живые, если они хранятся в коллекциях, таких
   как списки, множества или карты:

```java
import java.util.ArrayList;
import java.util.List;

class MyObject {
    // Поля и методы
}

public class Main {
    public static void main(String[] args) {
        List<MyObject> list = new ArrayList<>();
        MyObject obj = new MyObject();
        list.add(obj); // Объект obj теперь считается "живым", так как он хранится в списке
    }
}
```

3. Статические поля<br>
   Если объект хранится в статическом поле класса, он также будет считаться
   живым:

```java
class MyClass {
    static MyObject staticObj = new MyObject(); // Статическое поле хранит ссылку на объект
}

public class Main {
    public static void main(String[] args) {
        // Объект staticObj считается "живым" благодаря статической ссылке
    }
}
```

4. Передача объектов в методы<br>
   Когда вы передаете объект в метод, он также считается живым, пока метод
   выполняется:

```java
class MyObject {
    // Поля и методы
}

public class Main {
    public static void process(MyObject obj) {
        // Объект obj считается "живым" внутри этого метода
    }

    public static void main(String[] args) {
        MyObject myObj = new MyObject();
        process(myObj); // Передаем объект в метод
    }
}

```

5. Использование внешних библиотек или фреймворков
   Некоторые фреймворки и библиотеки могут управлять жизненным циклом объектов и
   поддерживать ссылки на них для обеспечения их доступности.

Заключение<br>
Объекты в Java считаются "живыми", если на них существуют ссылки из других
объектов или переменных. Чтобы пометить объект как живой, достаточно создать
хотя бы одну ссылку на него — это может быть локальная переменная, элемент
коллекции или статическое поле класса. Как только все ссылки на объект будут
удалены (например, переменные выйдут из области видимости или будут присвоены
null), объект станет недостижимым и может быть удален сборщиком мусора.

GC Root — это ключевая концепция в управлении памятью Java и сборке мусора. Она
определяет начальные точки для поиска достижимых объектов и помогает сборщику
мусора эффективно освобождать память от ненужных объектов.

==================


> ## Java Core:
> - ## устройство памяти и сборка мусора

### Основные области памяти в Java

Когда ты запускаешь Java-программу, память делится на несколько важных частей:

| Область           | Что хранится                                    |
|-------------------|-------------------------------------------------|
| **Heap (Куча)**   | Все объекты и данные, созданные с помощью `new` |
| **Stack (Стек)**  | Локальные переменные и вызовы методов           |
| **Метаспейс**     | Информация о классах (метаданные)               |
| **Code Cache**    | Скомпилированный код JIT-компилятора            |
| **Direct Memory** | Память вне куч (используется, например, NIO)    |

#### Heap (Куча)

- Самая большая область памяти.
- Управляется сборщиком мусора (**GC** — Garbage Collector).
- все **объекты** (`new` объекты, массивы),
- связанные с ними данные.

**Heap** — это общая память для всех потоков.  
Если переменная — это ссылка на объект, то сама ссылка хранится в стеке, а
объект — в куче.

_Как устроена куча?_

Heap делится на несколько областей:

```
Heap Memory
├── Young Generation
│    ├── Eden (сад новых объектов)
│    ├── Survivor 0 (выжившие объекты)
│    └── Survivor 1
├── Old Generation (старые объекты)
└── (иногда) Metaspace (для классов)
```

_Как работает память в куче?_

1. **Создание нового объекта** (`new MyClass()`) ➔ память выделяется в Eden.
2. **Minor GC** очищает Eden от мусора.
    - Выжившие объекты переносятся в Survivor области.
3. **Старение объектов**: после нескольких Minor GC выжившие объекты
   перемещаются в **Old Generation**.
4. **Major GC** убирает мусор из Old Generation.

_Что хранится в куче?_

| Элемент             | Описание                                         |
|:--------------------|:-------------------------------------------------|
| Экземпляры классов  | Все `new` объекты                                |
| Массивы             | Массивы любого типа (`int[]`, `String[]` и т.д.) |
| Строки (`String`)   | Если создаются явно через `new`, а не через пул  |
| Кэшированные данные | Например, коллекции, кэш                         |

_Жизненный цикл объекта в куче_

| Стадия      | Что происходит                                                             |
|:------------|:---------------------------------------------------------------------------|
| Создание    | Объект создается в Eden.                                                   |
| Перемещение | Если выжил после нескольких GC ➔ попадает в Survivor, потом в Old Gen.     |
| Уничтожение | Когда больше нет сильных ссылок ➔ объект собирается сборщиком мусора (GC). |

**Сравнение: Стек против Кучи**

| Параметр   | Стек                         | Куча                                    |
|:-----------|:-----------------------------|:----------------------------------------|
| Содержимое | Локальные переменные, ссылки | Объекты                                 |
| Жизнь      | До завершения метода         | До того, как объект станет недостижимым |
| Размер     | Маленький                    | Большой                                 |
| Управление | Автоматическое               | Сборщик мусора                          |

**Итого:**

- **Куча** — для хранения всех объектов приложения.
- **Управляется автоматически** через сборку мусора (GC).
- **Одна куча** на все потоки.
- **Heap перегружен ➔ OutOfMemoryError**.

_**Куча делится на поколения:**_

| Поколение            | Описание                                         |
|----------------------|--------------------------------------------------|
| **Young Generation** | Новые объекты; быстро умирают — быстро убираются |
| **Old Generation**   | "Долго живущие" объекты                          |
| **Survivor Spaces**  | Промежуточные буферы между Young и Old           |

##### **Молодое поколение (Young Gen)**

- Делится на **Eden** + **Survivor S0/S1**.
- Новые объекты сначала появляются в **Eden**.
- После одной или нескольких сборок мусора могут перейти в **Survivor** или
  **Old**.

**Что такое молодые объекты в Java Heap?**

Когда программа создаёт новые объекты, они сначала **попадают в специальную
часть кучи**, которая называется **Young Generation** или просто Young Gen.  
**Это место для "молодых" объектов** — то есть недавно созданных.

**Основная идея:**

- Большинство объектов в приложениях живут очень **короткое время** (например,
  какие-то временные строки, коллекции и т.д.).
- Чтобы эффективно их быстро убирать, Java делит кучу на поколения:  
  **молодые** (Young) и **старые** (Old).

**Структура кучи памяти в Java**

Грубо делится на две большие части:

```
Heap Memory
├── Young Generation
│    ├── Eden Space
│    ├── Survivor Space 1 (S0)
│    └── Survivor Space 2 (S1)
└── Old Generation (Tenured Space)
```

_Состоит из трёх частей:_

1. **Eden Space** — место, где появляются все новые объекты.
2. **Survivor Space 0 (S0)** — "пережившие" объекты после первой сборки мусора.
3. **Survivor Space 1 (S1)** — вторая зона для дальнейшего перемещения выживших
   объектов.

_Как это работает?_

1. **Создание объекта** ➔ он попадает в **Eden**.
2. Когда **Eden** заполняется ➔ происходит **Minor GC** (маленькая сборка
   мусора).
    - Все **неиспользуемые** объекты в Eden удаляются.
    - **Выжившие** перемещаются в один из **Survivor**-спейсов.
3. После нескольких сборок (переходов между S0 и S1):
    - Если объект всё ещё жив ➔ он **перемещается в Old Generation**.

_Цикл жизни молодого объекта:_

```
[Создание] → Eden → Minor GC → Survivor 0 → Survivor 1 → ... → Old Generation
```

Немного подробнее про сборки:

- **Minor GC** — быстрая сборка, только Young Gen.
- **Major GC (или Full GC)** — затрагивает и Young, и Old Gen. Долгая операция!

_Визуальная схема (упрощённо):_

```
Создание новых объектов → Eden  
Eden заполнился → Minor GC  
Выжившие → Survivor 0  
Выжившие → Survivor 1  
Много выжили? → Old Generation
```

_Итог:_

| Термин               | Что значит                            |
|:---------------------|:--------------------------------------|
| **Young Generation** | Память для недавно созданных объектов |
| **Eden Space**       | Место создания новых объектов         |
| **Survivor Spaces**  | Переходная зона для выживших          |
| **Minor GC**         | Быстрая очистка молодых объектов      |
| **Promotion**        | Перемещение объекта в Old Gen         |

##### **Старое поколение (Old Gen)**

- Здесь хранятся объекты, которые "пережили" много циклов сборки мусора.
- Старые объекты редко убираются => сборка мусора здесь медленнее.

**Старое поколение** в Java Heap — это область памяти, где находятся
долгоживущие объекты.<br>
Туда попадают те объекты, которые:

- **Пережили несколько сборок мусора** в молодом поколении (Young Gen),
- **Их возраст (`age`) превысил порог** (`MaxTenuringThreshold`).

**Идея:**  
Если объект живёт достаточно долго, скорее всего, он ещё долго будет нужен ➔ его
перемещают в Old Gen, чтобы не трогать часто.

_Структура памяти:_

```
Heap Memory
├── Young Generation
│    ├── Eden
│    ├── Survivor 0 (S0)
│    └── Survivor 1 (S1)
└── Old Generation (Tenured Space)   ← старые объекты здесь!
```

_Как объекты попадают в Old Gen?_

1. Новый объект создаётся ➔ попадает в Eden.
2. После Minor GC:
    - Если объект **выжил**, переходит в Survivor.
    - При каждом следующем Minor GC его возраст увеличивается.
3. Когда возраст объекта >= MaxTenuringThreshold ➔
    - **Объект перемещается в Old Generation** (promotion).

_Что хранится в Old Gen?_

- Сессии пользователей (`HttpSession`).
- Долгоживущие коллекции (`Map`, `List`), например, кэш.
- Данные уровня приложения (например, постоянные конфигурационные объекты).

_Особенности работы со Старым поколением:_

| Характеристика | Детали                                                                          |
|:---------------|:--------------------------------------------------------------------------------|
| Размер         | Обычно больше, чем Young Gen.                                                   |
| Частота GC     | Реже, чем в Young Gen.                                                          |
| Тип GC         | **Major GC** или **Full GC** (медленные, могут приостанавливать приложение).    |
| Алгоритмы      | Обычно используется **маркировка и сжатие** (`Mark-Compact`), а не копирование. |

_Как происходит сборка мусора в Old Gen?_

- Когда **Old Gen заполняется**, запускается **Major GC**.
- В отличие от Minor GC (работающего в Young Gen), Major GC:
    - Проходит по всей памяти.
    - Находит живые объекты.
    - **Компактирует** живые объекты в одну часть кучи (убирает "дыры" памяти).
    - Может **заморозить все потоки** (`Stop The World`).

Это более тяжёлая операция, чем обычный Minor GC, поэтому старое поколение
стараются заполнять как можно реже.

#### Stack (Стек)

- Каждый поток имеет **свой стек**.
- При вызове метода создается **Stack Frame**:
    - Локальные переменные
    - Параметры метода
    - Адрес возврата
- После завершения метода его стек-фрейм **удаляется**.

**Важно**: объекты в стеке не хранятся — только **ссылки** на них, если есть.

**Стек памяти** — это **область оперативной памяти**, которая выделяется для:

- хранения **вызовов методов**,
- хранения **локальных переменных**,
- хранения **контекста выполнения** (например, параметры методов, ссылки на
  объекты).

Каждый поток (`Thread`) в Java имеет **свой собственный стек**.  
То есть у каждого потока — **отдельная** изолированная память под вызовы своих
методов.

_Как устроен стек?_

Работает по принципу **"последним пришёл — первым ушёл"** (LIFO: Last In — First
Out).

Когда вызывается метод:

1. Создаётся **новая запись в стеке** (`Stack Frame`).
2. В неё помещаются:
    - Параметры метода,
    - Локальные переменные,
    - Ссылки на другие объекты,
    - Некоторая информация о возврате.

Когда метод завершается:

- Его стек-фрейм удаляется ("выворачивается" из стека).

_Что именно хранится в стеке:_

| Элемент              | Описание                                                    |
|:---------------------|:------------------------------------------------------------|
| Параметры метода     | Переданные значения при вызове                              |
| Локальные переменные | Внутренние переменные метода                                |
| Адрес возврата       | Куда переходить после выполнения метода                     |
| Ссылки на объекты    | Сами объекты лежат в куче (Heap), а ссылки на них — в стеке |

Пример: как растёт стек

```java
public class StackExample {
    public static void main(String[] args) {
        int result = add(2, 3);
        System.out.println(result);
    }

    public static int add(int a, int b) {
        return a + b;
    }
}
```

**Что происходит в памяти:**

1. `main()` запускается → создается фрейм для `main()`.
2. `add(2, 3)` вызывается → новый фрейм для `add()`.
3. В `add()` создаются локальные переменные `a=2`, `b=3`.
4. `add()` завершает работу ➔ его фрейм удаляется.
5. `main()` продолжает работу.

**StackOverflowError**

Если метод вызывает сам себя бесконечно (рекурсия без выхода), стек
переполняется:

```java
public class OverflowExample {
    public static void endless() {
        endless(); // бесконечный вызов
    }

    public static void main(String[] args) {
        endless();
    }
}
```

**Ошибка:**

```
Exception in thread "main" java.lang.StackOverflowError
```

Потому что стек ограничен по размеру (например, 1–2 МБ на поток, можно
настраивать через `-Xss`).

_Важные особенности стека:_

| Особенность           | Что означает                                                                   |
|:----------------------|:-------------------------------------------------------------------------------|
| Быстрая работа        | Стек — очень быстрый (память выделяется и освобождается за константное время). |
| Безопасность потоков  | У каждого потока свой стек ➔ нет гонок за память.                              |
| Живёт во время вызова | Переменные существуют только пока жив метод.                                   |

_Сравнение Stack vs Heap_

| Характеристика | Stack                           | Heap                   |
|:---------------|:--------------------------------|:-----------------------|
| Содержимое     | Локальные переменные, параметры | Объекты, массивы       |
| Жизненный цикл | До завершения метода            | Пока объект достижим   |
| Доступ         | Быстрый (LIFO)                  | Медленный (по ссылкам) |
| Размер         | Маленький                       | Большой                |
| Управление     | Автоматически                   | Сборщик мусора (GC)    |

Мини-схема:

```
Stack Memory (поток 1)
└─ main() frame
   └─ вызвал add()
      └─ frame add()
         └─ локальные переменные: a=2, b=3
Stack Memory (поток 2)
└─ свой стек
```

Итого:

- **Стек** — память для хранения контекста выполнения метода.
- **Быстрая** работа за счёт простой структуры.
- **Изолирован** для каждого потока.
- При ошибках глубоких вызовов ➔ возможен `StackOverflowError`.

#### Metaspace (Раньше был PermGen)

- Хранит информацию о загруженных классах: названия, методы, поля и т.д.
- Начиная с Java 8 вместо PermGen используется **Metaspace**.
- Использует **нативную память** (не ограничена кучей).

#### Code Cache

- Для ускорения работы JIT-компилятор компилирует часто используемый байт-код в
  **машинный код**.
- Этот код хранится в **Code Cache**.

#### Direct Memory

- Обход обычной кучи.
- Используется в высокопроизводительных приложениях, например через
  `ByteBuffer.allocateDirect()`.
- Управляется вручную (Java NIO, Netty и пр.).

#### Визуальная схема

```plaintext
+---------------------------------------------------+
|                   Память процесса                 |
| +---------------------+  +----------------------+ |
| |    Стек потока 1    |  |   Стек потока 2      | |
| +---------------------+  +----------------------+ |
|                    Куча (Heap)                    |
|  +---------------------------------------------+  |
|  |  Young Gen (Eden + Survivor)                |  |
|  |  Old Gen                                    |  |
|  +---------------------------------------------+  |
|               Метаспейс (Metaspace)               |
|               Code Cache                          |
|               Direct Memory                       |
+---------------------------------------------------+
```

**Важно помнить**

- Java сама управляет памятью через **GC**.
- StackOverflowError происходит, когда стек слишком сильно разрастается
  (например, рекурсия без выхода).
- OutOfMemoryError возникает, если куча или метаспейс переполнены.

### Сборка мусора

#### Что такое сборка мусора?

**Garbage Collection** — это механизм в Java, который автоматически **находит и
удаляет неиспользуемые объекты** из памяти, чтобы освободить место.

**Идея:** если на объект **нет больше ссылок**, значит, он **больше не нужен**,
и его можно безопасно удалить.

#### Основные этапы работы GC

1. **Маркировка (Marking):**
    - GC проходит по всем "живым" объектам, начиная с корней (`GC roots`) и
      помечает доступные объекты как живые.
2. **Удаление (Sweeping):**
    - Все немаркированные объекты считаются мусором и удаляются.
3. **Компактирование (Compacting) (иногда):**
    - Перемещает живые объекты, чтобы убрать пустые промежутки и уменьшить
      фрагментацию памяти.

### Что такое GC roots?

**GC Roots** — это начальные точки, откуда GC начинает искать живые объекты.
Примеры:

- Статические поля (`static`)
- Стековые переменные методов
- Активные потоки
- Ссылки внутри JNI

**GC Root** — это **специальная точка отсчёта** для сборщика мусора (**Garbage
Collector**), откуда начинается поиск **живых объектов** в памяти.

**Проще говоря:**  
Когда сборщик мусора ищет, какие объекты можно удалить, он сначала смотрит,
**какие объекты доступны из GC Roots**.  
Все объекты, **которые достижимы** (через цепочку ссылок) от GC Roots, считаются
**живыми**.  
Остальные — **мусор** ➔ их можно удалить.

**Ключевая идея:**

**Если на объект есть хотя бы одна цепочка ссылок от GC Root — он живой.**  
**Если нет — его можно собрать и освободить память.**

**Какие бывают GC Roots?**

В Java в роли **GC Root** выступают:

| Тип GC Root                          | Описание                                                                      |
|:-------------------------------------|:------------------------------------------------------------------------------|
| **Ссылки из стека потоков**          | Все локальные переменные и параметры методов в стеке потока.                  |
| **Ссылки из статических переменных** | Статические поля классов (`static` поля).                                     |
| **Ссылки из классов**                | Классы, загруженные через специальные ClassLoader'ы.                          |
| **Ссылки от JNI**                    | Объекты, которые используются нативным кодом (через Java Native Interface).   |
| **Менеджеры JVM**                    | Например, системные объекты (пулы потоков, классы сдержания ресурсов и т.д.). |

**Как работает сборка мусора через GC Roots:**

1. GC начинает обход всех GC Roots.
2. По каждой ссылке ищет, какие объекты достижимы.
3. Строится граф "живых объектов".
4. Всё, до чего нельзя дойти ➔ **собирается**.

Этот процесс называется **"Tracing Garbage Collection"** (сборка мусора через
трассировку ссылок).

**Краткий пример:**

```java
public class GCRootExample {
    static Object staticObject;
    Object instanceObject;

    public static void main(String[] args) {
        GCRootExample example = new GCRootExample();
        staticObject = new Object();
        example.instanceObject = new Object();
        // Здесь staticObject и instanceObject доступны через GC Roots
    }
}
```

- `staticObject` — доступен через статическую ссылку (GC Root).
- `example.instanceObject` — доступен через локальную переменную `example` в
  стеке main-потока (GC Root через стек).

**Почему это важно знать?**

- **Понимание GC Roots** позволяет правильно **анализировать утечки памяти**.
- В профайлерах памяти (например, **VisualVM**, **YourKit**, **JProfiler**)
  можно смотреть "путь к GC Root" ➔ это показывает, **почему объект не может
  быть собран**.

**Если коротко:**

| Вопрос                 | Ответ                                                   |
|:-----------------------|:--------------------------------------------------------|
| Что такое GC Root?     | Точка, откуда начинается поиск живых объектов.          |
| Какие бывают GC Roots? | Стек потоков, статические поля, классы, JNI-ссылки.     |
| Почему важно?          | Помогает понимать сборку мусора и искать утечки памяти. |

## String Pool

**String Pool** — это одна из фишек Java, которая позволяет **оптимизировать
работу с памятью** при использовании строк.

**Что такое String Pool?**

**String Pool** — это специальная область памяти в куче (**Heap**), где Java
хранит **уникальные экземпляры строк** (`String`).

**Идея:**  
Если две строки имеют одинаковое значение, **Java не создает два объекта**, а
**использует один и тот же**.

То есть:

`String a = "hello";`  
`String b = "hello";`

`a` и `b` будут ссылаться на **один и тот же объект** в памяти!

**Где именно находится String Pool?**

- До **Java 7**: String Pool был в **PermGen** (область для метаданных классов).
- Начиная с **Java 7 и выше**: String Pool переместили в **Heap** (кучу) вместе
  с обычными объектами.

Это позволило избежать ошибок, связанных с ограниченным размером PermGen.

**Как строки попадают в String Pool?**

1. Если строка создана **литералом** (`"someText"`), то Java сначала ищет строку
   в String Pool.
2. Если такой строки нет — она **добавляется** туда.
3. Если строка **уже есть** — возвращается ссылка на существующую строку.

Пример:

```java
void demo() {
    String a = "test";
    String b = "test";

    System.out.println(a == b); // true (они указывают на один объект)
}
```

**А если создать через `new`?**

```code
String a = new String("test");
String b = new String("test");
System.out.println(a ==b); // false (два разных объекта)
```

- `new String()` **всегда создает новый объект** в куче, независимо от того,
  есть строка в пуле или нет.
- Но можно потом добавить такую строку в пул явно через `.intern()`.


**Что делает метод `.intern()`?**

Метод `intern()`:

- Проверяет, есть ли строка в пуле.
- Если есть — возвращает ссылку на существующую строку.
- Если нет — добавляет в пул.

Пример:

```java
String a = new String("hello").intern();
String b = "hello";

System.out.

println(a ==b); // true
```

Почему String Pool важен?

- **Экономия памяти**: одинаковые строки хранятся только один раз.
- **Быстрая проверка строк**: можно использовать `==`, а не `equals()`, если
  строки интернированы.
- **Оптимизация производительности**: меньше затрат на создание и сборку мусора.

## JIT компилятор

Отличный вопрос! Давай разберем максимально понятно. 🚀

---

# 📚 Что такое JIT-компилятор в Java?

**JIT** — это **Just-In-Time Compiler**,  
или по-русски **"компилятор на лету"**.

**Его задача** — **ускорить выполнение Java-программ**.

---

## 🔥 Кратко: зачем нужен JIT?

Когда ты запускаешь Java-программу:

- Сначала код компилируется в **байткод** (`.class` файлы).
- Байткод выполняется на **JVM** (Java Virtual Machine).
- Обычно интерпретатор **читает и выполняет** байткод **построчно**.

**Проблема**: интерпретация — **медленная**.  
**Решение**: часто используемые участки кода компилировать в **машинный код**
прямо **во время работы программы** ➔ выполняется намного быстрее!

**Вот этим и занимается JIT.**

---

# 🛠 Как работает JIT-компилятор:

1. Ты запускаешь приложение ➔ JVM начинает интерпретировать байткод.
2. JVM **следит**, какие методы часто вызываются (**"горячие методы"**).
3. Когда метод становится популярным:
    - JIT-компилятор **компилирует байткод в нативный код процессора (CPU)**.
4. Теперь JVM **больше не интерпретирует этот метод**, а **исполняет его как
   обычный машинный код** ➔ очень быстро!

---

## ✨ Пример:

```java
public class HelloWorld {
    public static void main(String[] args) {
        for (int i = 0; i < 1_000_000; i++) {
            sayHello();
        }
    }

    static void sayHello() {
        System.out.println("Hello");
    }
}
```

- Метод `sayHello()` **очень часто вызывается**.
- JVM это замечает ➔ **JIT компилирует** `sayHello()` в машинный код.
- Последующие вызовы работают быстрее.

---

# 🎯 Какие есть режимы у JIT?

| Режим  | Описание                                                                                |
|:-------|:----------------------------------------------------------------------------------------|
| Client | Быстрая компиляция, без сильной оптимизации. Подходит для приложений с короткой жизнью. |
| Server | Медленная, но очень агрессивная оптимизация кода. Для долгоживущих сервисов (бэкенд).   |

(Сейчас в Java все умнее: используются гибридные режимы.)

---

# 🧠 Какие оптимизации делает JIT?

✅ Инлайнинг методов (вставка тела метода прямо в код)  
✅ Удаление лишних проверок (например, ненужных `null`-проверок)  
✅ Предсказание циклов и ветвлений  
✅ Удаление мертвого кода (который никогда не исполняется)  
✅ Escape analysis (если объект не "убегает" за пределы метода — создается прямо
в стеке, а не в куче)

---

# 🔥 Что еще важно знать?

- **JIT улучшает производительность**, но **разгоняется не сразу** ➔  
  в начале программа может работать медленно (интерпретация), потом быстро (
  после JIT-компиляции).
- Оптимизированный код может **адаптивно пересобираться**: если условия
  изменились ➔ JIT может пересобрать по-другому.

---

# 📦 В двух словах:

| Без JIT                          | С JIT                              |
|:---------------------------------|:-----------------------------------|
| Медленная интерпретация байткода | Быстрое исполнение машинного кода  |
| Построчное выполнение            | Компиляция "горячего" кода на лету |
| Простая JVM                      | Умная и быстрая JVM                |

---

# 📢 Итого

- **JIT** — это часть JVM, которая **ускоряет выполнение программ**.
- Он **компилирует часто используемые методы** в **нативный код** прямо во время
  работы.
- Благодаря JIT, **Java-программы работают почти так же быстро**, как C++
  программы, особенно после "разгона".

---

Хочешь, могу ещё показать:

- 🔹 Как работает **инлайнинг** методов (очень крутая JIT-оптимизация),
- 🔹 Или рассказать про **AOT (Ahead-Of-Time) компиляцию** в Java (например,
  GraalVM).

Хочешь углубиться? 🚀  
Тема офигенно интересная, особенно если любишь разбираться в производительности!
👨‍💻✨