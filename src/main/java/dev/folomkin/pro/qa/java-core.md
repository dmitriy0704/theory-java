> ## JAVA CORE. <br> Generics. Можем как-то ограничить типы (про super)

В Java, как и в других языках программирования, концепция уровней обобщений (или
обобщенных типов) позволяет создавать классы, интерфейсы и методы, которые
работают с различными типами данных. Это достигается с помощью параметров типа (
type parameters). В контексте обобщений можно выделить верхний и нижний уровни
обобщений.

Верхний уровень обобщений (Upper Bound Wildcards)

Верхний уровень обобщений используется для ограничения типа, который может быть
использован в качестве параметра. Это делается с помощью ключевого слова
extends. Например:

```java
public void processList(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```

В этом примере метод processList принимает список, содержащий объекты любого
типа, который является подтипом Number (например, Integer, Double и т.д.). Это
позволяет работать с различными типами данных, сохраняя при этом безопасность
типов.

Нижний уровень обобщений (Lower Bound Wildcards)

Нижний уровень обобщений используется для указания того, что параметр может быть
определён как определённый тип или любой его суперкласс. Это делается с помощью
ключевого слова super. Например:

```java
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}
```

В этом примере метод addNumbers принимает список, который может содержать
объекты типа Integer или любого его суперкласса (например, Number или Object).
Это позволяет добавлять элементы в список без необходимости знать точный тип
списка.

Применение

Верхние границы полезны, когда вы хотите читать данные из структуры данных и не
хотите беспокоиться о том, какой конкретный подтип вы получаете.
Нижние границы полезны, когда вы хотите добавлять данные в структуру данных и
хотите гарантировать, что вы можете добавлять элементы определенного типа или
его подтипов.  
Эти концепции позволяют создавать более гибкие и безопасные API в Java.

> ## JAVA CORE. <br> Generics. PECS

PECS расшифровывается как Producer extends Consumer super.
Принцип PECS непосредственно связан с коллекциями и обобщениями.

### Producer Extends

```java
List<? extends Employee> employees = ... // upper bounded wildcard

```

Это значит, что эта коллекция будет содержать объекты либо Employee, либо
классов, которые наследуют Employee.

Код для примера:

```java

class Person {
}

class Employee extends Person {
}

class Manager extends Employee {
}

public class Demo {
    public static void main(String[] args) {

    }

}
```

В примере

```java
List<? extends Employee> employees = ... // upper bounded wildcard

```

List будет содержать класс Employee либо Manager.

```java
public class Demo {
    public static void main(String[] args) {

        List<Person> persons = new ArrayList<>();
        List<Employee> employees = new ArrayList<>();
        List<Manager> managers = new ArrayList<>();

        processUpperBounded(persons); //-> ошибка компиляции
        processUpperBounded(employees);
        processUpperBounded(managers);

    }

    public static void processUpperBounded(List<? extends Employee> employees) {

    }
}
```

В первом случае у нас будет ошибка компиляции - коллекцию типа Person мы
передать не можем, потому что коллекция ограничена с помощью extends. На вход
нашего метода processUpperBounded мы можем передать только коллекцию, которая
содержит Employee либо Manager, но не Person.

Получить из коллекции элементы можно так:

```java
public class Demo {
    public static void main(String[] args) {
    }

    public static void processUpperBounded(List<? extends Employee> employees) {
        Person person = upperBoundedEmployees.get(0);
        Employee employee = upperBoundedEmployees.get(0);
        Manager manager = upperBoundedEmployees.get(0); //-> ошибка - не все 
        // Employee являются Manager, но все employee являются Person.

        //-> Нельзя добавить элементы, потому что в списке находятся 
        // элеенты наследуемые от Employee - Manager и не Manager.
    }
}
```

### Consumer Super

```java
List<? super Employee> managers = ...// // lower bounded wildcard

```

В этом случае мы указываем, что эта коллекция managers будет содержать объекты
Employee, либо его супер классы.

```java

public class Demo {
    public static void main(String[] args) {
        List<Person> persons = new ArrayList<>();
        List<Employee> employees = new ArrayList<>();
        List<Manager> managers = new ArrayList<>();

        //-> Мы можем на вход метода передать коллекцию типа Person и коллекцию
        // с типом Employee. Но мы не можем передать коллекцию, которая содержит
        // объекты типа Manager, у нас будет ошибка компиляции:

        processLowerBounded(persons);
        processLowerBounded(employees);
        processLowerBounded(managers); //-> ошибка компиляции
    }

    public static void processLowerBounded(List<? super Employee> employees) {
        employees.add(new Person()); //-> ошибка компиляции
        employees.add(new Employee());
        employees.add(new Manager());
    }
}
```

Если коллекция является Consumer - в такую коллекцию можно добавлять объекты,
но не получать их. В методе processLowerBounded мы пытаемся
добавить в нашу коллекцию employees объекты типа Person, Employee и Manager.
Когда мы добавляем Person, будет ошибка
компиляции, но мы можем добавить объекты Employee и Manager. Здесь я хочу
обратить внимание на такой тонкий момент - когда мы передаём на вход метода
коллекции, мы можем в employees присвоить только коллекции, которые содержат
объекты типа Person и Employee, но не Manager. Но когда мы в эту коллекцию
добавляем объекты, то мы не можем добавить сюда значение типа Person, только
Employee и Manager. Почему так происходит?
Принцип PECS применим при присвоении одной коллекции другой:

```java
List<? extends Employee> list1 = employees;
List<? extends Employee> list2 = managers;
List<? super Employee> list3 = persons;
```

То есть в переменную, которая объявлена как <? extends Employee>, мы можем
присвоить другую коллекцию, которая содержит объекты типа Employee, либо объекты
типа Manager. В переменную list3 мы можем добавить коллекцию, которая содержит
Person. Но принцип PECS не применим при добавлении объектов в коллекции:

```java
public static void processLowerBounded(List<? super Employee> employees) {
    employees.add(new Person()); //compilation error
    employees.add(new Employee());
    employees.add(new Manager());...
}
```

В коллекцию, объявленную как <? super Employee>, мы можем добавить только
Employee и Manager.
На этапе компиляции компилятор не знает какого именно типа объекты будут
содержаться в employees. Но он чётко знает, что это либо Employee, либо Person,
либо Object. Если это будет коллекция содержащая тип Employee, то объект типа
Person мы в такую коллекцию добавить не можем - не любой Person может быть
Employee. Но мы можем добавить в такую коллекцию объект типа Employee и объект
типа Manager. Даже если коллекция employees будет иметь тип Person, в такую
коллекцию мы можем добавить и Employee, и Manager - они являются Person.



> ## JAVA CORE. <br> StreamAPI. Вызов без терминальной операции

Промежуточные операции не выполняются немедленно — они откладываются до тех пор,
пока не будет вызвана терминальная операция.  
Именно терминальная операция запускает выполнение потока. После ее вызова
происходит анализ операций в пайплайне, и определяется эффективная стратегия его
выполнения.

> ## JAVA CORE. <br> StreamAPI. .parallel(), fork-join-poll

Для параллельного выполнения потоков в Stream Api collection.stream()
можно заменить на` collection.parallelStream().operation()`  
либо в общем случае для произвольного stream:
`Source.stream().parallel().operation()`.
.parallel()<br>
Для запуска потоков в параллельном режиме можно использовать методы
parallelStream() или parallel(). По умолчанию потоки выполняются
последовательно, но с явным вызовом одного из этих методов поток переключается
в параллельный режим.

parallelStream()

Методы stream().parallel() и parallelStream() в Java представляют два разных
способа создания параллельного потока.

1. stream().parallel(): этот метод используется для преобразования
   последовательного потока в параллельный поток. Его можно вызвать для любого
   объекта последовательного потока, чтобы включить параллельную обработку этого
   потока. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        ,Stream<String> parallelStream = list.stream().parallel();

2. parallelStream(): этот метод вызывается непосредственно для объекта коллекции
   для создания параллельного потока. Он возвращает параллельный поток,
   позволяющий выполнять параллельную обработку элементов коллекции. Например:

        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> parallelStream = list.parallelStream();

Оба метода достигают одного и того же результата создания параллельного потока,
но основное различие заключается в способе их вызова. Метод stream().parallel()
вызывается для последовательного объекта потока, тогда как метод
parallelStream() вызывается непосредственно для объекта коллекции.

ForkJoinPool<br>
Java использует ForkJoinPool для распределения задач параллельных потоков. Это
общий пул потоков, где задачи разбиваются на более мелкие фрагменты и
распределяются между потоками. Такой же подход применяется и в
CompletableFuture. При необходимости можно указать свой пул потоков, если
текущий пул перегружен или необходимо изменить его поведение.

Существующая связь между параллельными потоками и инфраструктурой ForkJoinPool
заключается в базовой реализации параллельных потоков. Когда вы создаете
параллельный поток, он использует ForkJoinPool по умолчанию, предоставленный
Java, для параллельного выполнения операций потока. Это означает, что работа по
разделению данных и их распределению по нескольким потокам выполняется
ForkJoinPool. ForkJoinPool управляет пулом рабочих потоков и планирует
выполнение подзадач параллельного потока этими потоками. Он динамически
регулирует количество потоков в зависимости от доступных ядер ЦП и рабочей
нагрузки. Таким образом обеспечивается эффективное использование системных
ресурсов и повышается общая производительность обработки параллельных потоков.
Таким образом, связь между параллельными потоками и ForkJoinPool заключается в
том, что параллельные потоки используют ForkJoinPool для параллельного
выполнения операций потока, используя возможности параллельной обработки и
эффективного распределения рабочей нагрузки.


> ## JAVA CORE. <br>  Garbage Collector. GCRoot

В Java, GC Root (или корень сборщика мусора) — это объект, который является
начальной точкой для процесса сборки мусора (Garbage Collection, GC). Сборщик
мусора использует корни для определения, какие объекты в памяти все еще доступны
и могут быть использованы, а какие объекты больше не нужны и могут быть удалены.

Что такое GC Root?<br>
GC Root — это набор объектов, которые всегда доступны и служат отправной точкой
для поиска всех достижимых объектов в памяти. Если объект не может быть
достигнут из любого из корней, он считается "мусором" и может быть удален
сборщиком мусора.

Примеры GC Root<br>
Вот несколько примеров объектов, которые считаются GC Root:<br>

- Статические поля:<br>
  Объекты, на которые ссылаются статические поля классов. Например, если у вас
  есть статическое поле в классе, которое ссылается на объект, этот объект будет
  являться корнем.
- Активные потоки:<br>
  Объекты, связанные с активными потоками (например, текущий поток выполнения).
- Объекты в локальных переменных:<br>
  Объекты, на которые ссылаются локальные переменные методов. Пока метод
  выполняется и локальные переменные находятся в стеке вызовов, эти объекты
  считаются достижимыми.
- JNI ссылки:<br>
  Объекты, на которые ссылаются нативные методы через Java Native Interface (
  JNI).
- Объекты класса java.lang.Runtime:<br>
  Объект Runtime, который предоставляет информацию о среде выполнения Java.

Как работает сборка мусора?<br>
Сборщик мусора использует алгоритмы для определения достижимости объектов:

1. Начинает с GC Roots: Сборщик начинает с объектов GC Root и проходит по всем
   ссылкам от этих объектов.
2. Обходит граф объектов: Он рекурсивно проверяет все объекты, на которые
   ссылаются корни.
3. Определяет недостижимые объекты: Все объекты, которые не могут быть
   достигнуты из корней, помечаются как "мусор" и подлежат удалению.

Важность GC Root<br>
Понимание концепции GC Root важно для оптимизации работы приложения и управления
памятью:<br>

1. Помогает разработчикам избегать утечек памяти.
2. Позволяет лучше понимать поведение сборщика мусора.
3. Способствует более эффективному управлению ресурсами в приложениях.

Как пометить объект "живым"<br>
В Java объекты помечаются как "живые" (или "достижимые") в контексте сборки
мусора (Garbage Collection) на основе ссылок на них. Если объект доступен через
одну или несколько ссылок, он считается живым и не может быть удален сборщиком
мусора. Вот несколько способов, как можно пометить объект как живой:

1. Создание ссылок на объект<br>
   Чтобы объект считался живым, необходимо создать хотя бы одну ссылку на него.
   Например:

```java
class MyObject {
// Поля и методы
}

public class Main {
    public static void main(String[] args) {
        MyObject obj = new MyObject(); // Создаем объект и сохраняем ссылку на него
// Объект obj считается "живым", пока существует ссылка на него
    }
}
```

В этом примере obj является ссылкой на экземпляр MyObject, и пока эта ссылка
существует, объект будет считаться живым.

2. Использование коллекций<br>
   Объекты могут быть помечены как живые, если они хранятся в коллекциях, таких
   как списки, множества или карты:

```java
import java.util.ArrayList;
import java.util.List;

class MyObject {
    // Поля и методы
}

public class Main {
    public static void main(String[] args) {
        List<MyObject> list = new ArrayList<>();
        MyObject obj = new MyObject();
        list.add(obj); // Объект obj теперь считается "живым", так как он хранится в списке
    }
}
```

3. Статические поля<br>
   Если объект хранится в статическом поле класса, он также будет считаться
   живым:

```java
class MyClass {
    static MyObject staticObj = new MyObject(); // Статическое поле хранит ссылку на объект
}

public class Main {
    public static void main(String[] args) {
        // Объект staticObj считается "живым" благодаря статической ссылке
    }
}
```

4. Передача объектов в методы<br>
   Когда вы передаете объект в метод, он также считается живым, пока метод
   выполняется:

```java
class MyObject {
    // Поля и методы
}

public class Main {
    public static void process(MyObject obj) {
        // Объект obj считается "живым" внутри этого метода
    }

    public static void main(String[] args) {
        MyObject myObj = new MyObject();
        process(myObj); // Передаем объект в метод
    }
}

```

5. Использование внешних библиотек или фреймворков
   Некоторые фреймворки и библиотеки могут управлять жизненным циклом объектов и
   поддерживать ссылки на них для обеспечения их доступности.

Заключение<br>
Объекты в Java считаются "живыми", если на них существуют ссылки из других
объектов или переменных. Чтобы пометить объект как живой, достаточно создать
хотя бы одну ссылку на него — это может быть локальная переменная, элемент
коллекции или статическое поле класса. Как только все ссылки на объект будут
удалены (например, переменные выйдут из области видимости или будут присвоены
null), объект станет недостижимым и может быть удален сборщиком мусора.

GC Root — это ключевая концепция в управлении памятью Java и сборке мусора. Она
определяет начальные точки для поиска достижимых объектов и помогает сборщику
мусора эффективно освобождать память от ненужных объектов.
