
> ## JAVA CORE. <br> Generics. Можем как-то ограничить типы (про super)

В Java, как и в других языках программирования, концепция уровней обобщений (или
обобщенных типов) позволяет создавать классы, интерфейсы и методы, которые
работают с различными типами данных. Это достигается с помощью параметров типа (
type parameters). В контексте обобщений можно выделить верхний и нижний уровни
обобщений.

Верхний уровень обобщений (Upper Bound Wildcards)

Верхний уровень обобщений используется для ограничения типа, который может быть
использован в качестве параметра. Это делается с помощью ключевого слова
extends. Например:

```java
public void processList(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```

В этом примере метод processList принимает список, содержащий объекты любого
типа, который является подтипом Number (например, Integer, Double и т.д.). Это
позволяет работать с различными типами данных, сохраняя при этом безопасность
типов.

Нижний уровень обобщений (Lower Bound Wildcards)

Нижний уровень обобщений используется для указания того, что параметр может быть
определён как определённый тип или любой его суперкласс. Это делается с помощью
ключевого слова super. Например:

```java
public void addNumbers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}
```

В этом примере метод addNumbers принимает список, который может содержать
объекты типа Integer или любого его суперкласса (например, Number или Object).
Это позволяет добавлять элементы в список без необходимости знать точный тип
списка.

Применение

Верхние границы полезны, когда вы хотите читать данные из структуры данных и не
хотите беспокоиться о том, какой конкретный подтип вы получаете.
Нижние границы полезны, когда вы хотите добавлять данные в структуру данных и
хотите гарантировать, что вы можете добавлять элементы определенного типа или
его подтипов.  
Эти концепции позволяют создавать более гибкие и безопасные API в Java.

> ## JAVA CORE. <br> Generics. PECS

Принцип PECS (Producer Extends, Consumer Super) — это концепция, связанная с
использованием обобщений (generics) в Java, которая помогает правильно управлять
типами при работе с коллекциями и другими обобщенными структурами данных. Этот
принцип особенно полезен для понимания того, как использовать wildcard-тип (
неопределенный тип) в Java.

**Основные идеи PECS**

Producer Extends: Если вы хотите создать структуру данных, которая будет
производить элементы (например, возвращать элементы из коллекции), используйте
`? extends T`. Это означает, что вы можете использовать любой подтип T.

Consumer Super: Если вы хотите создать структуру данных, которая будет
потреблять элементы (например, добавлять элементы в коллекцию), используйте
`? super T`. Это означает, что вы можете использовать любой суперкласс T.

_Примеры_

**Producer Extends**

Предположим, у вас есть класс Animal и его подклассы Dog и Cat. Если у вас есть
метод, который возвращает список животных:

```java
class Animal {
}

class Dog extends Animal {
}

class Cat extends Animal {
}

public void printAnimals(List<? extends Animal> animals) {
    for (Animal animal : animals) {
        System.out.println(animal);
    }
}
```

В этом примере метод printAnimals принимает список животных `(List<? extends
Animal>)`. Это позволяет передавать списки как List<Dog>, так и List<Cat>,
поскольку оба класса являются подтипами Animal. Метод может безопасно читать
объекты из списка и обрабатывать их как объекты типа Animal.

**Consumer Super**

Теперь рассмотрим ситуацию, когда вам нужно добавить животных в коллекцию:

```java
public void addDogs(List<? super Dog> dogs) {
    dogs.add(new Dog());
    // dogs.add(new Animal()); // Ошибка компиляции
}
```

В этом примере метод addDogs принимает список, который может содержать объекты
типа Dog или любого его суперкласса (например, Animal или даже Object). Это
позволяет добавлять объекты типа Dog в список. Однако вы не можете добавлять
объекты типа Animal, потому что это может привести к нарушению типов.

В Java, когда вы используете обобщения (generics) с `? super T`, важно понимать,
как работает механизм типов и что именно разрешено добавлять в коллекцию.

Объяснение

Тип ? super T:

Когда вы используете `List<? super Dog>`, это означает, что вы можете передать
список, который может содержать объекты типа Dog или любого его суперкласса (
например, Animal или даже Object).  
Однако это также означает, что вы не можете добавлять объекты типа Animal,
потому что компилятор не может гарантировать, что этот список предназначен для
хранения объектов типа Animal. Он может быть списком, который предназначен
только для хранения объектов типа Dog.
Добавление объектов:

Когда вы добавляете объект типа Dog, это безопасно, потому что Dog является
подклассом и совместим с любым суперклассом.  
Однако если бы вы попытались добавить объект типа Animal, компилятор не смог бы
гарантировать, что это допустимо. Например, если у вас есть список типа
List<Animal>, он может содержать объекты других подклассов (например, Cat). Если
бы вы добавили объект типа Animal, это могло бы привести к ситуации, когда в
списке окажутся объекты разных типов (например, и Dog, и Cat), что нарушает
типизацию.

Пример

Рассмотрим следующий код:

```java
import java.util.ArrayList;
import java.util.List;

class Animal {
}

class Dog extends Animal {
}

class Cat extends Animal {
}

public class ConsumerSuperExample {
    public void addDogs(List<? super Dog> dogs) {
        dogs.add(new Dog()); // Это допустимо
        // dogs.add(new Animal()); // Ошибка компиляции
    }

    public static void main(String[] args) {
        List<Animal> animalList = new ArrayList<>();
        List<Dog> dogList = new ArrayList<>();

        ConsumerSuperExample example = new ConsumerSuperExample();

        example.addDogs(animalList); // Это допустимо
        // example.addDogs(dogList); // Ошибка компиляции
    }

}
```

Почему это происходит:  
Добавление объекта типа Dog:

Когда вы вызываете dogs.add(new Dog()), это безопасно, потому что метод ожидает
список, который может содержать объекты типа Dog или его суперклассы. Таким
образом, добавление объекта типа Dog всегда будет допустимо.
Попытка добавить объект типа Animal:

Если бы вы попытались добавить объект типа Animal, компилятор выдаст ошибку. Это
связано с тем, что метод не знает точно, какой именно тип данных хранится в
списке. Например:

```java
List<Animal> animalList = new ArrayList<>();
List<Cat> catList = new ArrayList<>();example.

addDogs(catList);
// Это вызвало бы ошибку компиляции
```

В этом случае метод не может гарантировать безопасность добавления объекта типа
Animal, так как он может быть несовместим с типом данных в списке.

Заключение<br>
Таким образом, использование обобщений с типом ? super T позволяет вам добавлять
объекты определенного подкласса (в данном случае — объекты класса Dog), но не
позволяет добавлять объекты базового класса (Animal) из-за ограничений типизации
и обеспечения безопасности типов в Java.

**Применение PECS**<br>  
Принцип PECS помогает разработчикам правильно выбирать между использованием
верхних (extends) и нижних (super) границ при работе с обобщениями. Вот
несколько рекомендаций:

- Используйте ? extends T, когда:
    - Вы читаете данные из структуры данных.
    - Вам нужно получить элементы из коллекции.

- Используйте ? super T, когда:
    - Вы записываете данные в структуру данных.
    - Вам нужно добавлять элементы в коллекцию.

Заключение<br>
Принцип PECS является важным инструментом для работы с обобщениями в Java. Он
помогает избежать ошибок компиляции и делает код более безопасным и понятным.
Понимание этого принципа позволяет разработчикам более эффективно использовать
возможности языка Java и создавать гибкие архитектуры программного обеспечения.

>## JAVA CORE. <br> StreamAPI. Вызов без терминальной операции

Промежуточные операции не выполняются немедленно — они откладываются до тех пор,
пока не будет вызвана терминальная операция.  
Именно терминальная операция запускает выполнение потока. После ее вызова
происходит анализ операций в пайплайне, и определяется эффективная стратегия его
выполнения.

>## JAVA CORE. <br> StreamAPI. .parallel(), fork-join-poll

.parallel()<br>
Для запуска потоков в параллельном режиме можно использовать методы
parallelStream() или parallel(). По умолчанию потоки выполняются
последовательно, но с явным вызовом одного из этих методов поток переключается в
параллельный режим.<br>
Для разделения коллекций на части, которые обрабатываются параллельно, Java
использует Spliterator и его метод trySplit(). Этот метод разделяет данные на
подзадачи, которые затем могут быть распределены между несколькими потоками.
Каждая часть обрабатывается независимо, и результаты объединяются после
завершения работы всех потоков.<br>

ForkJoinPool<br>
Java использует ForkJoinPool для распределения задач параллельных потоков. Это
общий пул потоков, где задачи разбиваются на более мелкие фрагменты и
распределяются между потоками. Такой же подход применяется и в
CompletableFuture. При необходимости можно указать свой пул потоков, если
текущий пул перегружен или необходимо изменить его поведение.

> ## JAVA CORE. <br>  Garbage Collector. GCRoot

В Java, GC Root (или корень сборщика мусора) — это объект, который является
начальной точкой для процесса сборки мусора (Garbage Collection, GC). Сборщик
мусора использует корни для определения, какие объекты в памяти все еще доступны
и могут быть использованы, а какие объекты больше не нужны и могут быть удалены.

Что такое GC Root?<br>
GC Root — это набор объектов, которые всегда доступны и служат отправной точкой
для поиска всех достижимых объектов в памяти. Если объект не может быть
достигнут из любого из корней, он считается "мусором" и может быть удален
сборщиком мусора.

Примеры GC Root<br>
Вот несколько примеров объектов, которые считаются GC Root:<br>

- Статические поля:<br>
  Объекты, на которые ссылаются статические поля классов. Например, если у вас
  есть статическое поле в классе, которое ссылается на объект, этот объект будет
  являться корнем.
- Активные потоки:<br>
  Объекты, связанные с активными потоками (например, текущий поток выполнения).
- Объекты в локальных переменных:<br>
  Объекты, на которые ссылаются локальные переменные методов. Пока метод
  выполняется и локальные переменные находятся в стеке вызовов, эти объекты
  считаются достижимыми.
- JNI ссылки:<br>
  Объекты, на которые ссылаются нативные методы через Java Native Interface (
  JNI).
- Объекты класса java.lang.Runtime:<br>
  Объект Runtime, который предоставляет информацию о среде выполнения Java.

Как работает сборка мусора?<br>
Сборщик мусора использует алгоритмы для определения достижимости объектов:

1. Начинает с GC Roots: Сборщик начинает с объектов GC Root и проходит по всем
   ссылкам от этих объектов.
2. Обходит граф объектов: Он рекурсивно проверяет все объекты, на которые
   ссылаются корни.
3. Определяет недостижимые объекты: Все объекты, которые не могут быть
   достигнуты из корней, помечаются как "мусор" и подлежат удалению.

Важность GC Root<br>
Понимание концепции GC Root важно для оптимизации работы приложения и управления
памятью:<br>

1. Помогает разработчикам избегать утечек памяти.
2. Позволяет лучше понимать поведение сборщика мусора.
3. Способствует более эффективному управлению ресурсами в приложениях.

Как пометить объект "живым"<br>
В Java объекты помечаются как "живые" (или "достижимые") в контексте сборки
мусора (Garbage Collection) на основе ссылок на них. Если объект доступен через
одну или несколько ссылок, он считается живым и не может быть удален сборщиком
мусора. Вот несколько способов, как можно пометить объект как живой:

1. Создание ссылок на объект<br>
   Чтобы объект считался живым, необходимо создать хотя бы одну ссылку на него.
   Например:

```java
class MyObject {
// Поля и методы
}

public class Main {
    public static void main(String[] args) {
        MyObject obj = new MyObject(); // Создаем объект и сохраняем ссылку на него
// Объект obj считается "живым", пока существует ссылка на него
    }
}
```

В этом примере obj является ссылкой на экземпляр MyObject, и пока эта ссылка
существует, объект будет считаться живым.

2. Использование коллекций<br>
   Объекты могут быть помечены как живые, если они хранятся в коллекциях, таких
   как списки, множества или карты:

```java
import java.util.ArrayList;
import java.util.List;

class MyObject {
    // Поля и методы
}

public class Main {
    public static void main(String[] args) {
        List<MyObject> list = new ArrayList<>();
        MyObject obj = new MyObject();
        list.add(obj); // Объект obj теперь считается "живым", так как он хранится в списке
    }
}
```

3. Статические поля<br>
   Если объект хранится в статическом поле класса, он также будет считаться
   живым:

```java
class MyClass {
    static MyObject staticObj = new MyObject(); // Статическое поле хранит ссылку на объект
}

public class Main {
    public static void main(String[] args) {
        // Объект staticObj считается "живым" благодаря статической ссылке
    }
}
```

4. Передача объектов в методы<br>
   Когда вы передаете объект в метод, он также считается живым, пока метод
   выполняется:

```java
class MyObject {
    // Поля и методы
}

public class Main {
    public static void process(MyObject obj) {
        // Объект obj считается "живым" внутри этого метода
    }

    public static void main(String[] args) {
        MyObject myObj = new MyObject();
        process(myObj); // Передаем объект в метод
    }
}

```

5. Использование внешних библиотек или фреймворков
   Некоторые фреймворки и библиотеки могут управлять жизненным циклом объектов и
   поддерживать ссылки на них для обеспечения их доступности.

Заключение<br>
Объекты в Java считаются "живыми", если на них существуют ссылки из других
объектов или переменных. Чтобы пометить объект как живой, достаточно создать
хотя бы одну ссылку на него — это может быть локальная переменная, элемент
коллекции или статическое поле класса. Как только все ссылки на объект будут
удалены (например, переменные выйдут из области видимости или будут присвоены
null), объект станет недостижимым и может быть удален сборщиком мусора.

GC Root — это ключевая концепция в управлении памятью Java и сборке мусора. Она
определяет начальные точки для поиска достижимых объектов и помогает сборщику
мусора эффективно освобождать память от ненужных объектов.
