
>## JAVA CORE. <br><br>Multitrading. <br>  ExecutorService

`ExecutorService` в Java — это интерфейс, который является частью пакета
`java.util.concurrent` и предоставляет высокоуровневый механизм для управления
потоками. Он позволяет выполнять асинхронные задачи, управлять пулом потоков и
упрощает работу с многопоточностью.

### Основные характеристики `ExecutorService`:

1. **Управление потоками**: `ExecutorService` управляет пулом потоков, что
   позволяет повторно использовать потоки для выполнения задач, тем самым
   уменьшая накладные расходы на создание и уничтожение потоков.

2. **Асинхронное выполнение**: Вы можете отправлять задачи на выполнение и
   продолжать выполнять другие операции, не дожидаясь завершения этих задач.

3. **Разные типы задач**: Вы можете отправлять как `Runnable`, так и `Callable`
   задачи. `Callable` позволяет возвращать результат и обрабатывать исключения.

4. **Управление жизненным циклом**: `ExecutorService` предоставляет методы для
   управления жизненным циклом пула потоков, такие как `shutdown()` и
   `shutdownNow()`, которые позволяют корректно завершить выполнение задач.

5. **Фабрики для создания экземпляров**: Для создания экземпляров
   `ExecutorService` обычно используются статические методы класса `Executors`,
   такие как:
    - `Executors.newFixedThreadPool(int nThreads)`: создает пул фиксированного
      размера.
    - `Executors.newCachedThreadPool()`: создает пул, который создает новые
      потоки по мере необходимости, но повторно использует ранее созданные
      потоки.
    - `Executors.newSingleThreadExecutor()`: создает пул с одним потоком.

### Пример использования:

Вот простой пример использования `ExecutorService`:

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        // Создаем ExecutorService с фиксированным количеством потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Отправляем задачи на выполнение
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " is running in "
                        + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000); // Имитация работы
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }

        // Завершаем ExecutorService
        executor.shutdown();
    }
}
```

В этом примере создается пул из трех потоков, и в него отправляются пять задач.
Каждая задача выполняется в одном из доступных потоков пула.



### Что такое задачи?

В контексте `ExecutorService` и многопоточности в Java, под "задачей"
подразумевается единица работы, которую необходимо выполнить. Задачи могут быть
представлены в виде объектов, реализующих интерфейсы `Runnable` или `Callable`.

### Основные характеристики задач:

1. **Единица работы**: Задача — это конкретная работа или операция, которую
   нужно выполнить. Это может быть что угодно: от простого вычисления до сложной
   обработки данных.

2. **Асинхронность**: Задачи могут выполняться асинхронно, что позволяет
   основному потоку продолжать выполнение других операций, не дожидаясь
   завершения задачи.

3. **Возврат результата**:
    - **Runnable**: Задачи, реализующие интерфейс `Runnable`, не возвращают
      результат. Метод `run()` этого интерфейса имеет тип `void`.
    - **Callable**: Задачи, реализующие интерфейс `Callable`, могут возвращать
      результат и могут выбрасывать проверяемые исключения. Метод `call()` этого
      интерфейса возвращает значение.

4. **Управление состоянием**: Каждая задача может находиться в одном из
   нескольких состояний (например, ожидает выполнения, выполняется или
   завершена). Это состояние можно отслеживать с помощью объекта типа `Future`,
   который возвращается при отправке задачи на выполнение.

### Примеры задач

Вот несколько примеров задач:

- **Вычислительные задачи**: Например, задача по вычислению факториала числа или
  сложению чисел в массиве.
- **Задачи ввода-вывода**: Чтение данных из файла или отправка HTTP-запроса.
- **Обработка данных**: Например, фильтрация списка объектов или преобразование
  данных.

### Пример использования задач

Вот пример создания и выполнения задач с использованием интерфейсов `Runnable` и
`Callable`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class TaskExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Задача Runnable
        Runnable runnableTask = () -> {
            System.out.println("Выполнение задачи Runnable");
        };

        // Задача Callable
        Callable<Integer> callableTask = () -> {
            System.out.println("Выполнение задачи Callable");
            return 42; // Возвращаем результат
        };

        // Отправляем задачи на выполнение
        executor.submit(runnableTask); // Для Runnable
        Future<Integer> future = executor.submit(callableTask); // Для Callable

        try {
            // Получаем результат выполнения задачи Callable
            Integer result = future.get();
            System.out.println("Результат задачи Callable: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задач**:
    - Мы определяем задачу типа `Runnable`, которая просто выводит сообщение.
    - Мы также определяем задачу типа `Callable`, которая выводит сообщение и
      возвращает значение 42.

3. **Отправка задач на выполнение**: Мы отправляем обе задачи на выполнение
   через метод `submit()`. Для задачи типа `Runnable` мы просто вызываем метод
   без ожидания результата, а для задачи типа `Callable` мы получаем объект типа
   `Future`.

4. **Получение результата**: Мы используем метод `get()` объекта `Future`, чтобы
   получить результат выполнения задачи типа `Callable`.

5. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

#### Заключение

Таким образом, под "задачей" в контексте многопоточности и использования
`ExecutorService` понимается конкретная работа или операция, которую необходимо
выполнить асинхронно. Задачи могут быть реализованы через интерфейсы `Runnable`
и `Callable`, что позволяет гибко управлять выполнением кода в многопоточной
среде.


### Асинхронные задачи

**Асинхронные задачи** — это задачи, которые выполняются независимо от основного
потока выполнения программы. Это означает, что основной поток может продолжать
свою работу, не дожидаясь завершения асинхронной задачи. Асинхронное выполнение
позволяет улучшить отзывчивость приложений, особенно в тех случаях, когда
требуется выполнение длительных операций, таких как сетевые запросы, операции
ввода-вывода или сложные вычисления.

#### Основные характеристики асинхронных задач:

1. **Независимость**: Асинхронные задачи могут выполняться в фоновом режиме,
   позволяя основному потоку продолжать выполнение других операций. Это особенно
   полезно в пользовательских интерфейсах, где блокировка основного потока может
   привести к зависанию приложения.

2. **Обработка результатов**: После завершения асинхронной задачи можно
   обработать результаты выполнения. В Java для этого часто используются объекты
   `Future` и `Callable`, которые позволяют получить результат выполнения задачи
   или обработать исключения.

3. **Параллелизм**: Асинхронные задачи могут выполняться параллельно с другими
   задачами, что позволяет более эффективно использовать ресурсы системы и
   сокращать общее время выполнения.

4. **Управление временем ожидания**: Асинхронные задачи могут быть настроены на
   выполнение с тайм-аутами или отменой, что позволяет избежать зависания
   приложения при выполнении долгих операций.

#### Примеры использования асинхронных задач:

1. **Сетевые запросы**: При выполнении HTTP-запросов к удаленному серверу можно
   использовать асинхронные задачи для того, чтобы не блокировать основной поток
   приложения во время ожидания ответа.

2. **Долгие вычисления**: Если приложение выполняет сложные вычисления (
   например, обработка больших объемов данных), эти операции можно вынести в
   асинхронные задачи, чтобы основной поток оставался отзывчивым.

3. **Работа с файлами**: Чтение и запись файлов может занять значительное время;
   использование асинхронных задач позволяет избежать блокировки
   пользовательского интерфейса во время этих операций.

#### Пример в Java:

Вот пример использования асинхронной задачи с помощью `ExecutorService` и
`Callable`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class AsyncTaskExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // Создаем асинхронную задачу
        Callable<Integer> task = () -> {
            Thread.sleep(2000); // Имитация долгой работы
            return 42; // Возвращаем результат
        };

        Future<Integer> future = executor.submit(task);

        // Основной поток продолжает выполнять другие операции
        System.out.println("Основной поток продолжает работу...");

        try {
            // Получаем результат выполнения асинхронной задачи
            Integer result = future.get(); // Это блокирует поток до получения результата
            System.out.println("Результат асинхронной задачи: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

В этом примере создается асинхронная задача, которая имитирует длительную
работу (с помощью `Thread.sleep`). Основной поток продолжает выполнение и
выводит сообщение на экран. После этого он ожидает завершения асинхронной задачи
и получает результат.

#### Заключение

Асинхронные задачи являются важным инструментом для разработки отзывчивых и
эффективных приложений. Они позволяют выполнять длительные операции без
блокировки основного потока выполнения и обеспечивают более плавный
пользовательский опыт.


### Callable

`Callable` — это функциональный интерфейс в Java, представляющий собой
задачу, которая может быть выполнена асинхронно и возвращает результат. Он
является частью пакета `java.util.concurrent` и часто используется в сочетании с
`ExecutorService` для выполнения задач в фоновом режиме.

#### Основные характеристики `Callable`:

1. **Возврат результата**: В отличие от интерфейса `Runnable`, который не
   возвращает результат (метод `run()` имеет тип `void`), метод `call()`
   интерфейса `Callable` возвращает значение. Это позволяет получать результат
   выполнения задачи.

2. **Обработка исключений**: Метод `call()` может выбрасывать проверяемые
   исключения (checked exceptions), что позволяет обрабатывать ошибки,
   возникающие во время выполнения задачи. В случае с `Runnable`, все исключения
   должны обрабатываться внутри метода `run()`.

3. **Использование с `Future`**: Когда задача, реализующая интерфейс `Callable`,
   отправляется на выполнение через `ExecutorService`, она возвращает объект
   типа `Future`. Этот объект позволяет проверять статус выполнения задачи и
   получать результат после ее завершения.

#### Синтаксис

Интерфейс `Callable` имеет следующий синтаксис:

```java

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

Где `<V>` — это тип результата, который будет возвращен методом `call()`.

#### Пример использования

Вот пример использования интерфейса `Callable` вместе с `ExecutorService`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Создаем задачу, реализующую Callable
        Callable<Integer> task = () -> {
            // Имитация длительной работы
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует поток до получения результата
            System.out.println("Результат асинхронной задачи: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу, реализующую интерфейс
   `Callable`, которая имитирует длительную работу (с помощью метода
   `Thread.sleep`) и возвращает значение 42.

3. **Отправка задачи на выполнение**: Задача отправляется на выполнение через
   метод `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы используем метод `get()` объекта `Future`, чтобы
   получить результат выполнения задачи. Этот метод блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения, которые могут
   возникнуть при выполнении задачи или при получении результата.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

#### Заключение

Интерфейс `Callable` является мощным инструментом для создания асинхронных задач
в Java, позволяя разработчикам выполнять фоновые операции и получать результаты
их выполнения. Он обеспечивает более гибкий подход по сравнению с интерфейсом
`Runnable`, особенно когда требуется обработка результатов или исключений.


### Задачи и потоки

Задачи и потоки в контексте многопоточности в Java тесно связаны между собой,
поскольку задачи представляют собой единицы работы, которые выполняются в
потоках. Давайте рассмотрим, как именно они связаны:

#### 1. **Определение потоков и задач**

- **Поток**: Поток — это отдельная последовательность выполнения в программе.
  Каждый поток имеет свой собственный стек вызовов и может выполняться
  параллельно с другими потоками. В Java потоки создаются с помощью класса
  `Thread` или через интерфейсы, такие как `Runnable` и `Callable`.

- **Задача**: Задача — это конкретная работа или операция, которую нужно
  выполнить. В Java задачи могут быть реализованы через интерфейсы `Runnable` (
  для задач без результата) и `Callable` (для задач с результатом).

#### 2. **Выполнение задач в потоках**

Когда вы отправляете задачу на выполнение в `ExecutorService`, она будет
выполнена в одном из потоков пула потоков. Вот как это работает:

- **Создание пула потоков**: При создании экземпляра `ExecutorService`, вы
  определяете пул потоков, который будет использоваться для выполнения задач.
  Например, с помощью метода `Executors.newFixedThreadPool(n)` создается пул из
  `n` потоков.

- **Отправка задач**: Когда вы отправляете задачу на выполнение (например, через
  метод `submit()`), `ExecutorService` выбирает один из доступных потоков из
  пула для выполнения этой задачи.

- **Асинхронное выполнение**: Задачи могут выполняться асинхронно, что означает,
  что основной поток программы может продолжать выполнение других операций, не
  дожидаясь завершения задачи.

#### 3. **Параллелизм и многопоточность**

Использование задач и потоков позволяет реализовать параллелизм:

- **Параллельное выполнение**: Если у вас есть несколько задач, которые могут
  выполняться одновременно (например, обработка данных или выполнение сетевых
  запросов), вы можете отправить их на выполнение в пул потоков. Пул будет
  распределять задачи между доступными потоками, что позволяет выполнять их
  параллельно.

- **Управление ресурсами**: Пулы потоков помогают управлять ресурсами более
  эффективно. Вместо создания нового потока для каждой задачи (что может быть
  затратным по времени и ресурсам), вы можете повторно использовать существующие
  потоки для выполнения новых задач.

#### 4. **Пример связи задач и потоков**

Вот пример кода, который демонстрирует связь между задачами и потоками:

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class TaskAndThreadExample {
    public static void main(String[] args) {
        // Создаем пул из 3 потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Определяем несколько задач
        Runnable task1 = () -> {
            System.out.println("Задача 1 выполняется в потоке: " + Thread.currentThread().getName());
        };

        Runnable task2 = () -> {
            System.out.println("Задача 2 выполняется в потоке: " + Thread.currentThread().getName());
        };

        Runnable task3 = () -> {
            System.out.println("Задача 3 выполняется в потоке: " + Thread.currentThread().getName());
        };

        // Отправляем задачи на выполнение
        executor.submit(task1);
        executor.submit(task2);
        executor.submit(task3);

        // Завершаем работу пула
        executor.shutdown();
    }
}
```

#### Объяснение примера:

1. **Создание пула**: Мы создаем пул из трех потоков.

2. **Определение задач**: Мы определяем три задачи типа `Runnable`, выводящих
   имя потока, в котором она выполняется.

3. **Отправка задач**: Мы отправляем все три задачи на выполнение через метод
   `submit()`. Пул распределяет эти задачи между доступными потоками.

4. **Вывод информации о потоке**: Каждая задача выводит имя потока, который ее
   выполняет. Это демонстрирует, что одна и та же задача может выполняться в
   разных потоках.

5. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула.

#### Заключение

Таким образом, задачи и потоки являются основными компонентами многопоточного
программирования в Java. Задачи представляют собой единицы работы, которые
необходимо выполнить, а потоки — это механизмы выполнения этих задач.
Использование пула потоков позволяет эффективно управлять выполнением множества
задач одновременно, обеспечивая параллелизм и оптимизацию использования ресурсов
системы.


#### Future

Объект `Future`, возвращаемый интерфейсом `Callable` в Java, представляет собой
результат асинхронной операции. Он предоставляет методы для проверки состояния
выполнения задачи, получения результата и обработки возможных исключений,
которые могут возникнуть во время выполнения задачи. Давайте рассмотрим основные
аспекты объекта `Future` более подробно.

#### Основные характеристики объекта `Future`

1. **Асинхронный результат**: Объект `Future` позволяет вам получить результат
   выполнения задачи, которая была отправлена на выполнение в пул потоков или
   другой механизм многопоточности. Поскольку задача выполняется асинхронно, вы
   можете продолжать выполнение других операций в основном потоке, не дожидаясь
   завершения задачи.

2. **Методы для управления состоянием**:
    - `isDone()`: Возвращает `true`, если задача завершена (независимо от того,
      была ли она выполнена успешно или завершилась с ошибкой).
    - `isCancelled()`: Возвращает `true`, если задача была отменена до ее
      завершения.
    - `cancel(boolean mayInterruptIfRunning)`: Пытается отменить выполнение
      задачи. Если задача уже выполняется и параметр `mayInterruptIfRunning`
      равен `true`, то выполнение задачи может быть прервано.

3. **Получение результата**:
    - `get()`: Блокирует текущий поток до тех пор, пока задача не завершится, и
      возвращает результат выполнения задачи. Если задача завершилась с
      исключением, метод `get()` выбросит это исключение.
    - `get(long timeout, TimeUnit unit)`: Блокирует текущий поток до тех пор,
      пока задача не завершится или не истечет указанный таймаут.

#### Пример использования объекта Future

Вот пример кода, который демонстрирует использование интерфейса `Callable` и
объекта `Future`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Определяем задачу Callable
        Callable<Integer> task = () -> {
            // Имитация длительной операции
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует текущий поток до получения результата
            System.out.println("Результат: " + result);
        } catch (InterruptedException e) {
            System.err.println("Задача была прервана");
        } catch (ExecutionException e) {
            System.err.println("Ошибка при выполнении задачи: " + e.getCause());
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу типа `Callable`, которая
   имитирует длительную операцию (например, задержку на 2 секунды) и возвращает
   значение 42.

3. **Отправка задачи**: Мы отправляем задачу на выполнение через метод
   `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы вызываем метод `get()` у объекта `Future`, чтобы
   получить результат выполнения задачи. Этот вызов блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения:
    - `InterruptedException`: Выбрасывается, если текущий поток был прерван во
      время ожидания результата.
    - `ExecutionException`: Выбрасывается, если задача завершилась с ошибкой; в
      этом случае мы можем получить причину ошибки через метод `getCause()`.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

#### Заключение

Объект `Future` является важным компонентом многопоточного программирования в
Java, позволяя управлять асинхронными задачами и получать результаты их
выполнения. Он предоставляет удобные методы для проверки состояния задач и
обработки результатов или ошибок, что делает его полезным инструментом для
работы с параллельными вычислениями.

#### Реализации Executor Service

ExecutorService – это интерфейс Java, который предоставляет удобный способ
управления потоками исполнения. Он позволяет создавать пул потоков исполнения и
выполнять задачи в этих потоках.

Существует несколько ключевых реализаций ExecutorService:

ThreadPoolExecutor
ScheduledThreadPoolExecutor
CachedThreadPoolExecutor
ForkJoinPool

#### **ThreadPoolExecutor**

ThreadPoolExecutor – это реализация интерфейса ExecutorService в Java, который
предоставляет пул потоков исполнения для выполнения задач в фоновом режиме.

ThreadPoolExecutor позволяет создать и настроить пул потоков исполнения с
определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения задач в фоновом режиме, что может улучшить
производительность и реактивность вашего приложения.

#### **ScheduledThreadPoolExecutor**

ScheduledThreadPoolExecutor – это реализация интерфейса ScheduledExecutorService
в Java, который предоставляет пул потоков исполнения для выполнения задач в
определенный момент времени или с определенной периодичностью.

ScheduledThreadPoolExecutor позволяет создать и настроить пул потоков исполнения
с определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения регулярных задач в фоновом режиме, что может
улучшить производительность и реактивность вашего приложения.

#### **CachedThreadPoolExecutor**

CachedThreadPoolExecutor – это реализация интерфейса ExecutorService в Java,
который предоставляет пул потоков исполнения для выполнения задач в фоновом
режиме.

CachedThreadPoolExecutor автоматически масштабирует количество потоков
исполнения в зависимости от количества задач, которые нужно выполнить. Если
задачи поступают слишком быстро и текущее количество потоков исполнения не может
справиться с ними, CachedThreadPoolExecutor создает новый поток исполнения,
чтобы обеспечить выполнение задачи. Если задачи не поступают достаточно быстро и
текущее количество потоков исполнения избыточно, CachedThreadPoolExecutor
автоматически удаляет потоки исполнения, чтобы уменьшить нагрузку на систему.

#### **ForkJoinPool**

ForkJoinPool – это реализация ExecutorService в Java, которая используется для
параллельного выполнения задач. Эти задачи могут быть разбиты на более мелкие
подзадачи. Она позволяет использовать принцип “разделяй и властвуй” для более
эффективного использования многопроцессорных и многопоточных систем.

_**Основные компоненты ForkJoinPool:**_

**Пул потоков исполнения**

ForkJoinPool управляет пулом потоков исполнения, которые используются для
выполнения задач. Количество потоков исполнения в пуле задается при создании
экземпляра ForkJoinPool. Каждый поток в пуле имеет свой собственный стек
вызовов, что позволяет ForkJoinPool улучшить производительность в случае, когда
задачи могут быть разбиты на более мелкие подзадачи.

**Разбиение и объединение задач:**

ForkJoinPool поддерживает работу с задачами типа RecursiveAction и
RecursiveTask, которые представляют собой рекурсивно делимые задачи без
возвращаемого значения и с возвращаемым значением соответственно. Когда
ForkJoinPool получает задачу типа RecursiveTask, он разбивает ее на более мелкие
подзадачи, выполняет их параллельно в разных потоках и объединяет результаты
выполнения в единую итоговую задачу.


> ## JAVA CORE. <br><br> Multitrading. <br> Atomic пакет Механизм под капотом (CAS)

В Java термин "atomic" (атомарный) относится к операциям, которые выполняются
как единое целое, без возможности прерывания. Это означает, что такие операции
являются неделимыми: они либо полностью выполняются, либо не выполняются вовсе.
Атомарные операции важны в контексте многопоточности, поскольку они помогают
избежать проблем с синхронизацией и состоянием гонки.

### Основные аспекты атомарности в Java

1. **Атомарные операции**: Атомарные операции гарантируют, что данные не будут
   изменены другими потоками во время выполнения операции. Например, если один
   поток обновляет значение переменной, другой поток не сможет увидеть
   промежуточное состояние этой переменной.

2. **Классы из пакета `java.util.concurrent.atomic`**: Java предоставляет
   несколько классов для работы с атомарными переменными в пакете
   `java.util.concurrent.atomic`. Эти классы обеспечивают атомарные операции над
   примитивными типами данных и объектами. Вот некоторые из них:
    - `AtomicInteger`: Атомарная целочисленная переменная.
    - `AtomicLong`: Атомарная переменная типа `long`.
    - `AtomicBoolean`: Атомарная булева переменная.
    - `AtomicReference<T>`: Атомарная ссылка на объект типа `T`.
    - `AtomicStampedReference<V>`: Атомарная ссылка на объект с меткой (
      стампом), что позволяет избежать проблем с состоянием гонки при обновлении
      ссылок.

3. **Методы атомарных классов**: Классы из пакета `java.util.concurrent.atomic`
   предоставляют методы для выполнения атомарных операций, такие как:
    - `get()`: Получает текущее значение.
    - `set(value)`: Устанавливает новое значение.
    - `incrementAndGet()`: Увеличивает текущее значение на 1 и возвращает новое
      значение.
    - `compareAndSet(expectedValue, newValue)`: Сравнивает текущее значение с
      ожидаемым значением и устанавливает новое значение, если они равны.

### Пример использования атомарных переменных

Вот пример кода, который демонстрирует использование класса `AtomicInteger`:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    public static void main(String[] args) {
        AtomicInteger atomicCounter = new AtomicInteger(0);

        // Создаем несколько потоков для увеличения счетчика
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                atomicCounter.incrementAndGet(); // Атомарное увеличение
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                atomicCounter.incrementAndGet(); // Атомарное увеличение
            }
        });

        // Запускаем потоки
        thread1.start();
        thread2.start();

        // Ждем завершения потоков
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Выводим итоговое значение счетчика
        System.out.println("Итоговое значение счетчика: " + atomicCounter.get());
    }
}
```

### Объяснение примера:

1. **Создание атомарного счетчика**: Мы создаем экземпляр класса
   `AtomicInteger`, инициализируя его значением 0.

2. **Создание потоков**: Мы создаем два потока, каждый из которых увеличивает
   счетчик на 1000 раз с помощью метода `incrementAndGet()`, который выполняет
   атомарное увеличение.

3. **Запуск потоков**: Мы запускаем оба потока.

4. **Ожидание завершения потоков**: Мы используем метод `join()` для ожидания
   завершения обоих потоков.

5. **Вывод результата**: После завершения работы потоков мы выводим итоговое
   значение счетчика. Поскольку мы использовали атомарную переменную, итоговое
   значение будет равно 2000, независимо от порядка выполнения потоков.

### Заключение

Атомарные операции и классы в Java обеспечивают безопасный доступ к общим данным
в многопоточной среде без необходимости использования явной синхронизации (
например, через блокировки). Это делает код более простым и эффективным при
работе с конкурентными задачами. Однако важно помнить, что атомарность не
гарантирует полной безопасности при работе с более сложными структурами данных
или логикой — в таких случаях может потребоваться дополнительная синхронизация.

### CAS

В Java "CAS" (Compare-And-Swap) — это атомарная операция, которая используется
для реализации механизмов синхронизации и управления состоянием в многопоточной
среде. CAS позволяет безопасно обновлять значение переменной, проверяя, равно ли
текущее значение ожидаемому значению, и только в этом случае заменяя его на
новое значение. Это делает CAS полезным для реализации неблокирующих алгоритмов
и структур данных.

#### Как работает CAS

Операция CAS включает три параметра:

1. **Адрес переменной**: Адрес (или ссылка) на переменную, которую мы хотим
   обновить.
2. **Ожидаемое значение**: Значение, с которым мы сравниваем текущее значение
   переменной.
3. **Новое значение**: Значение, которое мы хотим установить, если текущее
   значение совпадает с ожидаемым.

Процесс работы CAS можно описать следующим образом:

1. Сравнить текущее значение переменной с ожидаемым значением.
2. Если они равны, обновить переменную новым значением.
3. Если они не равны, операция завершается без изменений.

#### Пример использования CAS в Java

Java предоставляет поддержку CAS через классы из пакета
`java.util.concurrent.atomic`, такие как `AtomicInteger`, `AtomicBoolean`,
`AtomicReference` и другие. Эти классы используют внутренние механизмы CAS для
выполнения атомарных операций.

Вот пример использования `AtomicInteger` с методом `compareAndSet()`:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCASExample {
    public static void main(String[] args) {
        AtomicInteger atomicCounter = new AtomicInteger(0);

        // Создаем несколько потоков для увеличения счетчика
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                int currentValue;
                do {
                    currentValue = atomicCounter.get();
                } while (!atomicCounter.compareAndSet(currentValue, currentValue + 1));
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                int currentValue;
                do {
                    currentValue = atomicCounter.get();
                } while (!atomicCounter.compareAndSet(currentValue, currentValue + 1));
            }
        });

        // Запускаем потоки
        thread1.start();
        thread2.start();

        // Ждем завершения потоков
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Выводим итоговое значение счетчика
        System.out.println("Итоговое значение счетчика: " + atomicCounter.get());
    }
}
```

#### Объяснение примера:

1. **Создание атомарного счетчика**: Мы создаем экземпляр класса
   `AtomicInteger`, инициализируя его значением 0.

2. **Создание потоков**: Мы создаем два потока, каждый из которых пытается
   увеличить счетчик на 1000 раз.

3. **Использование CAS**:
    - В каждом потоке мы используем цикл `do-while`, чтобы попытаться получить
      текущее значение счетчика.
    - Затем мы вызываем метод `compareAndSet(currentValue, currentValue + 1)`.
      Этот метод проверяет, равно ли текущее значение счетчика (
      `atomicCounter.get()`) ожидаемому значению (`currentValue`). Если да, то
      он устанавливает новое значение (`currentValue + 1`). Если нет — операция
      завершается без изменений, и цикл повторяется.

4. **Запуск потоков**: Мы запускаем оба потока.

5. **Ожидание завершения потоков**: Мы используем метод `join()` для ожидания
   завершения обоих потоков.

6. **Вывод результата**: После завершения работы потоков мы выводим итоговое
   значение счетчика. Поскольку мы использовали атомарную переменную с
   CAS-операцией, итоговое значение будет равно 2000.

### Преимущества и недостатки CAS

#### Преимущества:

- **Без блокировок**: CAS позволяет избежать использования блокировок (например,
  synchronized), что может улучшить производительность в многопоточных
  приложениях.
- **Простота реализации**: Многие алгоритмы могут быть реализованы проще с
  использованием CAS.

#### Недостатки:

- **Проблема "проверка-замена"**: Если несколько потоков одновременно пытаются
  обновить одно и то же значение, это может привести к частым неудачным попыткам
  обновления (потоки будут повторять операции), что может снизить
  производительность.
- **Необходимость повторных попыток**: В некоторых случаях может потребоваться
  много итераций для успешного выполнения операции из-за состояния гонки между
  потоками.

### Заключение

CAS является мощным инструментом для реализации неблокирующих алгоритмов и
структур данных в Java. Он позволяет безопасно обновлять значения переменных в
многопоточной среде без необходимости использования явных блокировок, что делает
код более эффективным и простым в понимании. Однако важно учитывать возможные
проблемы с производительностью при высокой конкуренции за ресурсы.
