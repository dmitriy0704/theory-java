
>## JAVA CORE. <br><br>Multitrading. <br>  ExecutorService



`ExecutorService` в Java — это интерфейс из пакета `java.util.concurrent`,
который представляет собой фреймворк для управления многопоточностью. Он
позволяет выполнять задачи асинхронно, управлять пулом потоков, и упрощает
работу с многопоточностью по сравнению с использованием `Thread` напрямую.

### Основные особенности `ExecutorService`:


1. **Управление потоками**: `ExecutorService` позволяет вам управлять пулом
   потоков, что означает, что вы можете повторно использовать потоки для
   выполнения нескольких задач, вместо создания нового потока для каждой задачи.
   Это значительно снижает накладные расходы на создание и уничтожение потоков.

2. **Асинхронное выполнение**: Вы можете отправлять задачи на выполнение и
   продолжать выполнять другие операции, не дожидаясь завершения этих задач.

3. **Планирование задач**: `ExecutorService` поддерживает планирование задач с
   использованием методов, таких как `schedule()` (в классе
   `ScheduledExecutorService`), что позволяет выполнять задачи через
   определенные интервалы времени или с задержкой.
4. **Разные типы задач**: Вы можете отправлять как `Runnable`, так и `Callable`
   задачи. `Callable` позволяет возвращать результат и обрабатывать исключения.

5. **Управление жизненным циклом**: `ExecutorService` предоставляет методы для
   управления жизненным циклом пула потоков, такие как `shutdown()` и
   `shutdownNow()`, которые позволяют корректно завершить выполнение задач.

4. **Фабрики для создания экземпляров**: Для создания экземпляров
   `ExecutorService` обычно используются статические методы класса `Executors`,
   такие как:
   - `Executors.newFixedThreadPool(int nThreads)`: создает пул фиксированного
     размера.
   - `Executors.newCachedThreadPool()`: создает пул, который создает новые
     потоки по мере необходимости, но повторно использует ранее созданные
     потоки.
   - `Executors.newSingleThreadExecutor()`: создает пул с одним потоком.



### Пример использования:

```java
import java.util.concurrent.*;

public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        Runnable task = () -> {
            System.out.println("Выполняется задача: " +
                    Thread.currentThread().getName());
        };

        for (int i = 0; i < 5; i++) {
            executor.submit(task);
        }

        executor.shutdown(); // корректное завершение работы
    }
}
```

### Ключевые методы:

- `submit()` - Отправляет `Runnable` или `Callable` на выполнение. Возвращает
  `Future`.
- `shutdown()` - Останавливает приём новых задач, завершает текущие.
- `shutdownNow()` - Пытается остановить все задачи и возвращает список
  непринятых.
- `invokeAll()` - Принимает список `Callable` и возвращает список `Future`
- `invokeAny()` - Выполняет несколько задач, возвращает результат самой
  быстрой.

### Разновидности пула:

`Executors` предоставляет фабрики для создания различных реализаций
`ExecutorService`:

- `Executors.newFixedThreadPool(int n)` - фиксированное количество потоков
- `Executors.newCachedThreadPool()` - новый поток при необходимости, повторное
  использование
- `Executors.newSingleThreadExecutor()` - один поток, задачи выполняются по
  очереди

### Преимущества:

- Повышение производительности за счёт повторного использования потоков.
- Централизованное управление многопоточностью.
- Упрощение кода и снижение ошибок, связанных с ручным управлением потоками.

---

## Runnable и Callable

| Особенность                | `Runnable`                          | `Callable<V>`                                 |
|----------------------------|-------------------------------------|-----------------------------------------------|
| Возвращает результат       | нет                                 | да (оборачивается в `Future<V>`)              |
| Может выбросить исключение | нет (только через try/catch внутри) | да (может выбрасывать проверяемые исключения) |
| Использование              | `executor.submit(Runnable)`         | `executor.submit(Callable)`                   |

**Пример `Runnable`:**

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        Runnable task = () -> System.out.println("Runnable task");
        executor.submit(task);
    }
}
```

**Пример `Callable`:**

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        Callable<Integer> task = () -> {
            Thread.sleep(1000);
            return 42;
        };
        Future<Integer> future = executor.submit(task);
    }
}
```

___

## Future

`Future<V>` — это объект, который представляет результат асинхронной операции. С
его помощью можно:

- Получить результат задачи.
- Проверить, завершена ли она.
- Отменить её выполнение.

### Пример работы с `Future`:

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        Callable<String> task = () -> {
            Thread.sleep(2000);
            return "Готово!";
        };

        Future<String> future = executor.submit(task);
        // Можно делать что-то другое пока задача выполняется...

        if (!future.isDone()) {
            System.out.println("Задача еще выполняется...");
        }

        String result = future.get(); // блокирует поток до завершения 
        // блокирует вызывающий поток, пока результат не будет готов.
        System.out.println("Результат: " + result);
    }
}

```

### Почему `ExecutorService` лучше, чем `Thread`?

| Функция / Особенность      | `Thread` вручную        | `ExecutorService`                         |
|----------------------------|-------------------------|-------------------------------------------|
| Масштабируемость           | ручное управление       | пулы потоков, динамическое распределение  |
| Повторное использование    | каждый поток — новый    | потоки переиспользуются                   |
| Управление задачами        | нет возврата результата | через `Future`, отмена задач              |
| Исключения                 | сложно обрабатывать     | логируются/обрабатываются через `Future`  |
| Контроль завершения работы | нет                     | `shutdown()`, `awaitTermination()` и т.д. |

--- 

## Задачи

В контексте `ExecutorService` (и вообще многопоточности в
Java), **"задача"** — это **единица работы**, которую мы хотим выполнить в
отдельном потоке.

В Java задача — это объект, реализующий один из интерфейсов:

- `Runnable` — если задача **не возвращает результат**
- `Callable<T>` — если задача **возвращает результат** и может выбрасывать
  исключения

Можно представить задачу как команду: "Сделай что-то". И `ExecutorService` —
это менеджер, который принимает такие команды и раздаёт их доступным
работникам (потокам из пула).

**Пример задачи с `Runnable`:**

```java
Runnable task = () -> System.out.println("Печать отчета...");
```

Эта задача просто что-то делает — побочный эффект, но **ничего не возвращает**.

**Пример задачи с `Callable`:**

```java
Callable<Integer> task = () -> {
    int result = 2 + 2;
    return result;
};
```

Эта задача **возвращает значение** — можно получить результат через
`Future<Integer>`.

_**Аналогия**:_

Представь офис:

- `ExecutorService` — это менеджер
- Потоки — это сотрудники
- Задачи — это поручения, которые ты даёшь этим сотрудникам
- `Future` — это бумажка, на которой сотрудник потом напишет результат твоей
  задачи

Ты кидаешь задачи в корзину (`submit()`), сотрудники их берут, делают и отдают
результат на бумажке (`Future.get()`).

_**Реальный пример с задачей, которая:**_

1. Делает какое-то вычисление (например, считает сумму чисел от 1 до N)
2. Возвращает результат
3. Используется через `Callable`
4. Обрабатывается через `Future`

Код:

```java
import java.util.concurrent.*;

public class TaskExample {
    public static void main(String[] args) {
        // 1. Создаём пул потоков
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // 2. Создаём задачу
        Callable<Integer> task = () -> {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
                Thread.sleep(10); // имитируем задержку
            }
            return sum;
        };

        // 3. Отправляем задачу в ExecutorService
        Future<Integer> future = executor.submit(task);

        // 4. Делаем что-то параллельно (для примера)
        System.out.println("Задача запущена. Выполняем другие действия...");

        try {
            // 5. Получаем результат (блокирует поток, пока не готово)
            Integer result = future.get();
            System.out.println("Результат вычислений: " + result);
        } catch (InterruptedException | ExecutionException e) {
            System.out.println("Произошла ошибка при выполнении задачи: " + e.getMessage());
        }

        // 6. Завершаем работу ExecutorService
        executor.shutdown();
    }
}
```

Что происходит шаг за шагом:

1. Мы создаём пул из одного потока (можно больше).
2. Описываем задачу — простое сложение чисел с задержкой.
3. Передаём задачу на выполнение.
4. Пока задача выполняется — основной поток может делать что-то ещё.
5. Получаем результат с помощью `future.get()`.
6. Завершаем работу пула.

### _**Параллельный запуск нескольких задач**_

_**InvokeAll():**_

Пример:

Запускаем **несколько задач параллельно**<br>
Каждая считает сумму от 1 до своего числа N<br>
Собираем **все результаты**<br>
Используем `ExecutorService` и `List<Future>`

_**Пример: несколько задач параллельно**_

```java
import java.util.concurrent.*;
import java.util.*;

public class MultiTaskExample {
    public static void main(String[] args) throws InterruptedException {
        // 1. Пул из 3 потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // 2. Список задач (Callable)
        List<Callable<Integer>> tasks = new ArrayList<>();
        for (int n : List.of(100, 200, 300)) {
            tasks.add(() -> {
                int sum = 0;
                for (int i = 1; i <= n; i++) {
                    sum += i;
                    Thread.sleep(5); // имитируем задержку
                }
                System.out.println("Задача для " + n + " завершена");
                return sum;
            });
        }

        // 3. Отправляем все задачи и получаем список Future
        List<Future<Integer>> results = executor.invokeAll(tasks);

        // 4. Обрабатываем результаты
        for (Future<Integer> future : results) {
            try {
                Integer result = future.get();
                System.out.println("Результат: " + result);
            } catch (ExecutionException e) {
                System.out.println("Ошибка в задаче: " + e.getMessage());
            }
        }

        // 5. Завершаем Executor
        executor.shutdown();


        // -> Задача для 100 завершена
        // Задача для 200 завершена
        // Задача для 300 завершена
        // Результат: 5050
        // Результат: 20100
        // Результат: 45150
    }
}
```

_**Что делает `invokeAll()`?**_

- Принимает список задач (`List<Callable<T>>`)
- Запускает их параллельно
- Возвращает список `Future<T>` — по одному на каждую задачу

`invokeAll()` **ждёт**, пока все задачи завершатся — это удобно для пакетной
обработки.

invokeAny();

`invokeAny()` — это почти как `invokeAll()`, **но он ждёт только первую
успешно завершённую задачу**, и:

- Возвращает **только один результат**
- Остальные задачи **отменяются**
- Это удобно, когда нужно просто получить **первый доступный ответ**, а не все

**Пример: `invokeAny()` в действии**

```java
import java.util.concurrent.*;
import java.util.*;

public class InvokeAnyExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Список задач с разной задержкой
        List<Callable<String>> tasks = List.of(
                () -> {
                    Thread.sleep(3000);
                    return "Результат из задачи 1 (3 сек)";
                },
                () -> {
                    Thread.sleep(1000);
                    return "Результат из задачи 2 (1 сек)";
                },
                () -> {
                    Thread.sleep(2000);
                    return "Результат из задачи 3 (2 сек)";
                }
        );

        try {
            // invokeAny ждёт первую выполненную и возвращает её результат
            String fastestResult = executor.invokeAny(tasks);
            System.out.println("Самая быстрая задача вернула: " + fastestResult);
        } catch (ExecutionException e) {
            System.out.println("Ошибка при выполнении одной из задач: " + e.getMessage());
        }

        executor.shutdown();
    }
}
```

**Что произойдёт:**

- Все 3 задачи стартуют одновременно.
- Первая, которая закончится — это вторая (через 1 сек).
- `invokeAny()` сразу возвращает её результат.
- Остальные 2 задачи отменяются автоматически.

Если все задачи упадут с ошибкой — `invokeAny()` выбросит `ExecutionException`.

Вывод:

```
Самая быстрая задача вернула: Результат из задачи 2 (1 сек)
```

Такой подход полезен, например, при:

- Обращении к нескольким серверам — взять ответ того, кто быстрее
- Поиске в разных источниках
- Параллельных попытках — "кто первый, тот и молодец"

---

## `ThreadPoolExecutor`

`ThreadPoolExecutor` — это **основной и самый гибкий класс**
для управления пулом потоков в Java. Когда ты используешь
`Executors.newFixedThreadPool()` и подобные методы — они **внутри создают
объект `ThreadPoolExecutor`**, просто прячут детали от тебя.

Если хочешь **полный контроль** — ты используешь `ThreadPoolExecutor` напрямую.

**Сигнатура конструктора `ThreadPoolExecutor`:**

```java
ThreadPoolExecutor(
        int corePoolSize,
        int maximumPoolSize,
        long keepAliveTime,
        TimeUnit unit,
        BlockingQueue<Runnable> workQueue,
        ThreadFactory threadFactory,
        RejectedExecutionHandler handler
)
```

- `corePoolSize` - Кол-во потоков, которые будут держаться "всегда", даже если
  простаивают
- `maximumPoolSize` - Максимальное кол-во потоков
- `keepAliveTime` - Сколько времени неактивные дополнительные потоки будут
  жить (если > corePoolSize)
- `workQueue` - Очередь задач (например, `LinkedBlockingQueue`)
- `threadFactory` - Как создаются потоки (можно передать дефолтный или
  кастомный)
- `handler` - Что делать, если все потоки заняты, а очередь переполнена


**Пример:**

```java
import java.util.concurrent.*;

public class CustomThreadPool {
    public static void main(String[] args) {
        BlockingQueue<Runnable> queue = new LinkedBlockingQueue<>(2);

        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, // corePoolSize
                4, // maximumPoolSize
                10, // keepAliveTime
                TimeUnit.SECONDS,
                queue,
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy() // выбросит исключение, если некуда девать задачу
        );

        for (int i = 1; i <= 10; i++) {
            int taskId = i;
            executor.execute(() -> {
                System.out.println("Запускается задача " + taskId + " в потоке " + Thread.currentThread().getName());
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Задача " + taskId + " завершена");
            });
        }

        executor.shutdown();
    }
}
```


Как работает этот пул:

- Первые 2 задачи — создаются потоки (`corePoolSize`)
- Следующие 2 — идут в очередь
- Затем, при поступлении 5-й и 6-й задач — создаются дополнительные потоки (до
  `maximumPoolSize`)
- Остальные — если и очередь, и потоки заняты — срабатывает
  `RejectedExecutionHandler` (в примере — `AbortPolicy`, которая кидает
  исключение)


### **Асинхронный сервис** на основе `ThreadPoolExecutor`

**Асинхронный сервис** на базе `ThreadPoolExecutor`, который:

Управляет задачами вручную  
Позволяет отправлять задачи (`submitTask()`)  
Возвращает `Future` с результатом  
Поддерживает graceful shutdown (`shutdown()`)  
Можно переиспользовать в разных частях приложения

## ✅ Пример: Асинхронный сервис `AsyncTaskService`

```java
import java.util.concurrent.*;

public class AsyncTaskService {
    private final ThreadPoolExecutor executor;

    public AsyncTaskService(int corePoolSize, int maxPoolSize, int queueSize) {
        this.executor = new ThreadPoolExecutor(
                corePoolSize,
                maxPoolSize,
                60, TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(queueSize),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy() // если перегрузка — выполнит вызывающий поток
        );
    }

    public <T> Future<T> submitTask(Callable<T> task) {
        return executor.submit(task);
    }

    public Future<?> submitTask(Runnable task) {
        return executor.submit(task);
    }

    public void shutdown() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    public boolean isShutdown() {
        return executor.isShutdown();
    }
}
```

---

## 🔄 Как использовать сервис:

```java
public class Main {
    public static void main(String[] args) {
        AsyncTaskService service = new AsyncTaskService(2, 4, 10);

        // Пример задачи с результатом
        Callable<String> task = () -> {
            Thread.sleep(1000);
            return "Hello from async!";
        };

        Future<String> result = service.submitTask(task);

        try {
            System.out.println("Результат: " + result.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        // Остановка сервиса
        service.shutdown();
    }
}
```

---

## 🧠 Преимущества такого подхода:

- Ты можешь использовать `AsyncTaskService` в любом классе приложения
- Управляешь политикой обработки перегрузки (`CallerRunsPolicy`, `AbortPolicy`,
  и т.д.)
- Можешь логировать состояние пула, расширить мониторинг или добавить
  retry-логику
- Гибкость выше, чем у стандартного `Executors`


### Основные методы

Вот некоторые ключевые методы интерфейса `ExecutorService`:

- **submit(Callable task)**: Отправляет задачу на выполнение и возвращает объект
  `Future`, который может быть использован для получения результата выполнения
  задачи.

- **submit(Runnable task)**: Отправляет задачу на выполнение и возвращает объект
  `Future`, который не возвращает результат (т.е. результат будет равен null).

- **invokeAll(Collection<? extends Callable<T>> tasks)**: Выполняет список задач
  и возвращает список объектов `Future`, которые представляют результаты
  выполнения этих задач.

- **invokeAny(Collection<? extends Callable<T>> tasks)**: Выполняет список задач
  и возвращает результат первой успешно выполненной задачи.

- **shutdown()**: Инициирует корректное завершение работы пула потоков, не
  принимая новые задачи.

- **shutdownNow()**: Попытка немедленно остановить все активные задачи и вернуть
  список ожидающих задач.

### Что такое задачи?

В контексте `ExecutorService` и многопоточности в Java, под "задачей"
подразумевается единица работы, которую необходимо выполнить. Задачи могут быть
представлены в виде объектов, реализующих интерфейсы `Runnable` или `Callable`.

### Асинхронные задачи

**Асинхронные задачи** — это задачи, которые выполняются независимо от основного
потока выполнения программы. Это означает, что основной поток может продолжать
свою работу, не дожидаясь завершения асинхронной задачи. Асинхронное выполнение
позволяет улучшить отзывчивость приложений, особенно в тех случаях, когда
требуется выполнение длительных операций, таких как сетевые запросы, операции
ввода-вывода или сложные вычисления. Асинхронные задачи могут выполняться в
фоновом режиме, позволяя основному потоку продолжать выполнение других операций.
После завершения асинхронной задачи можно обработать результаты выполнения. В
Java для этого часто используются объекты`Future` и `Callable`, которые
позволяют получить результат выполнения задачи или обработать исключения.
Асинхронные задачи могут быть настроены на выполнение с тайм-аутами или отменой,
что позволяет избежать зависания приложения при выполнении долгих операций.

### Callable

`Callable` — это функциональный интерфейс в Java, представляющий собой
задачу, которая может быть выполнена асинхронно и возвращает результат. Он
является частью пакета `java.util.concurrent` и часто используется в сочетании с
`ExecutorService` для выполнения задач в фоновом режиме.

В отличие от интерфейса `Runnable`, который не
возвращает результат (метод `run()` имеет тип `void`), метод `call()`
интерфейса `Callable` возвращает значение. Это позволяет получать результат
выполнения задачи.

Метод `call()` может выбрасывать проверяемые
исключения (checked exceptions), что позволяет обрабатывать ошибки,
возникающие во время выполнения задачи. В случае с `Runnable`, все исключения
должны обрабатываться внутри метода `run()`.

Когда задача, реализующая интерфейс `Callable`,
отправляется на выполнение через `ExecutorService`, она возвращает объект
типа `Future`. Этот объект позволяет проверять статус выполнения задачи и
получать результат после ее завершения.

### Задачи и потоки

Задачи и потоки в контексте многопоточности в Java тесно связаны между собой,
поскольку задачи представляют собой единицы работы, которые выполняются в
потоках.

#### 1. **Определение потоков и задач**

- **Поток**: Поток — это отдельная последовательность выполнения в программе.
  Каждый поток имеет свой собственный стек вызовов и может выполняться
  параллельно с другими потоками. В Java потоки создаются с помощью класса
  `Thread` или через интерфейсы, такие как `Runnable` и `Callable`.

- **Задача**: Задача — это конкретная работа или операция, которую нужно
  выполнить. В Java задачи могут быть реализованы через интерфейсы `Runnable` (
  для задач без результата) и `Callable` (для задач с результатом).

#### 2. **Выполнение задач в потоках**

Когда вы отправляете задачу на выполнение в `ExecutorService`, она будет
выполнена в одном из потоков пула потоков. Вот как это работает:

- **Создание пула потоков**: При создании экземпляра `ExecutorService`, вы
  определяете пул потоков, который будет использоваться для выполнения задач.
  Например, с помощью метода `Executors.newFixedThreadPool(n)` создается пул из
  `n` потоков.

- **Отправка задач**: Когда вы отправляете задачу на выполнение (например, через
  метод `submit()`), `ExecutorService` выбирает один из доступных потоков из
  пула для выполнения этой задачи.

- **Асинхронное выполнение**: Задачи могут выполняться асинхронно, что означает,
  что основной поток программы может продолжать выполнение других операций, не
  дожидаясь завершения задачи.

#### 3. **Параллелизм и многопоточность**

Использование задач и потоков позволяет реализовать параллелизм:

- **Параллельное выполнение**: Если у вас есть несколько задач, которые могут
  выполняться одновременно (например, обработка данных или выполнение сетевых
  запросов), вы можете отправить их на выполнение в пул потоков. Пул будет
  распределять задачи между доступными потоками, что позволяет выполнять их
  параллельно.

- **Управление ресурсами**: Пулы потоков помогают управлять ресурсами более
  эффективно. Вместо создания нового потока для каждой задачи (что может быть
  затратным по времени и ресурсам), вы можете повторно использовать существующие
  потоки для выполнения новых задач.

### Future

Объект `Future`, возвращаемый интерфейсом `Callable` в Java, представляет собой
результат асинхронной операции. Он предоставляет методы для проверки состояния
выполнения задачи, получения результата и обработки возможных исключений,
которые могут возникнуть во время выполнения задачи. Давайте рассмотрим основные
аспекты объекта `Future` более подробно.

#### Основные характеристики объекта `Future`

1. **Асинхронный результат**: Объект `Future` позволяет вам получить результат
   выполнения задачи, которая была отправлена на выполнение в пул потоков или
   другой механизм многопоточности. Поскольку задача выполняется асинхронно, вы
   можете продолжать выполнение других операций в основном потоке, не дожидаясь
   завершения задачи.

2. **Методы для управления состоянием**:
   - `isDone()`: Возвращает `true`, если задача завершена (независимо от того,
     была ли она выполнена успешно или завершилась с ошибкой).
   - `isCancelled()`: Возвращает `true`, если задача была отменена до ее
     завершения.
   - `cancel(boolean mayInterruptIfRunning)`: Пытается отменить выполнение
     задачи. Если задача уже выполняется и параметр `mayInterruptIfRunning`
     равен `true`, то выполнение задачи может быть прервано.

3. **Получение результата**:
   - `get()`: Блокирует текущий поток до тех пор, пока задача не завершится, и
     возвращает результат выполнения задачи. Если задача завершилась с
     исключением, метод `get()` выбросит это исключение.
   - `get(long timeout, TimeUnit unit)`: Блокирует текущий поток до тех пор,
     пока задача не завершится или не истечет указанный таймаут.

#### Пример использования объекта Future

Вот пример кода, который демонстрирует использование интерфейса `Callable` и
объекта `Future`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Определяем задачу Callable
        Callable<Integer> task = () -> {
            // Имитация длительной операции
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует текущий поток до получения результата
            System.out.println("Результат: " + result);
        } catch (InterruptedException e) {
            System.err.println("Задача была прервана");
        } catch (ExecutionException e) {
            System.err.println("Ошибка при выполнении задачи: " + e.getCause());
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу типа `Callable`, которая
   имитирует длительную операцию (например, задержку на 2 секунды) и возвращает
   значение 42.

3. **Отправка задачи**: Мы отправляем задачу на выполнение через метод
   `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы вызываем метод `get()` у объекта `Future`, чтобы
   получить результат выполнения задачи. Этот вызов блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения:
   - `InterruptedException`: Выбрасывается, если текущий поток был прерван во
     время ожидания результата.
   - `ExecutionException`: Выбрасывается, если задача завершилась с ошибкой; в
     этом случае мы можем получить причину ошибки через метод `getCause()`.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

#### Заключение

Объект `Future` является важным компонентом многопоточного программирования в
Java, позволяя управлять асинхронными задачами и получать результаты их
выполнения. Он предоставляет удобные методы для проверки состояния задач и
обработки результатов или ошибок, что делает его полезным инструментом для
работы с параллельными вычислениями.

#### Реализации Executor Service

ThreadPoolExecutor
ScheduledThreadPoolExecutor
CachedThreadPoolExecutor
ForkJoinPool

#### **ThreadPoolExecutor**

ThreadPoolExecutor – это реализация интерфейса ExecutorService в Java, который
предоставляет пул потоков исполнения для выполнения задач в фоновом режиме.

ThreadPoolExecutor позволяет создать и настроить пул потоков исполнения с
определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения задач в фоновом режиме, что может улучшить
производительность и реактивность вашего приложения.

#### **ScheduledThreadPoolExecutor**

ScheduledThreadPoolExecutor – это реализация интерфейса ScheduledExecutorService
в Java, который предоставляет пул потоков исполнения для выполнения задач в
определенный момент времени или с определенной периодичностью.

ScheduledThreadPoolExecutor позволяет создать и настроить пул потоков исполнения
с определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения регулярных задач в фоновом режиме, что может
улучшить производительность и реактивность вашего приложения.

#### **CachedThreadPoolExecutor**

CachedThreadPoolExecutor – это реализация интерфейса ExecutorService в Java,
который предоставляет пул потоков исполнения для выполнения задач в фоновом
режиме.

CachedThreadPoolExecutor автоматически масштабирует количество потоков
исполнения в зависимости от количества задач, которые нужно выполнить. Если
задачи поступают слишком быстро и текущее количество потоков исполнения не может
справиться с ними, CachedThreadPoolExecutor создает новый поток исполнения,
чтобы обеспечить выполнение задачи. Если задачи не поступают достаточно быстро и
текущее количество потоков исполнения избыточно, CachedThreadPoolExecutor
автоматически удаляет потоки исполнения, чтобы уменьшить нагрузку на систему.

#### **ForkJoinPool**

ForkJoinPool – это реализация ExecutorService в Java, которая используется для
параллельного выполнения задач. Эти задачи могут быть разбиты на более мелкие
подзадачи. Она позволяет использовать принцип “разделяй и властвуй” для более
эффективного использования многопроцессорных и многопоточных систем.

_**Основные компоненты ForkJoinPool:**_

**Пул потоков исполнения**

ForkJoinPool управляет пулом потоков исполнения, которые используются для
выполнения задач. Количество потоков исполнения в пуле задается при создании
экземпляра ForkJoinPool. Каждый поток в пуле имеет свой собственный стек
вызовов, что позволяет ForkJoinPool улучшить производительность в случае, когда
задачи могут быть разбиты на более мелкие подзадачи.

**Разбиение и объединение задач:**

ForkJoinPool поддерживает работу с задачами типа RecursiveAction и
RecursiveTask, которые представляют собой рекурсивно делимые задачи без
возвращаемого значения и с возвращаемым значением соответственно. Когда
ForkJoinPool получает задачу типа RecursiveTask, он разбивает ее на более мелкие
подзадачи, выполняет их параллельно в разных потоках и объединяет результаты
выполнения в единую итоговую задачу.





===

`ExecutorService` в Java — это интерфейс, который является частью пакета
`java.util.concurrent` и предоставляет высокоуровневый механизм для управления
потоками. Он позволяет выполнять асинхронные задачи, управлять пулом потоков и
упрощает работу с многопоточностью.

### Основные характеристики `ExecutorService`:

1. **Управление потоками**: `ExecutorService` управляет пулом потоков, что
   позволяет повторно использовать потоки для выполнения задач, тем самым
   уменьшая накладные расходы на создание и уничтожение потоков.

2. **Асинхронное выполнение**: Вы можете отправлять задачи на выполнение и
   продолжать выполнять другие операции, не дожидаясь завершения этих задач.

3. **Разные типы задач**: Вы можете отправлять как `Runnable`, так и `Callable`
   задачи. `Callable` позволяет возвращать результат и обрабатывать исключения.

4. **Управление жизненным циклом**: `ExecutorService` предоставляет методы для
   управления жизненным циклом пула потоков, такие как `shutdown()` и
   `shutdownNow()`, которые позволяют корректно завершить выполнение задач.

5. **Фабрики для создания экземпляров**: Для создания экземпляров
   `ExecutorService` обычно используются статические методы класса `Executors`,
   такие как:
    - `Executors.newFixedThreadPool(int nThreads)`: создает пул фиксированного
      размера.
    - `Executors.newCachedThreadPool()`: создает пул, который создает новые
      потоки по мере необходимости, но повторно использует ранее созданные
      потоки.
    - `Executors.newSingleThreadExecutor()`: создает пул с одним потоком.

### Пример использования:

Вот простой пример использования `ExecutorService`:

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        // Создаем ExecutorService с фиксированным количеством потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Отправляем задачи на выполнение
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " is running in "
                        + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000); // Имитация работы
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }

        // Завершаем ExecutorService
        executor.shutdown();
    }
}
```

В этом примере создается пул из трех потоков, и в него отправляются пять задач.
Каждая задача выполняется в одном из доступных потоков пула.



### Что такое задачи?

В контексте `ExecutorService` и многопоточности в Java, под "задачей"
подразумевается единица работы, которую необходимо выполнить. Задачи могут быть
представлены в виде объектов, реализующих интерфейсы `Runnable` или `Callable`.

### Основные характеристики задач:

1. **Единица работы**: Задача — это конкретная работа или операция, которую
   нужно выполнить. Это может быть что угодно: от простого вычисления до сложной
   обработки данных.

2. **Асинхронность**: Задачи могут выполняться асинхронно, что позволяет
   основному потоку продолжать выполнение других операций, не дожидаясь
   завершения задачи.

3. **Возврат результата**:
    - **Runnable**: Задачи, реализующие интерфейс `Runnable`, не возвращают
      результат. Метод `run()` этого интерфейса имеет тип `void`.
    - **Callable**: Задачи, реализующие интерфейс `Callable`, могут возвращать
      результат и могут выбрасывать проверяемые исключения. Метод `call()` этого
      интерфейса возвращает значение.

4. **Управление состоянием**: Каждая задача может находиться в одном из
   нескольких состояний (например, ожидает выполнения, выполняется или
   завершена). Это состояние можно отслеживать с помощью объекта типа `Future`,
   который возвращается при отправке задачи на выполнение.

### Примеры задач

Вот несколько примеров задач:

- **Вычислительные задачи**: Например, задача по вычислению факториала числа или
  сложению чисел в массиве.
- **Задачи ввода-вывода**: Чтение данных из файла или отправка HTTP-запроса.
- **Обработка данных**: Например, фильтрация списка объектов или преобразование
  данных.

### Пример использования задач

Вот пример создания и выполнения задач с использованием интерфейсов `Runnable` и
`Callable`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class TaskExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Задача Runnable
        Runnable runnableTask = () -> {
            System.out.println("Выполнение задачи Runnable");
        };

        // Задача Callable
        Callable<Integer> callableTask = () -> {
            System.out.println("Выполнение задачи Callable");
            return 42; // Возвращаем результат
        };

        // Отправляем задачи на выполнение
        executor.submit(runnableTask); // Для Runnable
        Future<Integer> future = executor.submit(callableTask); // Для Callable

        try {
            // Получаем результат выполнения задачи Callable
            Integer result = future.get();
            System.out.println("Результат задачи Callable: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задач**:
    - Мы определяем задачу типа `Runnable`, которая просто выводит сообщение.
    - Мы также определяем задачу типа `Callable`, которая выводит сообщение и
      возвращает значение 42.

3. **Отправка задач на выполнение**: Мы отправляем обе задачи на выполнение
   через метод `submit()`. Для задачи типа `Runnable` мы просто вызываем метод
   без ожидания результата, а для задачи типа `Callable` мы получаем объект типа
   `Future`.

4. **Получение результата**: Мы используем метод `get()` объекта `Future`, чтобы
   получить результат выполнения задачи типа `Callable`.

5. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

#### Заключение

Таким образом, под "задачей" в контексте многопоточности и использования
`ExecutorService` понимается конкретная работа или операция, которую необходимо
выполнить асинхронно. Задачи могут быть реализованы через интерфейсы `Runnable`
и `Callable`, что позволяет гибко управлять выполнением кода в многопоточной
среде.


### Асинхронные задачи

**Асинхронные задачи** — это задачи, которые выполняются независимо от основного
потока выполнения программы. Это означает, что основной поток может продолжать
свою работу, не дожидаясь завершения асинхронной задачи. Асинхронное выполнение
позволяет улучшить отзывчивость приложений, особенно в тех случаях, когда
требуется выполнение длительных операций, таких как сетевые запросы, операции
ввода-вывода или сложные вычисления.

#### Основные характеристики асинхронных задач:

1. **Независимость**: Асинхронные задачи могут выполняться в фоновом режиме,
   позволяя основному потоку продолжать выполнение других операций. Это особенно
   полезно в пользовательских интерфейсах, где блокировка основного потока может
   привести к зависанию приложения.

2. **Обработка результатов**: После завершения асинхронной задачи можно
   обработать результаты выполнения. В Java для этого часто используются объекты
   `Future` и `Callable`, которые позволяют получить результат выполнения задачи
   или обработать исключения.

3. **Параллелизм**: Асинхронные задачи могут выполняться параллельно с другими
   задачами, что позволяет более эффективно использовать ресурсы системы и
   сокращать общее время выполнения.

4. **Управление временем ожидания**: Асинхронные задачи могут быть настроены на
   выполнение с тайм-аутами или отменой, что позволяет избежать зависания
   приложения при выполнении долгих операций.

#### Примеры использования асинхронных задач:

1. **Сетевые запросы**: При выполнении HTTP-запросов к удаленному серверу можно
   использовать асинхронные задачи для того, чтобы не блокировать основной поток
   приложения во время ожидания ответа.

2. **Долгие вычисления**: Если приложение выполняет сложные вычисления (
   например, обработка больших объемов данных), эти операции можно вынести в
   асинхронные задачи, чтобы основной поток оставался отзывчивым.

3. **Работа с файлами**: Чтение и запись файлов может занять значительное время;
   использование асинхронных задач позволяет избежать блокировки
   пользовательского интерфейса во время этих операций.

#### Пример в Java:

Вот пример использования асинхронной задачи с помощью `ExecutorService` и
`Callable`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class AsyncTaskExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // Создаем асинхронную задачу
        Callable<Integer> task = () -> {
            Thread.sleep(2000); // Имитация долгой работы
            return 42; // Возвращаем результат
        };

        Future<Integer> future = executor.submit(task);

        // Основной поток продолжает выполнять другие операции
        System.out.println("Основной поток продолжает работу...");

        try {
            // Получаем результат выполнения асинхронной задачи
            Integer result = future.get(); // Это блокирует поток до получения результата
            System.out.println("Результат асинхронной задачи: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

В этом примере создается асинхронная задача, которая имитирует длительную
работу (с помощью `Thread.sleep`). Основной поток продолжает выполнение и
выводит сообщение на экран. После этого он ожидает завершения асинхронной задачи
и получает результат.

#### Заключение

Асинхронные задачи являются важным инструментом для разработки отзывчивых и
эффективных приложений. Они позволяют выполнять длительные операции без
блокировки основного потока выполнения и обеспечивают более плавный
пользовательский опыт.


### Callable

`Callable` — это функциональный интерфейс в Java, представляющий собой
задачу, которая может быть выполнена асинхронно и возвращает результат. Он
является частью пакета `java.util.concurrent` и часто используется в сочетании с
`ExecutorService` для выполнения задач в фоновом режиме.

#### Основные характеристики `Callable`:

1. **Возврат результата**: В отличие от интерфейса `Runnable`, который не
   возвращает результат (метод `run()` имеет тип `void`), метод `call()`
   интерфейса `Callable` возвращает значение. Это позволяет получать результат
   выполнения задачи.

2. **Обработка исключений**: Метод `call()` может выбрасывать проверяемые
   исключения (checked exceptions), что позволяет обрабатывать ошибки,
   возникающие во время выполнения задачи. В случае с `Runnable`, все исключения
   должны обрабатываться внутри метода `run()`.

3. **Использование с `Future`**: Когда задача, реализующая интерфейс `Callable`,
   отправляется на выполнение через `ExecutorService`, она возвращает объект
   типа `Future`. Этот объект позволяет проверять статус выполнения задачи и
   получать результат после ее завершения.

#### Синтаксис

Интерфейс `Callable` имеет следующий синтаксис:

```java

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

Где `<V>` — это тип результата, который будет возвращен методом `call()`.

#### Пример использования

Вот пример использования интерфейса `Callable` вместе с `ExecutorService`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Создаем задачу, реализующую Callable
        Callable<Integer> task = () -> {
            // Имитация длительной работы
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует поток до получения результата
            System.out.println("Результат асинхронной задачи: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу, реализующую интерфейс
   `Callable`, которая имитирует длительную работу (с помощью метода
   `Thread.sleep`) и возвращает значение 42.

3. **Отправка задачи на выполнение**: Задача отправляется на выполнение через
   метод `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы используем метод `get()` объекта `Future`, чтобы
   получить результат выполнения задачи. Этот метод блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения, которые могут
   возникнуть при выполнении задачи или при получении результата.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

#### Заключение

Интерфейс `Callable` является мощным инструментом для создания асинхронных задач
в Java, позволяя разработчикам выполнять фоновые операции и получать результаты
их выполнения. Он обеспечивает более гибкий подход по сравнению с интерфейсом
`Runnable`, особенно когда требуется обработка результатов или исключений.


### Задачи и потоки

Задачи и потоки в контексте многопоточности в Java тесно связаны между собой,
поскольку задачи представляют собой единицы работы, которые выполняются в
потоках. Давайте рассмотрим, как именно они связаны:

#### 1. **Определение потоков и задач**

- **Поток**: Поток — это отдельная последовательность выполнения в программе.
  Каждый поток имеет свой собственный стек вызовов и может выполняться
  параллельно с другими потоками. В Java потоки создаются с помощью класса
  `Thread` или через интерфейсы, такие как `Runnable` и `Callable`.

- **Задача**: Задача — это конкретная работа или операция, которую нужно
  выполнить. В Java задачи могут быть реализованы через интерфейсы `Runnable` (
  для задач без результата) и `Callable` (для задач с результатом).

#### 2. **Выполнение задач в потоках**

Когда вы отправляете задачу на выполнение в `ExecutorService`, она будет
выполнена в одном из потоков пула потоков. Вот как это работает:

- **Создание пула потоков**: При создании экземпляра `ExecutorService`, вы
  определяете пул потоков, который будет использоваться для выполнения задач.
  Например, с помощью метода `Executors.newFixedThreadPool(n)` создается пул из
  `n` потоков.

- **Отправка задач**: Когда вы отправляете задачу на выполнение (например, через
  метод `submit()`), `ExecutorService` выбирает один из доступных потоков из
  пула для выполнения этой задачи.

- **Асинхронное выполнение**: Задачи могут выполняться асинхронно, что означает,
  что основной поток программы может продолжать выполнение других операций, не
  дожидаясь завершения задачи.

#### 3. **Параллелизм и многопоточность**

Использование задач и потоков позволяет реализовать параллелизм:

- **Параллельное выполнение**: Если у вас есть несколько задач, которые могут
  выполняться одновременно (например, обработка данных или выполнение сетевых
  запросов), вы можете отправить их на выполнение в пул потоков. Пул будет
  распределять задачи между доступными потоками, что позволяет выполнять их
  параллельно.

- **Управление ресурсами**: Пулы потоков помогают управлять ресурсами более
  эффективно. Вместо создания нового потока для каждой задачи (что может быть
  затратным по времени и ресурсам), вы можете повторно использовать существующие
  потоки для выполнения новых задач.

#### 4. **Пример связи задач и потоков**

Вот пример кода, который демонстрирует связь между задачами и потоками:

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class TaskAndThreadExample {
    public static void main(String[] args) {
        // Создаем пул из 3 потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Определяем несколько задач
        Runnable task1 = () -> {
            System.out.println("Задача 1 выполняется в потоке: " + Thread.currentThread().getName());
        };

        Runnable task2 = () -> {
            System.out.println("Задача 2 выполняется в потоке: " + Thread.currentThread().getName());
        };

        Runnable task3 = () -> {
            System.out.println("Задача 3 выполняется в потоке: " + Thread.currentThread().getName());
        };

        // Отправляем задачи на выполнение
        executor.submit(task1);
        executor.submit(task2);
        executor.submit(task3);

        // Завершаем работу пула
        executor.shutdown();
    }
}
```

#### Объяснение примера:

1. **Создание пула**: Мы создаем пул из трех потоков.

2. **Определение задач**: Мы определяем три задачи типа `Runnable`, выводящих
   имя потока, в котором она выполняется.

3. **Отправка задач**: Мы отправляем все три задачи на выполнение через метод
   `submit()`. Пул распределяет эти задачи между доступными потоками.

4. **Вывод информации о потоке**: Каждая задача выводит имя потока, который ее
   выполняет. Это демонстрирует, что одна и та же задача может выполняться в
   разных потоках.

5. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула.

#### Заключение

Таким образом, задачи и потоки являются основными компонентами многопоточного
программирования в Java. Задачи представляют собой единицы работы, которые
необходимо выполнить, а потоки — это механизмы выполнения этих задач.
Использование пула потоков позволяет эффективно управлять выполнением множества
задач одновременно, обеспечивая параллелизм и оптимизацию использования ресурсов
системы.


#### Future

Объект `Future`, возвращаемый интерфейсом `Callable` в Java, представляет собой
результат асинхронной операции. Он предоставляет методы для проверки состояния
выполнения задачи, получения результата и обработки возможных исключений,
которые могут возникнуть во время выполнения задачи. Давайте рассмотрим основные
аспекты объекта `Future` более подробно.

#### Основные характеристики объекта `Future`

1. **Асинхронный результат**: Объект `Future` позволяет вам получить результат
   выполнения задачи, которая была отправлена на выполнение в пул потоков или
   другой механизм многопоточности. Поскольку задача выполняется асинхронно, вы
   можете продолжать выполнение других операций в основном потоке, не дожидаясь
   завершения задачи.

2. **Методы для управления состоянием**:
    - `isDone()`: Возвращает `true`, если задача завершена (независимо от того,
      была ли она выполнена успешно или завершилась с ошибкой).
    - `isCancelled()`: Возвращает `true`, если задача была отменена до ее
      завершения.
    - `cancel(boolean mayInterruptIfRunning)`: Пытается отменить выполнение
      задачи. Если задача уже выполняется и параметр `mayInterruptIfRunning`
      равен `true`, то выполнение задачи может быть прервано.

3. **Получение результата**:
    - `get()`: Блокирует текущий поток до тех пор, пока задача не завершится, и
      возвращает результат выполнения задачи. Если задача завершилась с
      исключением, метод `get()` выбросит это исключение.
    - `get(long timeout, TimeUnit unit)`: Блокирует текущий поток до тех пор,
      пока задача не завершится или не истечет указанный таймаут.

#### Пример использования объекта Future

Вот пример кода, который демонстрирует использование интерфейса `Callable` и
объекта `Future`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Определяем задачу Callable
        Callable<Integer> task = () -> {
            // Имитация длительной операции
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует текущий поток до получения результата
            System.out.println("Результат: " + result);
        } catch (InterruptedException e) {
            System.err.println("Задача была прервана");
        } catch (ExecutionException e) {
            System.err.println("Ошибка при выполнении задачи: " + e.getCause());
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу типа `Callable`, которая
   имитирует длительную операцию (например, задержку на 2 секунды) и возвращает
   значение 42.

3. **Отправка задачи**: Мы отправляем задачу на выполнение через метод
   `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы вызываем метод `get()` у объекта `Future`, чтобы
   получить результат выполнения задачи. Этот вызов блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения:
    - `InterruptedException`: Выбрасывается, если текущий поток был прерван во
      время ожидания результата.
    - `ExecutionException`: Выбрасывается, если задача завершилась с ошибкой; в
      этом случае мы можем получить причину ошибки через метод `getCause()`.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

#### Заключение

Объект `Future` является важным компонентом многопоточного программирования в
Java, позволяя управлять асинхронными задачами и получать результаты их
выполнения. Он предоставляет удобные методы для проверки состояния задач и
обработки результатов или ошибок, что делает его полезным инструментом для
работы с параллельными вычислениями.

#### Реализации Executor Service

ExecutorService – это интерфейс Java, который предоставляет удобный способ
управления потоками исполнения. Он позволяет создавать пул потоков исполнения и
выполнять задачи в этих потоках.

Существует несколько ключевых реализаций ExecutorService:

ThreadPoolExecutor
ScheduledThreadPoolExecutor
CachedThreadPoolExecutor
ForkJoinPool

#### **ThreadPoolExecutor**

ThreadPoolExecutor – это реализация интерфейса ExecutorService в Java, который
предоставляет пул потоков исполнения для выполнения задач в фоновом режиме.

ThreadPoolExecutor позволяет создать и настроить пул потоков исполнения с
определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения задач в фоновом режиме, что может улучшить
производительность и реактивность вашего приложения.

#### **ScheduledThreadPoolExecutor**

ScheduledThreadPoolExecutor – это реализация интерфейса ScheduledExecutorService
в Java, который предоставляет пул потоков исполнения для выполнения задач в
определенный момент времени или с определенной периодичностью.

ScheduledThreadPoolExecutor позволяет создать и настроить пул потоков исполнения
с определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения регулярных задач в фоновом режиме, что может
улучшить производительность и реактивность вашего приложения.

#### **CachedThreadPoolExecutor**

CachedThreadPoolExecutor – это реализация интерфейса ExecutorService в Java,
который предоставляет пул потоков исполнения для выполнения задач в фоновом
режиме.

CachedThreadPoolExecutor автоматически масштабирует количество потоков
исполнения в зависимости от количества задач, которые нужно выполнить. Если
задачи поступают слишком быстро и текущее количество потоков исполнения не может
справиться с ними, CachedThreadPoolExecutor создает новый поток исполнения,
чтобы обеспечить выполнение задачи. Если задачи не поступают достаточно быстро и
текущее количество потоков исполнения избыточно, CachedThreadPoolExecutor
автоматически удаляет потоки исполнения, чтобы уменьшить нагрузку на систему.

#### **ForkJoinPool**

ForkJoinPool – это реализация ExecutorService в Java, которая используется для
параллельного выполнения задач. Эти задачи могут быть разбиты на более мелкие
подзадачи. Она позволяет использовать принцип “разделяй и властвуй” для более
эффективного использования многопроцессорных и многопоточных систем.

_**Основные компоненты ForkJoinPool:**_

**Пул потоков исполнения**

ForkJoinPool управляет пулом потоков исполнения, которые используются для
выполнения задач. Количество потоков исполнения в пуле задается при создании
экземпляра ForkJoinPool. Каждый поток в пуле имеет свой собственный стек
вызовов, что позволяет ForkJoinPool улучшить производительность в случае, когда
задачи могут быть разбиты на более мелкие подзадачи.

**Разбиение и объединение задач:**

ForkJoinPool поддерживает работу с задачами типа RecursiveAction и
RecursiveTask, которые представляют собой рекурсивно делимые задачи без
возвращаемого значения и с возвращаемым значением соответственно. Когда
ForkJoinPool получает задачу типа RecursiveTask, он разбивает ее на более мелкие
подзадачи, выполняет их параллельно в разных потоках и объединяет результаты
выполнения в единую итоговую задачу.


> ## JAVA CORE. <br><br> Multitrading. <br> Atomic пакет Механизм под капотом (CAS)

В Java термин "atomic" (атомарный) относится к операциям, которые выполняются
как единое целое, без возможности прерывания. Это означает, что такие операции
являются неделимыми: они либо полностью выполняются, либо не выполняются вовсе.
Атомарные операции важны в контексте многопоточности, поскольку они помогают
избежать проблем с синхронизацией и состоянием гонки.

### Основные аспекты атомарности в Java

1. **Атомарные операции**: Атомарные операции гарантируют, что данные не будут
   изменены другими потоками во время выполнения операции. Например, если один
   поток обновляет значение переменной, другой поток не сможет увидеть
   промежуточное состояние этой переменной.

2. **Классы из пакета `java.util.concurrent.atomic`**: Java предоставляет
   несколько классов для работы с атомарными переменными в пакете
   `java.util.concurrent.atomic`. Эти классы обеспечивают атомарные операции над
   примитивными типами данных и объектами. Вот некоторые из них:
    - `AtomicInteger`: Атомарная целочисленная переменная.
    - `AtomicLong`: Атомарная переменная типа `long`.
    - `AtomicBoolean`: Атомарная булева переменная.
    - `AtomicReference<T>`: Атомарная ссылка на объект типа `T`.
    - `AtomicStampedReference<V>`: Атомарная ссылка на объект с меткой (
      стампом), что позволяет избежать проблем с состоянием гонки при обновлении
      ссылок.

3. **Методы атомарных классов**: Классы из пакета `java.util.concurrent.atomic`
   предоставляют методы для выполнения атомарных операций, такие как:
    - `get()`: Получает текущее значение.
    - `set(value)`: Устанавливает новое значение.
    - `incrementAndGet()`: Увеличивает текущее значение на 1 и возвращает новое
      значение.
    - `compareAndSet(expectedValue, newValue)`: Сравнивает текущее значение с
      ожидаемым значением и устанавливает новое значение, если они равны.

### Пример использования атомарных переменных

Вот пример кода, который демонстрирует использование класса `AtomicInteger`:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    public static void main(String[] args) {
        AtomicInteger atomicCounter = new AtomicInteger(0);

        // Создаем несколько потоков для увеличения счетчика
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                atomicCounter.incrementAndGet(); // Атомарное увеличение
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                atomicCounter.incrementAndGet(); // Атомарное увеличение
            }
        });

        // Запускаем потоки
        thread1.start();
        thread2.start();

        // Ждем завершения потоков
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Выводим итоговое значение счетчика
        System.out.println("Итоговое значение счетчика: " + atomicCounter.get());
    }
}
```

### Объяснение примера:

1. **Создание атомарного счетчика**: Мы создаем экземпляр класса
   `AtomicInteger`, инициализируя его значением 0.

2. **Создание потоков**: Мы создаем два потока, каждый из которых увеличивает
   счетчик на 1000 раз с помощью метода `incrementAndGet()`, который выполняет
   атомарное увеличение.

3. **Запуск потоков**: Мы запускаем оба потока.

4. **Ожидание завершения потоков**: Мы используем метод `join()` для ожидания
   завершения обоих потоков.

5. **Вывод результата**: После завершения работы потоков мы выводим итоговое
   значение счетчика. Поскольку мы использовали атомарную переменную, итоговое
   значение будет равно 2000, независимо от порядка выполнения потоков.

### Заключение

Атомарные операции и классы в Java обеспечивают безопасный доступ к общим данным
в многопоточной среде без необходимости использования явной синхронизации (
например, через блокировки). Это делает код более простым и эффективным при
работе с конкурентными задачами. Однако важно помнить, что атомарность не
гарантирует полной безопасности при работе с более сложными структурами данных
или логикой — в таких случаях может потребоваться дополнительная синхронизация.

### CAS

В Java "CAS" (Compare-And-Swap) — это атомарная операция, которая используется
для реализации механизмов синхронизации и управления состоянием в многопоточной
среде. CAS позволяет безопасно обновлять значение переменной, проверяя, равно ли
текущее значение ожидаемому значению, и только в этом случае заменяя его на
новое значение. Это делает CAS полезным для реализации неблокирующих алгоритмов
и структур данных.

#### Как работает CAS

Операция CAS включает три параметра:

1. **Адрес переменной**: Адрес (или ссылка) на переменную, которую мы хотим
   обновить.
2. **Ожидаемое значение**: Значение, с которым мы сравниваем текущее значение
   переменной.
3. **Новое значение**: Значение, которое мы хотим установить, если текущее
   значение совпадает с ожидаемым.

Процесс работы CAS можно описать следующим образом:

1. Сравнить текущее значение переменной с ожидаемым значением.
2. Если они равны, обновить переменную новым значением.
3. Если они не равны, операция завершается без изменений.

#### Пример использования CAS в Java

Java предоставляет поддержку CAS через классы из пакета
`java.util.concurrent.atomic`, такие как `AtomicInteger`, `AtomicBoolean`,
`AtomicReference` и другие. Эти классы используют внутренние механизмы CAS для
выполнения атомарных операций.

Вот пример использования `AtomicInteger` с методом `compareAndSet()`:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCASExample {
    public static void main(String[] args) {
        AtomicInteger atomicCounter = new AtomicInteger(0);

        // Создаем несколько потоков для увеличения счетчика
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                int currentValue;
                do {
                    currentValue = atomicCounter.get();
                } while (!atomicCounter.compareAndSet(currentValue, currentValue + 1));
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                int currentValue;
                do {
                    currentValue = atomicCounter.get();
                } while (!atomicCounter.compareAndSet(currentValue, currentValue + 1));
            }
        });

        // Запускаем потоки
        thread1.start();
        thread2.start();

        // Ждем завершения потоков
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Выводим итоговое значение счетчика
        System.out.println("Итоговое значение счетчика: " + atomicCounter.get());
    }
}
```

#### Объяснение примера:

1. **Создание атомарного счетчика**: Мы создаем экземпляр класса
   `AtomicInteger`, инициализируя его значением 0.

2. **Создание потоков**: Мы создаем два потока, каждый из которых пытается
   увеличить счетчик на 1000 раз.

3. **Использование CAS**:
    - В каждом потоке мы используем цикл `do-while`, чтобы попытаться получить
      текущее значение счетчика.
    - Затем мы вызываем метод `compareAndSet(currentValue, currentValue + 1)`.
      Этот метод проверяет, равно ли текущее значение счетчика (
      `atomicCounter.get()`) ожидаемому значению (`currentValue`). Если да, то
      он устанавливает новое значение (`currentValue + 1`). Если нет — операция
      завершается без изменений, и цикл повторяется.

4. **Запуск потоков**: Мы запускаем оба потока.

5. **Ожидание завершения потоков**: Мы используем метод `join()` для ожидания
   завершения обоих потоков.

6. **Вывод результата**: После завершения работы потоков мы выводим итоговое
   значение счетчика. Поскольку мы использовали атомарную переменную с
   CAS-операцией, итоговое значение будет равно 2000.

### Преимущества и недостатки CAS

#### Преимущества:

- **Без блокировок**: CAS позволяет избежать использования блокировок (например,
  synchronized), что может улучшить производительность в многопоточных
  приложениях.
- **Простота реализации**: Многие алгоритмы могут быть реализованы проще с
  использованием CAS.

#### Недостатки:

- **Проблема "проверка-замена"**: Если несколько потоков одновременно пытаются
  обновить одно и то же значение, это может привести к частым неудачным попыткам
  обновления (потоки будут повторять операции), что может снизить
  производительность.
- **Необходимость повторных попыток**: В некоторых случаях может потребоваться
  много итераций для успешного выполнения операции из-за состояния гонки между
  потоками.

### Заключение

CAS является мощным инструментом для реализации неблокирующих алгоритмов и
структур данных в Java. Он позволяет безопасно обновлять значения переменных в
многопоточной среде без необходимости использования явных блокировок, что делает
код более эффективным и простым в понимании. Однако важно учитывать возможные
проблемы с производительностью при высокой конкуренции за ресурсы.
