# Нововведения, добавленные в Java 17

## Оператор switch

### Расширения

- выражения switch;
- оператор yield;
- поддержка списка констант case;
- оператор case со стрелкой;

Выражение switch это по существу оператор switch, который производит значение.
Таким образом, выражение switch можно применять, например, в правой части
операции присваивания. Значение, созданное выражением switch, указывается с
помощью оператора yield. Теперь можно иметь более одной константы в операторе
case за счет использования списка констант. Добавлена вторая форма оператора
case, в которой вместо двоеточия применяется стрелка (->), предоставляющая ему
новые возможности.

### Использование списка констант case

**Традиционный оператор switch:**

```java
public class Code {
    // Использование традиционного оператора switch для получения способа
    // доставки товара с заданным идентификатором. Для большинства товаров
    // используется стандартная доставка, но некоторые требуют специальной
    // транспортировки,
    enum ShipMethod {
        STANDARD, TRUCK, AIR, OVERNIGHT
        // Стандартный, грузовой, самолетом, срочный
    }

    public static void main(String[] args) {
        ShipMethod shipBy;
        int productID = 5099;

        // Для получения способа доставки применятся традиционный оператор switch
        switch (productID) {
            case 1774:
            case 6709:
                shipBy = ShipMethod.TRUCK;
                break;
            case 5099:
                shipBy = ShipMethod.OVERNIGHT;
                break;
            default:
                shipBy = ShipMethod.STANDARD;
        }
        System.out.println("productID " + productID + " : shipBy " + shipBy);
    }
}
```

Операторы case можно заменить на:

            case 1774, 6709:
                shipBy = ShipMethod.TRUCK;
                break;

### Оператор yield

Предоставить значение выражения switch можно с помощью нового оператора yield,
который имеет следующий общий вид:

    yield значение;

**yield вызывает немедленное прекращение switch**.
Здесь значение производится оператором switch и может быть любым выражением,
совместимым с требуемым типом значения. Следовательно, он работает примерно так
же, как break, но обладает дополнительной возможностью предоставлять значение.

Выражение switch указывается в контекст, где требуется значение: в правую часть
оператора присваивания, в аргумент метода или в возвращаемое значение метода.

    int result = switch(what) { // ...

Результат switch присваивается переменной result. Каждый оператор case (плюс
default) должен производить значение (если только не генерируется исключение).

```java
public class Code {
    // Использование традиционного оператора switch для получения способа
    // доставки товара с заданным идентификатором. Для большинства товаров
    // используется стандартная доставка, но некоторые требуют специальной
    // транспортировки,
    enum ShipMethod {
        STANDARD, TRUCK, AIR, OVERNIGHT
        // Стандартный, грузовой, самолетом, срочный
    }

    public static void main(String[] args) {
        int productID = 5099;
        ShipMethod shipBy = switch (productID) {
            case 1774, 8708, 6709:
                yield ShipMethod.TRUCK;
            case 4657, 1887:
                yield ShipMethod.AIR;
            case 2907, 5099:
                yield ShipMethod.OVERNIGHT;
            default:
                yield ShipMethod.STANDARD;
        };
        System.out.println("productID " + productID + " : shipBy " + shipBy);
    }
}
```

### Стрелка в операторе case

Запись

    case 1774, 8708, 6709: // ...

можно заменить на:

    case 1774, 8708, 6709 ->  // ...

Их отличия:

- поток выполнения после case со стрелкой не переходит к следующему оператору
  case.
- case со стрелкой обеспечивает “сокращенный” способ предоставления значения в
  случае использования в выражении switch;
- целью case со стрелкой должно быть выражение, блок либо исключение. Ею не
  может быть последовательность
  операторов, как разрешено в традиционном операторе case.

  case константа - > выражение;
  case константа - > { блок-операторов }
  case константа - > throw . . .

Целью -> также может служить блок кода.

```java
package dev.folomkin.java.features;

public class Code {
  enum ShipMethod {
    STANDARD, TRUCK, AIR, OVERNIGHT
  }

  public static void main(String[] args) {
    int productID = 5099;
    boolean extraCharge;
    ShipMethod shipBy = switch (productID) {
      case 1774, 8708, 6709 -> {
        extraCharge = true;
        yield ShipMethod.TRUCK;
      }
      case 4657, 1887 -> {
        extraCharge = false;
        yield ShipMethod.AIR;
      }
      case 2907, 5099 -> {
        extraCharge = false;
        yield ShipMethod.OVERNIGHT;
      }
      default -> {
        extraCharge = false;
        yield ShipMethod.STANDARD;
      }
    };
    System.out.println("productID " + productID + " : shipBy " + shipBy);
    if (extraCharge) {
      System.out.println("productID " + productID + " : extraCharge");
    }
  }
}
```

## Записи (record)

Как уже упоминалось, запись это узконаправленный, специализированный класс.
Запись объявляется с помощью контекстночувствительного ключевого слова record,
которое трактуется как ключевое слово только в контексте объявления записи. В
других ситуациях record считается пользовательским идентификатором без особой
значимости. Таким образом, добавление record не влияет на существующий код и не
нарушает его работу.

Ниже показана общая форма объявления записи:

    record имя записи [ список-компонентов ) {
        // необязательные операторы тела
    }

Видно, что объявление записи имеет существенные отличия от объявления класса.
Во-первых, сразу после имени записи следует разделенный запятыми список
объявлений параметров, называемый списком компонентов. В списке компонентов
определяются данные, которые будут храниться в записи.
Во-вторых, тело записи является необязательным благодаря тому, что компилятор
автоматически предоставит элементы, необходимые для хранения данных, создаст
конструктор записи и методы получения, которые обеспечат доступ к данным, а
также переопределит методы toString(), equals() и hashCode(), унаследованные от
класса Object. В результате во многих сценариях использования тело не требуется,
т.к. само объявление record полностью определяет запись.  
Пример объявления простой записи:

    record Item(String name, int itemNum, double price) {}

Для только что показанного объявления Item определенные элементы создаются
автоматически.
Во-первых, для name, itemNum и price объявляются закрытые финальные поля с
типами String, int и double.
Во-вторых, предоставляются открытые методы доступа, допускающие только чтение (
методы получения), которые имеют такие же имена и типы, как у компонентов записи
name, itemNum и price, т.е. name(), itemNum() и price(). В общем случае для
каждого компонента записи компилятор будет автоматически создавать
соответствующее закрытое финальное поле и открытый метод получения, допускающий
только чтение.  
Еще одним элементом, который автоматически создается компилятором, будет
канонический конструктор записи. Такой конструктор имеет список параметров,
который содержит те же элементы в том же порядке, что и список компонентов в
объявлении записи. Значения , передаваемые конструктору, автоматически
присваиваются соответствующим полям в записи. Канонический конструктор в записи
заменяет собой стандартный конструктор в классе.  
Запись создается с помощью операции new тем же способом, каким создается
экземпляр класса. Например:

```java
record Item(String name, int itemNum, double price) {
}

class Code {
    public static void main(String[] args) {
        Item item = new Item("test", 2, 1.0);
        System.out.println(item.itemNum() + " " + item.price() + " " + item.name());
    }
}
```

Данные записи хранятся в закрытых финальных полях и предоставляются только
методы получения. Следовательно, содержащиеся в записи данные являются
неизменяемыми. После конструирования записи ее содержимое модифицировать нельзя.
Тем не менее, если запись содержит ссылку на какой-то объект, тогда в этот
объект можно вносить изменения, но не разрешено изменять то, на что ссылается
ссылка в записи. Таким образом, в терминах Java говорят, что записи поверхностно
неизменяемы

```java
// Простой пример работы с записями.
// Объявить запись Item, что приведет к автоматическому созданию класса
// с закрытыми финальными полями, имеющими имена name, itemNum и price,
// а также с методами доступа name(), itemNum() и price().
record Item(String name, int itemNum, double price) {
} // <- Объявляется запись

class Code {
    public static void main(String[] args) {
        // Создать массив записей Item.
        Item[] items = new Item[4];
        // Заполнить массив элементами.
        // Аргументы автоматически присваиваются полям name, itemNum
        // и price в создаваемой записи.
        items[0] = new Item("Hammer", 257, 10.99); // Создать экземпляр записи
        items[1] = new Item("Wrench", 18, 19.29);
        items[2] = new Item("Drill", 903, 22.25);
        items[3] = new Item("Saw", 27, 34.59);
        // Использовать методы доступа к содержимому записи
        // для отображения списка товаров ,
        for (Item i : items) {
            System.out.println(i.name() + "; Идентификационный номер: "
                    + i.itemNum() + "; Цена: " + i.price());
        }
    }
}
```

**_Ограничения записей_**

**Запись не может быть унаследована от другого класса**.  
Все записи неявно унаследованы от класса java.lang. Record,
в котором переопределяются абстрактные методы equals(), hashCode() и toString(),
объявленные в Object. Неявные реализации этих методов создаются автоматически
на основе объявления записи.  
**Тип записи не может быть расширен**.   
Таким образом, все объявления записей считаются финальными. Хотя запись не может
расширять другой класс, она может реализовывать один или несколько интерфейсов.
За исключением equals применять имена методов, определенных в Object, для имен
компонентов записи нельзя. Помимо полей, ассоциированных с компонентами записи,
любые другие поля должны быть статическими.   
**Запись может быть обобщенной.**

### Создание конструкторов записи

Можно определить собственную реализацию канонического конструктора.
Например, конструктор может проверять, входит ли значение в требуемый
диапазон, выяснять, находится ли значение в корректном формате,
удостоверяться в том, что объект реализует необязательную функциональность,
или подтверждать, что аргумент не равен null.  
Существуют два основных вида конструкторов, создаваемые явно: канонический и
неканонический, и между ними есть некоторые различия.

#### Объявление канонического конструктора

Существуют два способа, которыми можно написать собственную реализацию.
Во-первых, есть возможность явно объявить полную форму _канонического
конструктора._ Во-вторых, можно использовать так называемый _компактный
канонический конструктор._

Для определения собственной реализации канонического конструктора,
указывается имя записи и список параметров. Важно подчеркнуть, что для
канонического конструктора типы и имена параметров обязаны совпадать с
указанными в объявлении записи. Причина в том, что имена параметров связаны с
автоматически создаваемыми полями и методами доступа, определенными в объявлении
записи. Таким образом, они должны соответствовать как по типу, так и по имени.
Кроме того, после завершения конструктора каждый компонент должен быть полностью
инициализирован.

**Применяются следующие ограничения:**
конструктор должен быть, по меньшей мере, таким же доступным, как в объявлении
записи. Если в записи указан модификатор доступа public, то конструктор тоже
должен быть определен как public. Конструктор не может быть обобщенным и не
может включать конструкцию throws. Он также не может вызывать другой
конструктор, определенный для записи.

```java
record Item(String name, int itemNum, double price) {

    // Явно объявленный канонический конструктор
    public Item(String name, int itemNum, double price) {
        // Удалить ведущие и завершающие пробелы с использованием
        // метода trim() , определенного в классе String ,
        this.name = name.trim();
        // Установить остальные поля в Item ,
        this.itemNum = itemNum;
        this.price = price;
    }
}
```

**_Компактный канонический конструктор_**   
объявляется за счет указания имени записи, но без параметров. Компактный
конструктор неявно имеет параметры, имена которых соответствуют компонентам
записи, а значения аргументов, переданных конструктору, автоматически
присваиваются данным компонентам. Внутри компактного конструктора можно изменить
один или несколько аргументов до того, как их значения будут присвоены
компонентам записи. Можно также сгенерировать исключение в случае возникновения
ошибки или выполнить какую-либо другую процедуру.

```java
record Item(String name, int itemNum, double price) {
    // Компактный канонический конструктор.
    public Item { // <- В компактном каноническом
        // конструкторе параметры не указываются.
        // Удаляем ведущие и завершающие пробелы с использованием
        // метода trim(), определенного в классе String,
        name = name.trim();
        // Полям name, itemNum и price автоматически присваиваются значения
        // соответствующих параметров, когда конструктор завершает работу.
    }
}
```

#### Объявление неканонического конструктора

Основное требование заключается в том, что любой неканонический конструктор
обязан сначала вызывать другой конструктор в записи через this. Объявление
неканонического конструктора позволяет создавать записи для особых случаев.
Скажем, вы можете применять такой конструктор для создания записи, в которой
одному или нескольким компонентам присваивается стандартное
значение-заполнитель. Другой сценарий использования связан с ситуацией, когда
аргумент не находится в форме, совместимой с каноническим конструктором.

```java
// Использование неканонического конструктора.
// Объявить запись для хранения товаров.
record Item(String name, int itemNum, double price) {
    // Использовать статическое поле в записи ,
    static double pricePending = -1;

    // Это неканонический конструктор. Он создает запись, для которой
    // цена товара передается в виде строки, а не значения double.
    // Таким образом, при передаче каноническому конструктору строка должна
    // быть преобразована в значение double,
    public Item(String name, int itemNum, String price) {
        this(name, itemNum, Double.parseDouble(price));
    }
}

class Code {
    public static void main(String[] args) {
        // Создать массив записей Item.
        Item[] items = new Item[4];
        // Создать несколько записей в items. Для этого будет
        // использоваться неявный канонический конструктор ,
        items[0] = new Item("Hammer ", 257, 10.99);
        items[1] = new Item("Wrench", 18, 19.29);
        // При создании следующих записей будет применяться неканонический
        // конструктор, поскольку цена передается в виде строки,
        // а не значения типа double.
        items[2] = new Item("Drill", 903, "22.25");
        items[3] = new Item("Saw", 27, "34.59");
        for (Item i : items) {
            System.out.println(i.name() + "; Идентификационный номер: "
                    + i.itemNum() + "; Цена: " + i.price());
        }
    }
}
```

#### Методы получения для записей

В случае объявления метода получения его неявная версия больше не
предоставляется. Одна из причин объявления собственного метода получения связана
с возможностью генерации исключения, когда не удовлетворено какое-либо условие.
Например, если запись содержит имя файла и URL-адрес, то метод получения для
имени файла может генерировать исключение FileNotFoundException при отсутствии
файла по указанному URL-адресу. Однако существует очень важное требование
относительно создания методов получения: они должны придерживаться принципа
неизменяемости записи. Таким образом, метод получения, возвращающий
модифицированное значение, семантически сомнителен (и его следует избегать),
даже если код будет синтаксически корректным.

**_Ограничения:_**  
К объявлению реализации метода получения применяется несколько правил. Метод
получения обязан иметь такой же тип возвращаемого значения и имя, как у
компонента, который он получает. Кроме того, он должен быть явно объявлен
открытым. (Следовательно, для объявления метода получения в записи стандартной
доступности недостаточно.) В объявлении метода получения не разрешена
конструкция throws. Наконец, метод получения не должен быть ни обобщенным, ни
статическим.

Часто вместо переопределения встроенного метода получения лучше просто создать
метод, возвращающий желаемое значение. Например, в показанной далее версии Item
определен метод по имени DiscountPrice(), который возвращает цену товара со
скидкой на указанный процент. При таком подходе встроенный метод получения
price() не модифицируется, что сохраняет неизменяемость. Если необходимо
значение со скидкой, тогда вместо него вызывается DiscountPrice().

    record Item(String name, int itemNum, double price) (
      // . . .
      double discountPrice(double percentage) {
        return price - (price * percentage / 100.0);
      }
    }

## Сопоставление с образцом в операции instanceof

Общая форма:

    Integer i = 10;
    System.out.println(i instanceof Integer);

Вторая форма операции instanceof, которая поддерживает новую возможность
_сопоставления с образцом_. В общих чертах сопоставление с образцом представляет
собой механизм, который определяет, соответствует ли значение общей форме.

Сопоставление с образцом используется для проверки типа значения (которое должно
быть ссылочным
типом) на соответствие указанному типу. Такой шаблон называется _шаблоном
типа_. Если шаблон совпадает, тогда _шаблонная переменная_ получит ссылку на
объект, соответствующий шаблону.   
Форма операции instanceof, поддерживающая сопоставление с образцом:

    объектная-ссылка instanceof тип шаблонная-переменная

Если операция instanceof завершается успешно, тогда создается шаблонная
переменная, содержащая ссылку на объект, который соответствует образцу. Если
операция instanceof терпит неудачу, то шаблонная переменная создаваться не
будет. Такая форма instanceof выполнится успешно, если объект, на который
ссылается объектная ссылка, может быть приведен к указанному типу, когда
статический тип объектной ссылки не является подтипом указанного типа.

Например, создается переменная типа Number по имени myOb, которая ссылается на
объект Integer. (Вспомните, что Number суперкласс для всех оболочек примитивных
числовых типов.) Затем в коде применяется операция instanceof для подтверждения
того, что объект, на который ссылается myOb, имеет тип Integer, каковым он и
будет в данном примере. В результате создается объект iObj типа Integer,
содержащий совпавшее значение.

```java
class Code {
    public static void main(String[] args) {
        Number myOb = Integer.valueOf(27);   // Переменная iObj
        // создается только в
        // случае успешного выполнения instanceof
        // Использование версии instanceof, поддерживающей
        // сопоставление с образцом.
        if (myOb instanceof Integer iObj) {
            // Здесь переменная iObj известна и находится в области видимости.
            System.out.println("iObj ссылается на целое число: " + iObj);
        }
        // Здесь iObj не существует.
    }
}
```

Переменная iObj известна только внутри области видимости оператора if, но не за
пределами if. Она также не была бы известной в конструкции else при ее наличии.
Критически важно понимать, что шаблонная переменная iObj создается только в
случае успешного сопоставления с образцом.  
Традиционная форма instanceof

```java
class Code {
    public static void main(String[] args) {

        // Использовать традиционную версию instanceof.
        if (myOb instanceof Integer) {
            // Использовать для получения iObj явное приведение.
            Integer iObj = (Integer) myOb;
            System.out.println("iObj ссылается на целое число: " + iObj);
        }
    }
}
```

## Запечатанные классы и интерфейсы

Начиная с версии JDK 17, разрешено объявлять класс, который может наследоваться
только определенными подклассами. Такой класс называется **запечатанным**. До
появления запечатанных классов класс можно было либо расширять через любой
подкласс, либо помечать как final, что полностью предотвращало наследование от
него. Запечатанные классы позволяют точно указывать, каким подклассам разрешено
быть унаследованными от суперкласса. Аналогичным образом можно объявлять
запечатанный интерфейс с указанием реализующих его классов и/или расширяющих его
интерфейсов.

### Запечатанные классы

Чтобы объявить запечатанный класс, необходимо поместить перед объявлением
ключевое слово sealed, а после имени класса указать конструкцию permits с
разрешенными подклассами.

Пример:

    public sealed class Fruit permits Apple, Pear, Grape {
      // ...
    }

Запечатанный класс имеет имя Fruit. Он разрешает наследование от себя только
трем подклассам: Apple, Pear и Grape. При попытке наследования от Fruit любого
другого класса возникнет ошибка на этапе компиляции.   
Важный момент: подкласс запечатанного класса должен быть объявлен как:

- final,
- sealed или
- non-sealed.

**_final_**:

```java
public final class Pear extends Fruit {
}

public final class Apple extends Fruit {
}

public sealed class Fruit permits Apple, Pear {
}
```

Определение класса как final предотвращает наличие у него каких-либо подклассов.
В данном случае это означает, что подклассы Apple запрещены.

**_sealed_**:

Чтобы запечатанным являлся сам подкласс, его необходимо объявить как sealed и
указать разрешенные подклассы. Например:

```java
final class Apple extends Fruit permits AppleSort1, AppleSort2 {
}
```

**_non-sealed_**:

Non-sealed распечатывает подкласс запечатанного класса. Разблокирует подкласс,
позволяя любому другому классу наследоваться от него. Так любой класс может
быть унаследован от Apple.

```java
public non-sealed class Apple extends Fruit {
    // . ..
}
```

Если имя класса присутствует в конструкции permits для запечатанного
класса, тогда этот класс обязан напрямую расширять запечатанный класс, иначе
возникнет ошибка на этапе компиляции. Таким образом, запечатанный класс и
его подклассы определяют взаимозависимую логическую единицу. Кроме того,
объявлять как non-sealed класс, который не расширяет запечатанный класс,
не допускается.

Ключевое требование запечатанного класса состоит в том, что каждый разрешенный
для наследования от него подкласс должен быть доступным. Более того, если
запечатанный класс содержится в именованном модуле, то каждый подкласс должен
находиться в том же самом именованном модуле. В таком случае подкласс может
располагаться не в том же пакете, что и запечатанный класс. Если запечатанный
класс находится в неименованном модуле, тогда запечатанный класс и все
разрешенные для наследования подклассы должны быть определены в одном и том же
пакете.

Суперкласс и его подклассы являются открытыми классами, а потому
каждый из них должен был храниться в отдельном файле (формально в единице
компиляции).
Если подклассы имеют стандартный доступ к
пакету (а не открытый доступ), то запечатанный класс и его подклассы можно
хранить в одном файле. В таких случаях для запечатанного класса не требуется
конструкция permits. Например:

```java
// Поскольку все классы находятся в одном файле,
// конструкция permits в Fruit не требуется ,
public sealed class Fruit {
// ...
}

final class Apple extends Fruit {
// ...
}

final class Pear extends Fruit {
// ...
}

final class Grape extends Fruit {
//...
}
```

### Запечатанные интерфейсы

Запечатанный интерфейс объявляется аналогично запечатанному классу с
применением ключевого слова sealed. Запечатанный интерфейс использует
свою конструкцию permits для указания классов, которым разрешено его
реализовывать, и/или интерфейсов, которым позволяется его расширять. Таким
образом, отсутствующий в конструкции permits класс не может реализовывать
запечатанный интерфейс, а интерфейс, не включенный в конструкцию
permits, не может его расширять.

    public sealed interface FruitIF permits Apple, Pear, Grape {
        String type();
    }

Класс, реализующий запечатанный интерфейс, должен быть определен как
final, sealed или non-sealed.

Любой класс, указанный в конструкции permits запечатанного интерфейса,
обязан реализовывать интерфейс.

В запечатанном интерфейсе также допускается указывать, какие другие интерфейсы
могут его расширять.

Важно:  
Во-первых, интерфейс, указанный в конструкции permits,
обязан расширять разрешающий интерфейс.  
Во-вторых, разрешенный интерфейс должен быть объявлен либо как non-sealed, либо
как sealed.   
В-третьих, класс может наследовать запечатанный класс и реализовывать
запечатанный интерфейс.

Если классы и интерфейсы объявлены открытыми они находятся в собственных файлах.
Однако, как и в случае с запечатанными классами,
запечатанный интерфейс и реализующие его классы (и
расширяющие интерфейсы) также могут храниться в одном файле при условии,
что классы и интерфейсы имеют стандартный доступ к пакету. В случаях
подобного рода для запечатанного интерфейса конструкция permits не требуется.

