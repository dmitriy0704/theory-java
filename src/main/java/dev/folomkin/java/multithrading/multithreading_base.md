# Многопоточность

# Состояния потока в Java

В Java **потоки** (threads) могут находиться в нескольких состояниях,
определённых в классе `Thread.State`. Эти состояния описывают жизненный цикл
потока. Вот полный список состояний потока:

1. **NEW (НОВЫЙ)**  
   Поток создан, но метод `start()` ещё не вызван. Поток находится в этом
   состоянии до запуска.

2. **RUNNABLE (ГОТОВ К ВЫПОЛНЕНИЮ)**  
   Поток выполняется или готов к выполнению, когда процессор выделит ему время.
   Это состояние включает два подвида:
    - Поток активно выполняется (running).
    - Поток ожидает процессорного времени (ready).

3. **BLOCKED (ЗАБЛОКИРОВАН)**  
   Поток ожидает получения монитора (lock) для входа в синхронизированный блок
   или метод. Например, это происходит, когда другой поток удерживает нужный
   монитор.

4. **WAITING (ОЖИДАНИЕ)**  
   Поток находится в бесконечном ожидании, пока другой поток не выполнит
   определённое действие. Это состояние возникает при вызове методов:
    - `Object.wait()`
    - `Thread.join()`
    - `LockSupport.park()`

5. **TIMED_WAITING (ОЖИДАНИЕ С ТАЙМАУТОМ)**  
   Поток ожидает определённое время, пока не произойдёт событие или не истечёт
   таймаут. Это состояние возникает при вызове методов:
    - `Thread.sleep(long millis)`
    - `Object.wait(long timeout)`
    - `Thread.join(long millis)`
    - `LockSupport.parkNanos()` или `LockSupport.parkUntil()`

6. **TERMINATED (ЗАВЕРШЁН)**  
   Поток завершил выполнение (либо метод `run()` завершился, либо произошло
   необработанное исключение). Поток в этом состоянии больше не может быть
   использован.

### Как узнать состояние потока?

Состояние потока можно получить с помощью метода `Thread.getState()`, который
возвращает значение перечисления `Thread.State`.

### Примечания:

- Переходы между состояниями зависят от действий программы, планировщика потоков
  и JVM.
- Состояния `BLOCKED`, `WAITING` и `TIMED_WAITING` связаны с управлением
  синхронизацией и ресурсами.
- Диаграмма жизненного цикла потока полезна для понимания переходов (например,
  NEW → RUNNABLE → TERMINATED или RUNNABLE → WAITING → RUNNABLE).

========================== УДАЛИТЬ ==========================
========================== УДАЛИТЬ ==========================
========================== УДАЛИТЬ ==========================
========================== УДАЛИТЬ ==========================
========================== УДАЛИТЬ ==========================
========================== УДАЛИТЬ ==========================
========================== УДАЛИТЬ ==========================

| Масштабируемость           | ручное управление       | пулы потоков, динамическое распределение  |
| Повторное использование    | каждый поток — новый    | потоки переиспользуются                   |
| Управление задачами        | нет возврата результата | через `Future`, отмена задач              |
| Исключения                 | сложно обрабатывать     | логируются/обрабатываются через `Future`  |
| Контроль завершения работы | нет                     | `shutdown()`, `awaitTermination()` и т.д. |

--- 

## Задачи

В контексте `ExecutorService` (и вообще многопоточности в
Java), **"задача"** — это **единица работы**, которую мы хотим выполнить в
отдельном потоке.

В Java задача — это объект, реализующий один из интерфейсов:

- `Runnable` — если задача **не возвращает результат**
- `Callable<T>` — если задача **возвращает результат** и может выбрасывать
  исключения

Можно представить задачу как команду: "Сделай что-то". И `ExecutorService` —
это менеджер, который принимает такие команды и раздаёт их доступным
работникам (потокам из пула).

**Пример задачи с `Runnable`:**

```java
Runnable task = () -> System.out.println("Печать отчета...");
```

Эта задача просто что-то делает — побочный эффект, но **ничего не возвращает**.

**Пример задачи с `Callable`:**

```java
Callable<Integer> task = () -> {
    int result = 2 + 2;
    return result;
};
```

Эта задача **возвращает значение** — можно получить результат через
`Future<Integer>`.

Ты кидаешь задачи в корзину (`submit()`), сотрудники их берут, делают и отдают
результат на бумажке (`Future.get()`).

_**Реальный пример с задачей, которая:**_

1. Делает какое-то вычисление (например, считает сумму чисел от 1 до N)
2. Возвращает результат
3. Используется через `Callable`
4. Обрабатывается через `Future`

Код:

```java
import java.util.concurrent.*;

public class TaskExample {
    public static void main(String[] args) {
        // 1. Создаём пул потоков
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // 2. Создаём задачу
        Callable<Integer> task = () -> {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
                Thread.sleep(10); // имитируем задержку
            }
            return sum;
        };

        // 3. Отправляем задачу в ExecutorService
        Future<Integer> future = executor.submit(task);

        // 4. Делаем что-то параллельно (для примера)
        System.out.println("Задача запущена. Выполняем другие действия...");

        try {
            // 5. Получаем результат (блокирует поток, пока не готово)
            Integer result = future.get();
            System.out.println("Результат вычислений: " + result);
        } catch (InterruptedException | ExecutionException e) {
            System.out.println("Произошла ошибка при выполнении задачи: " + e.getMessage());
        }

        // 6. Завершаем работу ExecutorService
        executor.shutdown();
    }
}
```

Что происходит шаг за шагом:

1. Мы создаём пул из одного потока (можно больше).
2. Описываем задачу — простое сложение чисел с задержкой.
3. Передаём задачу на выполнение.
4. Пока задача выполняется — основной поток может делать что-то ещё.
5. Получаем результат с помощью `future.get()`.
6. Завершаем работу пула.

### Основные характеристики задач:

1. **Единица работы**: Задача — это конкретная работа или операция, которую
   нужно выполнить. Это может быть что угодно: от простого вычисления до сложной
   обработки данных.

2. **Асинхронность**: Задачи могут выполняться асинхронно, что позволяет
   основному потоку продолжать выполнение других операций, не дожидаясь
   завершения задачи.

3. **Возврат результата**:
    - **Runnable**: Задачи, реализующие интерфейс `Runnable`, не возвращают
      результат. Метод `run()` этого интерфейса имеет тип `void`.
    - **Callable**: Задачи, реализующие интерфейс `Callable`, могут возвращать
      результат и могут выбрасывать проверяемые исключения. Метод `call()` этого
      интерфейса возвращает значение.

4. **Управление состоянием**: Каждая задача может находиться в одном из
   нескольких состояний (например, ожидает выполнения, выполняется или
   завершена). Это состояние можно отслеживать с помощью объекта типа `Future`,
   который возвращается при отправке задачи на выполнение.

### Параллельный запуск нескольких задач

_**InvokeAll():**_

Пример:

Запускаем **несколько задач параллельно**<br>
Каждая считает сумму от 1 до своего числа N<br>
Собираем **все результаты**<br>
Используем `ExecutorService` и `List<Future>`

_**Пример: несколько задач параллельно**_

```java
import java.util.concurrent.*;
import java.util.*;

public class MultiTaskExample {
    public static void main(String[] args) throws InterruptedException {
        // 1. Пул из 3 потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // 2. Список задач (Callable)
        List<Callable<Integer>> tasks = new ArrayList<>();
        for (int n : List.of(100, 200, 300)) {
            tasks.add(() -> {
                int sum = 0;
                for (int i = 1; i <= n; i++) {
                    sum += i;
                    Thread.sleep(5); // имитируем задержку
                }
                System.out.println("Задача для " + n + " завершена");
                return sum;
            });
        }

        // 3. Отправляем все задачи и получаем список Future
        List<Future<Integer>> results = executor.invokeAll(tasks);

        // 4. Обрабатываем результаты
        for (Future<Integer> future : results) {
            try {
                Integer result = future.get();
                System.out.println("Результат: " + result);
            } catch (ExecutionException e) {
                System.out.println("Ошибка в задаче: " + e.getMessage());
            }
        }

        // 5. Завершаем Executor
        executor.shutdown();


        // -> Задача для 100 завершена
        // Задача для 200 завершена
        // Задача для 300 завершена
        // Результат: 5050
        // Результат: 20100
        // Результат: 45150
    }
}
```

_**Что делает `invokeAll()`?**_

- Принимает список задач (`List<Callable<T>>`)
- Запускает их параллельно
- Возвращает список `Future<T>` — по одному на каждую задачу

`invokeAll()` **ждёт**, пока все задачи завершатся — это удобно для пакетной
обработки.

invokeAny();

`invokeAny()` — это почти как `invokeAll()`, **но он ждёт только первую
успешно завершённую задачу**, и:

- Возвращает **только один результат**
- Остальные задачи **отменяются**
- Это удобно, когда нужно просто получить **первый доступный ответ**, а не все

**Пример: `invokeAny()` в действии**

```java
import java.util.concurrent.*;
import java.util.*;

public class InvokeAnyExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Список задач с разной задержкой
        List<Callable<String>> tasks = List.of(
                () -> {
                    Thread.sleep(3000);
                    return "Результат из задачи 1 (3 сек)";
                },
                () -> {
                    Thread.sleep(1000);
                    return "Результат из задачи 2 (1 сек)";
                },
                () -> {
                    Thread.sleep(2000);
                    return "Результат из задачи 3 (2 сек)";
                }
        );

        try {
            // invokeAny ждёт первую выполненную и возвращает её результат
            String fastestResult = executor.invokeAny(tasks);
            System.out.println("Самая быстрая задача вернула: " + fastestResult);
        } catch (ExecutionException e) {
            System.out.println("Ошибка при выполнении одной из задач: " + e.getMessage());
        }

        executor.shutdown();
    }
}
```

**Что произойдёт:**

- Все 3 задачи стартуют одновременно.
- Первая, которая закончится — это вторая (через 1 сек).
- `invokeAny()` сразу возвращает её результат.
- Остальные 2 задачи отменяются автоматически.

Если все задачи упадут с ошибкой — `invokeAny()` выбросит `ExecutionException`.

Вывод:

```
Самая быстрая задача вернула: Результат из задачи 2 (1 сек)
```

Такой подход полезен, например, при:

- Обращении к нескольким серверам — взять ответ того, кто быстрее
- Поиске в разных источниках
- Параллельных попытках — "кто первый, тот и молодец"

## Асинхронные задачи

**Асинхронные задачи** — это задачи, которые выполняются независимо от основного
потока выполнения программы. Это означает, что основной поток может продолжать
свою работу, не дожидаясь завершения асинхронной задачи. Асинхронное выполнение
позволяет улучшить отзывчивость приложений, особенно в тех случаях, когда
требуется выполнение длительных операций, таких как сетевые запросы, операции
ввода-вывода или сложные вычисления. Асинхронные задачи могут выполняться в
фоновом режиме, позволяя основному потоку продолжать выполнение других операций.
После завершения асинхронной задачи можно обработать результаты выполнения. В
Java для этого часто используются объекты`Future` и `Callable`, которые
позволяют получить результат выполнения задачи или обработать исключения.
Асинхронные задачи могут быть настроены на выполнение с тайм-аутами или отменой,
что позволяет избежать зависания приложения при выполнении долгих операций.

### Callable

`Callable` — это функциональный интерфейс в Java, представляющий собой
задачу, которая может быть выполнена асинхронно и возвращает результат. Он
является частью пакета `java.util.concurrent` и часто используется в сочетании с
`ExecutorService` для выполнения задач в фоновом режиме.

В отличие от интерфейса `Runnable`, который не
возвращает результат (метод `run()` имеет тип `void`), метод `call()`
интерфейса `Callable` возвращает значение. Это позволяет получать результат
выполнения задачи.

Метод `call()` может выбрасывать проверяемые
исключения (checked exceptions), что позволяет обрабатывать ошибки,
возникающие во время выполнения задачи. В случае с `Runnable`, все исключения
должны обрабатываться внутри метода `run()`.

Когда задача, реализующая интерфейс `Callable`,
отправляется на выполнение через `ExecutorService`, она возвращает объект
типа `Future`. Этот объект позволяет проверять статус выполнения задачи и
получать результат после ее завершения.

## Задачи и потоки

Задачи и потоки в контексте многопоточности в Java тесно связаны между собой,
поскольку задачи представляют собой единицы работы, которые выполняются в
потоках.

### 1. **Определение потоков и задач**

- **Поток**: Поток — это отдельная последовательность выполнения в программе.
  Каждый поток имеет свой собственный стек вызовов и может выполняться
  параллельно с другими потоками. В Java потоки создаются с помощью класса
  `Thread` или через интерфейсы, такие как `Runnable` и `Callable`.

- **Задача**: Задача — это конкретная работа или операция, которую нужно
  выполнить. В Java задачи могут быть реализованы через интерфейсы `Runnable` (
  для задач без результата) и `Callable` (для задач с результатом).

### 2. **Выполнение задач в потоках**

Когда вы отправляете задачу на выполнение в `ExecutorService`, она будет
выполнена в одном из потоков пула потоков. Вот как это работает:

- **Создание пула потоков**: При создании экземпляра `ExecutorService`, вы
  определяете пул потоков, который будет использоваться для выполнения задач.
  Например, с помощью метода `Executors.newFixedThreadPool(n)` создается пул из
  `n` потоков.

- **Отправка задач**: Когда вы отправляете задачу на выполнение (например, через
  метод `submit()`), `ExecutorService` выбирает один из доступных потоков из
  пула для выполнения этой задачи.

- **Асинхронное выполнение**: Задачи могут выполняться асинхронно, что означает,
  что основной поток программы может продолжать выполнение других операций, не
  дожидаясь завершения задачи.

### 3. **Параллелизм и многопоточность**

Использование задач и потоков позволяет реализовать параллелизм:

- **Параллельное выполнение**: Если у вас есть несколько задач, которые могут
  выполняться одновременно (например, обработка данных или выполнение сетевых
  запросов), вы можете отправить их на выполнение в пул потоков. Пул будет
  распределять задачи между доступными потоками, что позволяет выполнять их
  параллельно.

- **Управление ресурсами**: Пулы потоков помогают управлять ресурсами более
  эффективно. Вместо создания нового потока для каждой задачи (что может быть
  затратным по времени и ресурсам), вы можете повторно использовать существующие
  потоки для выполнения новых задач.

## Future

Объект `Future`, возвращаемый интерфейсом `Callable` в Java, представляет собой
результат асинхронной операции. Он предоставляет методы для проверки состояния
выполнения задачи, получения результата и обработки возможных исключений,
которые могут возникнуть во время выполнения задачи. Давайте рассмотрим основные
аспекты объекта `Future` более подробно.

#### Основные характеристики объекта `Future`

1. **Асинхронный результат**: Объект `Future` позволяет вам получить результат
   выполнения задачи, которая была отправлена на выполнение в пул потоков или
   другой механизм многопоточности. Поскольку задача выполняется асинхронно, вы
   можете продолжать выполнение других операций в основном потоке, не дожидаясь
   завершения задачи.

2. **Методы для управления состоянием**:
    - `isDone()`: Возвращает `true`, если задача завершена (независимо от того,
      была ли она выполнена успешно или завершилась с ошибкой).
    - `isCancelled()`: Возвращает `true`, если задача была отменена до ее
      завершения.
    - `cancel(boolean mayInterruptIfRunning)`: Пытается отменить выполнение
      задачи. Если задача уже выполняется и параметр `mayInterruptIfRunning`
      равен `true`, то выполнение задачи может быть прервано.

3. **Получение результата**:
    - `get()`: Блокирует текущий поток до тех пор, пока задача не завершится, и
      возвращает результат выполнения задачи. Если задача завершилась с
      исключением, метод `get()` выбросит это исключение.
    - `get(long timeout, TimeUnit unit)`: Блокирует текущий поток до тех пор,
      пока задача не завершится или не истечет указанный таймаут.

#### Пример использования объекта Future

Вот пример кода, который демонстрирует использование интерфейса `Callable` и
объекта `Future`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Определяем задачу Callable
        Callable<Integer> task = () -> {
            // Имитация длительной операции
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует текущий поток до получения результата
            System.out.println("Результат: " + result);
        } catch (InterruptedException e) {
            System.err.println("Задача была прервана");
        } catch (ExecutionException e) {
            System.err.println("Ошибка при выполнении задачи: " + e.getCause());
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу типа `Callable`, которая
   имитирует длительную операцию (например, задержку на 2 секунды) и возвращает
   значение 42.

3. **Отправка задачи**: Мы отправляем задачу на выполнение через метод
   `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы вызываем метод `get()` у объекта `Future`, чтобы
   получить результат выполнения задачи. Этот вызов блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения:
    - `InterruptedException`: Выбрасывается, если текущий поток был прерван во
      время ожидания результата.
    - `ExecutionException`: Выбрасывается, если задача завершилась с ошибкой; в
      этом случае мы можем получить причину ошибки через метод `getCause()`.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

### Заключение

Объект `Future` является важным компонентом многопоточного программирования в
Java, позволяя управлять асинхронными задачами и получать результаты их
выполнения. Он предоставляет удобные методы для проверки состояния задач и
обработки результатов или ошибок, что делает его полезным инструментом для
работы с параллельными вычислениями.

## Реализации ExecutorService

ThreadPoolExecutor
ScheduledThreadPoolExecutor
CachedThreadPoolExecutor
ForkJoinPool

#### **ThreadPoolExecutor**

ThreadPoolExecutor – это реализация интерфейса ExecutorService в Java, который
предоставляет пул потоков исполнения для выполнения задач в фоновом режиме.

ThreadPoolExecutor позволяет создать и настроить пул потоков исполнения с
определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения задач в фоновом режиме, что может улучшить
производительность и реактивность вашего приложения.

#### **ScheduledThreadPoolExecutor**

ScheduledThreadPoolExecutor – это реализация интерфейса ScheduledExecutorService
в Java, который предоставляет пул потоков исполнения для выполнения задач в
определенный момент времени или с определенной периодичностью.

ScheduledThreadPoolExecutor позволяет создать и настроить пул потоков исполнения
с определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения регулярных задач в фоновом режиме, что может
улучшить производительность и реактивность вашего приложения.

#### **CachedThreadPoolExecutor**

CachedThreadPoolExecutor – это реализация интерфейса ExecutorService в Java,
который предоставляет пул потоков исполнения для выполнения задач в фоновом
режиме.

CachedThreadPoolExecutor автоматически масштабирует количество потоков
исполнения в зависимости от количества задач, которые нужно выполнить. Если
задачи поступают слишком быстро и текущее количество потоков исполнения не может
справиться с ними, CachedThreadPoolExecutor создает новый поток исполнения,
чтобы обеспечить выполнение задачи. Если задачи не поступают достаточно быстро и
текущее количество потоков исполнения избыточно, CachedThreadPoolExecutor
автоматически удаляет потоки исполнения, чтобы уменьшить нагрузку на систему.

#### **ForkJoinPool**

ForkJoinPool – это реализация ExecutorService в Java, которая используется для
параллельного выполнения задач. Эти задачи могут быть разбиты на более мелкие
подзадачи. Она позволяет использовать принцип “разделяй и властвуй” для более
эффективного использования многопроцессорных и многопоточных систем.

_**Основные компоненты ForkJoinPool:**_

**Пул потоков исполнения**

ForkJoinPool управляет пулом потоков исполнения, которые используются для
выполнения задач. Количество потоков исполнения в пуле задается при создании
экземпляра ForkJoinPool. Каждый поток в пуле имеет свой собственный стек
вызовов, что позволяет ForkJoinPool улучшить производительность в случае, когда
задачи могут быть разбиты на более мелкие подзадачи.

**Разбиение и объединение задач:**

ForkJoinPool поддерживает работу с задачами типа RecursiveAction и
RecursiveTask, которые представляют собой рекурсивно делимые задачи без
возвращаемого значения и с возвращаемым значением соответственно. Когда
ForkJoinPool получает задачу типа RecursiveTask, он разбивает ее на более мелкие
подзадачи, выполняет их параллельно в разных потоках и объединяет результаты
выполнения в единую итоговую задачу.

# Atomic пакет Механизм под капотом (CAS)

## Atomic пакет

Пакет `java.util.concurrent.atomic` в Java предоставляет набор классов для
выполнения атомарных операций, то есть операций, которые выполняются как единое,
неделимое действие, гарантируя отсутствие вмешательства со стороны других
потоков. Это полезно в многопоточных приложениях, где требуется безопасная
работа с общими переменными без использования явных блокировок (`synchronized`).

### Основные характеристики

1. **Атомарность**: Операции, такие как чтение, запись или обновление
   переменных, выполняются как единое целое, исключая состояние гонки (race
   condition).
2. **Отсутствие блокировок**: Используются низкоуровневые механизмы, такие как *
   *Compare-and-Swap (CAS)**, что делает операции более эффективными по
   сравнению с `synchronized`.
3. **Высокая производительность**: Подход CAS (оптимистическая блокировка)
   минимизирует накладные расходы на синхронизацию, особенно при низкой
   конкуренции потоков.
4. **Поддержка примитивов и ссылок**: Классы пакета поддерживают работу с
   примитивными типами (`int`, `long`, `boolean`), ссылками и массивами.

### Основные классы

Пакет `java.util.concurrent.atomic` содержит следующие ключевые классы:

1. **AtomicInteger**: Для атомарной работы с целыми числами (`int`).
2. **AtomicLong**: Для работы с длинными целыми числами (`long`).
3. **AtomicBoolean**: Для работы с булевыми значениями.
4. **AtomicReference<V>**: Для атомарной работы с объектами любого типа.
5. **AtomicIntegerArray**, **AtomicLongArray**, **AtomicReferenceArray**: Для
   работы с массивами соответствующих типов.
6. **AtomicMarkableReference**, **AtomicStampedReference**: Для атомарных
   операций с дополнительными метками или версиями (например, для предотвращения
   проблемы ABA в CAS).
7. **Adder и Accumulator**:
    - `LongAdder`, `DoubleAdder`: Оптимизированы для подсчета (например,
      инкремента) в условиях высокой конкуренции.
    - `LongAccumulator`, `DoubleAccumulator`: Для обобщенных накопительных
      операций.
8. **AtomicReferenceFieldUpdater**, **AtomicIntegerFieldUpdater**, *
   *AtomicLongFieldUpdater**: Для атомарного обновления полей объектов.

### Основные методы

Большинство классов (`AtomicInteger`, `AtomicLong`, `AtomicReference` и др.)
предоставляют схожие методы:

- **get()**: Получить текущее значение.
- **set(T value)**: Установить новое значение.
- **getAndSet(T value)**: Установить новое значение и вернуть старое.
- **compareAndSet(T expected, T update)**: Атомарно обновить значение, если
  текущее равно ожидаемому.
- **getAndIncrement()**, **getAndDecrement()** (для числовых типов):
  Увеличить/уменьшить значение и вернуть старое.
- **incrementAndGet()**, **decrementAndGet()**: Увеличить/уменьшить значение и
  вернуть новое.
- **getAndUpdate(UpdateFunction)**, **updateAndGet(UpdateFunction)**: Применить
  функцию к текущему значению и вернуть старое/новое значение.
- **lazySet(T value)**: Установить значение с возможной задержкой (менее строгая
  синхронизация для оптимизации).

### Пример использования

#### 1. AtomicInteger

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);

        // Несколько потоков увеличивают счетчик
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.incrementAndGet();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Итоговое значение: " + counter.get()); // 2000
    }
}
```

Здесь `AtomicInteger` гарантирует, что инкремент счетчика будет безопасным в
многопоточной среде.

#### 2. AtomicReference

```java
import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceExample {
    public static void main(String[] args) {
        AtomicReference<String> ref = new AtomicReference<>("Initial");

        // Атомарное обновление
        boolean success = ref.compareAndSet("Initial", "Updated");
        System.out.println("Успех: " + success); // true
        System.out.println("Значение: " + ref.get()); // Updated
    }
}
```

#### 3. LongAdder

```java
import java.util.concurrent.atomic.LongAdder;

public class LongAdderExample {
    public static void main(String[] args) throws InterruptedException {
        LongAdder adder = new LongAdder();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                adder.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Сумма: " + adder.sum()); // 2000
    }
}
```

`LongAdder` эффективен при высокой конкуренции, так как распределяет обновления
между несколькими счетчиками.

### Когда использовать

- **AtomicInteger/Long/Boolean**: Для счетчиков, флагов или других примитивных
  значений, требующих атомарных операций.
- **AtomicReference**: Для безопасного обновления ссылок на объекты (например, в
  структурах данных).
- **LongAdder/DoubleAdder**: Для сценариев с частыми обновлениями (например,
  статистика, счетчики событий).
- **Atomic*Array**: Для работы с массивами в многопоточной среде.
- **Atomic*FieldUpdater**: Для атомарного обновления полей объектов без создания
  новых экземпляров.

### Преимущества

- **Безопасность без блокировок**: CAS-операции минимизируют конкуренцию по
  сравнению с `synchronized`.
- **Производительность**: Особенно эффективны при низкой или средней конкуренции
  потоков.
- **Простота**: Упрощают написание потокобезопасного кода без сложной
  синхронизации.
- **Гибкость**: Поддерживают сложные сценарии, такие как условные обновления (
  `compareAndSet`).

### Ограничения

- **Ограниченные операции**: Поддерживают только определенные типы атомарных
  операций (например, инкремент, сравнение и замена).
- **Проблема ABA**: В `compareAndSet` может возникнуть проблема ABA (когда
  значение меняется A → B → A, и CAS не замечает изменений). Для этого
  используются `AtomicStampedReference` или `AtomicMarkableReference`.
- **Производительность при высокой конкуренции**: CAS может приводить к
  множественным попыткам обновления, что снижает производительность. В таких
  случаях `LongAdder` или `LongAccumulator` предпочтительнее.

### Сравнение с `synchronized`

- **`synchronized`**:
    - Использует блокировку, что может привести к простоям потоков.
    - Подходит для сложной синхронизации, где требуется блокировать несколько
      операций.
    - Более высокие накладные расходы при высокой конкуренции.
- **Atomic**:
    - Использует CAS, избегая блокировок.
    - Подходит для простых операций (например, инкремент, обновление значения).
    - Более эффективен при низкой конкуренции, но может быть менее эффективен
      при высокой.

### Пример сравнения

Без `AtomicInteger` с использованием `synchronized`:

```java
class Counter {
    private int count = 0;

    synchronized void increment() {
        count++;
    }

    int get() {
        return count;
    }
}
```

С `AtomicInteger`:

```java
class Counter {
    private AtomicInteger count = new AtomicInteger(0);

    void increment() {
        count.incrementAndGet();
    }

    int get() {
        return count.get();
    }
}
```

`AtomicInteger` более лаконичен и часто быстрее, так как избегает блокировок.

### Итог

Пакет `java.util.concurrent.atomic` предоставляет мощные инструменты для
потокобезопасной работы с переменными без явных блокировок. Он идеально подходит
для счетчиков, флагов, атомарных обновлений объектов и сценариев с высокой
конкуренцией (с использованием `LongAdder`). Однако для сложной синхронизации,
включающей несколько операций, может потребоваться `synchronized` или другие
механизмы из `java.util.concurrent`.

Если у вас есть конкретный сценарий или вопрос по использованию классов
`atomic`, напишите, и я помогу с примером или разъяснением!

## CAS

Механизм **CAS (Compare-and-Swap)** — это низкоуровневая атомарная операция,
используемая в многопоточных приложениях для безопасного обновления значений без
явных блокировок. В Java CAS широко применяется в классах пакета
`java.util.concurrent.atomic` (например, `AtomicInteger`, `AtomicReference`) и
других структурах данных для обеспечения потокобезопасности. Рассмотрим его
подробнее.

### Что такое CAS?

CAS — это операция, которая атомарно сравнивает текущее значение переменной с
ожидаемым значением и, если они совпадают, обновляет переменную новым значением.
Если значения не совпадают, операция не выполняется, и переменная остается
неизменной. Атомарность гарантирует, что операция выполняется как единое целое,
без вмешательства других потоков.

**Формат CAS**:

```
boolean compareAndSwap(T expectedValue, T newValue)
```

- **expectedValue**: Ожидаемое значение переменной.
- **newValue**: Новое значение, которое будет установлено, если текущее значение
  равно `expectedValue`.
- **Возвращаемое значение**: `true`, если обновление успешно, `false`, если
  текущее значение не совпадает с ожидаемым.

### Как работает CAS?

1. Поток читает текущее значение переменной (например, `A`).
2. Поток готовит новое значение (например, `B`).
3. CAS сравнивает текущее значение переменной с ожидаемым (`A`):
    - Если текущее значение равно `A`, переменная обновляется до `B`, и
      возвращается `true`.
    - Если текущее значение не равно `A` (например, другой поток изменил его на
      `C`), обновление не происходит, и возвращается `false`.
4. Если CAS не удалось, поток может повторить попытку (чтение → подготовка →
   CAS), что называется **оптимистической блокировкой**.

### Пример CAS в Java

В `AtomicInteger` метод `compareAndSet` использует CAS:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class CASExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(100);

        // Попытка обновить значение с 100 на 200
        boolean success = counter.compareAndSet(100, 200);
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + counter.get()); // 200

        // Попытка обновить с неверным ожидаемым значением
        success = counter.compareAndSet(100, 300);
        System.out.println("Успех: " + success); // false
        System.out.println("Значение: " + counter.get()); // 200
    }
}
```

### Реализация CAS

CAS обычно реализуется на уровне аппаратного обеспечения (процессором) через
специальные инструкции, такие как `cmpxchg` (Compare and Exchange) на
архитектурах x86. В Java это реализовано через нативные методы, использующие
библиотеку `sun.misc.Unsafe` или аналогичные механизмы JVM.

Пример псевдокода CAS:

```java
boolean compareAndSwap(Variable var, T expected, T newValue) {
    if (var.get() == expected) {
        var.set(newValue);
        return true;
    }
    return false;
}
```

На деле это атомарная инструкция, выполняемая процессором за один цикл.

### Преимущества CAS

1. **Без блокировок**: Избегает накладных расходов на синхронизацию (
   `synchronized`), что делает его быстрее при низкой конкуренции.
2. **Производительность**: Эффективен в сценариях, где конфликты между потоками
   редки.
3. **Простота**: Упрощает написание потокобезопасного кода для простых
   операций (например, счетчики, флаги).
4. **Широкое применение**: Используется в `Atomic*` классах, неблокирующих
   структурах данных (например, `ConcurrentHashMap`, `ConcurrentLinkedQueue`).

### Недостатки CAS

1. **Проблема ABA**:
    - Ситуация, когда значение переменной меняется с `A` на `B` и обратно на
      `A`. CAS может принять это как отсутствие изменений, что приводит к
      ошибкам.
    - Решение: Использование `AtomicStampedReference` или
      `AtomicMarkableReference`, которые добавляют метку или версию.
    - Пример проблемы ABA:
        - Поток 1 читает значение `A` и готовит CAS.
        - Поток 2 меняет `A` на `B`, затем на `A`.
        - Поток 1 выполняет CAS, думая, что значение не изменилось, хотя оно
          было модифицировано.
2. **Высокая конкуренция**:
    - При большом количестве потоков CAS может приводить к множественным
      неудачным попыткам, что снижает производительность.
    - В таких случаях `LongAdder` или `LongAccumulator` предпочтительнее, так
      как они распределяют нагрузку.
3. **Ограниченные операции**: CAS подходит только для простых обновлений (
   например, замена значения), но не для сложной логики, требующей нескольких
   операций.

### Пример с повторными попытками

Если CAS не удался, поток может повторить попытку:

```java
AtomicInteger counter = new AtomicInteger(0);

void safeIncrement() {
    while (true) {
        int current = counter.get();
        int next = current + 1;
        if (counter.compareAndSet(current, next)) {
            break; // Успех
        }
        // Иначе повторяем
    }
}
```

Этот подход называется **spin-lock** (цикл ожидания), так как поток активно
пытается выполнить операцию, пока не добьется успеха.

### Сравнение с `synchronized`

- **CAS**:
    - Оптимистическая блокировка: предполагает, что конфликты редки, и повторяет
      попытки при неудаче.
    - Быстрее при низкой конкуренции.
    - Не блокирует потоки, но может тратить CPU на повторные попытки.
- **synchronized**:
    - Пессимистическая блокировка: блокирует доступ других потоков к критической
      секции.
    - Прост в использовании для сложной логики, но имеет большие накладные
      расходы при высокой конкуренции.

### Применение CAS в Java

1. **Пакет `java.util.concurrent.atomic`**:
    - `AtomicInteger`, `AtomicLong`, `AtomicReference` и др. используют CAS для
      операций вроде `incrementAndGet`, `compareAndSet`.
2. **Неблокирующие структуры данных**:
    - `ConcurrentHashMap`, `ConcurrentLinkedQueue` используют CAS для
      безопасного обновления своих внутренних структур.
3. **Параллельные алгоритмы**:
    - Например, в `ForkJoinPool` или `parallelStream` для координации задач.
4. **Кастомизация**:
    - Разработчики могут использовать `sun.misc.Unsafe` (не рекомендуется) или
      писать собственные неблокирующие алгоритмы на основе CAS.

### Итог

CAS — это мощный механизм для атомарных операций без блокировок, лежащий в
основе многих потокобезопасных конструкций в Java. Он эффективен для простых
обновлений (например, счетчиков, флагов), но требует осторожности из-за проблемы
ABA и возможных проблем с производительностью при высокой конкуренции. Для
большинства задач достаточно использовать классы из
`java.util.concurrent.atomic`, которые уже реализуют CAS безопасно и эффективно.

## Условные обновления

Условное обновление в контексте программирования, особенно в многопоточных
приложениях Java, — это операция, которая изменяет значение переменной только
при выполнении определенного условия. Обычно это связано с механизмом *
*Compare-and-Swap (CAS)** или аналогичными подходами, где обновление значения
происходит только в том случае, если текущее значение переменной соответствует
ожидаемому. В Java условное обновление чаще всего реализуется с использованием
классов из пакета `java.util.concurrent.atomic`, таких как `AtomicInteger`,
`AtomicLong`, `AtomicReference` и других.

### Что такое условное обновление?

Условное обновление — это атомарная операция, которая:

1. Проверяет текущее значение переменной.
2. Сравнивает его с ожидаемым значением.
3. Если они совпадают, обновляет переменную новым значением.
4. Если не совпадают, операция не выполняется (или возвращается `false`, чтобы
   сигнализировать об этом).

Такой подход используется для обеспечения потокобезопасности без блокировок,
избегая состояний гонки (race conditions) в многопоточных приложениях.

### Основной механизм: Compare-and-Swap (CAS)

Условное обновление в Java чаще всего реализуется через CAS, который атомарно
выполняет сравнение и замену. Основной метод для этого —
`compareAndSet(expectedValue, newValue)`:

- Если текущее значение равно `expectedValue`, оно заменяется на `newValue`, и
  метод возвращает `true`.
- Если текущее значение не равно `expectedValue`, обновление не происходит, и
  метод возвращает `false`.

### Пример условного обновления

#### С использованием `AtomicInteger`

```java
import java.util.concurrent.atomic.AtomicInteger;

public class ConditionalUpdateExample {
    public static void main(String[] args) {
        AtomicInteger value = new AtomicInteger(10);

        // Условное обновление: изменить значение на 20, если текущее значение равно 10
        boolean success = value.compareAndSet(10, 20);
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + value.get()); // 20

        // Повторная попытка с неверным ожидаемым значением
        success = value.compareAndSet(10, 30);
        System.out.println("Успех: " + success); // false
        System.out.println("Значение: " + value.get()); // 20
    }
}
```

#### С использованием `AtomicReference`

```java
import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceExample {
    public static void main(String[] args) {
        AtomicReference<String> ref = new AtomicReference<>("OldValue");

        // Условное обновление: заменить "OldValue" на "NewValue"
        boolean success = ref.compareAndSet("OldValue", "NewValue");
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + ref.get()); // NewValue
    }
}
```

### Применение условного обновления

1. **Счетчики**:
    - Например, атомарное увеличение счетчика только при определенных условиях.
    - `AtomicInteger` использует CAS для методов вроде `incrementAndGet`,
      которые внутренне проверяют текущее значение.
2. **Потокобезопасные структуры данных**:
    - В `ConcurrentHashMap`, `ConcurrentLinkedQueue` и других неблокирующих
      структурах CAS используется для обновления узлов или значений.
3. **Управление состоянием**:
    - Например, изменение флага (`AtomicBoolean`) только при определенном
      состоянии.
4. **Кэши или ленивая инициализация**:
    - Обновление значения в кэше только если оно отсутствует или устарело.
5. **Пользовательские алгоритмы**:
    - Реализация неблокирующих алгоритмов, таких как списки, деревья или
      очереди.

### Пример с повторными попытками

Если условное обновление не удалось (например, из-за изменения значения другим
потоком), можно повторить попытку:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class RetryCASExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);

        // Условное увеличение счетчика
        while (true) {
            int current = counter.get();
            int next = current + 1;
            if (counter.compareAndSet(current, next)) {
                System.out.println("Успешно обновлено до: " + counter.get());
                break;
            }
            // Повторяем, если значение изменилось
        }
    }
}
```

Этот подход называется **spin-lock** — поток продолжает пытаться обновить
значение, пока не добьется успеха.

### Преимущества условного обновления

1. **Без блокировок**: Использует CAS, что снижает накладные расходы по
   сравнению с `synchronized`.
2. **Потокобезопасность**: Гарантирует атомарность операций, избегая состояний
   гонки.
3. **Гибкость**: Позволяет реализовать сложные сценарии, где обновление зависит
   от текущего состояния.
4. **Производительность**: Эффективно при низкой конкуренции потоков, так как не
   блокирует другие потоки.

### Недостатки

1. **Проблема ABA**:
    - Если значение переменной изменилось с `A` на `B` и обратно на `A`, CAS
      может ошибочно принять это как отсутствие изменений.
    - Решение: Использование `AtomicStampedReference` или
      `AtomicMarkableReference`, которые добавляют метку или версию.
2. **Высокая конкуренция**:
    - При большом количестве потоков, пытающихся выполнить CAS, могут возникать
      множественные неудачные попытки, что снижает производительность.
    - В таких случаях лучше использовать `LongAdder` или `LongAccumulator`.
3. **Ограниченная применимость**:
    - Подходит только для операций, которые можно выразить как сравнение и
      замену одного значения.

### Связь с другими механизмами

- **ExecutorService и ThreadPoolExecutor**: Условное обновление может
  использоваться внутри задач для управления общими ресурсами (например,
  счетчиков).
- **ForkJoinPool**: В рекурсивных задачах CAS может применяться для обновления
  промежуточных результатов.
- **Пакет `java.util.concurrent.atomic`**: Основной инструмент для условного
  обновления в Java, реализующий CAS для различных типов данных.

### Итог

Условное обновление — это механизм, позволяющий безопасно изменять значения
переменных в многопоточной среде, основанный на проверке текущего состояния (
обычно через CAS). Он широко используется в классах `Atomic*`, неблокирующих
структурах данных и кастомных алгоритмах. Это мощный инструмент для
потокобезопасности, но требует осторожности из-за проблем вроде ABA и
производительности при высокой конкуренции.

## Ожидаемое значение

В механизме **CAS (Compare-and-Swap)** в Java **ожидаемое значение** — это
значение, которое поток предполагает находится в переменной на момент выполнения
операции CAS. Оно используется для проверки, не было ли значение переменной
изменено другим потоком перед обновлением. Ожидаемое значение является ключевой
частью условного обновления, так как CAS сравнивает текущее значение переменной
с ожидаемым, чтобы решить, выполнять обновление или нет.

### Подробное объяснение

CAS-операция принимает три параметра:

1. **Ожидаемое значение** (`expectedValue`): Значение, которое, по мнению
   потока, в данный момент хранится в переменной.
2. **Новое значение** (`newValue`): Значение, на которое нужно заменить текущее,
   если проверка пройдет успешно.
3. **Текущее значение**: Фактическое значение переменной в момент выполнения
   CAS.

Процесс CAS:

- Сравнивается **текущее значение** переменной с **ожидаемым значением**.
- Если они совпадают, переменная обновляется до **нового значения**, и операция
  возвращает `true`.
- Если они не совпадают (значение было изменено другим потоком), обновление не
  происходит, и операция возвращает `false`.

### Пример с `AtomicInteger`

```java
import java.util.concurrent.atomic.AtomicInteger;

public class CASExpectedValueExample {
    public static void main(String[] args) {
        AtomicInteger value = new AtomicInteger(5);

        // Поток предполагает, что текущее значение = 5 (ожидаемое значение)
        int expectedValue = 5;
        int newValue = 10;

        // Пытаемся обновить значение с 5 на 10
        boolean success = value.compareAndSet(expectedValue, newValue);
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + value.get()); // 10

        // Теперь ожидаемое значение = 5, но текущее значение уже 10
        success = value.compareAndSet(5, 20);
        System.out.println("Успех: " + success); // false
        System.out.println("Значение: " + value.get()); // 10
    }
}
```

В этом примере:

- Первая операция `compareAndSet(5, 10)` успешна, так как текущее значение (`5`)
  совпадает с ожидаемым (`5`).
- Вторая операция `compareAndSet(5, 20)` не выполняется, так как текущее
  значение (`10`) не совпадает с ожидаемым (`5`).

### Роль ожидаемого значения

1. **Проверка целостности**: Ожидаемое значение позволяет убедиться, что
   переменная не была изменена другим потоком с момента последнего чтения. Это
   предотвращает состояния гонки.
2. **Оптимистическая блокировка**: Поток предполагает, что значение не
   изменилось (оптимизм), и использует CAS для проверки. Если значение
   изменилось, поток может повторить попытку с новым ожидаемым значением.
3. **Основа потокобезопасности**: Ожидаемое значение обеспечивает атомарность
   операции, избегая необходимости явных блокировок (`synchronized`).

### Пример с повторными попытками

Если CAS не удался из-за несовпадения ожидаемого значения, поток может
перечитать текущее значение и повторить попытку:

```java
AtomicInteger counter = new AtomicInteger(0);

void safeIncrement() {
    while (true) {
        int expectedValue = counter.get(); // Читаем текущее значение как ожидаемое
        int newValue = expectedValue + 1;
        if (counter.compareAndSet(expectedValue, newValue)) {
            break; // Успех
        }
        // Повторяем, если ожидаемое значение не совпало с текущим
    }
}
```

Здесь поток получает текущее значение (`expectedValue`), вычисляет новое
значение и пытается выполнить CAS. Если другой поток изменил значение, CAS
возвращает `false`, и цикл повторяется с новым ожидаемым значением.

### Проблема ABA

Ожидаемое значение может вызвать проблему ABA:

- Поток 1 читает значение `A` как ожидаемое.
- Поток 2 меняет значение на `B`, а затем обратно на `A`.
- Поток 1 выполняет CAS, думая, что значение не изменилось, так как текущее
  значение снова `A`.

**Решение**: Использование `AtomicStampedReference` или
`AtomicMarkableReference`, которые добавляют метку или версию к значению, чтобы
отслеживать изменения.

### Применение ожидаемого значения

- **Счетчики**: Например, `AtomicInteger` использует ожидаемое значение в
  `incrementAndGet` для атомарного увеличения.
- **Неблокирующие структуры данных**: В `ConcurrentHashMap` или
  `ConcurrentLinkedQueue` CAS с ожидаемым значением используется для обновления
  узлов.
- **Кастомные алгоритмы**: Ожидаемое значение позволяет реализовать
  потокобезопасные операции без блокировок.

### Итог

Ожидаемое значение в CAS — это значение, которое поток ожидает увидеть в
переменной на момент выполнения операции. Оно используется для проверки, что
переменная не была изменена другим потоком, обеспечивая атомарность и
потокобезопасность. Если ожидаемое значение не совпадает с текущим, обновление
не происходит, что позволяет избежать состояний гонки. Этот механизм лежит в
основе классов `java.util.concurrent.atomic` и неблокирующих алгоритмов.

# Оптимистическая и пессимистическая блокировки

**Оптимистическая** и **пессимистическая блокировки** — это два разных подхода к
управлению доступом к общим ресурсам в многопоточных приложениях, таких как в
Java. Они используются для обеспечения потокобезопасности, предотвращения
состояний гонки и конфликтов при одновременном доступе нескольких потоков к
данным. Рассмотрим их отличия, механизмы и применение.

### 1. **Оптимистическая блокировка**

**Оптимистическая блокировка** предполагает, что конфликты между потоками редки,
и поэтому потоки могут работать с данными без предварительной блокировки. Вместо
этого проверка целостности данных выполняется в момент записи (например, с
использованием **Compare-and-Swap (CAS)**). Если конфликт обнаруживается (данные
были изменены другим потоком), операция повторяется.

#### Как работает?

- Поток читает данные и выполняет вычисления, не блокируя ресурс.
- При попытке записать изменения проверяется, не изменились ли данные с момента
  их чтения (например, с помощью ожидаемого значения в CAS).
- Если данные не изменились, обновление выполняется.
- Если данные изменились, операция либо отменяется, либо повторяется с новыми
  данными.

#### Пример в Java

Оптимистическая блокировка часто реализуется с использованием классов из пакета
`java.util.concurrent.atomic`, таких как `AtomicInteger`:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class OptimisticLockExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                while (true) {
                    int expectedValue = counter.get();
                    int newValue = expectedValue + 1;
                    if (counter.compareAndSet(expectedValue, newValue)) {
                        break; // Успех
                    }
                    // Повторяем, если значение изменилось
                }
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Итоговое значение: " + counter.get()); // 2000
    }
}
```

Здесь `compareAndSet` проверяет, совпадает ли текущее значение с ожидаемым, и
только тогда обновляет его. Если значение изменилось, поток повторяет попытку.

#### Преимущества

- **Высокая производительность при низкой конкуренции**: Нет накладных расходов
  на блокировки, так как потоки работают параллельно без ожидания.
- **Меньше блокировок**: Потоки не блокируют друг друга, что снижает вероятность
  взаимоблокировок (deadlocks).
- **Масштабируемость**: Хорошо работает в системах с большим количеством потоков
  и редкими конфликтами.

#### Недостатки

- **Проблема при высокой конкуренции**: Если много потоков пытаются обновить
  данные одновременно, CAS может приводить к множественным неудачным попыткам,
  что снижает производительность.
- **Проблема ABA**: Если значение изменилось с `A` на `B` и обратно на `A`, CAS
  может не заметить изменений (решается с помощью `AtomicStampedReference`).
- **Сложность кода**: Требует ручного управления повторными попытками при
  неудачном обновлении.

#### Когда использовать

- Когда конфликты между потоками редки (например, в счетчиках, кэшах).
- В неблокирующих структурах данных (`ConcurrentHashMap`,
  `ConcurrentLinkedQueue`).
- Для простых операций, таких как обновление счетчиков или флагов.

### 2. **Пессимистическая блокировка**

**Пессимистическая блокировка** предполагает, что конфликты между потоками
вероятны, поэтому доступ к ресурсу блокируется заранее, чтобы только один поток
мог работать с ним в определенный момент. В Java это обычно реализуется с
помощью ключевого слова `synchronized` или блокировок из пакета
`java.util.concurrent.locks` (например, `ReentrantLock`).

#### Как работает?

- Поток захватывает блокировку (lock) перед доступом к общему ресурсу.
- Другие потоки, пытающиеся получить доступ, приостанавливаются (блокируются),
  пока блокировка не будет освобождена.
- После завершения работы поток освобождает блокировку, позволяя другим потокам
  продолжить.

#### Пример в Java

Использование `synchronized` для пессимистической блокировки:

```java
public class PessimisticLockExample {
    private int counter = 0;

    public synchronized void increment() {
        counter++;
    }

    public int getCounter() {
        return counter;
    }

    public static void main(String[] args) throws InterruptedException {
        PessimisticLockExample example = new PessimisticLockExample();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Итоговое значение: " + example.getCounter()); // 2000
    }
}
```

Здесь `synchronized` гарантирует, что только один поток может выполнять метод
`increment` в определенный момент.

#### Преимущества

- **Простота**: Легко реализовать для сложных операций, требующих нескольких
  шагов.
- **Гарантия целостности**: Полностью исключает конфликты, так как только один
  поток имеет доступ к ресурсу.
- **Подходит для высокой конкуренции**: Хорошо работает, когда много потоков
  часто обращаются к одному ресурсу.

#### Недостатки

- **Низкая производительность при высокой конкуренции**: Потоки могут долго
  ждать освобождения блокировки, что приводит к простоям.
- **Риск взаимоблокировок**: Неправильное использование блокировок может
  привести к deadlock’ам.
- **Накладные расходы**: Блокировки требуют ресурсов для управления (например,
  мониторы в `synchronized`).

#### Когда использовать

- Когда операции сложные и требуют нескольких шагов, которые должны быть
  выполнены атомарно.
- Когда конфликты между потоками часты, и повторные попытки CAS были бы слишком
  затратными.
- Для критических секций, где важна строгая последовательность операций.

### Сравнение оптимистической и пессимистической блокировок

| Характеристика         | Оптимистическая блокировка (CAS)                    | Пессимистическая блокировка (`synchronized`, `Lock`) |
|------------------------|-----------------------------------------------------|------------------------------------------------------|
| **Подход**             | Предполагает редкие конфликты, проверяет при записи | Предполагает частые конфликты, блокирует заранее     |
| **Механизм**           | CAS (Compare-and-Swap)                              | Блокировки (мониторы, `ReentrantLock`)               |
| **Производительность** | Высокая при низкой конкуренции                      | Низкая при высокой конкуренции                       |
| **Сложность кода**     | Требует управления повторными попытками             | Прост в использовании для сложных операций           |
| **Риск**               | Проблема ABA, неудачные попытки при конкуренции     | Взаимоблокировки, простои потоков                    |
| **Примеры в Java**     | `AtomicInteger`, `ConcurrentHashMap`                | `synchronized`, `ReentrantLock`                      |
| **Использование**      | Простые обновления, неблокирующие структуры         | Сложные операции, критические секции                 |

### Пример сценария

1. **Оптимистическая блокировка**:
    - Подсчет посещений страницы в веб-приложении с помощью `AtomicInteger` или
      `LongAdder`.
    - Обновление значения в кэше, если оно не изменилось.
2. **Пессимистическая блокировка**:
    - Обновление банковского счета, где требуется проверить баланс, списать
      средства и записать транзакцию в одной критической секции.
    - Работа с файлом, где несколько операций (чтение, изменение, запись) должны
      быть атомарными.

### Связь с другими механизмами

- **ExecutorService/ThreadPoolExecutor**: Оптимистическая блокировка может
  использоваться внутри задач для обновления общих счетчиков или флагов.
- **ForkJoinPool**: Часто использует CAS для координации подзадач (например, в
  `parallelStream`).
- **Пакет `java.util.concurrent.atomic`**: Основной инструмент для
  оптимистической блокировки через CAS.

### Итог

- **Оптимистическая блокировка** (CAS) подходит для сценариев с редкими
  конфликтами, где важна производительность и масштабируемость. Она избегает
  блокировок, но требует управления повторными попытками и учета проблемы ABA.
- **Пессимистическая блокировка** (`synchronized`, `ReentrantLock`) лучше для
  сложных операций или высокой конкуренции, но может приводить к простоям
  потоков и риску взаимоблокировок.

Если у вас есть конкретный пример или задача, где нужно выбрать между этими
подходами, напишите, и я помогу с кодом или рекомендациями!