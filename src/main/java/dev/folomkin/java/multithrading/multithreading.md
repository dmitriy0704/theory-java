# Многопоточность

# Состояния потока в Java

В Java **потоки** (threads) могут находиться в нескольких состояниях,
определённых в классе `Thread.State`. Эти состояния описывают жизненный цикл
потока. Вот полный список состояний потока:

1. **NEW (НОВЫЙ)**  
   Поток создан, но метод `start()` ещё не вызван. Поток находится в этом
   состоянии до запуска.

2. **RUNNABLE (ГОТОВ К ВЫПОЛНЕНИЮ)**  
   Поток выполняется или готов к выполнению, когда процессор выделит ему время.
   Это состояние включает два подвида:
    - Поток активно выполняется (running).
    - Поток ожидает процессорного времени (ready).

3. **BLOCKED (ЗАБЛОКИРОВАН)**  
   Поток ожидает получения монитора (lock) для входа в синхронизированный блок
   или метод. Например, это происходит, когда другой поток удерживает нужный
   монитор.

4. **WAITING (ОЖИДАНИЕ)**  
   Поток находится в бесконечном ожидании, пока другой поток не выполнит
   определённое действие. Это состояние возникает при вызове методов:
    - `Object.wait()`
    - `Thread.join()`
    - `LockSupport.park()`

5. **TIMED_WAITING (ОЖИДАНИЕ С ТАЙМАУТОМ)**  
   Поток ожидает определённое время, пока не произойдёт событие или не истечёт
   таймаут. Это состояние возникает при вызове методов:
    - `Thread.sleep(long millis)`
    - `Object.wait(long timeout)`
    - `Thread.join(long millis)`
    - `LockSupport.parkNanos()` или `LockSupport.parkUntil()`

6. **TERMINATED (ЗАВЕРШЁН)**  
   Поток завершил выполнение (либо метод `run()` завершился, либо произошло
   необработанное исключение). Поток в этом состоянии больше не может быть
   использован.

### Как узнать состояние потока?

Состояние потока можно получить с помощью метода `Thread.getState()`, который
возвращает значение перечисления `Thread.State`.

### Примечания:

- Переходы между состояниями зависят от действий программы, планировщика потоков
  и JVM.
- Состояния `BLOCKED`, `WAITING` и `TIMED_WAITING` связаны с управлением
  синхронизацией и ресурсами.
- Диаграмма жизненного цикла потока полезна для понимания переходов (например,
  NEW → RUNNABLE → TERMINATED или RUNNABLE → WAITING → RUNNABLE).

---

# ExecutorService

**ExecutorService** в Java — это высокоуровневый интерфейс из пакета
`java.util.concurrent`, предназначенный для управления потоками выполнения задач
в многопоточных приложениях. Он упрощает работу с потоками, предоставляя пул
потоков и механизмы для асинхронного выполнения задач. Вот основные аспекты:

### Основные характеристики

1. **Абстракция над потоками**: ExecutorService позволяет выполнять задачи (
   `Runnable` или `Callable`) без необходимости вручную создавать и управлять
   потоками.
2. **Пул потоков**: Вместо создания нового потока для каждой задачи,
   ExecutorService использует пул потоков, что снижает накладные расходы на
   создание и уничтожение потоков.
3. **Гибкость**: Поддерживает выполнение задач асинхронно, с возможностью
   получения результатов (через `Future`) и управления временем выполнения.
4. **Управление жизненным циклом**: Предоставляет методы для корректного
   завершения работы пула потоков.

### Основные особенности `ExecutorService`:

1. **Управление потоками**: `ExecutorService` позволяет вам управлять пулом
   потоков, что означает, что вы можете повторно использовать потоки для
   выполнения нескольких задач, вместо создания нового потока для каждой задачи.
   Это значительно снижает накладные расходы на создание и уничтожение потоков.
2. **Асинхронное выполнение**: Вы можете отправлять задачи на выполнение и
   продолжать выполнять другие операции, не дожидаясь завершения этих задач.
3. **Планирование задач**: `ExecutorService` поддерживает планирование задач с
   использованием методов, таких как `schedule()` (в классе
   `ScheduledExecutorService`), что позволяет выполнять задачи через
   определенные интервалы времени или с задержкой.
4. **Разные типы задач**: Вы можете отправлять как `Runnable`, так и `Callable`
   задачи. `Callable` позволяет возвращать результат и обрабатывать исключения.
5. **Управление жизненным циклом**: `ExecutorService` предоставляет методы для
   управления жизненным циклом пула потоков, такие как `shutdown()` и
   `shutdownNow()`, которые позволяют корректно завершить выполнение задач.
6. **Фабрики для создания экземпляров**: Для создания экземпляров
   `ExecutorService` обычно используются статические методы класса `Executors`,
   такие как:
    - `Executors.newFixedThreadPool(int nThreads)`: создает пул фиксированного
      размера.
    - `Executors.newCachedThreadPool()`: создает пул, который создает новые
      потоки по мере необходимости, но повторно использует ранее созданные
      потоки.
    - `Executors.newSingleThreadExecutor()`: создает пул с одним потоком.

### Основные интерфейсы и классы

- **Executor**: Базовый интерфейс с методом `execute(Runnable)`.
- **ExecutorService**: Расширяет `Executor`, добавляя методы для управления
  задачами и завершением работы.
- **ScheduledExecutorService**: Подинтерфейс для планирования задач с задержкой
  или периодическим выполнением.
- Реализации:
    - `ThreadPoolExecutor`: Настраиваемый пул потоков.
    - `ScheduledThreadPoolExecutor`: Для планирования задач.
    - `ForkJoinPool`: Для задач, разбиваемых на подзадачи (рекурсивные
      вычисления).

### Создание ExecutorService

Создать `ExecutorService` можно с помощью фабричных методов класса `Executors`:

```java
import java.util.concurrent.*;

// Фиксированный пул потоков (например, 5 потоков)
ExecutorService executor = Executors.newFixedThreadPool(5);

        // Кэширующий пул (создает потоки по необходимости)
        ExecutorService executor = Executors.newCachedThreadPool();

        // Одиночный поток
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // Планировщик задач
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
```

### Основные методы

1. **Отправка задач**:
    - `execute(Runnable)`: Выполняет задачу без возврата результата.
    - `submit(Runnable)`: Возвращает `Future<?>` для отслеживания завершения.
    - `submit(Callable<T>)`: Выполняет задачу, возвращающую результат (тип `T`).
    - `invokeAll(Collection<Callable<T>>)`: Выполняет все задачи и возвращает
      список `Future`.
    - `invokeAny(Collection<Callable<T>>)`: Выполняет задачи и возвращает
      результат первой успешно завершенной.

2. **Управление завершением**:
    - `shutdown()`: Завершает прием новых задач, но выполняет уже отправленные.
    - `shutdownNow()`: Пытается прервать все задачи и завершить работу.
    - `awaitTermination(long timeout, TimeUnit unit)`: Ждет завершения всех
      задач в течение указанного времени.

3. **Планирование (для ScheduledExecutorService)**:
    - `schedule(Runnable/Callable, long delay, TimeUnit unit)`: Выполняет задачу
      после задержки.
    -
   `scheduleAtFixedRate(Runnable, long initialDelay, long period, TimeUnit unit)`:
   Периодическое выполнение с фиксированным интервалом.
    -
   `scheduleWithFixedDelay(Runnable, long initialDelay, long delay, TimeUnit unit)`:
   Периодическое выполнение с фиксированной задержкой между задачами.

### Пример использования

```java
import java.util.concurrent.*;

public class ExecutorServiceExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Задача Runnable
        executor.submit(() -> System.out.println("Задача Runnable выполнена в " + Thread.currentThread().getName()));

        // Задача Callable с результатом
        Future<Integer> future = executor.submit(() -> {
            Thread.sleep(1000);
            return 42;
        });

        // Получение результата
        System.out.println("Результат Callable: " + future.get());

        // Завершение пула
        executor.shutdown();
        if (executor.awaitTermination(5, TimeUnit.SECONDS)) {
            System.out.println("Пул завершен");
        } else {
            executor.shutdownNow();
            System.out.println("Пул принудительно остановлен");
        }
    }
}
```

### Преимущества

- Упрощает управление потоками.
- Повышает производительность за счет повторного использования потоков.
- Поддерживает асинхронное выполнение и обработку результатов.
- Гибкость в настройке пула (размер, стратегия обработки очереди).

### Рекомендации

1. **Всегда завершайте пул**: Используйте `shutdown()` или `shutdownNow()`,
   чтобы избежать утечек ресурсов.
2. **Обрабатывайте исключения**: Проверяйте исключения в `Future.get()` или
   используйте `try-catch` при выполнении задач.
3. **Выбирайте подходящий тип пула**:
    - `newFixedThreadPool`: Для ограниченного числа потоков.
    - `newCachedThreadPool`: Для множества короткоживущих задач.
    - `newSingleThreadExecutor`: Для последовательного выполнения.
4. **Избегайте перегрузки**: Слишком большое количество задач может привести к
   исчерпанию ресурсов.

### Ограничения

- Неуправляемый `newCachedThreadPool` может создавать слишком много потоков, что
  приведет к снижению производительности.
- Неправильное завершение пула может вызвать утечки памяти.
- Очереди задач (например, в `ThreadPoolExecutor`) могут переполниться при
  большом количестве задач.

### Когда использовать

`ExecutorService` идеально подходит для:

- Параллельной обработки задач (например, обработка запросов в веб-сервере).
- Выполнения длительных операций в фоновом режиме.
- Планирования периодических задач (например, очистка кэша).
- Разбиения задач на подзадачи (с `ForkJoinPool`).

Для более сложных сценариев можно настроить `ThreadPoolExecutor` напрямую,
задавая параметры пула (размер, очередь, политика отклонения задач).

## В чем отличие ExecutorService от ForkJoinPool?

`ExecutorService` и `ForkJoinPool` в Java оба используются для управления
потоками и выполнения задач в многопоточной среде, но они имеют разные цели,
архитектуру и подходы к обработке задач. Вот основные отличия:

### 1. **Назначение и область применения**

- **ExecutorService**:
    - Универсальный интерфейс из пакета `java.util.concurrent` для выполнения
      асинхронных задач.
    - Подходит для общего управления потоками и выполнения независимых задач,
      таких как обработка запросов в веб-сервере, выполнение фоновых операций
      или параллельная обработка данных.
    - Не оптимизирован для рекурсивных или иерархических задач.
- **ForkJoinPool**:
    - Специализированная реализация `ExecutorService`, предназначенная для
      задач, которые можно рекурсивно разделять на подзадачи (подход "разделяй и
      властвуй").
    - Оптимизирован для задач с интенсивным разбиением (например, обработка
      больших массивов, рекурсивные алгоритмы типа сортировки или вычислений).
    - Основное использование: задачи, где большая работа разбивается на меньшие
      подзадачи, которые затем объединяются (например, параллельная обработка в
      `parallelStream` в Java).

### 2. **Архитектура и механизм работы**

- **ExecutorService**:
    - Использует пул потоков фиксированного или динамического размера (например,
      `FixedThreadPool`, `CachedThreadPool`).
    - Задачи распределяются по потокам из пула, и каждый поток выполняет задачу
      независимо.
    - Не имеет встроенной поддержки для рекурсивного разбиения задач.
    - Очередь задач (например, `LinkedBlockingQueue`) управляет порядком
      выполнения.
- **ForkJoinPool**:
    - Использует механизм **work-stealing** (кража работы): каждый поток имеет
      свою очередь задач, и если поток простаивает, он может "украсть" задачи из
      очереди другого потока, что повышает эффективность.
    - Оптимизирован для задач, где создаются подзадачи (через `ForkJoinTask`,
      такие, как `RecursiveTask` или `RecursiveAction`).
    - Поддерживает рекурсивное разбиение задач: задача делится на подзадачи (
      `fork`), которые выполняются параллельно, а затем результаты
      объединяются (`join`).

### 3. **Типы задач**

- **ExecutorService**:
    - Подходит для независимых задач, которые не требуют взаимодействия или
      координации между собой.
    - Примеры: обработка HTTP-запросов, выполнение независимых вычислений,
      запуск фоновых операций.
    - Задачи обычно представляют собой `Runnable` или `Callable`.
- **ForkJoinPool**:
    - Идеален для задач, которые можно разделить на меньшие части, выполняемые
      параллельно, с последующим объединением результатов.
    - Примеры: рекурсивная сортировка (QuickSort, MergeSort), обработка больших
      массивов, вычисления на графах.
    - Задачи обычно представляют собой `ForkJoinTask` (подклассы `RecursiveTask`
      для задач с возвращаемым результатом или `RecursiveAction` для задач без
      результата).

### 4. **Производительность**

- **ExecutorService**:
    - Эффективен для задач с предсказуемой нагрузкой и независимыми операциями.
    - Может быть менее эффективен для задач с большим количеством подзадач, так
      как не оптимизирован для динамического разбиения.
    - Накладные расходы зависят от типа пула (например, `CachedThreadPool` может
      создавать много потоков, что снижает производительность при высокой
      нагрузке).
- **ForkJoinPool**:
    - Высокая производительность для рекурсивных задач благодаря механизму
      work-stealing, который минимизирует простои потоков.
    - Оптимизирован для задач с высокой степенью параллелизма, где подзадачи
      имеют схожую вычислительную сложность.
    - Может быть менее эффективен для задач, которые не подразумевают
      рекурсивное разбиение, из-за дополнительных накладных расходов на
      управление подзадачами.

### 5. **API и использование**

- **ExecutorService**:
    - Простое API: `execute`, `submit`, `invokeAll`, `invokeAny`.
    - Управление жизненным циклом через `shutdown`, `shutdownNow`,
      `awaitTermination`.
    - Пример:
      ```java
      ExecutorService executor = Executors.newFixedThreadPool(4);
      executor.submit(() -> System.out.println("Задача выполнена"));
      executor.shutdown();
      ```
- **ForkJoinPool**:
    - Более сложное API, ориентированное на рекурсию: задачи делятся с помощью
      `fork()` и объединяются с помощью `join()`.
    - Используется с `ForkJoinTask` или его подклассами.
    - Пример:
      ```java
      import java.util.concurrent.*;
  
      public class ForkJoinExample extends RecursiveTask<Integer> {
          private final int[] array;
          private final int start, end;
  
          public ForkJoinExample(int[] array, int start, int end) {
              this.array = array;
              this.start = start;
              this.end = end;
          }
  
          @Override
          protected Integer compute() {
              if (end - start <= 10) {
                  int sum = 0;
                  for (int i = start; i < end; i++) sum += array[i];
                  return sum;
              } else {
                  int mid = (start + end) / 2;
                  ForkJoinExample left = new ForkJoinExample(array, start, mid);
                  ForkJoinExample right = new ForkJoinExample(array, mid, end);
                  left.fork(); // Разделяем задачу
                  return right.compute() + left.join(); // Объединяем результаты
              }
          }
  
          public static void main(String[] args) {
              ForkJoinPool pool = ForkJoinPool.commonPool();
              int[] array = new int[100]; // Заполнить массив
              ForkJoinExample task = new ForkJoinExample(array, 0, array.length);
              int result = pool.invoke(task);
              System.out.println("Сумма: " + result);
              pool.shutdown();
          }
      }
      ```

### 6. **Интеграция с Java**

- **ExecutorService**:
    - Используется в широком спектре приложений, например, в веб-серверах (
      Tomcat, Jetty), пулах соединений, обработке событий.
    - Подходит для любых асинхронных задач.
- **ForkJoinPool**:
    - Интегрирован с Java Streams API (начиная с Java 8): `parallelStream`
      использует `ForkJoinPool.commonPool()` для параллельной обработки.
    - Пример: `Arrays.stream(array).parallel().sum()` использует `ForkJoinPool`.

### 7. **Общий пул (Common Pool)**

- **ExecutorService**:
    - Не имеет общего пула по умолчанию; вы создаете собственный экземпляр с
      помощью `Executors`.
- **ForkJoinPool**:
    - Имеет общий пул (`ForkJoinPool.commonPool()`), который используется для
      `parallelStream` и других задач, если не указан конкретный пул.
    - Размер пула по умолчанию равен количеству доступных процессоров (
      `Runtime.getRuntime().availableProcessors()`).

### Когда использовать что

- **ExecutorService**:
    - Для независимых задач, где не требуется рекурсивное разбиение.
    - Когда нужна простая модель пула потоков (фиксированный, кэширующий или
      одиночный).
    - Примеры: обработка запросов, выполнение фоновых задач, запуск таймеров.
- **ForkJoinPool**:
    - Для рекурсивных задач, которые можно эффективно разделить на подзадачи.
    - Когда вы хотите использовать механизм work-stealing для повышения
      производительности.
    - Примеры: обработка больших массивов, рекурсивные алгоритмы, задачи в
      `parallelStream`.

### Краткое сравнение

| Характеристика         | ExecutorService                   | ForkJoinPool                            |
|------------------------|-----------------------------------|-----------------------------------------|
| **Назначение**         | Универсальное выполнение задач    | Рекурсивные задачи с разделением        |
| **Механизм**           | Пул потоков, очередь задач        | Work-stealing, рекурсивное разбиение    |
| **Тип задач**          | Независимые `Runnable`/`Callable` | `ForkJoinTask` (`RecursiveTask/Action`) |
| **Производительность** | Хорошая для независимых задач     | Оптимизирована для рекурсивных задач    |
| **API**                | Простое (`submit`, `execute`)     | Сложнее (`fork`, `join`)                |
| **Использование**      | Веб-серверы, фоновые задачи       | `parallelStream`, рекурсивные алгоритмы |
| **Общий пул**          | Отсутствует                       | `commonPool()`                          |

### Итог

- Если ваши задачи независимы и не требуют рекурсивного разбиения, используйте
  `ExecutorService` (например, `FixedThreadPool` или `CachedThreadPool`).
- Если задачи можно разделить на подзадачи (например, обработка больших данных
  или рекурсивные вычисления), используйте `ForkJoinPool` для повышения
  эффективности за счет work-stealing.

## ThreadPoolExecutor

**ThreadPoolExecutor** в Java — это мощная и гибкая реализация интерфейса
`ExecutorService` из пакета `java.util.concurrent`, предназначенная для
управления пулом потоков. Она позволяет настраивать параметры пула потоков,
такие как размер пула, политика обработки очереди задач и поведение при
перегрузке. Это более низкоуровневый инструмент по сравнению с фабричными
методами `Executors`, предоставляя детальный контроль над выполнением задач.

### Основные характеристики

- **Пул потоков**: `ThreadPoolExecutor` создает пул потоков, которые повторно
  используются для выполнения задач, что снижает накладные расходы на создание и
  уничтожение потоков.
- **Гибкость настройки**: Позволяет задавать минимальное и максимальное
  количество потоков, тип очереди задач и стратегию обработки отклоненных задач.
- **Управление задачами**: Поддерживает асинхронное выполнение задач (`Runnable`
  или `Callable`) с возможностью получения результатов через `Future`.
- **Жизненный цикл**: Обеспечивает методы для управления завершением пула (
  `shutdown`, `shutdownNow`, `awaitTermination`).

### Конструкторы

`ThreadPoolExecutor` имеет несколько конструкторов, самый полный из которых:

```java
ThreadPoolExecutor(int corePoolSize,
                   int maximumPoolSize,
                   long keepAliveTime,
                   TimeUnit unit,
                   BlockingQueue<Runnable> workQueue,
                   ThreadFactory threadFactory,
                   RejectedExecutionHandler handler)
```

- **corePoolSize**: Количество потоков, которые постоянно поддерживаются в
  пуле (даже если простаивают).
- **maximumPoolSize**: Максимальное количество потоков, которое может быть
  создано при переполнении очереди.
- **keepAliveTime**: Время, в течение которого лишние потоки (сверх
  `corePoolSize`) будут простаивать перед завершением.
- **unit**: Единица измерения времени для `keepAliveTime` (например,
  `TimeUnit.SECONDS`).
- **workQueue**: Очередь для хранения задач, ожидающих выполнения (например,
  `LinkedBlockingQueue`, `ArrayBlockingQueue`, `SynchronousQueue`).
- **threadFactory**: Фабрика для создания новых потоков (обычно
  `Executors.defaultThreadFactory()`).
- **handler**: Политика обработки задач, которые не могут быть выполнены из-за
  переполнения пула или очереди (например, `AbortPolicy`, `CallerRunsPolicy`).

### Основные параметры и их влияние

1. **corePoolSize и maximumPoolSize**:
    - Пул начинает с `corePoolSize` потоков. Если очередь задач переполняется,
      создаются дополнительные потоки до `maximumPoolSize`.
    - Если `corePoolSize` равно `maximumPoolSize`, пул имеет фиксированный
      размер (аналог `Executors.newFixedThreadPool`).
2. **workQueue**:
    - `LinkedBlockingQueue`: Неограниченная очередь (по умолчанию). Может
      привести к переполнению памяти при большом количестве задач.
    - `ArrayBlockingQueue`: Ограниченная очередь с фиксированным размером.
    - `SynchronousQueue`: Очередь без буфера — задачи передаются напрямую потоку
      или отклоняются.
    - `PriorityBlockingQueue`: Очередь с приоритетами для задач.
3. **keepAliveTime**:
    - Если количество потоков превышает `corePoolSize`, избыточные потоки
      завершаются после простоя в течение `keepAliveTime`.
    - Если `allowCoreThreadTimeOut(true)`, даже основные потоки (`corePoolSize`)
      могут завершаться при простое.
4. **RejectedExecutionHandler**:
    - Определяет, что делать, если задача не может быть добавлена в очередь или
      выполнена:
        - `AbortPolicy` (по умолчанию): выбрасывает
          `RejectedExecutionException`.
        - `CallerRunsPolicy`: Выполняет задачу в вызывающем потоке.
        - `DiscardPolicy`: Тихо отбрасывает задачу.
        - `DiscardOldestPolicy`: Отбрасывает самую старую задачу в очереди и
          пытается добавить новую.

### Создание ThreadPoolExecutor

Пример создания:

```java
import java.util.concurrent.*;

ThreadPoolExecutor executor = new ThreadPoolExecutor(
        2, // corePoolSize
        4, // maximumPoolSize
        60, // keepAliveTime
        TimeUnit.SECONDS, // единица времени
        new ArrayBlockingQueue<>(10), // очередь на 10 задач
        Executors.defaultThreadFactory(), // фабрика потоков
        new ThreadPoolExecutor.AbortPolicy() // политика отклонения
);
```

### Основные методы

`ThreadPoolExecutor` наследует методы от `ExecutorService`:

- `execute(Runnable)`: Выполняет задачу без возврата результата.
- `submit(Runnable/Callable)`: Выполняет задачу и возвращает `Future`.
- `invokeAll/invokeAny`: Выполняет коллекцию задач.
- `shutdown()`: Завершает прием новых задач, но выполняет существующие.
- `shutdownNow()`: Пытается прервать все задачи.
- `awaitTermination`: Ждет завершения всех задач в течение заданного времени.

Дополнительные методы:

- `getPoolSize()`: Возвращает текущий размер пула.
- `getActiveCount()`: Количество активных потоков.
- `getQueue()`: Возвращает очередь задач.
- `setCorePoolSize(int)`: Динамически изменяет размер пула.

### Пример использования

```java
import java.util.concurrent.*;

public class ThreadPoolExecutorExample {
    public static void main(String[] args) throws Exception {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, 4, 60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(10),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );

        // Отправка задач
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Задача " + taskId + " выполняется в " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                }
            });
        }

        // Мониторинг
        System.out.println("Активных потоков: " + executor.getActiveCount());
        System.out.println("Задач в очереди: " + executor.getQueue().size());

        // Завершение
        executor.shutdown();
        if (executor.awaitTermination(10, TimeUnit.SECONDS)) {
            System.out.println("Пул завершен");
        } else {
            executor.shutdownNow();
            System.out.println("Пул принудительно остановлен");
        }
    }
}
```

### Преимущества

- **Гибкость**: Тонкая настройка пула (размер, очередь, политика отклонения).
- **Эффективность**: Повторное использование потоков снижает накладные расходы.
- **Мониторинг**: Возможность отслеживать состояние пула (активные потоки,
  очередь).
- **Управление перегрузкой**: Настраиваемые политики обработки отклоненных
  задач.

### Ограничения

- **Сложность настройки**: Требует понимания параметров (`corePoolSize`,
  `maximumPoolSize`, `workQueue`) для оптимальной работы.
- **Риск переполнения**: Неограниченные очереди (например,
  `LinkedBlockingQueue`) могут привести к исчерпанию памяти.
- **Ручное управление**: В отличие от `Executors.newFixedThreadPool` или
  `ForkJoinPool`, требует явной настройки.

### Сравнение с другими пулами

- **По сравнению с `Executors.newFixedThreadPool`**:
    - `FixedThreadPool` — это `ThreadPoolExecutor` с `corePoolSize` =
      `maximumPoolSize` и неограниченной очередью (`LinkedBlockingQueue`).
    - `ThreadPoolExecutor` позволяет настраивать поведение (например,
      ограниченная очередь, время жизни потоков).
- **По сравнению с `Executors.newCachedThreadPool`**:
    - `CachedThreadPool` — это `ThreadPoolExecutor` с `corePoolSize = 0`,
      `maximumPoolSize = Integer.MAX_VALUE` и `SynchronousQueue`.
    - `ThreadPoolExecutor` дает больше контроля над количеством потоков и
      очередью.
- **По сравнению с `ForkJoinPool`**:
    - `ForkJoinPool` оптимизирован для рекурсивных задач с механизмом
      work-stealing.
    - `ThreadPoolExecutor` лучше подходит для независимых задач и не
      поддерживает рекурсивное разбиение.

### Когда использовать

- Когда нужна тонкая настройка пула потоков (например, ограниченная очередь или
  специфическая политика отклонения).
- Для задач, где требуется управление количеством одновременно выполняемых
  потоков.
- Для приложений с предсказуемой нагрузкой, таких как веб-серверы, обработка
  запросов или фоновые задачи.

### Рекомендации

1. **Выбирайте подходящую очередь**:
    - Используйте `ArrayBlockingQueue` для ограничения памяти.
    - Избегайте `LinkedBlockingQueue` без ограничений, чтобы предотвратить
      переполнение.
2. **Настройте политику отклонения**:
    - `CallerRunsPolicy` помогает избежать перегрузки, выполняя задачи в
      вызывающем потоке.
    - `AbortPolicy` подходит, если нужно явно обрабатывать отказы.
3. **Мониторьте пул**:
    - Используйте методы `getActiveCount()`, `getQueue().size()` для
      отслеживания нагрузки.
4. **Завершайте пул корректно**:
    - Всегда вызывайте `shutdown()` или `shutdownNow()` для освобождения
      ресурсов.
5. **Тестируйте параметры**:
    - Подберите `corePoolSize` и `maximumPoolSize` в зависимости от нагрузки и
      доступных процессоров.

___

## Future

`Future<V>` — это объект, который представляет результат асинхронной операции. С
его помощью можно:

- Получить результат задачи.
- Проверить, завершена ли она.
- Отменить её выполнение.

### Пример работы с `Future`:

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        Callable<String> task = () -> {
            Thread.sleep(2000);
            return "Готово!";
        };

        Future<String> future = executor.submit(task);
        // Можно делать что-то другое пока задача выполняется...

        if (!future.isDone()) {
            System.out.println("Задача еще выполняется...");
        }

        String result = future.get(); // блокирует поток до завершения 
        // блокирует вызывающий поток, пока результат не будет готов.
        System.out.println("Результат: " + result);
    }
}

```

### Почему `ExecutorService` лучше, чем `Thread`?

| Функция / Особенность      | `Thread` вручную        | `ExecutorService`                         |
|----------------------------|-------------------------|-------------------------------------------|
| Масштабируемость           | ручное управление       | пулы потоков, динамическое распределение  |
| Повторное использование    | каждый поток — новый    | потоки переиспользуются                   |
| Управление задачами        | нет возврата результата | через `Future`, отмена задач              |
| Исключения                 | сложно обрабатывать     | логируются/обрабатываются через `Future`  |
| Контроль завершения работы | нет                     | `shutdown()`, `awaitTermination()` и т.д. |

--- 

## Задачи

В контексте `ExecutorService` (и вообще многопоточности в
Java), **"задача"** — это **единица работы**, которую мы хотим выполнить в
отдельном потоке.

В Java задача — это объект, реализующий один из интерфейсов:

- `Runnable` — если задача **не возвращает результат**
- `Callable<T>` — если задача **возвращает результат** и может выбрасывать
  исключения

Можно представить задачу как команду: "Сделай что-то". И `ExecutorService` —
это менеджер, который принимает такие команды и раздаёт их доступным
работникам (потокам из пула).

**Пример задачи с `Runnable`:**

```java
Runnable task = () -> System.out.println("Печать отчета...");
```

Эта задача просто что-то делает — побочный эффект, но **ничего не возвращает**.

**Пример задачи с `Callable`:**

```java
Callable<Integer> task = () -> {
    int result = 2 + 2;
    return result;
};
```

Эта задача **возвращает значение** — можно получить результат через
`Future<Integer>`.

Ты кидаешь задачи в корзину (`submit()`), сотрудники их берут, делают и отдают
результат на бумажке (`Future.get()`).

_**Реальный пример с задачей, которая:**_

1. Делает какое-то вычисление (например, считает сумму чисел от 1 до N)
2. Возвращает результат
3. Используется через `Callable`
4. Обрабатывается через `Future`

Код:

```java
import java.util.concurrent.*;

public class TaskExample {
    public static void main(String[] args) {
        // 1. Создаём пул потоков
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // 2. Создаём задачу
        Callable<Integer> task = () -> {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
                Thread.sleep(10); // имитируем задержку
            }
            return sum;
        };

        // 3. Отправляем задачу в ExecutorService
        Future<Integer> future = executor.submit(task);

        // 4. Делаем что-то параллельно (для примера)
        System.out.println("Задача запущена. Выполняем другие действия...");

        try {
            // 5. Получаем результат (блокирует поток, пока не готово)
            Integer result = future.get();
            System.out.println("Результат вычислений: " + result);
        } catch (InterruptedException | ExecutionException e) {
            System.out.println("Произошла ошибка при выполнении задачи: " + e.getMessage());
        }

        // 6. Завершаем работу ExecutorService
        executor.shutdown();
    }
}
```

Что происходит шаг за шагом:

1. Мы создаём пул из одного потока (можно больше).
2. Описываем задачу — простое сложение чисел с задержкой.
3. Передаём задачу на выполнение.
4. Пока задача выполняется — основной поток может делать что-то ещё.
5. Получаем результат с помощью `future.get()`.
6. Завершаем работу пула.

### Основные характеристики задач:

1. **Единица работы**: Задача — это конкретная работа или операция, которую
   нужно выполнить. Это может быть что угодно: от простого вычисления до сложной
   обработки данных.

2. **Асинхронность**: Задачи могут выполняться асинхронно, что позволяет
   основному потоку продолжать выполнение других операций, не дожидаясь
   завершения задачи.

3. **Возврат результата**:
    - **Runnable**: Задачи, реализующие интерфейс `Runnable`, не возвращают
      результат. Метод `run()` этого интерфейса имеет тип `void`.
    - **Callable**: Задачи, реализующие интерфейс `Callable`, могут возвращать
      результат и могут выбрасывать проверяемые исключения. Метод `call()` этого
      интерфейса возвращает значение.

4. **Управление состоянием**: Каждая задача может находиться в одном из
   нескольких состояний (например, ожидает выполнения, выполняется или
   завершена). Это состояние можно отслеживать с помощью объекта типа `Future`,
   который возвращается при отправке задачи на выполнение.

### Параллельный запуск нескольких задач

_**InvokeAll():**_

Пример:

Запускаем **несколько задач параллельно**<br>
Каждая считает сумму от 1 до своего числа N<br>
Собираем **все результаты**<br>
Используем `ExecutorService` и `List<Future>`

_**Пример: несколько задач параллельно**_

```java
import java.util.concurrent.*;
import java.util.*;

public class MultiTaskExample {
    public static void main(String[] args) throws InterruptedException {
        // 1. Пул из 3 потоков
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // 2. Список задач (Callable)
        List<Callable<Integer>> tasks = new ArrayList<>();
        for (int n : List.of(100, 200, 300)) {
            tasks.add(() -> {
                int sum = 0;
                for (int i = 1; i <= n; i++) {
                    sum += i;
                    Thread.sleep(5); // имитируем задержку
                }
                System.out.println("Задача для " + n + " завершена");
                return sum;
            });
        }

        // 3. Отправляем все задачи и получаем список Future
        List<Future<Integer>> results = executor.invokeAll(tasks);

        // 4. Обрабатываем результаты
        for (Future<Integer> future : results) {
            try {
                Integer result = future.get();
                System.out.println("Результат: " + result);
            } catch (ExecutionException e) {
                System.out.println("Ошибка в задаче: " + e.getMessage());
            }
        }

        // 5. Завершаем Executor
        executor.shutdown();


        // -> Задача для 100 завершена
        // Задача для 200 завершена
        // Задача для 300 завершена
        // Результат: 5050
        // Результат: 20100
        // Результат: 45150
    }
}
```

_**Что делает `invokeAll()`?**_

- Принимает список задач (`List<Callable<T>>`)
- Запускает их параллельно
- Возвращает список `Future<T>` — по одному на каждую задачу

`invokeAll()` **ждёт**, пока все задачи завершатся — это удобно для пакетной
обработки.

invokeAny();

`invokeAny()` — это почти как `invokeAll()`, **но он ждёт только первую
успешно завершённую задачу**, и:

- Возвращает **только один результат**
- Остальные задачи **отменяются**
- Это удобно, когда нужно просто получить **первый доступный ответ**, а не все

**Пример: `invokeAny()` в действии**

```java
import java.util.concurrent.*;
import java.util.*;

public class InvokeAnyExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Список задач с разной задержкой
        List<Callable<String>> tasks = List.of(
                () -> {
                    Thread.sleep(3000);
                    return "Результат из задачи 1 (3 сек)";
                },
                () -> {
                    Thread.sleep(1000);
                    return "Результат из задачи 2 (1 сек)";
                },
                () -> {
                    Thread.sleep(2000);
                    return "Результат из задачи 3 (2 сек)";
                }
        );

        try {
            // invokeAny ждёт первую выполненную и возвращает её результат
            String fastestResult = executor.invokeAny(tasks);
            System.out.println("Самая быстрая задача вернула: " + fastestResult);
        } catch (ExecutionException e) {
            System.out.println("Ошибка при выполнении одной из задач: " + e.getMessage());
        }

        executor.shutdown();
    }
}
```

**Что произойдёт:**

- Все 3 задачи стартуют одновременно.
- Первая, которая закончится — это вторая (через 1 сек).
- `invokeAny()` сразу возвращает её результат.
- Остальные 2 задачи отменяются автоматически.

Если все задачи упадут с ошибкой — `invokeAny()` выбросит `ExecutionException`.

Вывод:

```
Самая быстрая задача вернула: Результат из задачи 2 (1 сек)
```

Такой подход полезен, например, при:

- Обращении к нескольким серверам — взять ответ того, кто быстрее
- Поиске в разных источниках
- Параллельных попытках — "кто первый, тот и молодец"

## Асинхронные задачи

**Асинхронные задачи** — это задачи, которые выполняются независимо от основного
потока выполнения программы. Это означает, что основной поток может продолжать
свою работу, не дожидаясь завершения асинхронной задачи. Асинхронное выполнение
позволяет улучшить отзывчивость приложений, особенно в тех случаях, когда
требуется выполнение длительных операций, таких как сетевые запросы, операции
ввода-вывода или сложные вычисления. Асинхронные задачи могут выполняться в
фоновом режиме, позволяя основному потоку продолжать выполнение других операций.
После завершения асинхронной задачи можно обработать результаты выполнения. В
Java для этого часто используются объекты`Future` и `Callable`, которые
позволяют получить результат выполнения задачи или обработать исключения.
Асинхронные задачи могут быть настроены на выполнение с тайм-аутами или отменой,
что позволяет избежать зависания приложения при выполнении долгих операций.

### Callable

`Callable` — это функциональный интерфейс в Java, представляющий собой
задачу, которая может быть выполнена асинхронно и возвращает результат. Он
является частью пакета `java.util.concurrent` и часто используется в сочетании с
`ExecutorService` для выполнения задач в фоновом режиме.

В отличие от интерфейса `Runnable`, который не
возвращает результат (метод `run()` имеет тип `void`), метод `call()`
интерфейса `Callable` возвращает значение. Это позволяет получать результат
выполнения задачи.

Метод `call()` может выбрасывать проверяемые
исключения (checked exceptions), что позволяет обрабатывать ошибки,
возникающие во время выполнения задачи. В случае с `Runnable`, все исключения
должны обрабатываться внутри метода `run()`.

Когда задача, реализующая интерфейс `Callable`,
отправляется на выполнение через `ExecutorService`, она возвращает объект
типа `Future`. Этот объект позволяет проверять статус выполнения задачи и
получать результат после ее завершения.

## Задачи и потоки

Задачи и потоки в контексте многопоточности в Java тесно связаны между собой,
поскольку задачи представляют собой единицы работы, которые выполняются в
потоках.

### 1. **Определение потоков и задач**

- **Поток**: Поток — это отдельная последовательность выполнения в программе.
  Каждый поток имеет свой собственный стек вызовов и может выполняться
  параллельно с другими потоками. В Java потоки создаются с помощью класса
  `Thread` или через интерфейсы, такие как `Runnable` и `Callable`.

- **Задача**: Задача — это конкретная работа или операция, которую нужно
  выполнить. В Java задачи могут быть реализованы через интерфейсы `Runnable` (
  для задач без результата) и `Callable` (для задач с результатом).

### 2. **Выполнение задач в потоках**

Когда вы отправляете задачу на выполнение в `ExecutorService`, она будет
выполнена в одном из потоков пула потоков. Вот как это работает:

- **Создание пула потоков**: При создании экземпляра `ExecutorService`, вы
  определяете пул потоков, который будет использоваться для выполнения задач.
  Например, с помощью метода `Executors.newFixedThreadPool(n)` создается пул из
  `n` потоков.

- **Отправка задач**: Когда вы отправляете задачу на выполнение (например, через
  метод `submit()`), `ExecutorService` выбирает один из доступных потоков из
  пула для выполнения этой задачи.

- **Асинхронное выполнение**: Задачи могут выполняться асинхронно, что означает,
  что основной поток программы может продолжать выполнение других операций, не
  дожидаясь завершения задачи.

### 3. **Параллелизм и многопоточность**

Использование задач и потоков позволяет реализовать параллелизм:

- **Параллельное выполнение**: Если у вас есть несколько задач, которые могут
  выполняться одновременно (например, обработка данных или выполнение сетевых
  запросов), вы можете отправить их на выполнение в пул потоков. Пул будет
  распределять задачи между доступными потоками, что позволяет выполнять их
  параллельно.

- **Управление ресурсами**: Пулы потоков помогают управлять ресурсами более
  эффективно. Вместо создания нового потока для каждой задачи (что может быть
  затратным по времени и ресурсам), вы можете повторно использовать существующие
  потоки для выполнения новых задач.

## Future

Объект `Future`, возвращаемый интерфейсом `Callable` в Java, представляет собой
результат асинхронной операции. Он предоставляет методы для проверки состояния
выполнения задачи, получения результата и обработки возможных исключений,
которые могут возникнуть во время выполнения задачи. Давайте рассмотрим основные
аспекты объекта `Future` более подробно.

#### Основные характеристики объекта `Future`

1. **Асинхронный результат**: Объект `Future` позволяет вам получить результат
   выполнения задачи, которая была отправлена на выполнение в пул потоков или
   другой механизм многопоточности. Поскольку задача выполняется асинхронно, вы
   можете продолжать выполнение других операций в основном потоке, не дожидаясь
   завершения задачи.

2. **Методы для управления состоянием**:
    - `isDone()`: Возвращает `true`, если задача завершена (независимо от того,
      была ли она выполнена успешно или завершилась с ошибкой).
    - `isCancelled()`: Возвращает `true`, если задача была отменена до ее
      завершения.
    - `cancel(boolean mayInterruptIfRunning)`: Пытается отменить выполнение
      задачи. Если задача уже выполняется и параметр `mayInterruptIfRunning`
      равен `true`, то выполнение задачи может быть прервано.

3. **Получение результата**:
    - `get()`: Блокирует текущий поток до тех пор, пока задача не завершится, и
      возвращает результат выполнения задачи. Если задача завершилась с
      исключением, метод `get()` выбросит это исключение.
    - `get(long timeout, TimeUnit unit)`: Блокирует текущий поток до тех пор,
      пока задача не завершится или не истечет указанный таймаут.

#### Пример использования объекта Future

Вот пример кода, который демонстрирует использование интерфейса `Callable` и
объекта `Future`:

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Определяем задачу Callable
        Callable<Integer> task = () -> {
            // Имитация длительной операции
            Thread.sleep(2000);
            return 42; // Возвращаем результат
        };

        // Отправляем задачу на выполнение
        Future<Integer> future = executor.submit(task);

        try {
            // Получаем результат выполнения задачи
            Integer result = future.get(); // Это блокирует текущий поток до получения результата
            System.out.println("Результат: " + result);
        } catch (InterruptedException e) {
            System.err.println("Задача была прервана");
        } catch (ExecutionException e) {
            System.err.println("Ошибка при выполнении задачи: " + e.getCause());
        } finally {
            executor.shutdown();
        }
    }
}
```

#### Объяснение примера:

1. **Создание пула потоков**: Мы создаем пул из двух потоков с помощью метода
   `Executors.newFixedThreadPool(2)`.

2. **Определение задачи**: Мы определяем задачу типа `Callable`, которая
   имитирует длительную операцию (например, задержку на 2 секунды) и возвращает
   значение 42.

3. **Отправка задачи**: Мы отправляем задачу на выполнение через метод
   `submit()`, который возвращает объект типа `Future`.

4. **Получение результата**: Мы вызываем метод `get()` у объекта `Future`, чтобы
   получить результат выполнения задачи. Этот вызов блокирует текущий поток до
   тех пор, пока задача не завершится.

5. **Обработка исключений**: Мы обрабатываем возможные исключения:
    - `InterruptedException`: Выбрасывается, если текущий поток был прерван во
      время ожидания результата.
    - `ExecutionException`: Выбрасывается, если задача завершилась с ошибкой; в
      этом случае мы можем получить причину ошибки через метод `getCause()`.

6. **Завершение работы пула**: В конце мы вызываем метод `shutdown()`, чтобы
   корректно завершить работу пула потоков.

### Заключение

Объект `Future` является важным компонентом многопоточного программирования в
Java, позволяя управлять асинхронными задачами и получать результаты их
выполнения. Он предоставляет удобные методы для проверки состояния задач и
обработки результатов или ошибок, что делает его полезным инструментом для
работы с параллельными вычислениями.

## Реализации ExecutorService

ThreadPoolExecutor
ScheduledThreadPoolExecutor
CachedThreadPoolExecutor
ForkJoinPool

#### **ThreadPoolExecutor**

ThreadPoolExecutor – это реализация интерфейса ExecutorService в Java, который
предоставляет пул потоков исполнения для выполнения задач в фоновом режиме.

ThreadPoolExecutor позволяет создать и настроить пул потоков исполнения с
определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения задач в фоновом режиме, что может улучшить
производительность и реактивность вашего приложения.

#### **ScheduledThreadPoolExecutor**

ScheduledThreadPoolExecutor – это реализация интерфейса ScheduledExecutorService
в Java, который предоставляет пул потоков исполнения для выполнения задач в
определенный момент времени или с определенной периодичностью.

ScheduledThreadPoolExecutor позволяет создать и настроить пул потоков исполнения
с определенным количеством потоков, а также управлять очередью задач. Он может
быть использован для выполнения регулярных задач в фоновом режиме, что может
улучшить производительность и реактивность вашего приложения.

#### **CachedThreadPoolExecutor**

CachedThreadPoolExecutor – это реализация интерфейса ExecutorService в Java,
который предоставляет пул потоков исполнения для выполнения задач в фоновом
режиме.

CachedThreadPoolExecutor автоматически масштабирует количество потоков
исполнения в зависимости от количества задач, которые нужно выполнить. Если
задачи поступают слишком быстро и текущее количество потоков исполнения не может
справиться с ними, CachedThreadPoolExecutor создает новый поток исполнения,
чтобы обеспечить выполнение задачи. Если задачи не поступают достаточно быстро и
текущее количество потоков исполнения избыточно, CachedThreadPoolExecutor
автоматически удаляет потоки исполнения, чтобы уменьшить нагрузку на систему.

#### **ForkJoinPool**

ForkJoinPool – это реализация ExecutorService в Java, которая используется для
параллельного выполнения задач. Эти задачи могут быть разбиты на более мелкие
подзадачи. Она позволяет использовать принцип “разделяй и властвуй” для более
эффективного использования многопроцессорных и многопоточных систем.

_**Основные компоненты ForkJoinPool:**_

**Пул потоков исполнения**

ForkJoinPool управляет пулом потоков исполнения, которые используются для
выполнения задач. Количество потоков исполнения в пуле задается при создании
экземпляра ForkJoinPool. Каждый поток в пуле имеет свой собственный стек
вызовов, что позволяет ForkJoinPool улучшить производительность в случае, когда
задачи могут быть разбиты на более мелкие подзадачи.

**Разбиение и объединение задач:**

ForkJoinPool поддерживает работу с задачами типа RecursiveAction и
RecursiveTask, которые представляют собой рекурсивно делимые задачи без
возвращаемого значения и с возвращаемым значением соответственно. Когда
ForkJoinPool получает задачу типа RecursiveTask, он разбивает ее на более мелкие
подзадачи, выполняет их параллельно в разных потоках и объединяет результаты
выполнения в единую итоговую задачу.

# Atomic пакет Механизм под капотом (CAS)

## Atomic пакет

Пакет `java.util.concurrent.atomic` в Java предоставляет набор классов для
выполнения атомарных операций, то есть операций, которые выполняются как единое,
неделимое действие, гарантируя отсутствие вмешательства со стороны других
потоков. Это полезно в многопоточных приложениях, где требуется безопасная
работа с общими переменными без использования явных блокировок (`synchronized`).

### Основные характеристики

1. **Атомарность**: Операции, такие как чтение, запись или обновление
   переменных, выполняются как единое целое, исключая состояние гонки (race
   condition).
2. **Отсутствие блокировок**: Используются низкоуровневые механизмы, такие как *
   *Compare-and-Swap (CAS)**, что делает операции более эффективными по
   сравнению с `synchronized`.
3. **Высокая производительность**: Подход CAS (оптимистическая блокировка)
   минимизирует накладные расходы на синхронизацию, особенно при низкой
   конкуренции потоков.
4. **Поддержка примитивов и ссылок**: Классы пакета поддерживают работу с
   примитивными типами (`int`, `long`, `boolean`), ссылками и массивами.

### Основные классы

Пакет `java.util.concurrent.atomic` содержит следующие ключевые классы:

1. **AtomicInteger**: Для атомарной работы с целыми числами (`int`).
2. **AtomicLong**: Для работы с длинными целыми числами (`long`).
3. **AtomicBoolean**: Для работы с булевыми значениями.
4. **AtomicReference<V>**: Для атомарной работы с объектами любого типа.
5. **AtomicIntegerArray**, **AtomicLongArray**, **AtomicReferenceArray**: Для
   работы с массивами соответствующих типов.
6. **AtomicMarkableReference**, **AtomicStampedReference**: Для атомарных
   операций с дополнительными метками или версиями (например, для предотвращения
   проблемы ABA в CAS).
7. **Adder и Accumulator**:
    - `LongAdder`, `DoubleAdder`: Оптимизированы для подсчета (например,
      инкремента) в условиях высокой конкуренции.
    - `LongAccumulator`, `DoubleAccumulator`: Для обобщенных накопительных
      операций.
8. **AtomicReferenceFieldUpdater**, **AtomicIntegerFieldUpdater**, *
   *AtomicLongFieldUpdater**: Для атомарного обновления полей объектов.

### Основные методы

Большинство классов (`AtomicInteger`, `AtomicLong`, `AtomicReference` и др.)
предоставляют схожие методы:

- **get()**: Получить текущее значение.
- **set(T value)**: Установить новое значение.
- **getAndSet(T value)**: Установить новое значение и вернуть старое.
- **compareAndSet(T expected, T update)**: Атомарно обновить значение, если
  текущее равно ожидаемому.
- **getAndIncrement()**, **getAndDecrement()** (для числовых типов):
  Увеличить/уменьшить значение и вернуть старое.
- **incrementAndGet()**, **decrementAndGet()**: Увеличить/уменьшить значение и
  вернуть новое.
- **getAndUpdate(UpdateFunction)**, **updateAndGet(UpdateFunction)**: Применить
  функцию к текущему значению и вернуть старое/новое значение.
- **lazySet(T value)**: Установить значение с возможной задержкой (менее строгая
  синхронизация для оптимизации).

### Пример использования

#### 1. AtomicInteger

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);

        // Несколько потоков увеличивают счетчик
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.incrementAndGet();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Итоговое значение: " + counter.get()); // 2000
    }
}
```

Здесь `AtomicInteger` гарантирует, что инкремент счетчика будет безопасным в
многопоточной среде.

#### 2. AtomicReference

```java
import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceExample {
    public static void main(String[] args) {
        AtomicReference<String> ref = new AtomicReference<>("Initial");

        // Атомарное обновление
        boolean success = ref.compareAndSet("Initial", "Updated");
        System.out.println("Успех: " + success); // true
        System.out.println("Значение: " + ref.get()); // Updated
    }
}
```

#### 3. LongAdder

```java
import java.util.concurrent.atomic.LongAdder;

public class LongAdderExample {
    public static void main(String[] args) throws InterruptedException {
        LongAdder adder = new LongAdder();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                adder.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Сумма: " + adder.sum()); // 2000
    }
}
```

`LongAdder` эффективен при высокой конкуренции, так как распределяет обновления
между несколькими счетчиками.

### Когда использовать

- **AtomicInteger/Long/Boolean**: Для счетчиков, флагов или других примитивных
  значений, требующих атомарных операций.
- **AtomicReference**: Для безопасного обновления ссылок на объекты (например, в
  структурах данных).
- **LongAdder/DoubleAdder**: Для сценариев с частыми обновлениями (например,
  статистика, счетчики событий).
- **Atomic*Array**: Для работы с массивами в многопоточной среде.
- **Atomic*FieldUpdater**: Для атомарного обновления полей объектов без создания
  новых экземпляров.

### Преимущества

- **Безопасность без блокировок**: CAS-операции минимизируют конкуренцию по
  сравнению с `synchronized`.
- **Производительность**: Особенно эффективны при низкой или средней конкуренции
  потоков.
- **Простота**: Упрощают написание потокобезопасного кода без сложной
  синхронизации.
- **Гибкость**: Поддерживают сложные сценарии, такие как условные обновления (
  `compareAndSet`).

### Ограничения

- **Ограниченные операции**: Поддерживают только определенные типы атомарных
  операций (например, инкремент, сравнение и замена).
- **Проблема ABA**: В `compareAndSet` может возникнуть проблема ABA (когда
  значение меняется A → B → A, и CAS не замечает изменений). Для этого
  используются `AtomicStampedReference` или `AtomicMarkableReference`.
- **Производительность при высокой конкуренции**: CAS может приводить к
  множественным попыткам обновления, что снижает производительность. В таких
  случаях `LongAdder` или `LongAccumulator` предпочтительнее.

### Сравнение с `synchronized`

- **`synchronized`**:
    - Использует блокировку, что может привести к простоям потоков.
    - Подходит для сложной синхронизации, где требуется блокировать несколько
      операций.
    - Более высокие накладные расходы при высокой конкуренции.
- **Atomic**:
    - Использует CAS, избегая блокировок.
    - Подходит для простых операций (например, инкремент, обновление значения).
    - Более эффективен при низкой конкуренции, но может быть менее эффективен
      при высокой.

### Пример сравнения

Без `AtomicInteger` с использованием `synchronized`:

```java
class Counter {
    private int count = 0;

    synchronized void increment() {
        count++;
    }

    int get() {
        return count;
    }
}
```

С `AtomicInteger`:

```java
class Counter {
    private AtomicInteger count = new AtomicInteger(0);

    void increment() {
        count.incrementAndGet();
    }

    int get() {
        return count.get();
    }
}
```

`AtomicInteger` более лаконичен и часто быстрее, так как избегает блокировок.

### Итог

Пакет `java.util.concurrent.atomic` предоставляет мощные инструменты для
потокобезопасной работы с переменными без явных блокировок. Он идеально подходит
для счетчиков, флагов, атомарных обновлений объектов и сценариев с высокой
конкуренцией (с использованием `LongAdder`). Однако для сложной синхронизации,
включающей несколько операций, может потребоваться `synchronized` или другие
механизмы из `java.util.concurrent`.

Если у вас есть конкретный сценарий или вопрос по использованию классов
`atomic`, напишите, и я помогу с примером или разъяснением!

## CAS

Механизм **CAS (Compare-and-Swap)** — это низкоуровневая атомарная операция,
используемая в многопоточных приложениях для безопасного обновления значений без
явных блокировок. В Java CAS широко применяется в классах пакета
`java.util.concurrent.atomic` (например, `AtomicInteger`, `AtomicReference`) и
других структурах данных для обеспечения потокобезопасности. Рассмотрим его
подробнее.

### Что такое CAS?

CAS — это операция, которая атомарно сравнивает текущее значение переменной с
ожидаемым значением и, если они совпадают, обновляет переменную новым значением.
Если значения не совпадают, операция не выполняется, и переменная остается
неизменной. Атомарность гарантирует, что операция выполняется как единое целое,
без вмешательства других потоков.

**Формат CAS**:

```
boolean compareAndSwap(T expectedValue, T newValue)
```

- **expectedValue**: Ожидаемое значение переменной.
- **newValue**: Новое значение, которое будет установлено, если текущее значение
  равно `expectedValue`.
- **Возвращаемое значение**: `true`, если обновление успешно, `false`, если
  текущее значение не совпадает с ожидаемым.

### Как работает CAS?

1. Поток читает текущее значение переменной (например, `A`).
2. Поток готовит новое значение (например, `B`).
3. CAS сравнивает текущее значение переменной с ожидаемым (`A`):
    - Если текущее значение равно `A`, переменная обновляется до `B`, и
      возвращается `true`.
    - Если текущее значение не равно `A` (например, другой поток изменил его на
      `C`), обновление не происходит, и возвращается `false`.
4. Если CAS не удалось, поток может повторить попытку (чтение → подготовка →
   CAS), что называется **оптимистической блокировкой**.

### Пример CAS в Java

В `AtomicInteger` метод `compareAndSet` использует CAS:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class CASExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(100);

        // Попытка обновить значение с 100 на 200
        boolean success = counter.compareAndSet(100, 200);
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + counter.get()); // 200

        // Попытка обновить с неверным ожидаемым значением
        success = counter.compareAndSet(100, 300);
        System.out.println("Успех: " + success); // false
        System.out.println("Значение: " + counter.get()); // 200
    }
}
```

### Реализация CAS

CAS обычно реализуется на уровне аппаратного обеспечения (процессором) через
специальные инструкции, такие как `cmpxchg` (Compare and Exchange) на
архитектурах x86. В Java это реализовано через нативные методы, использующие
библиотеку `sun.misc.Unsafe` или аналогичные механизмы JVM.

Пример псевдокода CAS:

```java
boolean compareAndSwap(Variable var, T expected, T newValue) {
    if (var.get() == expected) {
        var.set(newValue);
        return true;
    }
    return false;
}
```

На деле это атомарная инструкция, выполняемая процессором за один цикл.

### Преимущества CAS

1. **Без блокировок**: Избегает накладных расходов на синхронизацию (
   `synchronized`), что делает его быстрее при низкой конкуренции.
2. **Производительность**: Эффективен в сценариях, где конфликты между потоками
   редки.
3. **Простота**: Упрощает написание потокобезопасного кода для простых
   операций (например, счетчики, флаги).
4. **Широкое применение**: Используется в `Atomic*` классах, неблокирующих
   структурах данных (например, `ConcurrentHashMap`, `ConcurrentLinkedQueue`).

### Недостатки CAS

1. **Проблема ABA**:
    - Ситуация, когда значение переменной меняется с `A` на `B` и обратно на
      `A`. CAS может принять это как отсутствие изменений, что приводит к
      ошибкам.
    - Решение: Использование `AtomicStampedReference` или
      `AtomicMarkableReference`, которые добавляют метку или версию.
    - Пример проблемы ABA:
        - Поток 1 читает значение `A` и готовит CAS.
        - Поток 2 меняет `A` на `B`, затем на `A`.
        - Поток 1 выполняет CAS, думая, что значение не изменилось, хотя оно
          было модифицировано.
2. **Высокая конкуренция**:
    - При большом количестве потоков CAS может приводить к множественным
      неудачным попыткам, что снижает производительность.
    - В таких случаях `LongAdder` или `LongAccumulator` предпочтительнее, так
      как они распределяют нагрузку.
3. **Ограниченные операции**: CAS подходит только для простых обновлений (
   например, замена значения), но не для сложной логики, требующей нескольких
   операций.

### Пример с повторными попытками

Если CAS не удался, поток может повторить попытку:

```java
AtomicInteger counter = new AtomicInteger(0);

void safeIncrement() {
    while (true) {
        int current = counter.get();
        int next = current + 1;
        if (counter.compareAndSet(current, next)) {
            break; // Успех
        }
        // Иначе повторяем
    }
}
```

Этот подход называется **spin-lock** (цикл ожидания), так как поток активно
пытается выполнить операцию, пока не добьется успеха.

### Сравнение с `synchronized`

- **CAS**:
    - Оптимистическая блокировка: предполагает, что конфликты редки, и повторяет
      попытки при неудаче.
    - Быстрее при низкой конкуренции.
    - Не блокирует потоки, но может тратить CPU на повторные попытки.
- **synchronized**:
    - Пессимистическая блокировка: блокирует доступ других потоков к критической
      секции.
    - Прост в использовании для сложной логики, но имеет большие накладные
      расходы при высокой конкуренции.

### Применение CAS в Java

1. **Пакет `java.util.concurrent.atomic`**:
    - `AtomicInteger`, `AtomicLong`, `AtomicReference` и др. используют CAS для
      операций вроде `incrementAndGet`, `compareAndSet`.
2. **Неблокирующие структуры данных**:
    - `ConcurrentHashMap`, `ConcurrentLinkedQueue` используют CAS для
      безопасного обновления своих внутренних структур.
3. **Параллельные алгоритмы**:
    - Например, в `ForkJoinPool` или `parallelStream` для координации задач.
4. **Кастомизация**:
    - Разработчики могут использовать `sun.misc.Unsafe` (не рекомендуется) или
      писать собственные неблокирующие алгоритмы на основе CAS.

### Итог

CAS — это мощный механизм для атомарных операций без блокировок, лежащий в
основе многих потокобезопасных конструкций в Java. Он эффективен для простых
обновлений (например, счетчиков, флагов), но требует осторожности из-за проблемы
ABA и возможных проблем с производительностью при высокой конкуренции. Для
большинства задач достаточно использовать классы из
`java.util.concurrent.atomic`, которые уже реализуют CAS безопасно и эффективно.

## Условные обновления

Условное обновление в контексте программирования, особенно в многопоточных
приложениях Java, — это операция, которая изменяет значение переменной только
при выполнении определенного условия. Обычно это связано с механизмом *
*Compare-and-Swap (CAS)** или аналогичными подходами, где обновление значения
происходит только в том случае, если текущее значение переменной соответствует
ожидаемому. В Java условное обновление чаще всего реализуется с использованием
классов из пакета `java.util.concurrent.atomic`, таких как `AtomicInteger`,
`AtomicLong`, `AtomicReference` и других.

### Что такое условное обновление?

Условное обновление — это атомарная операция, которая:

1. Проверяет текущее значение переменной.
2. Сравнивает его с ожидаемым значением.
3. Если они совпадают, обновляет переменную новым значением.
4. Если не совпадают, операция не выполняется (или возвращается `false`, чтобы
   сигнализировать об этом).

Такой подход используется для обеспечения потокобезопасности без блокировок,
избегая состояний гонки (race conditions) в многопоточных приложениях.

### Основной механизм: Compare-and-Swap (CAS)

Условное обновление в Java чаще всего реализуется через CAS, который атомарно
выполняет сравнение и замену. Основной метод для этого —
`compareAndSet(expectedValue, newValue)`:

- Если текущее значение равно `expectedValue`, оно заменяется на `newValue`, и
  метод возвращает `true`.
- Если текущее значение не равно `expectedValue`, обновление не происходит, и
  метод возвращает `false`.

### Пример условного обновления

#### С использованием `AtomicInteger`

```java
import java.util.concurrent.atomic.AtomicInteger;

public class ConditionalUpdateExample {
    public static void main(String[] args) {
        AtomicInteger value = new AtomicInteger(10);

        // Условное обновление: изменить значение на 20, если текущее значение равно 10
        boolean success = value.compareAndSet(10, 20);
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + value.get()); // 20

        // Повторная попытка с неверным ожидаемым значением
        success = value.compareAndSet(10, 30);
        System.out.println("Успех: " + success); // false
        System.out.println("Значение: " + value.get()); // 20
    }
}
```

#### С использованием `AtomicReference`

```java
import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceExample {
    public static void main(String[] args) {
        AtomicReference<String> ref = new AtomicReference<>("OldValue");

        // Условное обновление: заменить "OldValue" на "NewValue"
        boolean success = ref.compareAndSet("OldValue", "NewValue");
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + ref.get()); // NewValue
    }
}
```

### Применение условного обновления

1. **Счетчики**:
    - Например, атомарное увеличение счетчика только при определенных условиях.
    - `AtomicInteger` использует CAS для методов вроде `incrementAndGet`,
      которые внутренне проверяют текущее значение.
2. **Потокобезопасные структуры данных**:
    - В `ConcurrentHashMap`, `ConcurrentLinkedQueue` и других неблокирующих
      структурах CAS используется для обновления узлов или значений.
3. **Управление состоянием**:
    - Например, изменение флага (`AtomicBoolean`) только при определенном
      состоянии.
4. **Кэши или ленивая инициализация**:
    - Обновление значения в кэше только если оно отсутствует или устарело.
5. **Пользовательские алгоритмы**:
    - Реализация неблокирующих алгоритмов, таких как списки, деревья или
      очереди.

### Пример с повторными попытками

Если условное обновление не удалось (например, из-за изменения значения другим
потоком), можно повторить попытку:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class RetryCASExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);

        // Условное увеличение счетчика
        while (true) {
            int current = counter.get();
            int next = current + 1;
            if (counter.compareAndSet(current, next)) {
                System.out.println("Успешно обновлено до: " + counter.get());
                break;
            }
            // Повторяем, если значение изменилось
        }
    }
}
```

Этот подход называется **spin-lock** — поток продолжает пытаться обновить
значение, пока не добьется успеха.

### Преимущества условного обновления

1. **Без блокировок**: Использует CAS, что снижает накладные расходы по
   сравнению с `synchronized`.
2. **Потокобезопасность**: Гарантирует атомарность операций, избегая состояний
   гонки.
3. **Гибкость**: Позволяет реализовать сложные сценарии, где обновление зависит
   от текущего состояния.
4. **Производительность**: Эффективно при низкой конкуренции потоков, так как не
   блокирует другие потоки.

### Недостатки

1. **Проблема ABA**:
    - Если значение переменной изменилось с `A` на `B` и обратно на `A`, CAS
      может ошибочно принять это как отсутствие изменений.
    - Решение: Использование `AtomicStampedReference` или
      `AtomicMarkableReference`, которые добавляют метку или версию.
2. **Высокая конкуренция**:
    - При большом количестве потоков, пытающихся выполнить CAS, могут возникать
      множественные неудачные попытки, что снижает производительность.
    - В таких случаях лучше использовать `LongAdder` или `LongAccumulator`.
3. **Ограниченная применимость**:
    - Подходит только для операций, которые можно выразить как сравнение и
      замену одного значения.

### Связь с другими механизмами

- **ExecutorService и ThreadPoolExecutor**: Условное обновление может
  использоваться внутри задач для управления общими ресурсами (например,
  счетчиков).
- **ForkJoinPool**: В рекурсивных задачах CAS может применяться для обновления
  промежуточных результатов.
- **Пакет `java.util.concurrent.atomic`**: Основной инструмент для условного
  обновления в Java, реализующий CAS для различных типов данных.

### Итог

Условное обновление — это механизм, позволяющий безопасно изменять значения
переменных в многопоточной среде, основанный на проверке текущего состояния (
обычно через CAS). Он широко используется в классах `Atomic*`, неблокирующих
структурах данных и кастомных алгоритмах. Это мощный инструмент для
потокобезопасности, но требует осторожности из-за проблем вроде ABA и
производительности при высокой конкуренции.

## Ожидаемое значение

В механизме **CAS (Compare-and-Swap)** в Java **ожидаемое значение** — это
значение, которое поток предполагает находится в переменной на момент выполнения
операции CAS. Оно используется для проверки, не было ли значение переменной
изменено другим потоком перед обновлением. Ожидаемое значение является ключевой
частью условного обновления, так как CAS сравнивает текущее значение переменной
с ожидаемым, чтобы решить, выполнять обновление или нет.

### Подробное объяснение

CAS-операция принимает три параметра:

1. **Ожидаемое значение** (`expectedValue`): Значение, которое, по мнению
   потока, в данный момент хранится в переменной.
2. **Новое значение** (`newValue`): Значение, на которое нужно заменить текущее,
   если проверка пройдет успешно.
3. **Текущее значение**: Фактическое значение переменной в момент выполнения
   CAS.

Процесс CAS:

- Сравнивается **текущее значение** переменной с **ожидаемым значением**.
- Если они совпадают, переменная обновляется до **нового значения**, и операция
  возвращает `true`.
- Если они не совпадают (значение было изменено другим потоком), обновление не
  происходит, и операция возвращает `false`.

### Пример с `AtomicInteger`

```java
import java.util.concurrent.atomic.AtomicInteger;

public class CASExpectedValueExample {
    public static void main(String[] args) {
        AtomicInteger value = new AtomicInteger(5);

        // Поток предполагает, что текущее значение = 5 (ожидаемое значение)
        int expectedValue = 5;
        int newValue = 10;

        // Пытаемся обновить значение с 5 на 10
        boolean success = value.compareAndSet(expectedValue, newValue);
        System.out.println("Успех: " + success); // true
        System.out.println("Новое значение: " + value.get()); // 10

        // Теперь ожидаемое значение = 5, но текущее значение уже 10
        success = value.compareAndSet(5, 20);
        System.out.println("Успех: " + success); // false
        System.out.println("Значение: " + value.get()); // 10
    }
}
```

В этом примере:

- Первая операция `compareAndSet(5, 10)` успешна, так как текущее значение (`5`)
  совпадает с ожидаемым (`5`).
- Вторая операция `compareAndSet(5, 20)` не выполняется, так как текущее
  значение (`10`) не совпадает с ожидаемым (`5`).

### Роль ожидаемого значения

1. **Проверка целостности**: Ожидаемое значение позволяет убедиться, что
   переменная не была изменена другим потоком с момента последнего чтения. Это
   предотвращает состояния гонки.
2. **Оптимистическая блокировка**: Поток предполагает, что значение не
   изменилось (оптимизм), и использует CAS для проверки. Если значение
   изменилось, поток может повторить попытку с новым ожидаемым значением.
3. **Основа потокобезопасности**: Ожидаемое значение обеспечивает атомарность
   операции, избегая необходимости явных блокировок (`synchronized`).

### Пример с повторными попытками

Если CAS не удался из-за несовпадения ожидаемого значения, поток может
перечитать текущее значение и повторить попытку:

```java
AtomicInteger counter = new AtomicInteger(0);

void safeIncrement() {
    while (true) {
        int expectedValue = counter.get(); // Читаем текущее значение как ожидаемое
        int newValue = expectedValue + 1;
        if (counter.compareAndSet(expectedValue, newValue)) {
            break; // Успех
        }
        // Повторяем, если ожидаемое значение не совпало с текущим
    }
}
```

Здесь поток получает текущее значение (`expectedValue`), вычисляет новое
значение и пытается выполнить CAS. Если другой поток изменил значение, CAS
возвращает `false`, и цикл повторяется с новым ожидаемым значением.

### Проблема ABA

Ожидаемое значение может вызвать проблему ABA:

- Поток 1 читает значение `A` как ожидаемое.
- Поток 2 меняет значение на `B`, а затем обратно на `A`.
- Поток 1 выполняет CAS, думая, что значение не изменилось, так как текущее
  значение снова `A`.

**Решение**: Использование `AtomicStampedReference` или
`AtomicMarkableReference`, которые добавляют метку или версию к значению, чтобы
отслеживать изменения.

### Применение ожидаемого значения

- **Счетчики**: Например, `AtomicInteger` использует ожидаемое значение в
  `incrementAndGet` для атомарного увеличения.
- **Неблокирующие структуры данных**: В `ConcurrentHashMap` или
  `ConcurrentLinkedQueue` CAS с ожидаемым значением используется для обновления
  узлов.
- **Кастомные алгоритмы**: Ожидаемое значение позволяет реализовать
  потокобезопасные операции без блокировок.

### Итог

Ожидаемое значение в CAS — это значение, которое поток ожидает увидеть в
переменной на момент выполнения операции. Оно используется для проверки, что
переменная не была изменена другим потоком, обеспечивая атомарность и
потокобезопасность. Если ожидаемое значение не совпадает с текущим, обновление
не происходит, что позволяет избежать состояний гонки. Этот механизм лежит в
основе классов `java.util.concurrent.atomic` и неблокирующих алгоритмов.

# Оптимистическая и пессимистическая блокировки

**Оптимистическая** и **пессимистическая блокировки** — это два разных подхода к
управлению доступом к общим ресурсам в многопоточных приложениях, таких как в
Java. Они используются для обеспечения потокобезопасности, предотвращения
состояний гонки и конфликтов при одновременном доступе нескольких потоков к
данным. Рассмотрим их отличия, механизмы и применение.

### 1. **Оптимистическая блокировка**

**Оптимистическая блокировка** предполагает, что конфликты между потоками редки,
и поэтому потоки могут работать с данными без предварительной блокировки. Вместо
этого проверка целостности данных выполняется в момент записи (например, с
использованием **Compare-and-Swap (CAS)**). Если конфликт обнаруживается (данные
были изменены другим потоком), операция повторяется.

#### Как работает?

- Поток читает данные и выполняет вычисления, не блокируя ресурс.
- При попытке записать изменения проверяется, не изменились ли данные с момента
  их чтения (например, с помощью ожидаемого значения в CAS).
- Если данные не изменились, обновление выполняется.
- Если данные изменились, операция либо отменяется, либо повторяется с новыми
  данными.

#### Пример в Java

Оптимистическая блокировка часто реализуется с использованием классов из пакета
`java.util.concurrent.atomic`, таких как `AtomicInteger`:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class OptimisticLockExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                while (true) {
                    int expectedValue = counter.get();
                    int newValue = expectedValue + 1;
                    if (counter.compareAndSet(expectedValue, newValue)) {
                        break; // Успех
                    }
                    // Повторяем, если значение изменилось
                }
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Итоговое значение: " + counter.get()); // 2000
    }
}
```

Здесь `compareAndSet` проверяет, совпадает ли текущее значение с ожидаемым, и
только тогда обновляет его. Если значение изменилось, поток повторяет попытку.

#### Преимущества

- **Высокая производительность при низкой конкуренции**: Нет накладных расходов
  на блокировки, так как потоки работают параллельно без ожидания.
- **Меньше блокировок**: Потоки не блокируют друг друга, что снижает вероятность
  взаимоблокировок (deadlocks).
- **Масштабируемость**: Хорошо работает в системах с большим количеством потоков
  и редкими конфликтами.

#### Недостатки

- **Проблема при высокой конкуренции**: Если много потоков пытаются обновить
  данные одновременно, CAS может приводить к множественным неудачным попыткам,
  что снижает производительность.
- **Проблема ABA**: Если значение изменилось с `A` на `B` и обратно на `A`, CAS
  может не заметить изменений (решается с помощью `AtomicStampedReference`).
- **Сложность кода**: Требует ручного управления повторными попытками при
  неудачном обновлении.

#### Когда использовать

- Когда конфликты между потоками редки (например, в счетчиках, кэшах).
- В неблокирующих структурах данных (`ConcurrentHashMap`,
  `ConcurrentLinkedQueue`).
- Для простых операций, таких как обновление счетчиков или флагов.

### 2. **Пессимистическая блокировка**

**Пессимистическая блокировка** предполагает, что конфликты между потоками
вероятны, поэтому доступ к ресурсу блокируется заранее, чтобы только один поток
мог работать с ним в определенный момент. В Java это обычно реализуется с
помощью ключевого слова `synchronized` или блокировок из пакета
`java.util.concurrent.locks` (например, `ReentrantLock`).

#### Как работает?

- Поток захватывает блокировку (lock) перед доступом к общему ресурсу.
- Другие потоки, пытающиеся получить доступ, приостанавливаются (блокируются),
  пока блокировка не будет освобождена.
- После завершения работы поток освобождает блокировку, позволяя другим потокам
  продолжить.

#### Пример в Java

Использование `synchronized` для пессимистической блокировки:

```java
public class PessimisticLockExample {
    private int counter = 0;

    public synchronized void increment() {
        counter++;
    }

    public int getCounter() {
        return counter;
    }

    public static void main(String[] args) throws InterruptedException {
        PessimisticLockExample example = new PessimisticLockExample();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Итоговое значение: " + example.getCounter()); // 2000
    }
}
```

Здесь `synchronized` гарантирует, что только один поток может выполнять метод
`increment` в определенный момент.

#### Преимущества

- **Простота**: Легко реализовать для сложных операций, требующих нескольких
  шагов.
- **Гарантия целостности**: Полностью исключает конфликты, так как только один
  поток имеет доступ к ресурсу.
- **Подходит для высокой конкуренции**: Хорошо работает, когда много потоков
  часто обращаются к одному ресурсу.

#### Недостатки

- **Низкая производительность при высокой конкуренции**: Потоки могут долго
  ждать освобождения блокировки, что приводит к простоям.
- **Риск взаимоблокировок**: Неправильное использование блокировок может
  привести к deadlock’ам.
- **Накладные расходы**: Блокировки требуют ресурсов для управления (например,
  мониторы в `synchronized`).

#### Когда использовать

- Когда операции сложные и требуют нескольких шагов, которые должны быть
  выполнены атомарно.
- Когда конфликты между потоками часты, и повторные попытки CAS были бы слишком
  затратными.
- Для критических секций, где важна строгая последовательность операций.

### Сравнение оптимистической и пессимистической блокировок

| Характеристика         | Оптимистическая блокировка (CAS)                    | Пессимистическая блокировка (`synchronized`, `Lock`) |
|------------------------|-----------------------------------------------------|------------------------------------------------------|
| **Подход**             | Предполагает редкие конфликты, проверяет при записи | Предполагает частые конфликты, блокирует заранее     |
| **Механизм**           | CAS (Compare-and-Swap)                              | Блокировки (мониторы, `ReentrantLock`)               |
| **Производительность** | Высокая при низкой конкуренции                      | Низкая при высокой конкуренции                       |
| **Сложность кода**     | Требует управления повторными попытками             | Прост в использовании для сложных операций           |
| **Риск**               | Проблема ABA, неудачные попытки при конкуренции     | Взаимоблокировки, простои потоков                    |
| **Примеры в Java**     | `AtomicInteger`, `ConcurrentHashMap`                | `synchronized`, `ReentrantLock`                      |
| **Использование**      | Простые обновления, неблокирующие структуры         | Сложные операции, критические секции                 |

### Пример сценария

1. **Оптимистическая блокировка**:
    - Подсчет посещений страницы в веб-приложении с помощью `AtomicInteger` или
      `LongAdder`.
    - Обновление значения в кэше, если оно не изменилось.
2. **Пессимистическая блокировка**:
    - Обновление банковского счета, где требуется проверить баланс, списать
      средства и записать транзакцию в одной критической секции.
    - Работа с файлом, где несколько операций (чтение, изменение, запись) должны
      быть атомарными.

### Связь с другими механизмами

- **ExecutorService/ThreadPoolExecutor**: Оптимистическая блокировка может
  использоваться внутри задач для обновления общих счетчиков или флагов.
- **ForkJoinPool**: Часто использует CAS для координации подзадач (например, в
  `parallelStream`).
- **Пакет `java.util.concurrent.atomic`**: Основной инструмент для
  оптимистической блокировки через CAS.

### Итог

- **Оптимистическая блокировка** (CAS) подходит для сценариев с редкими
  конфликтами, где важна производительность и масштабируемость. Она избегает
  блокировок, но требует управления повторными попытками и учета проблемы ABA.
- **Пессимистическая блокировка** (`synchronized`, `ReentrantLock`) лучше для
  сложных операций или высокой конкуренции, но может приводить к простоям
  потоков и риску взаимоблокировок.

Если у вас есть конкретный пример или задача, где нужно выбрать между этими
подходами, напишите, и я помогу с кодом или рекомендациями!