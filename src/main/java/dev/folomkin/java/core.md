# JAVA CORE

################################################################################
--------------------------------------------------------------------------------

# Нововведения по версиям Java

Я расскажу о ключевых нововведениях в Java по основным версиям, начиная с Java
1.0 и до актуальных на май 2025 года. Список будет кратким, но охватит основные
изменения, влияющие на язык, стандартную библиотеку и JVM. Для удобства разобью
по версиям, выделяя наиболее значимые новшества.

### Java 1.0 (1996)

- Первый релиз Java.
- Основные черты: платформонезависимость, объектно-ориентированное
  программирование, автоматическое управление памятью (сборка мусора).
- Библиотека: базовые классы (AWT для GUI, java.util для коллекций).

### Java 1.1 (1997)

- Введение внутреннего классов (inner classes).
- JDBC для работы с базами данных.
- Улучшения в AWT и добавление JavaBeans.

### Java 2 (Java 1.2, 1998)

- Коллекции (Collections Framework: List, Set, Map).
- Swing для продвинутого GUI.
- JIT-компилятор (Just-In-Time) для повышения производительности.
- Поддержка строгой типизации в `strictfp`.

### Java 1.3 (2000)

- HotSpot JVM — новый движок для оптимизации производительности.
- JNDI (Java Naming and Directory Interface).
- Улучшения в JavaSound и RMI.

### Java 1.4 (2002)

- Регулярные выражения (`java.util.regex`).
- Assertions для отладки.
- NIO (New Input/Output) для неблокирующего ввода-вывода.
- Логгинг API (`java.util.logging`).
- Поддержка XML (JAXP).

### Java 5 (1.5, 2004)

- **Generics**: обобщённые типы для безопасной работы с коллекциями.
- Перечисления (Enums).
- Аннотации (`@Override`, `@Deprecated` и др.).
- Autoboxing/unboxing для автоматического преобразования примитивов в объекты.
- Цикл `for-each` для упрощения итерации.
- Varargs (`...`) для методов с переменным числом аргументов.
- `java.util.concurrent` для многопоточного программирования (ExecutorService,
  ConcurrentHashMap).

### Java 6 (2006)

- Улучшения производительности JVM.
- Поддержка скриптовых языков (JavaScript через `javax.script`).
- Улучшения в JDBC 4.0 и поддержка XML (JAXB 2.0).
- Инструменты мониторинга и диагностики JVM.

### Java 7 (2011)

- **Switch с String**: использование строк в `switch`.
- Try-with-resources для автоматического закрытия ресурсов.
- Diamond-оператор (`<>`) для упрощения работы с Generics.
- NIO.2: улучшения для работы с файловой системой (`java.nio.file`).
- Fork/Join Framework для параллельных вычислений.
- Мелкие улучшения синтаксиса (бинарные литералы, подчёркивания в числах).

### Java 8 (2014)

- **Lambda-выражения**: функциональное программирование (`x -> x * 2`).
- **Stream API**: обработка данных в функциональном стиле (`filter`, `map`,
  `reduce`).
- Интерфейсы с методами по умолчанию (`default methods`).
- `Optional` для борьбы с `NullPointerException`.
- Новый API для работы с датой и временем (`java.time`).
- Nashorn JavaScript-движок.
- Удаление PermGen, замена на Metaspace в JVM.

### Java 9 (2017)

- **Модульная система** (JPMS, Jigsaw): `module-info.java` для модульности.
- Интерактивная консоль JShell.
- Улучшения в Stream API и `Optional`.
- `HttpClient` для работы с HTTP/2.
- Private методы в интерфейсах.
- Улучшения в Process API и GC (G1 стал сборщиком по умолчанию).

### Java 10 (2018)

- **Local-Variable Type Inference**: `var` для локальных переменных.
- Улучшения в GC и контейнеризации.
- API для неизменяемых коллекций (`List.of()`, `Set.of()`).
- Экспериментальная поддержка GraalVM.

### Java 11 (2018, LTS)

- Новый HTTP Client (стандарт).
- Удаление Java EE и CORBA модулей.
- Поддержка TLS 1.3.
- `String` методы: `isBlank()`, `lines()`, `strip()`.
- `var` в лямбда-выражениях.
- Epsilon GC (без сборки мусора для специфичных случаев).

### Java 12 (2019)

- Switch-выражения (preview, упрощённый синтаксис).
- Shenandoah GC (экспериментальный, низкие паузы).
- Улучшения в производительности JVM.
- `String` методы: `indent()`, `transform()`.

### Java 13 (2019)

- Улучшения в switch-выражениях (preview).
- Текстовые блоки (preview, многострочные строки).
- Улучшения в ZGC (Z Garbage Collector).
- Динамические CDS (Class Data Sharing) архивы.

### Java 14 (2020)

- Switch-выражения стали стандартными.
- Текстовые блоки (preview 2).
- Records (preview, компактные классы для данных).
- Pattern Matching для `instanceof` (preview).
- Улучшения в ZGC и NullPointerException (подробные сообщения).

### Java 15 (2020)

- Текстовые блоки стали стандартными.
- Records (preview 2).
- Sealed Classes (preview, ограничение наследования).
- Hidden Classes для фреймворков.
- Улучшения в GC (ZGC, Shenandoah).

### Java 16 (2021)

- Records стали стандартными.
- Pattern Matching для `instanceof` (стандарт).
- Sealed Classes (preview 2).
- Новый инструмент `jpackage` для создания инсталляторов.
- Улучшения в Stream API и Vector API (incubator).

### Java 17 (2021, LTS)

- Sealed Classes стали стандартными.
- Улучшения в Random API.
- Удаление устаревших API (Applet API).
- Восстановление Always-Strict Floating-Point семантики.
- Поддержка macOS/AArch64.

### Java 18 (2022)

- UTF-8 как кодировка по умолчанию.
- Простой веб-сервер (`jwebserver`).
- Code Snippets в JavaDoc (`@snippet`).
- Vector API (второй incubator).
- Pattern Matching для switch (preview).

### Java 19 (2022)

- Pattern Matching для switch (preview 2).
- Virtual Threads (preview, Project Loom) для упрощения многопоточности.
- Vector API (третий incubator).
- Record Patterns (preview).

### Java 20 (2023)

- Pattern Matching для switch (preview 3).
- Record Patterns (preview 2).
- Virtual Threads (preview 2).
- Scoped Values (incubator, для передачи данных в потоках).
- Structured Concurrency (incubator).

### Java 21 (2023, LTS)

- Virtual Threads стали стандартными.
- Pattern Matching для switch (стандарт).
- Record Patterns (стандарт).
- Sequenced Collections (новый интерфейс для коллекций с порядком).
- String Templates (preview).
- Unnamed Classes и Instance Main Methods (preview, упрощение кода).

### Java 22 (2024)

- Unnamed Classes и Instance Main Methods (стандарт).
- String Templates (preview 2).
- Foreign Function & Memory API (стандарт, для взаимодействия с нативным кодом).
- Structured Concurrency (стандарт).
- Vector API (стандарт).
- Statements перед `super()` в конструкторах (preview).

### Java 23 (2024)

- Модульные JAR-файлы для упрощения работы с модулями.
- Улучшения в `Stream` API (Gatherers для кастомной обработки).
- Implicit Classes и Instance Main Methods (preview 2).
- Primitive Types в Pattern Matching (preview).
- Flexible Constructor Bodies (стандарт).

### Java 24 (ожидается в 2025)

На момент мая 2025 года Java 24 ещё не выпущена, но ожидаемые нововведения (на
основе JEP и обсуждений сообщества):

- Улучшения в Project Valhalla (Value Objects, Primitive Classes для оптимизации
  производительности).
- Дальнейшая работа над Pattern Matching для примитивов.
- Упрощение API для многопоточности (Project Loom).
- Потенциальные улучшения в GC и JVM для контейнеров.

### Текущая ситуация (май 2025)

- **LTS-версии**: Java 8, 11, 17, 21 — самые используемые в продакшене.
- **Активные проекты**:
    - **Project Loom**: упрощение многопоточности (Virtual Threads).
    - **Project Valhalla**: Value Objects и примитивные классы.
    - **Project Panama**: улучшение взаимодействия с нативным кодом.
    - **Project Amber**: упрощение синтаксиса (Pattern Matching, Records).
- Oracle продолжает выпускать версии каждые полгода, с долгосрочной поддержкой (
  LTS) каждые два года.

Если нужно углубиться в конкретную версию, проект или пример кода, дайте знать!

################################################################################
--------------------------------------------------------------------------------

# Устройство памяти

В Java память управляется автоматически с помощью **сборщика мусора** (Garbage
Collector), что отличает её от языков, где требуется ручное управление памятью (
например, C++). Устройство памяти в Java делится на несколько основных областей,
которые используются JVM (Java Virtual Machine) для выполнения программы.
Рассмотрим их подробно:

### 1. **Общая структура памяти JVM**

JVM делит память на несколько областей:

- **Heap (Куча)**: Хранит объекты и их данные.
- **Stack (Стек)**: Используется для хранения локальных переменных и стеков
  вызовов методов.
- **Method Area (Область методов)**: Хранит метаданные классов, статические
  переменные и код методов.
- **PC Register (Регистр программного счётчика)**: Содержит адрес текущей
  инструкции для каждого потока.
- **Native Method Stack (Стек нативных методов)**: Используется для выполнения
  нативного кода (например, через JNI).

### 2. **Heap (Куча)**

- **Основное назначение**: Хранит все объекты, созданные с помощью `new`,
  включая экземпляры классов и массивы.
- **Структура кучи**:
    - **Young Generation (Молодое поколение)**:
        - **Eden**: Сюда изначально помещаются новые объекты.
        - **Survivor Spaces (S0 и S1)**: Объекты, пережившие сборку мусора,
          перемещаются сюда.
    - **Old Generation (Старое поколение)**: Хранит долгоживущие объекты.
    - **Permanent Generation (до Java 8) / Metaspace (с Java 8)**: Хранит
      метаданные классов и строки из строкового пула (в Java 7+ строки
      перемещены в кучу).
- **Сборка мусора**:
    - Молодое поколение очищается чаще (Minor GC), так как многие объекты "
      живут" недолго.
    - Старое поколение очищается реже (Major GC или Full GC), так как там
      находятся долгоживущие объекты.
    - Алгоритмы сборки мусора: Mark-and-Sweep, G1, ZGC, Shenandoah (в
      зависимости от версии JVM).

### 3. **Stack (Стек)**

- **Назначение**: Хранит локальные переменные, ссылки на объекты и информацию о
  вызовах методов (каждый поток имеет свой стек).
- **Структура**:
    - Каждый вызов метода создаёт **фрейм** (frame) в стеке.
    - Фрейм содержит:
        - Локальные переменные метода.
        - Операндовый стек для промежуточных вычислений.
        - Ссылку на текущий метод и класс.
- **Особенности**:
    - Стек работает по принципу LIFO (Last In, First Out).
    - Если стек переполняется (например, при глубокой рекурсии), возникает
      `StackOverflowError`.
    - Локальные переменные примитивных типов (`int`, `double` и т.д.) хранятся
      непосредственно в стеке, а ссылки на объекты указывают на кучу.

### 4. **Method Area (Область методов)**

- **Назначение**: Хранит:
    - Метаданные классов (структура, поля, методы).
    - Статические переменные.
    - Константный пул (константы, используемые классом).
- **Особенности**:
    - До Java 8 эта область была частью кучи и называлась Permanent Generation.
    - С Java 8 используется **Metaspace**, который выделяется в нативной памяти
      и может динамически расширяться.
    - Если Metaspace переполняется, возникает `OutOfMemoryError: Metaspace`.

### 5. **PC Register (Регистр программного счётчика)**

- **Назначение**: Хранит адрес текущей инструкции, выполняемой потоком.
- **Особенности**:
    - Каждый поток имеет свой регистр.
    - Используется JVM для управления выполнением байт-кода.

### 6. **Native Method Stack (Стек нативных методов)**

- **Назначение**: Хранит информацию о вызовах нативных методов (например,
  написанных на C/C++ через JNI).
- **Особенности**: Размер стека ограничен, переполнение вызывает
  `StackOverflowError`.

### 7. **Управление памятью**

- **Сборщик мусора**:
    - Отслеживает объекты, на которые больше нет ссылок, и освобождает память.
    - Основные алгоритмы: Serial GC, Parallel GC, G1 (по умолчанию с Java 9),
      ZGC, Shenandoah.
- **Ключевые особенности**:
    - Java не позволяет вручную освобождать память (нет аналога `free` или
      `delete`).
    - Вы можете лишь "предложить" сборку мусора через `System.gc()`, но JVM не
      гарантирует её выполнение.
    - Для оптимизации работы с памятью используются пулы объектов, кэширование и
      другие техники.

### 8. **Типичные ошибки, связанные с памятью**

- **OutOfMemoryError**:
    - `Java heap space`: Недостаточно памяти в куче.
    - `Metaspace`: Переполнение области метаданных.
- **StackOverflowError**: Переполнение стека, обычно из-за глубокой рекурсии.
- **Memory Leak**: Утечки памяти из-за удержания ссылок на ненужные объекты (
  например, в коллекциях).

### 9. **Оптимизация памяти**

- Используйте правильные коллекции (например, `ArrayList` вместо `LinkedList`
  для быстрого доступа).
- Избегайте хранения ненужных ссылок в статических полях.
- Настраивайте параметры JVM (например, `-Xms`, `-Xmx` для кучи,
  `-XX:MaxMetaspaceSize` для Metaspace).
- Используйте инструменты профилирования (VisualVM, JProfiler) для анализа
  использования памяти.

### Пример

```java
public class MemoryExample {
    public static void main(String[] args) {
        // Объект создаётся в куче (Eden), ссылка myObj в стеке
        MyClass myObj = new MyClass();
        // Локальная переменная i хранится в стеке
        int i = 10;
        // Статическая переменная хранится в Metaspace
        MyClass.staticField = 20;
    }
}

class MyClass {
    static int staticField; // В Metaspace
    int instanceField; // В куче
}
```

### Заключение

Устройство памяти в Java организовано так, чтобы разработчик мог сосредоточиться
на логике программы, а JVM автоматически управляет памятью. Куча и стек —
основные области, где хранятся данные, а сборщик мусора минимизирует утечки
памяти. Понимание структуры памяти помогает оптимизировать производительность и
избегать ошибок вроде `OutOfMemoryError`.


--------------

## Heap. Young Generation (Молодое поколение). Old Generation (Старое поколение)

В Java **Heap (Куча)** делится на несколько областей, из которых **Young
Generation** (Молодое поколение) и **Old Generation** (Старое поколение) играют
ключевую роль в управлении памятью и работе сборщика мусора (Garbage Collector,
GC). Рассмотрим их подробнее.

### 1. **Young Generation (Молодое поколение)**

Молодое поколение — это область кучи, где создаются новые объекты и происходит
их начальная обработка сборщиком мусора. Оно оптимизировано для работы с
объектами, которые обычно имеют короткий жизненный цикл (быстро создаются и
уничтожаются).

#### Структура Young Generation

Молодое поколение делится на три подобласти:

- **Eden**:
    - Все новые объекты, созданные с помощью `new`, изначально размещаются
      здесь.
    - Это самая большая часть Young Generation.
    - Большинство объектов в Eden "живут" недолго и быстро становятся
      недостижимыми (например, временные объекты в методах).
- **Survivor Spaces (S0 и S1)**:
    - Два небольших пространства, называемые **From** и **To**, используются для
      хранения объектов, переживших хотя бы одну сборку мусора.
    - После сборки мусора в Eden живые объекты перемещаются в один из Survivor
      Spaces (например, S0).
    - При следующей сборке мусора объекты из S0 (если они всё ещё живы)
      перемещаются в S1, и наоборот.
    - Объекты, которые переживают несколько циклов сборки мусора (обычно 15, в
      зависимости от настройки JVM), перемещаются в **Old Generation**.

#### Работа сборщика мусора в Young Generation

- **Minor GC**: Процесс сборки мусора в Young Generation.
    - Быстрый, так как область относительно небольшая.
    - Удаляет недостижимые объекты из Eden и Survivor Spaces.
    - Живые объекты перемещаются между Survivor Spaces или в Old Generation (
      если они "достаточно старые").
- Алгоритмы: Обычно используется **Copying Collector** (копирующий сборщик
  мусора), который копирует живые объекты из Eden и одного Survivor Space в
  другой Survivor Space, минимизируя фрагментацию.

#### Особенности

- Размер Young Generation обычно меньше, чем Old Generation, но сборка мусора
  здесь происходит чаще.
- Параметры JVM, такие как `-Xmn`, позволяют настраивать размер Young
  Generation.
- Оптимизировано для объектов с коротким жизненным циклом, что соответствует
  принципу "большинство объектов умирают молодыми".

### 2. **Old Generation (Старое поколение)**

Старое поколение — это область кучи, предназначенная для хранения долгоживущих
объектов, которые пережили несколько циклов сборки мусора в Young Generation.

#### Характеристики

- **Назначение**: Хранит объекты, которые используются в течение длительного
  времени (например, объекты конфигурации, кэши, пулы соединений).
- **Размер**: Обычно значительно больше, чем Young Generation, так как
  долгоживущие объекты накапливаются.
- **Сборка мусора**:
    - Процесс называется **Major GC** или **Full GC** (если затрагивает всю
      кучу).
    - Выполняется реже, чем Minor GC, но занимает больше времени, так как
      область больше и алгоритмы сложнее.
    - Используются алгоритмы, такие как **Mark-and-Sweep-Compact** (в старых
      версиях JVM) или более современные, например **G1** или **ZGC**, которые
      минимизируют паузы.
- **Проблемы**:
    - Переполнение Old Generation вызывает `OutOfMemoryError: Java heap space`.
    - Утечки памяти (например, из-за неправильно управляемых коллекций) часто
      проявляются в Old Generation.

#### Перемещение объектов

- Объекты попадают в Old Generation, если они пережили заданное количество
  циклов Minor GC (параметр `-XX:MaxTenuringThreshold`, по умолчанию 15).
- Некоторые объекты (например, очень большие) могут создаваться сразу в Old
  Generation, минуя Young Generation, если их размер превышает определённый
  порог.

### 3. **Ключевые различия**

| **Характеристика**   | **Young Generation**                    | **Old Generation**                      |
|----------------------|-----------------------------------------|-----------------------------------------|
| **Назначение**       | Хранение новых и краткоживущих объектов | Хранение долгоживущих объектов          |
| **Подобласти**       | Eden, Survivor Spaces (S0, S1)          | Единая область                          |
| **Сборка мусора**    | Minor GC (быстрая)                      | Major/Full GC (медленная)               |
| **Алгоритмы**        | Copying Collector                       | Mark-and-Sweep, G1, ZGC и др.           |
| **Размер**           | Меньше, настраивается через `-Xmn`      | Больше, зависит от `-Xmx`               |
| **Частота GC**       | Часто                                   | Редко                                   |
| **Типичные объекты** | Временные объекты, локальные переменные | Кэши, пулы, глобальные структуры данных |

### 4. **Пример работы**

```java
public class Example {
    public static void main(String[] args) {
        // Создаётся в Eden
        Object temp = new Object();
        // Локальная переменная temp перестанет существовать после выхода из метода
        // и будет удалена при Minor GC

        // Объект, который может попасть в Old Generation
        static List<Object> cache = new ArrayList<>();
        cache.add(new Object()); // Этот объект может пережить несколько GC и попасть в Old Generation
    }
}
```

- Объект `temp` создаётся в Eden и, скорее всего, будет удалён при следующем
  Minor GC.
- Объект в `cache` может переместиться в Survivor Space, а затем в Old
  Generation, если останется достижимым.

### 5. **Оптимизация**

- **Young Generation**:
    - Увеличение размера Eden (`-XX:NewSize`, `-XX:MaxNewSize`) может уменьшить
      частоту Minor GC, но увеличивает паузы.
    - Настройка соотношения Eden и Survivor Spaces (`-XX:SurvivorRatio`)
      помогает балансировать производительность.
- **Old Generation**:
    - Используйте современные сборщики мусора (G1, ZGC) для минимизации пауз.
    - Избегайте утечек памяти, очищая коллекции и слабые ссылки (
      `WeakReference`, `SoftReference`).
    - Настройте максимальный размер кучи (`-Xmx`) для поддержки долгоживущих
      объектов.

### 6. **Заключение**

Young Generation и Old Generation — это ключевые области кучи, которые разделяют
объекты по их "возрасту" и жизненному циклу. Young Generation оптимизирован для
быстрого создания и удаления объектов, а Old Generation — для хранения
долгоживущих данных. Понимание их работы помогает оптимизировать
производительность Java-приложений и эффективно управлять памятью.

Если нужно углубиться в конкретный аспект (например, алгоритмы GC или настройка
параметров JVM), дайте знать!


==========================================================
---------------------------------------------------------

# Сборка мусора. CG Root

Сборка мусора (Garbage Collection, GC) в Java — это автоматический процесс
управления памятью, который освобождает память, занятую объектами, на которые
больше нет ссылок. JVM (Java Virtual Machine) использует сборщик мусора для
предотвращения утечек памяти и упрощения работы разработчика. В этом ответе я
расскажу о сборке мусора в Java, её механизмах, а также подробно объясню, что
такое **Garbage Collector Roots** (корни сборщика мусора).

---

### 1. **Сборка мусора в Java: Основы**

Сборка мусора в Java основана на принципе: если объект недостижим (на него нет
активных ссылок из программы), он считается "мусором" и может быть удалён.
Основные задачи сборщика мусора:

- Определение недостижимых объектов.
- Освобождение памяти, занятой этими объектами.
- Устранение фрагментации памяти (в некоторых алгоритмах).

#### Процесс сборки мусора

1. **Mark (Пометка)**: Сборщик мусора идентифицирует, какие объекты всё ещё
   достижимы, начиная с корней (Garbage Collector Roots).
2. **Sweep (Очистка)**: Удаляет недостижимые объекты, освобождая память.
3. **Compact (Уплотнение, опционально)**: Перемещает оставшиеся объекты, чтобы
   уменьшить фрагментацию (используется в некоторых алгоритмах, например,
   Mark-and-Sweep-Compact).
4. **Copy (Копирование, в Young Generation)**: В Молодом поколении живые объекты
   копируются из одной области (например, Eden) в другую (Survivor Space),
   минимизируя фрагментацию.

#### Области памяти, где работает GC

Сборка мусора происходит в основном в **Heap (Куче)**, которая делится на:

- **Young Generation** (Eden + Survivor Spaces): Для краткоживущих объектов,
  очищается с помощью **Minor GC**.
- **Old Generation**: Для долгоживущих объектов, очищается с помощью **Major GC
  ** или **Full GC** (затрагивает всю кучу).
- **Metaspace** (с Java 8): Хранит метаданные классов, очищается отдельно.

#### Типы сборщиков мусора

JVM предоставляет несколько реализаций сборщика мусора, каждая из которых
подходит для разных сценариев:

1. **Serial GC**: Однопоточный, для небольших приложений.
2. **Parallel GC**: Многопоточный, для высокой пропускной способности.
3. **CMS (Concurrent Mark-Sweep)**: Минимизирует паузы, но устарел с Java 9.
4. **G1 (Garbage-First)**: Баланс между паузами и пропускной способностью,
   используется по умолчанию с Java 9.
5. **ZGC** и **Shenandoah**: Современные сборщики с низкими паузами для больших
   объёмов памяти (доступны с Java 11+).

---

### 2. **Garbage Collector Roots (Корни сборщика мусора)**

**Garbage Collector Roots** — это отправные точки, с которых сборщик мусора
начинает поиск достижимых объектов. Корни представляют собой ссылки, от которых
можно "добраться" до объектов в памяти. Если объект не связан с корнем ни одной
цепочкой ссылок, он считается недостижимым и подлежит удалению.

#### Что является GC Root?

GC Roots — это объекты или ссылки, которые гарантированно "живы" в контексте
программы. Основные типы корней:

1. **Локальные переменные в стеке**:
    - Переменные, находящиеся в стеке текущего метода (например, параметры
      метода или локальные переменные).
    - Пример: `Object obj = new Object();` — `obj` в стеке является GC Root.
2. **Статические переменные**:
    - Статические поля классов, хранящиеся в Metaspace.
    - Пример: `static List<Object> cache = new ArrayList<>();` — `cache`
      является GC Root.
3. **Активные потоки (Threads)**:
    - Все запущенные потоки (объекты `Thread`) считаются корнями, так как они
      активны.
    - Ссылки из стека вызовов потока также являются корнями.
4. **Классы, загруженные ClassLoader'ом**:
    - Объекты классов, загруженные активным загрузчиком классов (например,
      системным ClassLoader'ом).
    - Это включает метаданные классов и их статические поля.
5. **Ссылки из нативного кода (JNI)**:
    - Объекты, на которые ссылаются из нативного кода через Java Native
      Interface (JNI).
6. **Синхронизационные мониторы**:
    - Объекты, используемые в блоках `synchronized`, пока они заблокированы.
7. **Ссылки JVM**:
    - Специальные объекты, которые JVM удерживает для своих внутренних нужд (
      например, строки в строковом пуле до Java 7 или системные объекты).

#### Как GC использует корни?

1. **Поиск достижимых объектов**:
    - Сборщик мусора начинает с GC Roots и рекурсивно обходит все ссылки (граф
      объектов).
    - Объекты, до которых можно добраться от корней, помечаются как "живые".
    - Объекты, не связанные с корнями, считаются "мусором".
2. **Пример**:
   ```java
   public class GCRootExample {
       static Object staticObj = new Object(); // GC Root (статическая переменная)
       public static void main(String[] args) {
           Object localObj = new Object(); // GC Root (локальная переменная в стеке)
           List<Object> list = new ArrayList<>(); // list — GC Root
           list.add(new Object()); // Объект в списке достижим через list
           localObj = null; // Объект, на который указывал localObj, теперь недостижим
       }
   }
   ```
    - `staticObj` — GC Root, объект, на который он ссылается, останется живым.
    - `localObj` — GC Root, пока метод `main` выполняется. После присваивания
      `null` объект становится недостижимым и может быть удалён.
    - Объект в `list` остаётся достижимым, так как `list` — GC Root.

#### Роль GC Roots в сборке мусора

- GC Roots определяют, какие объекты "живы". Без корней сборщик мусора не смог
  бы понять, что можно удалить.
- Неправильное управление корнями (например, хранение ссылок в статических
  полях) может привести к утечкам памяти, так как объекты остаются достижимыми.

---

### 3. **Ключевые особенности сборки мусора**

- **Автоматичность**: Разработчик не управляет памятью вручную (нет `free` или
  `delete`).
- **Паузы (Stop-the-World)**: Во время сборки мусора (особенно Major GC)
  выполнение программы может приостанавливаться. Современные сборщики (ZGC,
  Shenandoah) минимизируют такие паузы.
- **Типы сборок**:
    - **Minor GC**: Очистка Young Generation, быстрая.
    - **Major/Full GC**: Очистка Old Generation или всей кучи, более
      ресурсоёмкая.
- **Настройка**:
    - Параметры JVM, такие как `-Xms`, `-Xmx`, `-XX:NewRatio`,
      `-XX:MaxTenuringThreshold`, позволяют настраивать поведение GC.
    - Выбор сборщика: `-XX:+UseG1GC`, `-XX:+UseZGC` и т.д.

---

### 4. **Проблемы и оптимизация**

- **Утечки памяти**:
    - Возникают, если объекты остаются достижимыми через GC Roots (например,
      статические коллекции).
    - Решение: Используйте слабые ссылки (`WeakReference`, `SoftReference`) или
      очищайте коллекции.
- **Долгие паузы**:
    - Major GC может вызывать заметные задержки. Современные сборщики (G1, ZGC)
      решают эту проблему.
- **Мониторинг**:
    - Используйте инструменты вроде VisualVM, JProfiler или параметры JVM (
      `-Xlog:gc`) для анализа работы GC.
- **Оптимизация**:
    - Уменьшайте создание ненужных объектов.
    - Настраивайте размеры Young и Old Generation.
    - Выбирайте подходящий сборщик мусора для вашего приложения.

---

### 5. **Заключение**

Сборка мусора в Java — это мощный механизм, который автоматизирует управление
памятью, освобождая разработчика от ручной работы. **GC Roots** играют
центральную роль, определяя, какие объекты остаются в памяти. Понимание корней и
их влияния на достижимость объектов помогает избегать утечек памяти и
оптимизировать производительность. Различные сборщики мусора (G1, ZGC и др.)
предоставляют гибкость для разных сценариев использования, от небольших
приложений до высоконагруженных серверов.

Если хотите углубиться в конкретный алгоритм (например, G1 или ZGC) или примеры
утечек памяти, дайте знать!

---------------------------------------- ---------- ---------- -----------------  

## Алгоритмы сборки мусора G1 и ZGC

В Java сборка мусора (Garbage Collection, GC) — ключевой механизм управления
памятью, а **G1 (Garbage-First)** и **ZGC (Z Garbage Collector)** — два
современных сборщика мусора, разработанных для повышения производительности и
минимизации пауз. Они подходят для разных сценариев: G1 балансирует пропускную
способность и паузы, а ZGC ориентирован на сверхнизкие задержки для больших
объёмов памяти. Рассмотрим их подробнее.

---

### 1. **G1 (Garbage-First)**

G1 — это сборщик мусора, представленный в Java 7 и ставший сборщиком по
умолчанию в Java 9. Он разработан для приложений с большими объемами памяти (от
нескольких ГБ) и ориентирован на баланс между пропускной способностью и
предсказуемыми паузами.

#### Основные особенности G1

- **Региональная структура кучи**:
    - G1 делит кучу на множество небольших регионов (обычно 1–32 МБ), которые
      могут быть частью Young Generation (Eden, Survivor) или Old Generation.
    - Регионы не обязаны быть смежными, что позволяет гибко управлять памятью.
- **Приоритетная очистка**:
    - G1 фокусируется на регионах с наибольшим количеством "мусора" (отсюда
      название Garbage-First), что повышает эффективность очистки.
- **Смешанная сборка (Mixed GC)**:
    - G1 выполняет как **Minor GC** (очистка Young Generation), так и **Mixed GC
      ** (очистка Young и части Old Generation).
    - Mixed GC позволяет постепенно очищать Old Generation, избегая длительных
      Full GC.
- **Параллельность и конкурентность**:
    - G1 использует несколько потоков для ускорения фазы пометки (Mark) и
      очистки (Sweep).
    - Некоторые этапы (например, пометка живых объектов) выполняются конкурентно
      с приложением, минимизируя паузы.
- **Stop-the-World (STW)**:
    - G1 использует STW-паузы для определённых операций, но они короче, чем у
      старых сборщиков (например, CMS).
    - Целевое время пауз можно настроить с помощью параметра
      `-XX:MaxGCPauseMillis` (по умолчанию 200 мс).

#### Как работает G1

1. **Инициализация**:
    - Куча делится на регионы, каждый из которых может быть Eden, Survivor, Old
      или свободным.
    - Новые объекты создаются в регионах Eden.
2. **Minor GC**:
    - Очищает Young Generation (Eden и Survivor).
    - Живые объекты копируются в новые регионы Survivor или перемещаются в Old
      Generation, если они достаточно "старые".
3. **Concurrent Marking**:
    - G1 конкурентно помечает достижимые объекты, начиная с GC Roots.
    - Определяет регионы с наибольшим количеством мусора.
4. **Mixed GC**:
    - Очищает как Young Generation, так и выбранные регионы Old Generation.
    - Выбираются регионы, где очистка даст наибольшую выгоду (много мусора, мало
      живых объектов).
5. **Full GC**:
    - Происходит редко, если G1 не успевает очищать Old Generation или куча
      переполняется.
    - Это STW-событие, которое G1 старается избегать.

#### Преимущества G1

- Эффективное управление большими кучами (от 4 ГБ и выше).
- Предсказуемые паузы за счёт настройки целевого времени пауз.
- Постепенная очистка Old Generation, что снижает вероятность Full GC.
- Автоматическая адаптация под нагрузку приложения.

#### Недостатки G1

- Более высокая нагрузка на процессор из-за конкурентных операций.
- Меньшая пропускная способность по сравнению с Parallel GC в некоторых
  сценариях.
- Full GC всё ещё возможен при высоких нагрузках или неправильной настройке.

#### Настройка G1

- `-XX:+UseG1GC`: Включение G1.
- `-XX:MaxGCPauseMillis`: Установка целевого времени паузы (например,
  `-XX:MaxGCPauseMillis=100`).
- `-XX:G1HeapRegionSize`: Размер региона кучи (по умолчанию выбирается
  автоматически).
- `-XX:InitiatingHeapOccupancyPercent`: Порог заполнения Old Generation для
  начала Concurrent Marking (по умолчанию 45%).

#### Когда использовать G1

- Приложения, требующие низких и предсказуемых пауз (например, веб-серверы).
- Большие кучи (4 ГБ и выше).
- Если требуется баланс между паузами и производительностью.

---

### 2. **ZGC (Z Garbage Collector)**

ZGC — это современный сборщик мусора, представленный в Java 11 (
экспериментально) и ставший полностью стабильным в Java 15. Он разработан для
приложений с очень большими кучами (до терабайт) и минимальными паузами (обычно
менее 10 мс), что делает его идеальным для высоконагруженных систем, где
задержки критичны.

#### Основные особенности ZGC

- **Низкие паузы**:
    - ZGC обеспечивает паузы менее 10 мс, независимо от размера кучи.
    - Большинство операций (пометка, перемещение объектов) выполняются
      конкурентно с приложением.
- **Colored Pointers**:
    - ZGC использует "цветные указатели" (colored pointers), где метаданные о
      состоянии объекта хранятся в самом указателе (в битах адреса).
    - Это позволяет отслеживать состояние объектов без дополнительных затрат
      памяти.
- **Load Barriers**:
    - ZGC использует барьеры чтения (load barriers) при доступе к объектам,
      чтобы обновлять ссылки в случае перемещения объектов.
- **Однопроходная сборка**:
    - В отличие от G1, ZGC не разделяет Young и Old Generation. Все объекты
      обрабатываются единообразно.
    - Это упрощает структуру кучи, но требует больше ресурсов для конкурентной
      работы.
- **Поддержка больших куч**:
    - ZGC эффективен для куч от нескольких ГБ до терабайт.
- **Уплотнение памяти**:
    - ZGC автоматически перемещает живые объекты, устраняя фрагментацию, причём
      делает это конкурентно.

#### Как работает ZGC

1. **Инициализация**:
    - Куча делится на регионы, как в G1, но без явного разделения на Young и Old
      Generation.
    - Новые объекты распределяются по регионам.
2. **Concurrent Marking**:
    - ZGC конкурентно помечает достижимые объекты, начиная с GC Roots, используя
      цветные указатели.
3. **Concurrent Relocation**:
    - ZGC перемещает живые объекты в новые регионы, устраняя фрагментацию.
    - Барьеры чтения обновляют ссылки на перемещённые объекты.
4. **Stop-the-World (STW)**:
    - Паузы минимальны и происходят только для синхронизации корней (GC Roots)
      или завершения некоторых операций.
    - Длительность пауз не зависит от размера кучи или количества объектов.

#### Преимущества ZGC

- Сверхнизкие паузы (<10 мс), подходящие для приложений с жёсткими требованиями
  к задержкам.
- Эффективная работа с большими кучами (до терабайт).
- Автоматическое устранение фрагментации без длительных STW-пауз.
- Простота настройки (ZGC требует минимальной конфигурации).

#### Недостатки ZGC

- Высокая нагрузка на процессор из-за конкурентных операций и барьеров чтения.
- Меньшая пропускная способность по сравнению с Parallel GC или G1 в некоторых
  сценариях.
- Требует 64-битной JVM и больше памяти для метаданных (цветные указатели).

#### Настройка ZGC

- `-XX:+UseZGC`: Включение ZGC.
- `-Xmx`: Установка максимального размера кучи (например, `-Xmx16g`).
- `-XX:ConcGCThreads`: Количество потоков для конкурентной работы (по умолчанию
  выбирается автоматически).
- `-XX:ZCollectionInterval`: Интервал между сборками (по умолчанию адаптивный).

#### Когда использовать ZGC

- Приложения с жёсткими требованиями к задержкам (например, финансовые системы,
  реал-тайм приложения).
- Очень большие кучи (десятки ГБ или терабайты).
- Системы, где важна стабильность времени отклика.

---

### 3. **Сравнение G1 и ZGC**

| **Характеристика**         | **G1**                                | **ZGC**                                        |
|----------------------------|---------------------------------------|------------------------------------------------|
| **Введён**                 | Java 7, по умолчанию с Java 9         | Java 11 (экспериментально), стабилен с Java 15 |
| **Паузы**                  | До 200 мс (настраиваемо)              | <10 мс, независимо от размера кучи             |
| **Структура кучи**         | Регионы, Young + Old Generation       | Регионы, без разделения на поколения           |
| **Сборка мусора**          | Minor GC, Mixed GC, Full GC           | Конкурентная сборка, минимальные STW           |
| **Фрагментация**           | Решается Mixed GC и Full GC           | Конкурентное уплотнение                        |
| **Пропускная способность** | Высокая, но ниже, чем у Parallel GC   | Ниже из-за барьеров чтения                     |
| **Подходит для**           | Средние/большие кучи, баланс пауз     | Большие кучи, минимальные задержки             |
| **Настройка**              | Много параметров для тонкой настройки | Минимальная настройка                          |

---

### 4. **Пример настройки**

Для приложения с кучей 16 ГБ и требованием пауз <100 мс:

- **G1**:
  ```bash
  java -XX:+UseG1GC -Xmx16g -XX:MaxGCPauseMillis=100 -jar app.jar
  ```
- **ZGC**:
  ```bash
  java -XX:+UseZGC -Xmx16g -jar app.jar
  ```

---

### 5. **Заключение**

- **G1** — универсальный выбор для большинства приложений с большими кучами, где
  требуется баланс между паузами и производительностью. Подходит для серверных
  приложений с умеренными требованиями к задержкам.
- **ZGC** — идеален для высоконагруженных систем с большими кучами, где
  критически важны минимальные паузы (например, реал-тайм системы или
  микросервисы).

Если нужно углубиться в конкретный сценарий использования, примеры настройки или
сравнение производительности, дайте знать!



==========================================================
---------------------------------------------------------

## Типы ссылок

==========================================================
---------------------------------------------------------

# String pool

**String Pool** (или **пул строк**) в Java — это специальная область памяти в
куче (Heap), предназначенная для хранения строковых литералов и интернированных
строк. Этот механизм оптимизирует использование памяти и повышает
производительность, так как строки являются одними из самых часто используемых
объектов в Java-программах. Давайте разберём, как работает String Pool, его
особенности и место в структуре памяти Java.

---

### 1. **Что такое String Pool?**

String Pool — это кэш строк, который хранит уникальные экземпляры строковых
объектов (`String`) в памяти. Основная цель:

- **Экономия памяти**: Повторно использует одинаковые строки вместо создания
  новых объектов.
- **Ускорение работы**: Сравнение строк с помощью `==` (на идентичность) для
  строк из пула быстрее, чем сравнение содержимого через `equals()`.

В Java строки неизменяемы (immutable), поэтому безопасно хранить их в пуле для
повторного использования.

---

### 2. **Где находится String Pool?**

- **До Java 7**:
    - String Pool находился в **Permanent Generation** (часть кучи, где хранятся
      метаданные классов и статические данные).
    - Это приводило к проблемам, так как Permanent Generation имела
      фиксированный размер, и переполнение пула строк могло вызвать
      `OutOfMemoryError: PermGen space`.
- **С Java 7 и выше**:
    - String Pool был перенесён в основную часть **Heap** (обычно в Young или
      Old Generation, в зависимости от "возраста" строк).
    - Это позволило лучше управлять памятью, так как куча динамически
      масштабируется (настраивается через `-Xmx`).
    - После Java 8 Permanent Generation заменён на **Metaspace**, который теперь
      хранит только метаданные классов, а не строки.

---

### 3. **Как работает String Pool?**

String Pool управляется JVM и содержит строки, созданные двумя основными
способами:

1. **Строковые литералы**:
    - Строки, заданные в коде напрямую, например: `String s = "Hello";`.
    - Такие строки автоматически помещаются в String Pool при загрузке класса.
    - Если строка с таким же содержимым уже есть в пуле, JVM возвращает ссылку
      на существующий объект вместо создания нового.
2. **Интернирование строк**:
    - Метод `String.intern()` позволяет вручную добавить строку в String Pool.
    - Если строка уже есть в пуле, возвращается ссылка на неё; если нет — строка
      добавляется в пул.

#### Пример:

```java
String s1 = "Hello"; // Создаётся в String Pool
String s2 = "Hello"; // Ссылается на тот же объект в String Pool
String s3 = new String("Hello"); // Создаётся новый объект в куче, НЕ в String Pool
String s4 = s3.intern(); // Помещает "Hello" в String Pool (или возвращает ссылку на существующий объект)

System.out.

println(s1 ==s2); // true (один и тот же объект в String Pool)
System.out.

println(s1 ==s3); // false (s3 — новый объект в куче)
System.out.

println(s1 ==s4); // true (s4 ссылается на объект в String Pool)
```

---

### 4. **Как строки попадают в String Pool?**

- **Литералы**: Все строковые литералы, объявленные в коде (например,
  `"Hello"`), автоматически добавляются в String Pool при загрузке класса.
- **Метод `intern()`**: Вызов `String.intern()` проверяет, есть ли строка в
  пуле. Если строка отсутствует, она добавляется; если есть — возвращается
  ссылка на неё.
- **Конкатенация констант**: Если строка создаётся путём конкатенации строковых
  литералов на этапе компиляции, она также помещается в String Pool. Например:
  ```java
  String s = "Hel" + "lo"; // "Hello" будет в String Pool
  ```
  Но если конкатенация происходит во время выполнения (например, с переменными),
  результат создаётся в куче, а не в пуле:
  ```java
  String prefix = "Hel";
  String s = prefix + "lo"; // Создаётся в куче, НЕ в String Pool
  ```

---

### 5. **Сборка мусора и String Pool**

- Строки в String Pool подлежат сборке мусора, если на них больше нет ссылок.
- **До Java 7**: Строки в Permanent Generation редко очищались, так как эта
  область нечасто подвергалась сборке мусора. Это могло привести к переполнению
  PermGen.
- **С Java 7**: Поскольку String Pool находится в куче, строки удаляются
  сборщиком мусора, как и другие объекты, если они становятся недостижимыми.
    - Строки, созданные как литералы, обычно остаются достижимыми через
      метаданные классов (ClassLoader), пока класс загружен.
    - Строки, добавленные через `intern()`, могут быть удалены, если на них нет
      ссылок.

---

### 6. **Особенности и ограничения**

- **Уникальность**: String Pool гарантирует, что для каждого уникального
  строкового значения существует только один объект в пуле.
- **Производительность**:
    - Использование String Pool снижает потребление памяти, так как одинаковые
      строки не дублируются.
    - Сравнение строк из пула с помощью `==` быстрее, чем `equals()`, но следует
      использовать `equals()` для сравнения содержимого, чтобы избежать ошибок.
- **Ограничения**:
    - Чрезмерное использование `intern()` может привести к переполнению кучи,
      особенно если создаётся много уникальных строк.
    - В старых версиях Java (до 7) переполнение String Pool вызывало
      `OutOfMemoryError: PermGen space`.

---

### 7. **Практические рекомендации**

- **Используйте литералы для констант**:
  ```java
  String s = "Hello"; // Эффективно, строка в String Pool
  ```
  Избегайте создания строк через `new String("Hello")`, так как это создаёт
  лишний объект в куче.
- **Осторожно с `intern()`**:
    - Используйте `intern()` только для строк, которые будут часто повторяться и
      использоваться долгое время.
    - Например, для обработки больших объёмов данных (парсинг, конфигурации).
- **Мониторинг памяти**:
    - Используйте инструменты (VisualVM, JProfiler) для анализа использования
      String Pool.
    - Настраивайте размер кучи (`-Xmx`) для больших приложений с интенсивным
      использованием строк.
- **Конкатенация**:
    - Для динамической конкатенации используйте `StringBuilder` или
      `StringBuffer`, чтобы избежать создания временных объектов в куче:
      ```java
      StringBuilder sb = new StringBuilder();
      sb.append("Hel").append("lo"); // Эффективно
      String result = sb.toString();
      ```

---

### 8. **Пример кода**

```java
public class StringPoolExample {
    public static void main(String[] args) {
        String literal1 = "Test"; // В String Pool
        String literal2 = "Test"; // Ссылается на тот же объект в String Pool
        String newString = new String("Test"); // В куче, вне String Pool
        String interned = newString.intern(); // Ссылается на объект в String Pool

        System.out.println(literal1 == literal2); // true (одинаковые объекты в String Pool)
        System.out.println(literal1 == newString); // false (newString в куче)
        System.out.println(literal1 == interned); // true (interned ссылается на String Pool)
        System.out.println(literal1.equals(newString)); // true (сравнение содержимого)
    }
}
```

---

### 9. **Заключение**

String Pool — это эффективный механизм в Java для оптимизации хранения строк,
который использует неизменяемость строк для повторного использования объектов. С
Java 7 он находится в куче, что упрощает управление памятью и делает его более
устойчивым к переполнению. Понимание работы String Pool помогает писать более
эффективный код, избегать лишнего потребления памяти и правильно использовать
методы вроде `intern()`.


================================================================================
--------------------------------------------------------------------------------

# HashCode, equals()

`hashCode()` и `equals()` — это **два ключевых метода**,
которые влияют на сравнение объектов и работу **коллекций**, таких как
`HashMap`, `HashSet`, `Hashtable`. Давай разберем всё по полочкам. 🚀

### Что такое `equals()`?

Метод `equals()` сравнивает **содержимое объектов** (не их ссылки).
По умолчанию (в `Object`) он работает как `==`, т.е. сравнивает **адреса в
памяти**.

Чтобы сравнивать по содержанию (например, по полям), нужно переопределить его.

#### Пример:

```java
public class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        Person p = (Person) obj;
        return this.age == p.age && this.name.equals(p.name);
    }
}
```

### Что такое `hashCode()`?

Метод `hashCode()` возвращает **целое число**, которое используется для быстрого
поиска объекта в хэш-таблицах (`HashMap`, `HashSet` и др.).

Если два объекта **равны по `equals()`**, они **обязаны иметь
одинаковый `hashCode()`**.

**_Важное правило:_**

> Если переопределяешь `equals()`, обязательно переопредели и `hashCode()`.
> Иначе `HashMap`, `HashSet` и т.п. будут работать **неправильно**.


Пример ошибки:

```java
void demo() {
    Person p1 = new Person("Alice", 30);
    Person p2 = new Person("Alice", 30);

    System.out.println(p1.equals(p2)); // true
    set.add(p1);
    set.contains(p2); // false, если hashCode не переопределен!
}
```

Причина: `hashCode` разный, и `HashSet` ищет в другой "корзине".

Как правильно переопределить `hashCode()`:

```java

@Override
public int hashCode() {
    return Objects.hash(name, age); // С Java 7+
}
```

_**Резюме:**_

| Метод        | Назначение                                  | Что сравнивает                |
|--------------|---------------------------------------------|-------------------------------|
| `equals()`   | Проверяет логическое равенство объектов     | Содержимое полей              |
| `hashCode()` | Возвращает хэш-значение для быстрого поиска | Используется в хэш-структурах |

_**Где применяются:**_

| Коллекция   | Что требует                      |
|-------------|----------------------------------|
| `HashMap`   | `equals()` и `hashCode()`        |
| `HashSet`   | `equals()` и `hashCode()`        |
| `TreeSet`   | `compareTo()` (или `Comparator`) |
| `ArrayList` | `equals()` для поиска и удаления |

