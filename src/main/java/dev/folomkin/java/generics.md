# Java Generics

## Ограничения типов. Верхний/нижний уровни

Ограничения типов в Java Generics — это механизм, который позволяет ограничивать
типы, используемые в обобщённых (generic) классах, интерфейсах или методах. Они
обеспечивают безопасность типов, гибкость и читаемость кода, позволяя
компилятору проверять корректность использования типов во время компиляции.
Ограничения типов в основном выражаются через ключевые слова `extends` и `super`
в сочетании с подстановочными знаками (`?`) или точными типами.

### Основные виды ограничений типов

1. **Верхняя граница (Upper Bound)**: `T extends SomeClass` или
   `? extends SomeClass`
2. **Нижняя граница (Lower Bound)**: `? super SomeClass`
3. **Без ограничений (Unbounded Wildcard)**: `?`
4. **Точный тип**: `T` без `extends` или `super`

### 1. Верхняя граница (Upper Bound)

- **Синтаксис**: `T extends Class` или `T extends Interface` (для подстановочных
  знаков: `? extends Class`).
- **Значение**: Ограничивает тип `T` или подстановочный тип `?` классом `Class`,
  интерфейсом `Interface` или их подтипами.
- **Применение**: Используется, когда нужно гарантировать, что обобщённый тип
  является подтипом определённого класса или реализует определённый интерфейс.
- **Особенности**:
    - Можно указать несколько интерфейсов:
      `T extends Class & Interface1 & Interface2`.
    - Нельзя указать несколько классов (Java не поддерживает множественное
      наследование классов).
    - Для подстановочных знаков (`? extends T`) чтение безопасно, но запись (
      кроме `null`) невозможна.

**Пример**:

```java
public <T extends Number> void printNumber(T number) {
    System.out.println(number.doubleValue()); // Метод доступен, так как T — подтип Number
}

printNumber(42);     // Integer — подтип Number

printNumber(3.14);   // Double — подтип Number
// printNumber("text"); // Ошибка компиляции: String не подтип Number
```

**Пример с коллекцией**:

```java
public void printList(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num); // Чтение безопасно
    }
    // list.add(1); // Ошибка компиляции: нельзя добавлять
}
```

### 2. Нижняя граница (Lower Bound)

- **Синтаксис**: `? super Class`
- **Значение**: Ограничивает подстановочный тип `?` классом `Class` или его
  супертипами.
- **Применение**: Используется, когда нужно разрешить запись объектов типа
  `Class` или его подтипов в коллекцию, но не требуется специфичное чтение.
- **Особенности**:
    - Применяется только к подстановочным знакам (`?`), а не к параметрам типа (
      `T super Class` не поддерживается).
    - Запись безопасна для типа `Class` и его подтипов.
    - Чтение возможно только как `Object`, так как точный тип неизвестен.

**Пример**:

```java
public void addIntegers(List<? super Integer> list) {
    list.add(1); // Безопасно, Integer совместим
    list.add(2);
    // Integer num = list.get(0); // Ошибка: нельзя гарантировать тип
    Object obj = list.get(0); // Работает
}

List<Number> numbers = new ArrayList<>();
List<Object> objects = new ArrayList<>();

addIntegers(numbers); // Работает: Number — супертип Integer

addIntegers(objects); // Работает: Object — супертип Integer
```

### 3. Без ограничений (Unbounded Wildcard)

- **Синтаксис**: `?`
- **Значение**: Подстановочный знак без ограничений, эквивалентен
  `? extends Object`.
- **Применение**: Используется, когда тип не важен, и требуется максимальная
  гибкость (например, для методов, которые работают с любыми типами).
- **Особенности**:
    - Чтение возможно только как `Object`.
    - Запись невозможна (кроме `null`).

**Пример**:

```java
public void printAnyList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj); // Чтение как Object
    }
    // list.add(1); // Ошибка: нельзя добавлять
}

List<String> strings = Arrays.asList("a", "b");
List<Integer> integers = Arrays.asList(1, 2);

printAnyList(strings);   // Работает

printAnyList(integers);  // Работает
```

### 4. Точный тип

- **Синтаксис**: `T` или `List<T>` (без `extends` или `super`).
- **Значение**: Требует точного соответствия типу `T`, без подтипов или
  супертипов.
- **Применение**: Используется, когда метод или класс должен работать с
  конкретным типом, и требуется как чтение, так и запись.
- **Особенности**: Менее гибко, чем подстановочные знаки, но позволяет полные
  операции с типом.

**Пример**:

```java
public <T> void addAndPrint(List<T> list, T item) {
    list.add(item); // Запись
    System.out.println(list.get(0)); // Чтение
}

List<String> strings = new ArrayList<>();

addAndPrint(strings, "hello"); // Работает
// addAndPrint(strings, 1); // Ошибка: Integer не String
```

### Практическое применение ограничений типов

1. **Безопасность типов**: Ограничения предотвращают ошибки, такие как
   добавление неподходящего типа в коллекцию.
2. **Гибкость API**: Подстановочные знаки (`? extends` и `? super`) позволяют
   методам работать с широким спектром типов.
3. **Улучшение читаемости**: Ограничения явно указывают, какие типы допустимы,
   делая код более понятным.

**Пример из стандартной библиотеки**:

- Метод `Collections.max`:
  ```java
  public static <T extends Comparable<? super T>> T max(Collection<? extends T> coll)
  ```
    - `T extends Comparable<? super T>`: Тип `T` должен быть сравнимым (
      реализовать `Comparable` для себя или супертипа).
    - `? extends T`: Коллекция содержит элементы типа `T` или его подтипов.

### Связь с PECS

Ограничения типов тесно связаны с правилом **PECS** (Producer Extends, Consumer
Super):

- **Producer (`? extends T`)**: Используется для чтения данных, ограничивает тип
  подтипами `T`.
- **Consumer (`? super T`)**: Используется для записи данных, ограничивает тип
  супертипами `T`.

### Ограничения и подводные камни

1. **Невозможность записи при `? extends T`**:
   ```java
   List<? extends Number> list = new ArrayList<Integer>();
   list.add(1); // Ошибка: компилятор не знает точный тип
   ```
2. **Ограниченное чтение при `? super T`**:
   ```java
   List<? super Integer> list = new ArrayList<Number>();
   Integer num = list.get(0); // Ошибка: можно читать только как Object
   ```
3. **Нельзя использовать `super` с параметрами типа**:
   ```java
   public <T super Number> void method(T t) {} // Ошибка
   ```
4. **Сложности с несколькими ограничениями**: Можно комбинировать класс и
   интерфейсы, но не два класса:
   ```java
   public <T extends Number & Comparable<T>> void method(T t) {} // Работает
   // public <T extends Number & String> void method(T t) {} // Ошибка
   ```

### Заключение

Ограничения типов в Java Generics позволяют точно контролировать, какие типы
могут использоваться в обобщённых классах, интерфейсах и методах. Верхняя
граница (`extends`) подходит для "производителей" данных, нижняя граница (
`super`) — для "потребителей", а подстановочные знаки без ограничений (`?`) —
для максимальной гибкости. Правильное использование ограничений делает код
безопасным, гибким и понятным. Если у вас есть конкретный пример или вопрос,
напишите, и я помогу разобраться!

================================================================================
--------------------------------------------------------------------------------

## Контракт PECS

Контракт **PECS** в Java Generics расшифровывается как **Producer Extends,
Consumer Super**. Это мнемоническое правило, предложенное Джошуа Блохом,
помогает определить, когда использовать ограничения `extends` и `super` в
обобщённых типах (generics) для обеспечения безопасности типов и гибкости кода.
PECS применяется к коллекциям или другим обобщённым типам, где важны роли "
производителя" (producer) и "потребителя" (consumer) данных.

### Основная идея PECS

- **Producer Extends**: Если обобщённый тип используется как **производитель**
  данных (т.е. вы только **читаете** данные из структуры), используйте
  ограничение `? extends T`. Это позволяет безопасно получать элементы типа `T`
  или его подтипов.
- **Consumer Super**: Если обобщённый тип используется как **потребитель**
  данных (т.е. вы только **записываете** данные в структуру), используйте
  ограничение `? super T`. Это позволяет безопасно записывать элементы типа `T`
  или его супертипов.

### Подробное объяснение


```java
// Основная идея:

// ? extend SuperClass
// ? < class - отдает данные, нельзя записать
// ? > class - получает данные, нельзя отдавать

public static void main(String[] args) {
    List<? extends Number> numbers = List.of(1.0, 2.0, 3.0);
    Number n = numbers.get(1);
    System.out.println(n);

    List<? super Integer> integers = new ArrayList<>();
    integers.add(1);
    Number m = integers.get(1);
    System.out.println(m);


}
```

#### 1. **Producer Extends (`? extends T`)**

- Используется, когда вы хотите **только читать** данные из обобщённой
  структуры.
- Ограничение `? extends T` означает, что коллекция содержит элементы типа `T`
  или любого его подтипа.
- Пример: Вы хотите прочитать элементы из списка, но не добавлять в него новые
  элементы.
- Почему это безопасно? При чтении вы получаете объекты типа `T` (или его
  подтипов), и компилятор гарантирует, что тип будет совместим с `T`.
- Ограничение: Вы **не можете добавлять** элементы в такую коллекцию (кроме
  `null`), так как компилятор не знает, какой конкретный подтип `T`
  используется.

**Пример кода:**

```java
public void printList(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num); // Чтение безопасно
    }
    // list.add(1); // Ошибка компиляции: нельзя добавлять
}

List<Integer> integers = Arrays.asList(1, 2, 3);
List<Double> doubles = Arrays.asList(1.5, 2.5);

printList(integers); // Работает

printList(doubles);  // Работает
```

Здесь `List<? extends Number>` позволяет читать элементы как `Number`, но
добавление невозможно, так как компилятор не знает, является ли список
`List<Integer>`, `List<Double>` или другим подтипом.

#### 2. **Consumer Super (`? super T`)**

- Используется, когда вы хотите **только записывать** данные в обобщённую
  структуру.
- Ограничение `? super T` означает, что коллекция может принимать элементы типа
  `T` или любого его супертипа.
- Пример: Вы хотите добавить элементы типа `T` в коллекцию, но не читать из неё
  специфичные данные.
- Почему это безопасно? При записи вы добавляете объекты типа `T`, которые
  гарантированно совместимы с типом коллекции (так как `T` является подтипом или
  самим типом коллекции).
- Ограничение: Вы **не можете безопасно читать** специфичные данные из такой
  коллекции, так как компилятор не знает точный тип (можно получить только
  `Object`).

**Пример кода:**

```java
public void addNumbers(List<? super Integer> list) {
    list.add(1); // Запись безопасна
    list.add(2);
    // Number num = list.get(0); // Ошибка компиляции: нельзя читать как Number
    Object obj = list.get(0); // Можно читать только как Object
}

List<Number> numbers = new ArrayList<>();
List<Object> objects = new ArrayList<>();

addNumbers(numbers); // Работает

addNumbers(objects); // Работает
```

Здесь `List<? super Integer>` позволяет добавлять `Integer` в список, так как
`Integer` совместим с `Number` или `Object`. Однако читать элементы как `Number`
нельзя, так как список может быть `List<Object>`.

### Когда использовать PECS?

PECS особенно полезен при написании методов, которые работают с обобщёнными
коллекциями. Правило помогает:

1. **Максимизировать гибкость**: Метод может принимать более широкий диапазон
   типов (например, `List<Integer>` и `List<Double>` для `? extends Number`).
2. **Обеспечить безопасность типов**: Компилятор предотвращает небезопасные
   операции (например, добавление неправильного типа).
3. **Упростить API**: Разработчику не нужно дублировать методы для разных типов.

### Пример из реальной жизни: `Collections.copy`

Метод `Collections.copy` в Java — классический пример применения PECS:

```java
public static <T> void copy(List<? super T> dest, List<? extends=extends T>src) {
    int srcIndex = 0;
    for (ListIterator<? super T> destIter = dest.listIterator(); srcIndex < src.size(); ) {
        destIter.set(src.get(srcIndex++));
    }
}
```

- `dest` использует `? super T`, так как в список назначения записываются
  элементы.
- `src` использует `? extends T`, так как из исходного списка только читаются
  элементы.

### Ключевые моменты

- **Producer (`? extends T`)**: Только чтение, нельзя записывать (кроме `null`).
- **Consumer (`? super T`)**: Только запись, нельзя читать (кроме как `Object`).
- **Без ограничений (`List<T>`)**: Можно и читать, и писать, но только точный
  тип `T` (без подтипов или супертипов).
- PECS не применяется к неизменяемым коллекциям или когда метод одновременно
  читает и пишет данные одного и того же типа.

### Частые ошибки

1. **Неправильное использование `extends` для записи**:
   ```java
   List<? extends Number> list = new ArrayList<Integer>();
   list.add(1); // Ошибка компиляции
   ```
2. **Неправильное использование `super` для чтения**:
   ```java
   List<? super Integer> list = new ArrayList<Number>();
   Integer num = list.get(0); // Ошибка компиляции
   ```
3. **Избыточное использование PECS**: Если метод работает только с конкретным
   типом `T` (без подтипов или супертипов), используйте просто `List<T>`.

### Заключение

PECS — это мощный инструмент для работы с generics в Java, который делает код
более гибким и безопасным. Понимание ролей "производителя" и "потребителя"
помогает правильно выбирать между `? extends T` и `? super T`. Если метод только
читает данные, используйте `extends`; если только записывает — `super`. Если
нужны оба действия, используйте точный тип `T` без ограничений.

Если у вас есть конкретный пример или вопрос по применению PECS, напишите, и я
разберу его подробнее!