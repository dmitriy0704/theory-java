# Обработка исключений

Обработка исключений в Java управляется пятью ключевыми словами:
try, catch, throw, throws и finally.
Операторы программы, которые вы хотите отслеживать на наличие
исключений, содержатся в блоке try. Если внутри блока try возникает исключение,
тогда оно генерируется. Ваш код может перехватить это исключение (с помощью
catch) и обработать его рациональным образом. Системные исключения автоматически
генерируются исполняющей средой Java. Для ручной генерации исключения
используйте ключевое слово throw. Любое исключение, генерируемое в методе,
должно быть указано как таковое с помощью конструкции throws. Любой код, который
обязательно должен быть выполнен после завершения блока try, помещается в блок
finally.

## Типы исключений

Все типы исключений являются подклассами встроенного класса Throwable. Таким
образом, класс Throwable расположен на вершине иерархии классов исключений.
Непосредственно под Throwable находятся два подкласса, которые разделяют
исключения на две отдельные ветви. Одну ветвь возглавляет класс Exception,
используемый для представления исключительных условий, которые должны
перехватываться пользовательскими программами. Он также будет служить подклассом
для создания собственных специальных типов исключений. Кроме того, у класса
Exception имеется важный подкласс, который называется RuntimeException.
Исключения такого типа автоматически определяются для разрабатываемых программ и
охватывают такие ситуации, как деление на ноль и недопустимое индексирование
массивов.

__Иерархия исключений:__

    Throwable:
        - Error
        - Exceptions:
          - RuntimeExceptions

Из-за того, что пакет java.lang неявно импортируется во все программы на Java,
многие исключения, производные от RuntimeException, доступны автоматически.
Более того, такие исключения не нужно включать в список throws любого метода. На
языке Java они называются **непроверяемыми** исключениями, потому что компилятор
не проверяет, обрабатывает метод подобные исключения или же генерирует их.

Исключения определенные в java.lang, которые должны помещаться в список throws
метода, если метод может генерировать одно из исключений и не обрабатывает его
самостоятельно. Они называются **проверяемыми** исключениями.

### Непроверяемые исключения, определенные в java.lang

| Исключения                          | Описание                                                                   |
|-------------------------------------|----------------------------------------------------------------------------|
| **ArithmeticException**             | Арифметическая ошибка, такая как деление на ноль;                          |
| **ArrayIndexOutOfBoundsException**  | Выход за допустимые пределы индекса в массиве;                             |
| **ArrayStoreException**             | Присваивание элементу массива значения несовместимого типа;                |
| **ClassCastException**              | Недопустимое приведение                                                    |
| **EnumConstantNotPresentException** | Попытка использования неопределенного значения перечисления                |
| **IllegalArgumentException**        | Использование недопустимого аргумента при вызове метода                    |
| **IllegalCallerException**          | Метод не может быть законно выполнен вызывающим кодом                      |
| **IllegalMonitorStateException**    | Недопустимая операция монитора, такая как ожидание неблокированного потока |
| **IllegalStateException**           | Некорректное состояние среды или приложения                                |
| **IllegalThreadStateException**     | Несовместимость запрошенной операции с текущим состоянием потока           |
| **IndexOutOfBoundsException**       | Выход за допустимые пределы индекса некоторого вида                        |
| **LayerInstantiationException**     | Невозможность создания уровня модуля                                       |
| **NegativeArraySizeException**      | Создание массива с отрицательным размером                                  |
| **NullPointerException**            | Недопустимое использование ссылки null                                     |
| **NumberFormatException**           | Недопустимое преобразование строки в числовой формат                       |
| **SecurityException**               | Попытка нарушения безопасности.                                            |
| **StringIndexOutOfBoundsException** | Попытка индексации за границами строки                                     |
| **TypeNotPresentException**         | Тип не найден                                                              |
| **UnsupportedOperationException**   | Обнаружение неподдерживаемой операции                                      |

### **Проверяемые исключения, определенные в java.lang**

| Исключения                       | Описание                                                               |
|----------------------------------|------------------------------------------------------------------------|
| **ClassNotFoundException**       | Класс не найден                                                        |
| **CloneNotSupportedException**   | Попытка клонирования объекта, который не реализует интерфейс Cloneable |
| **IllegalAccessException**       | Доступ к классу запрещен                                               |
| **InstantiationException**       | Попытка создания объекта абстрактного класса или интерфейса            |
| **InterruptedException**         | Один поток был прерван другим потоком                                  |
| **NoSuchFieldException**         | Запрошенное поле не существует                                         |
| **NoSuchMethodException**        | Запрошенный метод не существует                                        |
| **ReflectiveOperationException** | Суперкласс исключений, связанных с рефлексией                          |

## Оператор throw

Программа может генерировать исключение явно с применением оператора throw со
следующей общей формой:

    throw Throwableinstance;

Здесь Throwableinstance должен быть объектом типа Throwable или
подклассом Throwable. Примитивные типы вроде int или char, а также
классы, отличающиеся от Throwable, такие как String и Object, не могут
использоваться в качестве исключений. Есть два способа получить объект
Throwable: указывая параметр в конструкции catch или создавая его с помощью
операции new.

## Конструкция throws

Если метод способен приводить к исключению, которое он не обрабатывает,
то метод должен сообщить о таком поведении, чтобы вызывающий его код
мог защитить себя от этого исключения. Задача решается добавлением к объявлению
метода конструкции throws, где перечисляются типы исключений,
которые может генерировать метод. Поступать так необходимо для всех исключений,
кроме исключений типа Error, RuntimeException или любых их
подклассов. Все остальные исключения, которые может генерировать метод,
должны быть объявлены в конструкции throws. В противном случае возникнет
ошибка на этапе компиляции.

```java
public class ThrowsDemo {
    public static void main(String[] args) {
        try {
            ThrowsDemo2.throwOne();
        } catch (IllegalAccessException e) {
            System.out.println("Исключение: " + e.getMessage());
        }
    }
}

class ThrowsDemo2 {
    static void throwOne() throws IllegalAccessException {
        throw new IllegalAccessException("демонстрация");
    }
}
```

## Создание собственных подклассов Exception

```java
package dev.folomkin.java.exceptions.example;

public class MyException extends Exception {
    private int detail;

    public MyException(int a) {
        detail = a;
    }

    public String toString() {
        return "MyException detail: [" + detail + "]";
    }
}

class ExceptionDemo {
    static void compute(int a) throws MyException {
        System.out.println("Вызов compute: [" + a + "]");
        if (a > 10) {
            throw new MyException(a);
        }
        System.out.println("Нормальное завершение");
    }

    public static void main(String[] args) {
        try {
            compute(1);
            compute(20);
        } catch (MyException e) {
            System.out.println("Перехвачено исключение " + e);
        }
    }
}

```
