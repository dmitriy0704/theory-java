# Лямбда выражения

## Введение

Ключевым аспектом для понимания реализации лямбда-выражений в Java являются две
конструкции: собственно лямбда - выражение и функциональный интерфейс.

**_Лямбда-выражение_** - анонимный (т.е. безымянный) метод. Используется для
реализации метода, определенного функциональным интерфейсом. Таким образом,
лямбда-выражение приводит к форме анонимного класса. Лямбда-выражения также
часто называют замыканиями.

**_Функциональный интерфейс_** это интерфейс, который содержит один и только
один абстрактный метод, обычно устанавливающий предполагаемое назначение
интерфейса. Соответственно функциональный интерфейс, как правило, представляет
одиночное действие. Например, стандартный интерфейс Runnable является
функциональным интерфейсом, поскольку в нем определен только один метод: run().
Следовательно, run() определяет действие Runnable. Кроме того, функциональный
интерфейс задает целевой тип лямбда-выражения. Важно понимать, что
лямбда-выражение может применяться только в контексте, в котором указан его
целевой тип. И еще один момент: функциональный интерфейс иногда называют
типом SAM, где SAM означает Single Abstract Method - единственный абстрактный
метод.

## Основы лямбда-выражений

Лямбда-выражение опирается на синтаксический элемент и операцию. Операцию иногда
называется лямбда-операцией или операцией стрелки и обозначается с помощью ->.
Она делит лямбда-выражение на две части. В левой части указываются любые
параметры, требующиеся в лямбда-выражении. В правой части находится тело
лямбда-выражения, которое определяет действия лямбда-выражения. В Java
определены два вида тела лямбда-выражения с **одиночным выражением** и с *
*блоком
кода**.

    // Код 
    double method() {
        return 98.6;
    }

    // можно заменить на
    () -> 98.6;

Когда лямбда-выражению необходим параметр, он указывается в списке параметров
слева от лямбда-операции:

    n -> (n % 2) == 0

```java
interface MyNumber {
    double getValue();
}

class Code {
    public static void main(String[] args) {
        MyNumber myNumber;
        myNumber = () -> 1.23;
    }
}

// -> или

interface MyNumber {
    double getValue(int number);
}

class Code {
    public static void main(String[] args) {
        MyNumber myNumber;
        myNumber = (n) -> n * 2;
    }
}
```

## Блочные лямбда-выражения

Тело в лямбда-выражениях, состоящее из единственного выражения называется
**_телом-выражением_**, а лямбда-выражение с телом-выражением **_одиночным
лямбда-выражением_**. В теле-выражении код в правой части лямбда-операции
должен содержать одно выражение. Но иногда требуется более одного выражения.
Для обработки таких случаев в Java поддерживается второй вид лямбда-выражений,
где в правой части лямбда-операции находится блок кода, который может содержать
более одного оператора. Тело этого вида называется **_блочным_**.
Лямбда-выражения с блочными телами иногда называются
**_блочными лямбда-выражениями_**.

За исключением того, что блочные лямбда-выражения разрешают указывать несколько
операторов, они используются почти так же, как только что рассмотренные
одиночные лямбда-выражения. Тем не менее, есть одно ключевое отличие: вы обязаны
явно применять оператор return, чтобы возвратить значение. Поступать так
необходимо, потому что тело блочного лямбда-выражения не представляет одиночное
выражение.

Блочное лямбда-выражение используется с целью нахождения наименьшего
положительного делителя для значения типа int. В нем применяется интерфейс
NumericFunc с методом func(), который принимает один аргумент типа int и
возвращает результат типа int. Таким образом, NumericFunc поддерживает числовую
функцию для значений типа int.

```java
// Блочное лямбда выражение находит наименьший положительный делитель для значения типа int.
interface NumericFunc {
    int func(int n);
}

public class Code {
    public static void main(String[] args) {
        // Это блочное лямбда-выражение возвращает наименьший
        // положительный делитель для значения.
        NumericFunc numericFunc = (n) -> {
            int result = 1;
            // Получаем абсолютное значение n.
            n = n < 0 ? -n : n;
            for (int i = 2; i < n / i; i++) {
                if ((n % 1) == 0) {
                    result = i;
                    break;
                }
            }
            return result;
        };
        System.out.println("Наименьший делитель 12" + numericFunc.func(12));
        System.out.println("Наименьший делитель 11" + numericFunc.func(11));
    }
}
```

## Передача лямбда-выражений в качестве аргументов

Чтобы лямбда-выражение можно было передавать как аргумент, тип параметра,
получающего аргумент в форме лямбда-выражения, должен относиться
к типу функционального интерфейса, который совместим с лямбда-выражением.

```java
package dev.folomkin.java.functional_interfaces;

interface StringFunc {
    String func(String n);
}

class Code {
    //Типом первого параметра этого метода является функциональный интерфейс.
    // Таким образом, ему можно передавать ссыпку на любой экземпляр реализации
    // данного интерфейса, в том числе экземпляр, созданный лямбда-выражением.
    // Во втором параметре указывается строка, с которой нужно работать.

    static String stringOp(StringFunc sf, String s) {
        return sf.func(s);
    }

    public static void main(String[] args) {
        String inString = "Hello World!";
        String outString;

        System.out.println("Исходная строка: " + inString);

        // Простое одиночное лямбда-выражение, которое переводит
        // в верхний регистр строку, переданную методу stringOp().
        outString = stringOp((str) -> str.toUpperCase(), inString);
        System.out.println("Строка в верхнем регистре" + outString);

        // Блочное выражение, удаляет пробелы
        outString = stringOp((str) -> {
            String result = "";
            for (int i = 0; i < str.length(); i++) {
                if (str.charAt(i) != ' ') {
                    result += str.charAt(i);
                }
            }
            return result;
        }, inString);
        System.out.println("result: " + outString);

        // Можно также передавать экземпляр StringFunc, заблаговременно
        // созданный лямбда-выражением. Например, после выполнения следующего
        // объявления reverse будет ссылаться на экземпляр StringFunc.
        StringFunc reverse = (str) -> {
            String result = " ";
            int i;
            for (i = str.length() - 1; i >= 0; i--)
                result += str.charAt(i);
            return result;
        };

        // Теперь reverse можно передать в первом параметре методу stringOp(),
        // поскольку этот параметр является ссылкой на объект StringFunc.
        System.out.println("Строка с противоположным порядком следования " +
                "символов: " + stringOp(reverse, inString));
    }
}
```

Первым делом обратите внимание в программе на метод stringOp (),
который принимает два параметра. Первый объявлен с типом StringFunc,
который является функциональным интерфейсом. Таким образом, данный
параметр может получать ссылку на любой экземпляр StringFunc, в том
числе созданный лямбда-выражением. Второй параметр stringOp () имеет
тип String и представляет собой строку, в отношении которой выполняется
операция.

## Генерация исключений в лямбда-выражениях

Лямбда-выражение может генерировать исключение. Тем не менее, если инициируется
проверяемое исключение, то оно должно быть совместимым с исключением или
исключениями, которые перечислены в конструкции throws абстрактного метода в
функциональном интерфейсе. Например, если лямбда-выражение генерирует исключение
IOException, то в конструкции throws абстрактного метода в функциональном
интерфейсе должно быть указано IOException.

```java
interface MyIOAction {
    boolean ioAction(Reader rdr) throws IOException;
}

class Code {
    public static void main(String[] args) {

        // Это блочное лямбда-выражение может сгенерировать исключение IOException.
        // Следовательно, IOException должно быть указано в конструкции throws
        // метода ioAction() в MyAction.
        MyIOAction myIOAction = (rdr) -> {  // <-- Это лямбда выражение
            // может сгенерировать исключение
            int ch = rdr.read();
            // throw new IOException;
            // ...  
            return true;
        };
    }
}
```

Поскольку вызов read() может привести к генерации исключения IOException,
конструкция throws метода ioAction() в функциональном интерфейсе MylOAction
должна включать IOException. В противном случае программа не скомпилируется,
потому что лямбда - выражение больше не будет совместимым с ioAction().

## Лямбда-выражения и захват переменных. Замыкания

Переменные, определенные в объемлющей области действия лямбда-выражения,
доступны внутри лямбда-выражения. Лямбда-выражение может задействовать
переменную экземпляра или статическую переменную, определенную в объемлющем
классе. Лямбда-выражение также имеет доступ к ссылке this(явно и неявно),
которая ссылается на вызывающий экземпляр класса, включающего лямбда-выражение.
Таким образом, лямбда-выражение может получать либо устанавливать значение
переменной экземпляра или статической переменной и вызывать метод, определенный
в объемлющем классе.

Когда в лямбда-выражении используется локальная переменная из его объемлющей
области видимости, то возникает особая ситуация, называемая захватом переменной.
В таком случае лямбда-выражение может работать только с локальными переменными,
которые являются фактически финальными. Фактически финальная переменная
представляет собой переменную, значение которой не меняется после ее первого
присваивания. Явно объявлять такую переменную как final нет никакой
необходимости, хотя поступать так не будет ошибкой. (Параметр this объемлющей
области видимости автоматически будет фактически финальным, а лямбда-выражения
не имеют собственной ссылки this.)
Локальная переменная из объемлющей области не может быть модифицирована
лямбда-выражением, поскольку в таком случае исчез бы ее статус фактически
финальной, из-за чего она стала бы незаконной для захвата.

```java
// Пример захвата локальной переменной из объемлющей области видимости ,
interface MyFunc {
    int func(int n);
}

class Code {
    public static void main(String[] args) {
        // Локальная переменная, которая может быть захвачена,
        int num = 10;
        MyFunc myLambda = (n) -> {
            // Использовать num подобным образом разрешено.
            // Переменная num не модифицируется,
            int v = num + n;
            // Однако следующая строка кода недопустима из-за того, что в ней
            // предпринимается попытка модифицировать значение num.
            // num++;
            return v;
        };
        // Использовать лямбда-выражение. Отобразится число 18.
        System.out.println(myLambda.func(8));
    }
    // Следующая строка кода тоже вызовет ошибку, потому что в ней
    // устраняется статус переменной num как фактически финальной.
    // num = 9;
}
```

В комментариях указано, что переменная num является фактически финальной и
потому может применяться внутри myLambda. Именно по этой причине оператор
printlnO выводит число 18. Когда метод func() вызывается с аргументом 8,
значение v внутри лямбда-выражения устанавливается путем сложения переменной
num (равной 10)и значения , переданного в п (равного 8). В итоге func()
возвращает 18. Такая работа объясняется тем, что num не изменяется после
инициализации. Однако если значение num будет изменено внутри лямбда-выражения
или за его пределами, то переменная num утратит свой статус фактически
финальной, что вызовет ошибку и программа не скомпилируется.
___ 

Блок кода, представляющий собой лямбда-выражение вместе со значениями локальных
переменных и параметров метода, в котором он объявлен, называется замыканием,
или closure. Объект-функция создается во время исполнения, и применен может быть
уже после того как объект, его создавший, прекратит существование. Такая
ситуация требует, чтобы переменные, которые использует лямбда-выражение, не
могли быть изменены. Значения переменных фиксируются замыканием и изменены быть
не могут.

```java
    public static Function<String, Integer> build(String strNum) {
    int count = 1;
    return t -> {
        int res = Integer.parseInt(strNum + t) + count;
        return res;
    };
}
// Или
// return t -> Integer.valueOf(strNum + t) + count;
```

При формировании объекта функции Function, как возвращаемого значения
метода build(), значения параметров сохраняются, и функция будет
использовать эти зафиксированные значения strNum и count в тот момент, когда
произойдет ее вызов.

```java

class Code {
    public static void main(String[] args) {
        Function<String, Integer> function = build("100");
        int res = function.apply("77");
        System.out.println(res);
    }

    public static Function<String, Integer> build(String strNum) {
        int count = 1;
        return t -> {
            int res = Integer.parseInt(strNum + t) + count;
            System.out.println(t);
            System.out.println(res);
            return res;

            // Переменные count и strNum не должны изменяться
        };
    }
}
```

Эти переменные должны иметь константные значения, как если бы они были
объявлены как final. Отсюда и название — замыкание.
Замыкания не запрещают использования полей класса как статических, так
и нестатических.

```java
public class FunctionBuilder<T> {
    static int count = 1;

    public static Function<String, Integer> build(String strNum) {
        count++;
        return t -> Integer.valueOf(strNum + t) + ++count;
    }
}
```

## Ссылки на методы

С лямбда-выражениями связана одна важная возможность, которая называется
ссылкой на метод. Ссылка на метод предлагает способ обращения к
методу, не инициируя его выполнение. Она имеет отношение к лямбда-выражениям,
поскольку тоже требует контекста целевого типа, состоящего из совместимого
функционального интерфейса. При вычислении ссылки на метод
также создается экземпляр функционального интерфейса.
Существуют различные виды ссылок на методы. Мы начнем со ссылок на
статические методы.

### Ссылки на статические методы

Для ссылки на статический метод применяется следующий общий синтаксис:
        
    имя-класса: :имя-метода

```java
package dev.folomkin.java.functional_interfaces;

interface StringFunc {
    String func(String n);
}

// В этом классе определен статический метод по имени strReverse().

class MyStringOps {
    // Статический метод, который изменяет порядок следования
    // символов на противоположный.
    static String StringReverse(String str) {
        String result = "";
        int i;
        for (i = str.length() - 1; i >= 0; i--) {
            result += str.charAt(i);
        }
        return result;
    }
}

class Code {

    // Первый параметр этого метода имеет тип функционального интерфейса.
    // Таким образом, ему можно передать любой экземпляр реализации
    // интерфейса StringFunc, включая ссылку на метод.
    static String stringOps(StringFunc sf, String s) {
        return sf.func(s);
    }

    public static void main(String[] args) {

        String inStr = "Hello World!";
        String outStr;

        // Передать в stringOp() ссылку на статический метод strReverse().
        outStr = stringOps(MyStringOps::StringReverse, inStr);

        System.out.println("Иcxoдная строка: " + inStr);
        System.out.println("Cтpoкa с противоположным порядком следования символов: " + outStr);
    }
}
```

### Ссылки на методы экземпляра

    объектная-ссылка::имя-метода

```java
package dev.folomkin.java.functional_interfaces;

interface StringFunc {
    String func(String n);
}

// В этом классе определен статический метод по имени strReverse().

class MyStringOps {
    // Статический метод, который изменяет порядок следования
    // символов на противоположный.
    String stringReverse(String str) {
        String result = "";
        int i;
        for (i = str.length() - 1; i >= 0; i--) {
            result += str.charAt(i);
        }
        return result;
    }
}

class Code {

    // Первый параметр этого метода имеет тип функционального интерфейса.
    // Таким образом, ему можно передать любой экземпляр реализации
    // интерфейса StringFunc, включая ссылку на метод.
    static String stringOps(StringFunc sf, String s) {
        return sf.func(s);
    }

    public static void main(String[] args) {

        String inStr = "Hello World!";
        String outStr;

        // Создать объект MyStringOps.
        MyStringOps stringOps = new MyStringOps();
        // Передать в stringOp() ссылку на метод экземпляра strReverse().
        outStr = stringOps(stringOps::stringReverse, inStr);

        System.out.println("Иcxoдная строка: " + inStr);
        System.out.println("Cтpoкa с противоположным порядком следования символов: " + outStr);
    }
}
```

### Ссылки на методы и обобщения

```java
package dev.folomkin.java.functional_interfaces;


// Демонстрация использования ссыпки на обобщенный метод,
// объявленный внутри необобщенного кла сса .

// Функциональный интерфейс, который работает с массивом
// и значением и возвращает результат int.

interface MyFunc<T> {
    int func(T[] vals, T v);
}


// В этом классе определен метод по имени countMatching() , который
// возвращает количество элементов в массиве, равных указанному значению.
// Обратите внимание, что метод countMatching() является обобщенным,
// но класс MyArrayOps - нет.
class MyArrayOps {

    static <T> int countMatching(T[] vals, T v) {
        int count = 0;
        for (int i = 0; i < vals.length; i++) {
            if (vals[i] == v) {
                count++;
            }
        }
        return count;
    }
}

class Code {

    // Первый параметр этого метода имеет тип функционального интерфейса MyFunc.
    // в остальных двух параметрах он принимает массив и значение, оба типа Т.

    static <T> int myOp(MyFunc<T> func, T[] vals, T v) {
        return func.func(vals, v);
    }

    public static void main(String[] args) {
        Integer[] vals = {1, 2, 3, 4, 2, 3, 4, 4, 5};
        String[] strs = {"0ne", "Two", "Three", "Two"};
        int count;
        count = myOp(MyArrayOps::<Integer>countMatching, vals, 4);
        System.out.println("Koличecтвo элементов 4, содержащихся в vals: "
                + count);
        count = myOp(MyArrayOps::<String>countMatching, strs, "Two");
        System.out.println("Количество элементов Two, содержащихся в strs: "
                + count);
    }
}
```

### Ссылки на конструкторы

Подобно ссылкам на методы можно создавать ссылки на конструкторы.
Ниже приведена общая форма синтаксиса, предназначенного для создания
ссылки на конструктор:

    имя-класса::new

```java
package dev.folomkin.java.functional_interfaces;

// Демонстрация использования ссыпки на конструктор .
// MyFunc - функциональный интерфейс, метод которого
// возвращает ссыпку на конструктор MyClass.
interface MyFunc<T> {
    MyClass func(int n);
}

class MyClass {
    private int val;

    // Конструктор, принимающий аргумент.
    MyClass(int v) {
        val = v;
    }

    // Стандартный конструктор.
    MyClass() {
        val = 0;
    }

    //...
    int getVal() {
        return val;
    }
}

class Code {

    public static void main(String[] args) {

        // Создать ссылку на конструктор MyClass.
        // Поскольку метод func ( ) в MyFunc принимает аргумент, new ссыпается
        // на параметризованный конструктор MyClass, а не на стандартный .
        MyFunc myClassCons = MyClass::new;
        // Создать экземпляр MyClass через эту ссыпку на конструктор .
        MyClass mc = myClassCons.func(100);
        // Использовать только что созданный экземпляр MyClass.
        System.out.println("val в mc равно " + mc.getVal());
    }
}
```