# Интерфейс List\<E>

**_РЕАЛИЗАЦИИ:_**

- ArrayList;
- LinkedList;
- Vector;
- Stack;

Интерфейс List в Java Collection Framework представляет упорядоченную
коллекцию (также известную как последовательность). Интерфейс List расширяет
Collection.
Кроме того, разработчику предоставляется возможность доступа к элементам
коллекции по индексу и по значению (так как реализации позволяют хранить
дубликаты, результатом поиска по значению будет первое найденное вхождение).

Помимо Iterator списки также могут вернуть Listerator, который позволяет вставку
и замену элементов, а также двунаправленный доступ.

**_ОСНОВНЫЕ МЕТОДЫ:_**

- **void add(int index, Object obj)** - вставляет элемент obj в позицию index.
  Старые элементы, начиная с позиции index, сдвигаются, их индексы увеличиваются
  на единицу.
- **boolean addAll(int index, Collection coll)** – вставляет все элементы
  коллекции coll
- **E get(int index)** - извлекает без удаления объект по индексу.
- **int indexOf(Object obj)** - возвращает индекс первого вхождения объекта obj
  или -1, если этот список не содержит элемента
- **int lastIndexOf(Object obj)** - возвращает индекс последнего вхождения
  объекта obj в список или -1 если его нет
- **E set(int index, E element)** - Используется для замены элемента в этом
  списке на указанной позиции на указанный элемент
- **List\<E> subList(int start, int end)** - получает набор элементов, которые
  находятся в списке между индексами start и end
- **E remove(int index)** - удаляет последний извлеченный в список. Если
  объект не найден, то возвращается -1
- **static \<E> List\<E> of(элементы)** - создает из набора элементов объект
  List
- **void sort(Comparator\<? super E> comp)** - сортирует список с помощью
  компаратора comp
- **ListIterator\<E> listIterator()** - возвращает объект ListIterator для
  обхода элементов списка

**_Методы наследуемые из Collection:_**

- **int size()**;
- **boolean isEmpty()**;
- **boolean add(E element)**;
- **boolean remove(Object o)**;
- **boolean contains(Object o)**;
- **void clear()**;

## _ArrayList\<E>_

Класс, реализующий интерфейс List, являющийся динамическим массивом объектных
ссылок. Несинхронизированный.
ArrayList - как и Vector является реализацией динамического массива объектов. 
Позволяет хранить любые данные, включая null в качестве элемента. Как можно 
догадаться из названия, его реализация основана на обычном массиве. Данную 
реализацию следует применять, если в процессе работы с коллекцией предполагается
частое обращение к элементам по индексу. Из-за особенностей реализации 
поиндексное обращение к элементам выполняется за константное время O(1). Но 
данную коллекцию рекомендуется избегать, если требуется частое 
удаление/добавление элементов в середину коллекции. 

**Иерархия наследования:**
java.util.AbstractCollection<E>
-> java.util.AbstractList<E>
-> java.util.ArrayList<E>

**_Конструкторы:_**

- **ArrayList()** - создает пустой список, размером 10;
- **ArrayList(Collection<? extends E> c)** - создает список из указанной
  коллекции
- **ArrayList(int initialCapacity)** - создает пустой список с изначально
  указанным объемом

**_Методы:_**

- **E get(int index)** – возвращает элемент, находящийся на указанной позиции в
  списке, представляет собой одно из главных достоинств класса из-за скорости
  выполнения;
- **boolean add(E e)** - добавляет указанный элемент в конец списка;
- **void add(int index, E e)** - вставляет указанный элемент на указанную
  позицию;
- **boolean addAll(Collection<? extends E> c)** – добавляет все элементы
  указанной коллекции в конец данного списка в порядке, определенном итератором
  Iterator данной коллекции;
- **boolean addAll(int index, Collection<? extends E> c)** – добавляет все
  элементы указанной коллекции в список, начиная с указанной позиции;
- **int indexOf(Object o)** – возвращает индекс первого вхождения указанного
  элемента данного списка или -1, если данный список не содержит указанный
  элемент;
- **E remove(int index)** – удаляет элемент из указанной позиции в списке;
- **boolean remove(Object o)** – удаляет первый встретившийся указанный элемент
  из списка, если он там имеется;
- **boolean removeAll(Collection<?> c)** – удаляет из списка все элементы,
  которые содержатся в указанной коллекции;
- **protected void removeRange(int fromIndex, int toIndex)** – удаляет из списка
  все элементы, чей индекс находится от fromIndex, включительно, до toIndex, не
  включая его;
- **E set(int index, E element)** – заменяет элемент на указанной позиции в
  списке на указанный элемент;
- **default void sort (Compare<? super E> e)** - сортирует список на основе
  компаратора;
- **List\<E> subList(int fromIndex, int toIndex)** – возвращает представление
  данного списка в виде подсписка, начиная с элемента с индексом fromIndex,
  включительно, до элемента с индексом toIndex, не включая его;
- static <E> copyOf(Collection <? extends E> coll) - создает немодифицированный
  список на основе передаваемой коллекции;
- **boolean isEmpty()** – возвращает true, если данный список не содержит
  элементов;
- **int lastIndexOf(Object o)** – возвращает индекс последнего вхождения
  указанного элемента данного списка или -1, если список не содержит данный
  элемент;
- **Iterator<E> iterator()** – возвращает итератор для правильного прохода по
  списку;
- **ListIterator<E> listIterator()** – возвращает итератор списка (для прохода в
  правильной последовательности);
- **ListIterator\<E> listIterator(int index)** – возвращает итератор списка (для
  прохода в правильной последовательности), начиная с указанной позиции в
  списке;
- **void ensureCapacity(int minCapacity)** - увеличивает объем данного
  экземпляра ArrayList, если это необходимо, чтобы удостовериться, что он может
  содержать, по меньшей мере, число элементов, указанное в аргументе
  minCapacity;
- **Object[] toArray()** – возвращает массив всех элементов данного списка в
  правильной последовательности (т.е. от первого до последнего элемента);
- **\<T> T[] toArray(T[] a)** – возвращает массив, содержащий все элементы
  данного списка в правильной последовательности (от первого до последнего
  элемента); тип возвращенного массива при выполнении – тот же самый, что и у
  указанного массива;
- **Object clone()** – возвращает копию объекта с теми же значениями полей, что
  у данного экземпляра ArrayList;
- **void trimToSize()** – сокращает массив до размера данного экземпляра
  ArrayList, который и будет текущим размером списка (так как при удалении
  элементов размер списка не изменяется).
- **boolean equals(Object o)** – сравнивает указанный объект с данным списком (
  на предмет равенства);
- **int hashCode()** – возвращает хэш-код для данного списка.
- **boolean retainAll(Collection<?> c)** – оставляет в данном списке только те
  элементы, которые содержатся в указанной коллекции;
- **int size()** – возвращает количество элементов данного списка;
- **void clear()** – удаляет все элементы из списка;
- -**boolean contains(Object o)** – возвращает true, если данный список содержит
  указанный элемент;
- **boolean containsAll(Collection<?> c)** – возвращает true, если данный список
  содержит все элементы данной коллекции;
- **toString** – возвращает представление коллекции в виде строки символов.
  Строковое представление состоит из списка элементов коллекции в порядке, в
  котором они возвращаются итератором, список заключается в квадратные
  скобки («[]»), соседние элементы разделяются символами «, » (запятая и
  пробел). Элементы преобразуются в строку таким же образом, как и в
  String.valueOf(Object).
- **protected void finalize()** – генерирует исключение Throwable, этот метод
  вызывается, когда Java – сборщик мусора обнаруживает, что на объект нет
  ссылок; подкласс переопределяет метод finalize, чтобы запросить системные
  ресурсы или выполнить другие операции по очистке памяти;
- **public final Class<?> getClass()** – возвращает класс объекта во время
  выполнения, например,
- **public final void notify()** – «просыпается» один поток, который ожидает на
  «мониторе» данный объект; если несколько потоков ожидают данный объект, то для
  «просыпания» выбирается один из них;
- **public final void notifyAll()** – пробуждает все потоки;
- **public final void wait(long timeout)** – генерирует исключение
  InterruptedException. У метода wait() есть три вариации. Один метод wait()
  бесконечно ждет другой поток, пока не будет вызван метод notify() или
  notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток
  в ожидание на определенное время. По истечении этого времени поток просыпается
  и продолжает работу.
- **boolean equals(Object o)** – сравнивает указанный объект со списком в смысле
  их равенства. Возвращает true тогда и только тогда, когда указанный объект
  является также списком, оба списка имеют одинаковый размер и все
  соответствующие пары элементов в обоих списках равны (Два элемента e1 и e2
  считаются равными, если (e1==null ? e2==null : e1.equals(e2)).)
- **int hashCode()** – возвращает значение хэш-кода для данного списка, хэш-код
  для списка определяется как результат следующих вычислений:

**Преобразование списка в массив - toArray():**

```java
public class ExampleStart {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        р
        list.add("A");
        list.add("B");
        list.add("C");
        Object[] strArray = list.toArray();
        System.out.println(Arrays.toString(strArray));
        String[] strArray2 = list.toArray(new String[list.size()]);
        System.out.println(Arrays.toString(strArray2));
    }
}
```

**Представление массива в виде списка:**

```java
public class ExampleStart {
    public static void main(String[] args) {
        String[] strings = {"a", "b", "c", "d"};
        List<String> list = Arrays.asList(strings);
        List<String> list2 = Arrays.asList("fd", "fgfd", "gfgsd");
        System.out.println(list);
    }
}
```

Удаление и добавление элементов для такой коллекции представляет ресурсоемкую
задачу, поэтому объект ArrayList<E> лучше всего подходит для хранения списков с
малым числом подобных действий. С другой стороны, навигация по списку
осуществляется очень быстро, поэтому операции поиска производятся за более
короткое время.

```java
    public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(5);
    list.add(null);
    list.add(50);
    System.out.println(list);
    list.add(5, 87);
    System.out.println(list);
    list.remove(2);
    System.out.println(list);
}
```

В данной ситуации не создается новый класс для каждого конкретного типа, и сама
коллекция не меняется, просто компилятор снабжается информацией о типе
элементов, которые могут храниться в list. При этом параметром коллекции может
быть только объектный тип. Попытка добавления\удаления элемента с номером,
выходящим за пределы текущего размера списка, приведет к исключительной
ситуации.  
Указывать тип следует при создании ссылки, иначе будет позволено добавлять
объекты всех типов. На этом основан принцип типобезопасности, обеспечиваемый
параметризацией коллекций.

## _LinkedList\<E>_

LinkedList - ещё одна реализация List. Позволяет хранить любые данные, включая 
null. Особенностью реализации данной коллекции является то, что в её основе 
лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий 
и следующий). Благодаря этому, добавление и удаление из середины, доступ по 
индексу, значению происходит за линейное время O(n), а из начала и конца за 
константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать 
как стек или очередь. Для этого в ней реализованы соответствующие методы. 

LinkedList\<E> является реализацией двусвязного списка для интерфейса List
который работает эффективно как для вставки элементов, так и для удаления,
используя, как издержки, более сложную структуру. LinkedList\<E> также реализует
интерфейсы Queue\<E> и Deque\<E> и может работать с обоих концов очереди. Он
может работать с очередью как по принципу FIFO, так и по принципу LIFO.  
Связанный список хранит ссылки на объекты отдельно вместе со ссылками
на следующее и предыдущее звенья последовательности, поэтому часто
называется двунаправленным списком.  

Самый быстрый метод класса add(E element). Главным же достоинством
класса является скорость работы метода remove() на Iterator, после получения
его из LinkedList. Также очень быстро работает метод add(E element) на
ListIterator. Операция удаления из начала и конца списка выполняется достаточно
быстро, в отличие от операций поиска и извлечения.  

При тестировании на списке из десяти тысяч элементов LinkedList быстрее,
чем ArrayList, при добавлении в середину списка методом add() в 2 раза, а в
начало или конец примерно в 40 раз. Вставки и удаления элементов из LinkedList
происходят за постоянное время, в том числе и с использованием итераторов,
в то же время вставка\удаление элемента в ArrayList приводит к сдвигу всех
элементов после позиции добавления\удаления, а в случае, если базовый массив
хранения переполняется, то еще и сам массив увеличивается в полтора раза с
копированием старого массива в новый. Список ArrayList, в свою очередь,
быстрее при вызове метода get(index) примерно в 50 раз. Происходит это
вследствие того, что определение позиции в списке производится за конкретный 
интервал времени, не зависящий от размера списка, при поиске же индекса в 
LinkedList время поиска пропорционально размеру списка.  

Список LinkedList занимает больший объем памяти за счет необходимости
хранения ссылок на соседние объекты, что следует учитывать при создании
списков больших размеров. Список LinkedList занимает от 3,5 до 5 раз больше
памяти нежели аналогичный список ArrayList.  

В этом классе объявлены методы, позволяющие манипулировать им как
очередью, двунаправленной очередью и т.д. Двунаправленный список, кроме
обычного, имеет особый «нисходящий» итератор, позволяющий двигаться от
конца списка к началу, и извлекается методом descendingIterator().

Для манипуляций с первым и последним элементами списка в LinkedList\<E>
реализованы методы:

- **void addFirst(E e), void addLast(E e)** - добавление элементов в начало и
  конец списка;
- **E getFirst(), E getLast()** — извлекающие элементы;
- **E removeFirst(), E removeLast()** — удаляющие и извлекающие элементы;
- **E removeLastOccurrence(E elem), E removeFirstOccurrence(E elem)** —
  удаляющие и извлекающие элемент, первый или последний раз встречаемый
  в списке.

**_Отличия ArrayList и LinkedList:_**

Если необходимо осуществлять быструю навигацию по списку, то следует применять
ArrayList, так как перебор элементов в LinkedList осуществляется на порядок
медленнее. С другой стороны, если требуется часто добавлять и удалять элементы
из списка, то уже класс LinkedList обеспечивает значительно более высокую
скорость переиндексации. То есть если коллекция формируется в начале процесса и
в дальнейшем используется только для доступа к информации, то применяется
ArrayList, если же коллекция подвергается изменениям на всем протяжении
функционирования приложения, то выгоднее LinkedList.

## _Vector\<E>_

Реализация динамического массива объектов. Позволяет хранить любые данные,
включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но, как
и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется
достижения потокобезопасности. Потому как в Vector, в отличии. от других
реализаций List, все операции с данными являются синхронизированными. В качестве
альтернативы часто применяется аналог — ArrayList.  
Как и массив, он содержит элементы, доступ к которым возможен по индексу. Однако
размер вектора может расти или уменьшаться в зависимости от добавления или
удаления элементов после того, как Vector уже был создан. Класс вектор является
синхронизированной реализацией интерфейса List.

**_Конструкторы:_**

- *Vector()* – создает пустой вектор таким образом, что внутренний массив имеет
  размер 10, а его стандартный инкремент объема равен нулю;
- *Vector(Collection<? extends E> c)* – создает вектор, содержащий элементы
  указанной коллекции в порядке, возвращенном итератором;
- *Vector(int initialCapacity)* – создает пустой вектор с указанным начальным
  объемом и со стандартным инкрементом объема, равным нулю;
- *Vector(int initialCapacity, int capacityIncrement)* – создает пустой вектор с
  указанными начальным объемом и инкрементом объема.

**_Методы:_**

- **void addElement(E obj)** – добавляет указанный компонент в конец вектора,
  увеличивая его размер на 1;
- **boolean removeElement(Object obj)** – удаляет первый, т.е. имеющий
  минимальный индекс, встретившийся аргумент из вектора;
- **void setElementAt(E obj, int index)** – вставляет элемент, представляющий
  собой указанный объект, на определенное индексом место в векторе;
- **public E elementAt(int index)** – возвращает элемент с указанным индексом;
  этот метод идентичен методу get(int), являющемуся частью интерфейса List;
- **public E firstElement()** – возвращает первый элемент (с индексом 0) данного
  вектора;
- **public E lastElement()** – возвращает последний элемент вектора;
- **public void insertElementAt(E obj,int index)** – вставляет указанный объект
  как элемент данного вектора на место, определенное индексом. Каждый элемент
  данного вектора с индексом, большим или равным указанному индексу, получает
  индекс, больший предыдущего на 1.

```java
public static void main(String[] args) {
    Vector v = new Vector(3, 2);
    System.out.println("Начальный размер " + v.size());
    System.out.println("Начальный объем " + v.capacity());
    v.addElement(1);
    v.addElement(2);
    v.addElement(3);
    v.addElement(4);
    System.out.println("Новый объем " + v.capacity());
    // Enumeration - доступ к серии элементов одновременно;
    Enumeration e = v.elements();
    while (e.hasMoreElements()) {
        System.out.println(e.nextElement());
    }
}
```

**Различия между классами ArrayList и Vector:**

| ArrayList                                                                                            | Vector                                                                                                                                                               |
|------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ArrayList не синхронизирован                                                                         | Vector синхронизирован                                                                                                                                               |
| ArrayList увеличивает на 50% <br/> текущий размер массива, если число элементов превышает его размер | Vector увеличивает на 100% <br/> текущий размер массива, если число элементов превышает его размер                                                                   |
| ArrayList не является классом-наследником                                                            | Vector является классом наследником                                                                                                                                  |
| ArrayList является быстрым, потому что он не синхронизированный                                      | Vector является медленным, таккак он синхронизирован, т.е. при многопоточности он будет удерживать другие потоки до тех пор, пока не освободит от блокировки объект. |
| ArrayList использует интерфейс Iterator для прохода по элементам                                     | Vector использует интерфейс Enumeration для перемещения по элементам. Но может также использовать и интерфейс Iterator.                                              |

## _Stack\<E>_

Stack\<E> — данная коллекция является расширением коллекции Vector. Была
добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является
частично синхронизированной коллекцией (кроме метода добавления push()). После
добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно
реализации этого интерфейса, например ArrayDeque.  
Stack\<E> – класс, определенный для структуры данных «стек», организованной
по принципу LIFO (last-in-first-out – последним вошел – первым вышел). Класс
Stack является наследником класса Vector, который является синхронизированным
массивом с изменяющимся размером.

***Методы:***

- **E void push(E element)** – помещает указанный элемент на вершину стека;
- **E pop()** – возвращает и удаляет элемент с вершины стека;
- **E peek()** – возвращает, но не удаляет;
- **boolean empty()** – проверяет, является ли стек пустым;
- **int search(Object obj)** – возвращает расстояние от указанного объекта до
  вершины стека (от 1 для вершины стека) или –1, если элемент не найден.
