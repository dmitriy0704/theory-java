# Self-injection

**Self-Injection** в Spring — это практика, когда компонент (например,
Spring-бин) внедряет (инжектит) сам себя через контейнер Spring.
Вместо того чтобы просто вызывать методы внутри класса напрямую, класс получает
ссылку на самого себя из Spring-контекста и вызывает методы через эту ссылку.

## Зачем это нужно?

Основная причина — **корректная работа аспектов (AOP), прокси и транзакций**.

Например, если у вас есть метод с аннотацией `@Transactional`, и вы вызываете
этот метод из другого метода того же класса напрямую (
`this.someTransactionalMethod()`), то Spring **не применит прокси и не создаст
транзакцию**, потому что вызов идёт внутри одного объекта.

Если же вызвать метод через прокси (через self injection), то аспекты сработают
корректно.

## Пример self injection

```java

@Component
public class MyService {

    @Autowired
    private MyService self;  // self injection

    public void methodA() {
        // вызов метода с транзакцией через прокси
        self.methodB();
    }

    @Transactional
    public void methodB() {
        // код, который должен выполняться в транзакции
    }
}
```

Здесь вызов `self.methodB()` пройдет через прокси Spring, и транзакция будет
создана. Если бы вызвали `this.methodB()`, то аннотация `@Transactional` не
сработала бы.

## Как работает?

Spring создает прокси-объект для бина и внедряет его в поле `self`. Таким
образом, при вызове методов через `self` вызывается проксированный объект с
применением аспектов.

#### Важные моменты

- Self injection может привести к циклическим зависимостям, если не аккуратно
  использовать.
- Альтернативы: использовать `ApplicationContext` для получения бина или
  рефакторить код так, чтобы методы с аспектами вызывались извне.
- В Spring 5+ можно использовать аннотацию `@Lazy` при инжекции самого себя,
  чтобы избежать проблем с циклическими зависимостями:

```java

@Autowired
@Lazy
private MyService self;
```

#### Кратко

**Self Injection** — это когда бин внедряет сам себя из контекста Spring для
того, чтобы внутренние вызовы методов проходили через прокси и корректно
работали такие механизмы как транзакции и AOP.
